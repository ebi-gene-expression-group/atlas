{"version":3,"sources":["webpack:///webpack_example_with_highcharts-page-bundle.js","webpack:///./src/webpack_example/highcharts/highcharts-page.js?0b28","webpack:///./~/jquery/dist/jquery.js?27d9*","webpack:///./src/webpack_example/highcharts/highcharts-page.js","webpack:///./~/highcharts-commonjs/index.js?db71","webpack:///./~/highcharts-commonjs/src/highcharts.src.js?2600","webpack:///./~/highcharts-commonjs/~/jquery/dist/jquery.js?cf11"],"names":["webpackJsonp","module","exports","__webpack_require__","global","call","this",1,"__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","document","w","Error","window","noGlobal","isArraylike","obj","length","type","jQuery","isWindow","nodeType","winnow","elements","qualifier","not","isFunction","grep","elem","i","risSimple","test","filter","inArray","sibling","cur","dir","createOptions","options","object","optionsCache","each","match","rnotwhite","_","flag","detach","addEventListener","removeEventListener","completed","detachEvent","event","readyState","ready","dataAttr","key","data","undefined","name","replace","rmultiDash","toLowerCase","getAttribute","rbrace","parseJSON","e","isEmptyDataObject","isEmptyObject","internalData","pvt","acceptData","ret","thisCache","internalKey","expando","isNode","cache","id","deletedIds","pop","guid","toJSON","noop","extend","camelCase","internalRemoveData","isArray","concat","map","split","cleanData","support","deleteExpando","returnTrue","returnFalse","safeActiveElement","activeElement","err","createSafeFragment","list","nodeNames","safeFrag","createDocumentFragment","createElement","getAll","context","tag","elems","found","getElementsByTagName","strundefined","querySelectorAll","childNodes","nodeName","push","merge","fixDefaultChecked","rcheckableType","defaultChecked","checked","manipulationTarget","content","firstChild","appendChild","ownerDocument","disableScript","find","attr","restoreScript","rscriptTypeMasked","exec","removeAttribute","setGlobalEval","refElements","_data","cloneCopyEvent","src","dest","hasData","l","oldData","curData","events","handle","add","fixCloneNodeIssues","noCloneEvent","removeEvent","text","parentNode","outerHTML","html5Clone","innerHTML","trim","value","defaultSelected","selected","defaultValue","actualDisplay","doc","style","appendTo","body","display","getDefaultComputedStyle","css","defaultDisplay","elemdisplay","iframe","documentElement","contentWindow","contentDocument","write","close","addGetHookIf","conditionFn","hookFn","get","condition","apply","arguments","vendorPropName","capName","charAt","toUpperCase","slice","origName","cssPrefixes","showHide","show","hidden","values","index","isHidden","setPositiveNumber","subtract","matches","rnumsplit","Math","max","augmentWidthOrHeight","extra","isBorderBox","styles","val","cssExpand","getWidthOrHeight","valueIsBorderBox","offsetWidth","offsetHeight","getStyles","boxSizing","curCSS","rnumnonpx","boxSizingReliable","parseFloat","Tween","prop","end","easing","prototype","init","createFxNow","setTimeout","fxNow","now","genFx","includeWidth","which","attrs","height","opacity","width","createTween","animation","tween","collection","tweeners","defaultPrefilter","props","opts","toggle","hooks","oldfire","checkDisplay","anim","orig","dataShow","queue","_queueHooks","unqueued","empty","fire","always","overflow","overflowX","overflowY","inlineBlockNeedsLayout","zoom","shrinkWrapBlocks","rfxtypes","done","hide","_removeData","start","propFilter","specialEasing","cssHooks","expand","Animation","properties","result","stopped","animationPrefilters","deferred","Deferred","tick","currentTime","remaining","startTime","duration","temp","percent","tweens","run","notifyWith","resolveWith","promise","originalProperties","originalOptions","stop","gotoEnd","rejectWith","fx","timer","progress","complete","fail","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","dataTypes","unshift","inspectPrefiltersOrTransports","jqXHR","inspect","inspected","prefilterOrFactory","dataTypeOrTransport","seekingTransport","transports","ajaxExtend","target","deep","flatOptions","ajaxSettings","ajaxHandleResponses","s","responses","firstDataType","ct","finalDataType","contents","shift","mimeType","getResponseHeader","converters","ajaxConvert","response","isSuccess","conv2","current","conv","tmp","prev","responseFields","dataFilter","state","error","buildParams","prefix","traditional","v","rbracket","createStandardXHR","XMLHttpRequest","createActiveXHR","ActiveXObject","getWindow","defaultView","parentWindow","indexOf","class2type","toString","hasOwn","hasOwnProperty","version","selector","fn","rtrim","rmsPrefix","rdashAlpha","fcamelCase","all","letter","jquery","constructor","toArray","num","pushStack","prevObject","callback","args","first","eq","last","len","j","sort","splice","copyIsArray","copy","clone","isPlainObject","random","isReady","msg","Array","isNumeric","ownLast","globalEval","execScript","string","makeArray","arr","results","Object","second","invert","callbackInverse","callbackExpect","arg","proxy","Date","Sizzle","seed","m","groups","old","nid","newContext","newSelector","preferredDoc","setDocument","documentIsHTML","rquickExpr","getElementById","contains","getElementsByClassName","qsa","rbuggyQSA","tokenize","rescape","setAttribute","toSelector","rsibling","testContext","join","qsaError","select","createCache","keys","Expr","cacheLength","markFunction","assert","div","removeChild","addHandle","handler","attrHandle","siblingCheck","a","b","diff","sourceIndex","MAX_NEGATIVE","nextSibling","createInputPseudo","createButtonPseudo","createPositionalPseudo","argument","matchIndexes","setFilters","tokens","addCombinator","matcher","combinator","base","checkNonElements","doneName","xml","oldCache","outerCache","newCache","dirruns","elementMatcher","matchers","multipleContexts","contexts","condense","unmatched","newUnmatched","mapped","setMatcher","preFilter","postFilter","postFinder","postSelector","preMap","postMap","preexisting","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","relative","implicitRelative","matchContext","matchAnyContext","outermostContext","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","uniqueSort","getText","isXML","compile","sortInput","hasDuplicate","docElem","rbuggyMatches","classCache","tokenCache","compilerCache","sortOrder","push_native","booleans","whitespace","characterEncoding","identifier","attributes","pseudos","rwhitespace","RegExp","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","ID","CLASS","TAG","ATTR","PSEUDO","CHILD","bool","needsContext","rinputs","rheader","rnative","runescape","funescape","escaped","escapedWhitespace","high","String","fromCharCode","unloadHandler","els","node","hasCompare","parent","top","attachEvent","className","createComment","getById","getElementsByName","attrId","getAttributeNode","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","expr","specified","duplicates","detectDuplicates","sortStable","textContent","nodeValue","selectors","createPseudo",">"," ","+","~","excess","unquoted","nodeNameSelector","pattern","operator","check","what","simple","forward","ofType","nodeIndex","useCache","lastChild","pseudo","idx","matched","has","innerText","lang","elemLang","hash","location","root","focus","hasFocus","href","tabIndex","enabled","disabled","selectedIndex","header","button","even","odd","lt","gt","radio","checkbox","file","password","image","submit","reset","filters","parseOnly","soFar","preFilters","cached","token","compiled","div1","unique","isXMLDoc","rneedsContext","rsingleTag","self","is","rootjQuery","parseHTML","rparentsprev","guaranteedUnique","children","next","until","n","r","targets","closest","pos","prevAll","addBack","parents","parentsUntil","nextAll","nextUntil","prevUntil","siblings","reverse","Callbacks","firing","memory","fired","firingLength","firingIndex","firingStart","stack","once","stopOnFalse","disable","remove","lock","locked","fireWith","tuples","then","fns","newDefer","tuple","returned","resolve","reject","notify","pipe","stateString","when","subordinate","progressValues","progressContexts","resolveContexts","resolveValues","updateFunc","readyList","readyWait","holdReady","hold","wait","triggerHandler","off","frameElement","doScroll","doScrollCheck","container","cssText","noData","applet ","embed ","object ","removeData","dequeue","startLength","setter","clearQueue","count","defer","pnum","source","el","access","chainable","emptyGet","raw","bulk","fragment","leadingWhitespace","tbody","htmlSerialize","cloneNode","appendChecked","noCloneChecked","checkClone","click","eventName","change","focusin","rformElems","rkeyEvent","rmouseEvent","rfocusMorph","rtypenamespace","types","t","handleObjIn","special","eventHandle","handleObj","handlers","namespaces","origType","elemData","triggered","dispatch","delegateType","bindType","namespace","delegateCount","setup","mappedTypes","origCount","teardown","trigger","onlyHandlers","ontype","bubbleType","eventPath","Event","isTrigger","namespace_re","noBubble","isPropagationStopped","preventDefault","isDefaultPrevented","_default","fix","handlerQueue","delegateTarget","preDispatch","currentTarget","isImmediatePropagationStopped","stopPropagation","postDispatch","sel","originalEvent","fixHook","fixHooks","mouseHooks","keyHooks","srcElement","metaKey","original","charCode","keyCode","eventDoc","fromElement","pageX","clientX","scrollLeft","clientLeft","pageY","clientY","scrollTop","clientTop","relatedTarget","toElement","load","blur","beforeunload","returnValue","simulate","bubble","isSimulated","defaultPrevented","timeStamp","cancelBubble","stopImmediatePropagation","mouseenter","mouseleave","pointerenter","pointerleave","related","submitBubbles","form","_submit_bubble","changeBubbles","propertyName","_just_changed","focusinBubbles","attaches","on","one","origFn","rinlinejQuery","rnoshimcache","rleadingWhitespace","rxhtmlTag","rtagName","rtbody","rhtml","rnoInnerhtml","rchecked","rscriptType","rcleanScript","wrapMap","option","legend","area","param","thead","tr","col","td","safeFragment","fragmentDiv","optgroup","tfoot","colgroup","caption","th","dataAndEvents","deepDataAndEvents","destElements","srcElements","inPage","buildFragment","scripts","selection","wrap","safe","nodes","createTextNode","append","domManip","prepend","insertBefore","before","after","keepData","html","replaceWith","replaceChild","hasScripts","set","iNoClone","_evalUrl","prependTo","insertAfter","replaceAll","insert","shrinkWrapBlocksVal","rmargin","rposition","getComputedStyle","opener","computed","minWidth","maxWidth","getPropertyValue","currentStyle","left","rs","rsLeft","runtimeStyle","pixelLeft","computeStyleTests","pixelPositionVal","boxSizingReliableVal","reliableMarginRightVal","marginRight","reliableHiddenOffsetsVal","cssFloat","backgroundClip","clearCloneStyle","MozBoxSizing","WebkitBoxSizing","reliableHiddenOffsets","pixelPosition","reliableMarginRight","swap","ralpha","ropacity","rdisplayswap","rrelNum","cssShow","position","visibility","cssNormalTransform","letterSpacing","fontWeight","cssNumber","columnCount","fillOpacity","flexGrow","flexShrink","lineHeight","order","orphans","widows","zIndex","cssProps","float","$1","margin","padding","border","suffix","expanded","parts","unit","propHooks","eased","step","linear","p","swing","cos","PI","timerId","rfxnum","rrun","*","scale","maxIterations","tweener","prefilter","speed","opt","speeds","fadeTo","to","animate","optall","doAnimation","finish","stopQueue","timers","cssFn","slideDown","slideUp","slideToggle","fadeIn","fadeOut","fadeToggle","interval","setInterval","clearInterval","slow","fast","delay","time","timeout","clearTimeout","getSetAttribute","hrefNormalized","checkOn","optSelected","enctype","optDisabled","radioValue","rreturn","valHooks","optionSet","scrollHeight","nodeHook","boolHook","ruseDefault","getSetInput","removeAttr","nType","attrHooks","propName","attrNames","propFix","getter","setAttributeNode","createAttribute","coords","contenteditable","rfocusable","rclickable","removeProp","for","class","notxml","tabindex","parseInt","rclass","addClass","classes","clazz","finalValue","proceed","removeClass","toggleClass","stateVal","classNames","hasClass","hover","fnOver","fnOut","bind","unbind","delegate","undelegate","nonce","rquery","rvalidtokens","JSON","parse","requireNonComma","depth","str","comma","open","Function","parseXML","DOMParser","parseFromString","async","loadXML","ajaxLocParts","ajaxLocation","rhash","rts","rheaders","rlocalProtocol","rnoContent","rprotocol","rurl","prefilters","allTypes","active","lastModified","etag","url","isLocal","processData","contentType","accepts","json","* text","text html","text json","text xml","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","status","nativeStatusText","headers","success","modified","statusText","timeoutTimer","transport","responseHeadersString","ifModified","cacheURL","callbackContext","statusCode","fireGlobals","globalEventContext","completeDeferred","responseHeaders","requestHeaders","requestHeadersNames","strAbort","getAllResponseHeaders","setRequestHeader","lname","overrideMimeType","code","abort","finalText","method","crossDomain","hasContent","beforeSend","send","getJSON","getScript","throws","wrapAll","wrapInner","unwrap","visible","r20","rCRLF","rsubmitterTypes","rsubmittable","encodeURIComponent","serialize","serializeArray","xhr","xhrId","xhrCallbacks","xhrSupported","cors","username","xhrFields","isAbort","onreadystatechange","responseText","script","text script","head","scriptCharset","charset","onload","oldCallbacks","rjsonp","jsonp","jsonpCallback","originalSettings","callbackName","overwritten","responseContainer","jsonProp","keepScripts","parsed","_load","params","animated","offset","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","using","win","box","getBoundingClientRect","pageYOffset","pageXOffset","offsetParent","parentOffset","scrollTo","Height","Width","defaultExtra","funcName","size","andSelf","_jQuery","_$","$","noConflict",9,"Highcharts","chartOptions","title","x","subtitle","xAxis","categories","yAxis","plotLines","color","tooltip","valueSuffix","layout","align","verticalAlign","borderWidth","series","createChart",20,"chart","renderTo","Chart","destroy",50,"doCopy","pInt","mag","isString","isObject","isNumber","log2lin","math","log","LN10","lin2log","pow","erase","item","defined","UNDEFINED","splat","isIE","hasSVG","attribs","nopad","NONE","extendClass","members","pad","number","getTZOffset","timestamp","getTimezoneOffset","timezoneOffset","formatSingle","format","decimals","floatRegex","decRegex","defaultOptions","numberFormat","decimalPoint","thousandsSep","dateFormat","ctx","segment","valueAndFormat","path","splitter","isInside","getMagnitude","mathFloor","normalizeTickInterval","multiples","magnitude","allowDecimals","preventExceed","normalized","retInterval","pick","stableSort","sortFunction","sortValue","ss_i","arrayMin","min","arrayMax","destroyObjectProperties","except","discardElement","element","garbageBin","DIV","console","correctFloat","toPrecision","setAnimation","globalAnimation","setTimeMethods","globalOptions","useUTC","GET","SET","makeTime","year","month","date","hours","minutes","seconds","d","UTC","getTime","getMinutes","getHours","getDay","getDate","getMonth","getFullYear","setMinutes","setHours","setDate","setMonth","setFullYear","setOptions","getOptions","SVGElement","Tick","axis","noLabel","isNew","addLabel","StackItem","isNegative","stackOption","inverted","total","points","alignOptions","y","textAlign","HighchartsAdapter","Renderer","hasTouch","pathAnim","timeUnits","AxisPlotLineOrBandExtension","mathRound","round","floor","mathCeil","ceil","mathMax","mathMin","mathAbs","abs","mathCos","mathSin","sin","mathPI","deg2rad","userAgent","navigator","isOpera","opera","docMode8","documentMode","isWebKit","isFirefox","isTouchDevice","SVG_NS","createElementNS","createSVGRect","hasBidiBug","useCanVG","getContext","symbolSizes","idCounter","charts","chartCount","PRODUCT","VERSION","ABSOLUTE","RELATIVE","HIDDEN","PREFIX","VISIBLE","PX","M","L","numRegex","NORMAL_STATE","HOVER_STATE","SELECT_STATE","marginNames","STROKE_WIDTH","seriesTypes","capitalize","isNaN","day","dayOfMonth","fullYear","langWeekdays","weekdays","replacements","substr","A","shortMonths","B","months","Y","H","I","P","S","getSeconds","dateFormats","millisecond","minute","hour","week","decPoint","c","toFixed","fromD","toD","endLength","startBaseLine","endBaseLine","bezier","numParams","sixify","isArea","startVal","Fx","easeOutQuad","addAnimSetter","ends","started","forEach","adapterRun","addEvent","eventType","fireEvent","eventArguments","defaultFunction","detachedType","layerX","layerY","washMouseEvent","$el","hasAnim","globalAdapter","adapter","colors","symbols","loading","numericSymbols","resetZoom","resetZoomTitle","canvasToolsURL","VMLRadialGradientURL","borderColor","borderRadius","defaultSeriesType","ignoreHiddenSeries","spacing","backgroundColor","plotBorderColor","resetZoomButton","theme","fontSize","plotOptions","line","allowPointSelect","showCheckbox","lineWidth","marker","radius","lineColor","states","lineWidthPlus","radiusPlus","fillColor","point","dataLabels","formatter","textShadow","cropThreshold","pointRange","halo","stickyTracking","turboThreshold","labels","labelFormatter","navigation","activeColor","inactiveColor","shadow","itemStyle","itemHoverStyle","itemHiddenStyle","itemCheckboxStyle","symbolPadding","labelStyle","dateTimeLabelFormats","footerFormat","headerFormat","pointFormat","snap","cursor","whiteSpace","credits","defaultPlotOptions","defaultSeriesOptions","rgbaRegEx","hexRegEx","rgbRegEx","Color","stops","rgba","brighten","alpha","setOpacity","textProps","renderer","wrapper","animOptions","colorGradient","colorObject","gradName","gradAttr","gradients","gradientObject","stopColor","stopOpacity","radialReference","linearGradient","radialGradient","x1","y1","x2","y2","gradientUnits","cx","cy","defs","stopObject","stop-color","stop-opacity","applyTextShadow","tspans","hasContrast","supports","forExport","getContrast","fill","fakeTS","ySetter","xSetter","strokeWidth","tspan","stroke","stroke-opacity","stroke-width","stroke-linejoin","hasSetSymbolSize","skipAttr","_defaultGetter","symbolName","symbolAttr","rotation","doTransform","_defaultSetter","shadows","updateShadows","updateTransform","cutHeight","currentClassName","clip","clipRect","crisp","rect","normalizer","textWidth","hyphenate","elemWrapper","oldStyles","newStyles","serializedCss","hasNew","added","buildText","svgElement","ontouchstart","touchEventFired","onclick","setRadialReference","coordinates","translate","translateX","translateY","transform","scaleX","scaleY","toFront","alignByTranslate","vAlign","alignTo","alignedObjects","right","center","bottom","middle","placed","alignAttr","getBBox","reload","bBox","toggleTextShadowShim","cacheKey","rad","textStr","elemStyle","namespaceURI","htmlGetBBox","isSVG","inherit","inserted","parentGroup","parentInverted","handleZ","zIndexSetter","onAdd","safeRemoveChild","grandParent","parentToClean","onmouseout","onmouseover","onmousemove","clipPath","shadowOptions","group","cutOff","shadowWidth","shadowElementOpacity","offsetX","offsetY","isShadow","xGetter","dSetter","dashstyleSetter","alignSetter","opacitySetter","titleSetter","titleNode","textSetter","fillSetter","otherElement","otherZIndex","parentWrapper","yGetter","translateXSetter","translateYSetter","rotationSetter","verticalAlignSetter","scaleXSetter","scaleYSetter","strokeSetter","hasStroke","SVGRenderer","Element","boxWrapper","desc","loc","getStyle","setSize","subPixelFix","fontFamily","rendererDefs","draw","lines","styleRegex","hrefRegex","textNode","hasMarkup","parentX","textStyles","textLineHeight","ellipsis","textOverflow","tempParent","getLineHeight","fontMetrics","h","unescapeAngleBrackets","inputStr","lineNo","spans","spanNo","span","spanStyle","dx","tooLong","wasTooLong","actualWidth","words","hasWhiteSpace","rest","dy","softLineNo","wordStr","measureSpanWidth","substring","normalState","hoverState","pressedState","disabledState","shape","stateOptions","stateStyle","normalStyle","hoverStyle","pressedStyle","disabledStyle","label","curState","verticalGradient","setState","crispLine","circle","arc","innerR","symbol","rSetter","rx","ry","g","preserveAspectRatio","setAttributeNS","imageElement","imageSrc","imageSize","centerImage","symbolFn","imageRegex","img","isImg","cpw","square","triangle","triangle-down","diamond","innerRadius","cosStart","sinStart","cosEnd","sinEnd","longArc","callout","arrowLength","halfDistance","safeDistance","anchorX","anchorY","useHTML","fakeSVG","parentVal","baseline","f","rotCorr","alterY","updateBoxSize","boxX","boxY","paddingLeft","baselineOffset","needsBox","alignFactor","deferredAttr","updateTextPadding","boxAttr","wrapperX","wrapperY","crispAdjust","widthSetter","heightSetter","paddingSetter","paddingLeftSetter","anchorXSetter","anchorYSetter","baseCss","htmlCss","tagName","offsetLeft","offsetTop","htmlUpdateTransform","alignOnAdd","alignCorrection","marginLeft","marginTop","child","invertChild","currentTextTransform","cTT","setSpanRotation","elemWidth","getSpanCorrection","xCorr","yCorr","rotationStyle","cssTransformKey","transformOrigin","svgGroupWrapper","htmlGroup","htmlGroupStyle","visibilitySetter","VMLRenderer","VMLElement","markup","isDiv","prepVML","deferUpdateTransform","costheta","sintheta","quad","elemHeight","nonLeft","pathToVML","isArc","clipMembers","cssRet","destroyClip","getCSS","evt","cutOffPath","modifiedPath","setAttr","classSetter","strokeElem","filled","stroke-widthSetter","stroked","updateClipping","VMLRendererExtension","isIE8","isVML","hcv","createStyleSheet","styleSheets","isObj","isShape","member","fillType","regexRgba","opacity1","opacity2","color1","color2","firstStop","lastStop","gradient","fillAttr","addFillNode","atan","sizex","sizey","applyRadialGradient","propNodes","vmlStyle","coordsize","isCircle","ren","parentStyle","imgStyle","flip","measuringSpan","CanVGRenderer","CanVGController","drawDeferred","callIndex","callLength","deferredRenderCalls","scriptLocation","dateTimeLabelFormat","names","labelOptions","tickPositions","isFirst","isLast","tickPositionInfo","info","isDatetimeAxis","higherRanks","unitName","isLog","labelGroup","labelLength","getLabelSize","horiz","handleOverflow","xy","leftPos","rightPos","pxPos","chartWidth","leftBound","labelLeft","rightBound","labelRight","factor","labelAlign","labelWidth","slotWidth","getPosition","tickmarkOffset","cHeight","oldChartHeight","chartHeight","transB","opposite","oldChartWidth","getLabelPosition","transA","reversed","staggerLines","tickRotCorr","yOffset","side","labelOffset","getMarkPath","tickLength","tickWidth","render","gridLinePath","markPath","gridLine","gridPrefix","tickPrefix","gridLineWidth","gridLineColor","dashStyle","tickColor","tickPosition","mark","reverseCrisp","isActive","getPlotLinePath","dashstyle","gridGroup","axisGroup","showFirstLabel","showLastLabel","isRadial","PlotLineOrBand","xs","ys","plotLine","optionsLabel","from","isBand","svgElem","getPlotBandPath","onGetPath","plotLinesAndBands","toPath","addPlotBand","addPlotBandOrLine","addPlotLine","coll","userOptions","removePlotBandOrLine","plotBands","Axis","endOnTick","minPadding","maxPadding","minorGridLineColor","minorGridLineWidth","minorTickColor","minorTickLength","minorTickPosition","startOfWeek","startOnTick","tickmarkPlacement","tickPixelInterval","defaultYAxisOptions","stackLabels","defaultLeftAxisOptions","defaultRightAxisOptions","defaultBottomAxisOptions","autoRotation","defaultTopAxisOptions","isXAxis","isX","defaultLabelFormatter","minPixelPadding","zoomEnabled","isLinked","linkedTo","ticks","labelEdge","minorTicks","alternateBands","minRange","userMinRange","maxZoom","range","stacks","oldStacks","crosshair","crosshairs","axes","isColorAxis","removePlotBand","removePlotLine","val2lin","lin2val","multi","formatOption","numericSymbolDetector","tickInterval","getSeriesExtremes","hasVisibleSeries","dataMin","dataMax","ignoreMinPadding","ignoreMaxPadding","buildStacks","xData","seriesDataMin","seriesDataMax","seriesOptions","threshold","getExtremes","backwards","cvsCoord","handleLog","pointPlacement","sign","cvsOffset","localA","oldTransA","localMin","oldMin","doPostTranslate","sector","toPixels","paneCoordinates","toValue","pixel","force","translatedValue","skip","axisLeft","axisTop","cWidth","between","getLinearTickPositions","lastPos","roundedMin","roundedMax","getMinorTickPositions","minorTickInterval","minorTickPositions","getLogTickPositions","getTimeTicks","normalizeTimeTickInterval","trimTicks","adjustForMinRange","zoomOffset","closestDataRange","distance","loopLength","minArgs","maxArgs","spaceAvailable","xIncrement","setAxisTranslation","saveOld","closestPointRange","ordinalCorrection","axisPointRange","minPointOffset","pointRangePadding","linkedParent","hasCategories","seriesPointRange","seriesClosestPointRange","single","noSharedTooltip","ordinalSlope","translationSlope","setTickInterval","secondPass","linkedParentExtremes","minTickInterval","tickIntervalOption","tickPixelIntervalOption","getTickAmount","userMin","userMax","beforePadding","usePercentage","ceiling","tickAmount","oldMax","beforeSetTickPositions","postProcessTickInterval","unsquish","setTickPositions","tickPositionsOption","tickPositioner","units","ordinalPositions","adjustTickAmount","hasOther","others","alignTicks","pane","finalTickAmt","currentTickAmount","setScale","isDirtyData","isDirtyAxisLength","oldAxisLength","setAxisSize","isDirty","forceRedraw","oldUserMin","oldUserMax","cum","setExtremes","newMin","newMax","redraw","serie","kdTree","eventArgs","isDirtyExtremes","allowZoomOutside","displayBtn","offsetRight","plotWidth","plotHeight","plotTop","plotLeft","percentRegex","getThreshold","realMin","realMax","autoLabelAlign","angle","newTickInterval","slotSize","rotationOption","labelMetrics","bestScore","Number","MAX_VALUE","getStep","spaceNeeded","rot","score","labelRotation","renderUnsquish","innerWidth","specCss","getOffset","showAxis","titleOffsetOption","labelOffsetPadded","lineHeightCorrection","invertedSide","titleOffset","titleMargin","axisTitleOptions","axisOffset","clipOffset","directionFactor","showEmpty","gridZIndex",3,"axisTitle","low","axisTitleMargin","getLinePath","lineLeft","lineTop","getTitlePosition","axisLength","alongAxis","offAxis","linePath","stackLabelOptions","alternateGridColor","hasRendered","slideInTicks","overlap","_addedPlotLB","plotLineOptions","forDestruction","destroyInactiveItems","axisLine","renderStackTotals","keepEvents","stackKey","cross","drawCrosshair","categorized","plotX","plotY","chartX","chartY","stackY","hideCrosshair","normalizedInterval","minYear","minDate","unitRange","setMilliseconds","getMilliseconds","setSeconds","minMonth","minDateDate","localTimezoneOffset","totalRange","unitsOption","lessThan","minor","positions","_minorAutoInterval","intermediate","break2","filteredTickIntervalOption","totalPixelLength","Tooltip","shared","hideTimer","tooltipTimeout","move","skipAnchor","followPointer","hoverPoints","hideDelay","hoverSeries","getAnchor","mouseEvent","tooltipPos","pointer","normalize","plotLow","plotHigh","boxWidth","boxHeight","swapped","preferFarSide","ttBelow","negative","firstDimension","dim","outerSize","innerSize","roomLeft","roomRight","alignedLeft","alignedRight","secondDimension","defaultFormatter","items","tooltipFooterHeaderFormatter","bodyFormatter","refresh","anchor","currentSeries","textConfig","pointConfig","tooltipOptions","getLabelConfig","category","updatePosition","positioner","getXDateFormat","xDateFormat","lastN","blank","strpos","isFooter","footOrHead","isDateTime","formatString","pointFormatter","tooltipFormatter","hoverChartIndex","Pointer","zoomX","zoomY","chartEvents","zoomType","zoomHor","zoomVert","hasZoom","runChartClick","pinchDown","lastValidTouch","followTouchMove","setDOMEvents","chartPosition","ePos","touches","changedTouches","getCoordinates","runPointActions","trueXkd","trueX","kdpoint","kdpointT","hoverPoint","rdistance","kdpoints","directTouch","searchPoint","enableMouseTracking","dist","distX","kdDimensions","distR","onMouseOver","_onDocumentMouseMove","onDocumentMouseMove","allowMove","tooltipPoints","onMouseOut","hoverX","scaleGroups","seriesAttribs","getPlotBox","markerGroup","dataLabelsGroup","clipBox","dragStart","mouseIsDown","cancelClick","mouseDownX","mouseDownY","drag","clickedInside","panKey","hasDragged","sqrt","isInsidePlot","hasCartesianSeries","selectionMarker","selectionMarkerFill","panning","pan","drop","hasPinched","runZoom","selectionData","selectionBox","selectionLeft","selectionTop","selectionWidth","selectionHeight","selectionMin","selectionMax","_cursor","onContainerMouseDown","onDocumentMouseUp","inClass","onContainerMouseLeave","onContainerMouseMove","openMenu","elemClassName","onTrackerMouseOut","relatedSeries","onContainerClick","firePointEvent","onmousedown","onContainerTouchStart","ontouchmove","onContainerTouchMove","onDocumentTouchEnd","pinchTranslate","pinchHor","pinchTranslateDirection","pinchVert","forcedScale","selectionWH","selectionXY","clipXY","outOfBounds","transformScale","scaleKey","XY","sChartXY","wh","plotLeftTop","bounds","singleTouch","touch0Start","touch0Now","touch1Start","touch1Now","pinch","touchesLength","fireClickEvent","runTrackerClick","absMin","absMax","res","plotBox","PointerEvent","MSPointerEvent","hasPointerEvent","getWebkitTouches","fake","translateMSPointer","wktype","pointerType","MSPOINTER_TYPE_TOUCH","onContainerPointerDown","pointerId","onContainerPointerMove","onDocumentPointerUp","batchMSEvents","-ms-touch-action","touch-action","Legend","itemMarginTop","initialItemX","initialItemY","maxItemWidth","itemHeight","symbolWidth","pages","positionCheckboxes","colorizeItem","legendItem","legendLine","legendSymbol","hiddenColor","textColor","symbolColor","legendColor","markerOptions","isMarker","convertAttribs","positionItem","ltr","rtl","legendItemPos","_legendItemPos","itemX","itemY","legendGroup","legendWidth","destroyItem","clearItems","getAllItems","scrollOffset","clipHeight","legendHeight","allItems","checkboxOffset","renderTitle","titleOptions","titleHeight","contentGroup","renderItem","itemWidth","horizontal","itemDistance","widthOption","itemMarginBottom","li","drawLegendSymbol","createCheckboxForItem","scrollGroup","labelFormat","setItemEvents","legendItemWidth","legendItemHeight","lastLineHeight","lastItemY","showInLegend","legendItems","legendType","adjustMargins","alignment","floating","alignments","legendBorderWidth","legendBackgroundColor","legendIndex","isResizing","lastY","optionsY","alignTop","spaceHeight","spacingBox","maxHeight","navOptions","arrowSize","nav","currentPage","fullHeight","up","scroll","pager","down","scrollBy","pageCount","LegendSymbolMixin","drawRectangle","symbolHeight","symbolRadius","drawLineMarker","legendOptions","legendItemGroup","verticalCenter","runPositionItem","callbacks","optionsChart","splashArray","showAxes","reflow","initReflow","pointCount","colorCounter","symbolCounter","firstRender","initSeries","constr","hasStackedSeries","hasDirtyStacks","redrawLegend","isDirtyLegend","isDirtyBox","seriesLength","isHiddenChart","afterRedraw","cloneRenderTo","layOutTitles","stacking","getStacks","maxTicks","getMargins","drawChartBox","isCartesian","getAxes","optionsArray","xAxisOptions","yAxisOptions","axisOptions","getSelectedPoints","getSelectedSeries","setTitle","subtitleOptions","chartTitleOptions","chartSubtitleOptions","requiresDirtyBox","autoWidth","getChartSize","heightOption","renderToClone","containerWidth","containerHeight","revert","setProperty","getContainer","oldChartIndex","containerId","indexAttrName","skipClone","-webkit-tap-highlight-color","create","chartIndex","skipAxes","resetMargins","extraBottomMargin","marginBottom","extraTopMargin","getAxisMargins","setChartSize","doReflow","hasUserSize","isPrinting","reflowTimeout","fireEndResize","clipX","clipY","plotBorderWidth","plotSizeX","plotSizeY","mgn","bgAttr","chartBackground","plotBackground","plotBorder","plotBGImage","chartBorderWidth","chartBackgroundColor","plotBackgroundColor","plotBackgroundImage","plotShadow","propFromSeries","klass","linkSeries","chartSeries","linkedSeries","renderSeries","renderLabels","tempWidth","tempHeight","redoHorizontal","redoVertical","seriesGroup","showCredits","isReadyToRender","canvg","serieOptions","oVar","tArray","CenteredSeriesMixin","getCenter","handleSlicingRoom","isPercent","slicingRoom","slicedOffset","centerOption","smallestSize","Point","applyOptions","pointAttr","colorByPoint","pointValKey","optionsToObject","autoIncrement","firstItemType","pointArrayMap","valueCount","_hasPointLabels","_hasPointMarkers","graphic","dataLabel","destroyElements","percentage","stackTotal","seriesTooltipOptions","valueDecimals","valuePrefix","importEvents","ctrlKey","shiftKey","Series","pointClass","sorted","requireSorting","pointAttrToOptions","axisTypes","parallelArrays","sortByIndex","_i","bindAxes","getColor","getSymbol","setData","AXIS","optionalAxis","updateParallelArrays","toYData","pointInterval","pointIntervalUnit","pointStart","getSegments","lastNull","segments","pointsLength","connectNulls","itemOptions","zones","userPlotOptions","typeOptions","zoneAxis","negativeColor","negativeFillColor","getCyclic","defaults","indexName","counterName","seriesMarkerOption","updatePoints","dataLength","pt","oldDataLength","firstPoint","yData","cropped","hasGroupedData","update","croppedData","xExtremes","processedXData","processedYData","cropStart","forceCrop","cropData","cropEnd","cropShoulder","generatePoints","dataOptions","processedDataLength","yDataLength","validValue","withinRange","activeYData","activeCounter","xMin","xMax","stackedYData","getExtremesFromAll","lastPlotX","hasModifyValue","modifyValue","dynamicallyPlaced","closestPointRangePx","pointStack","stackValues","xValue","yValue","yBottom","negStacks","pointXOffset","barW","Infinity","setClip","seriesClipBox","sharedClipKey","markerClipRect","afterAnimate","drawPoints","isImage","pointMarkerOptions","hasPointMarker","seriesMarkerOptions","seriesPointAttr","globallyEnabled","base1","base2","base3","conversion","getAttribs","pointStateOptionsHover","normalOptions","stateOptionsHover","seriesColor","seriesNegativeColor","normalDefaults","hasPointSpecificOptions","defaultLineColor","defaultFillColor","brightness","issue134","animationTimeout","getSegmentPath","segmentPath","lastPoint","getPointSpline","getGraphPath","graphPath","singlePoints","drawGraph","roundCap","linecap","fillGraph","graphKey","graph","applyZones","translatedFrom","translatedTo","clipAttr","clips","chartSizeMax","ignoreZones","invertGroups","setInvert","groupName","plotGroup","animDuration","chartSeriesGroup","drawDataLabels","drawTracker","wasDirtyData","wasDirty","kdAxisArray","kdComparer","searchKDTree","buildKDTree","_kdtree","dimensions","median","startRecursive","kdSync","_distance","p1","p2","kdX","kdY","distY","_search","search","tree","tdist","sideA","sideB","nPoint1","nPoint2","xOffset","xWidth","stackItem","neg","yZero","stackBox","crop","reversedStacks","setStackedPoints","setPercentStacks","oneStack","stackCategory","stackTotalGroup","other","pointKey","negKey","pointExtremes","totalFactor","addSeries","addAxis","showLoading","loadingDiv","loadingOptions","setLoadingSize","loadingSpan","loadingShown","showDuration","hideLoading","hideDuration","runEvent","fixedBox","updateTotals","removePoint","addPoint","isInTheMiddle","currentShift","graphNeg","areaNeg","isRemoving","newOptions","oldOptions","oldType","proto","preserve","axisSeries","newTitleOptions","setCategories","LineSeries","AreaSeries","pointMap","stackPoint","areaSegmentPath","segLength","translatedThreshold","closedStacks","closeSegment","areaPath","areaKey","spline","SplineSeries","leftContX","leftContY","rightContX","rightContY","smoothing","denom","nextPoint","correction","lastX","nextX","nextY","areaspline","areaProto","AreaSplineSeries","column","groupPadding","pointPadding","minPointLength","ColumnSeries","trackerGroups","otherSeries","getColumnMetrics","columnIndex","reversedXAxis","stackGroups","grouping","otherOptions","otherYAxis","categoryWidth","groupWidth","pointOffsetWidth","optionPointWidth","pointWidth","colIndex","columnMetrics","metrics","seriesBarW","xCrisp","yCrisp","fromTop","barX","barY","barH","shapeType","shapeArgs","animationLimit","borderAttr","bar","BarSeries","scatter","ScatterSeries","takeOrdinalPosition","pie","ignoreHiddenPoint","PiePoint","toggleSlice","setVisible","vis","doRedraw","sliced","translation","slicedTranslation","shadowGroup","haloPath","PieSeries","startAngleRad","radiusX","radiusY","cumulative","precision","connectorOffset","startAngle","endAngleRad","endAngle","circ","labelDistance","getX","asin","half","labelPos","groupTranslation","sortByAngle","pointOptions","generalOptions","dlProcessOptions","labelConfig","connector","moreStyle","dlOptions","inside","alignDataLabel","forceDL","justifyDataLabel","justified","connectorPath","dataLabelWidth","labelHeight","rankArr","connectorPadding","connectorWidth","softConnector","distanceOption","seriesCenter","centerY","outside","halves","slotsLength","slotIndex","slots","usedSlots","rank","slotI","slot","naturalY","justify","_attr","_pos","connX","connY","verifyDataLabelOverflow","placeDataLabels","connectorColor","moved","minSize","newSize","dlBox","below","collectAndHide","allowOverlap","labelrank","hideOverlappingLabels","label1","label2","intersectRect","pos1","pos2","size1","size2","oldOpacity","newOpacity","isOld","TrackerMixin","drawTrackerPoint","_hasTracking","drawTrackerGraph","singlePoint","trackByArea","trackerPath","trackerPathLength","tracker","TRACKER_FILL","strLegendItemClick","fnLegendItemClick","browserEvent","showResetZoom","btnOptions","relativeTo","zoomOut","resetSelection","hasZoomed","displayButton","axisData","mousePos","startPos","halfPointRange","extremes","goingLeft","accumulate","loopPoint","hasImportedEvents","haloOptions","newSymbol","normalDisabled","markerStateOptions","stateDisabled","stateMarkerGraphic","pointMarker","currentSymbol","mouseOver","mouseOut","showOrHide","oldVisibility","svg","canvas","vml","product",156,"Data","defineProperty","uid","data_user","data_priv","pdataOld","pdataCur","udataOld","udataCur","fixInput","indirect","eval","truncate","owner","descriptor","unlock","defineProperties","stored","camel","discard","camelKey","computePixelPositionAndBoxSizingReliable","divStyle","marginDiv","hasAttribute","firstElementChild","xhrSuccessStatus",1223,"onerror"],"mappings":"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","file":"webpack_example_with_highcharts-page-bundle.js","sourcesContent":["webpackJsonp([7,9],{\n\n/***/ 0:\n/*!***********************************************************!*\\\n  !*** ./src/webpack_example/highcharts/highcharts-page.js ***!\n  \\***********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"$page\"] = __webpack_require__(/*! -!./src/webpack_example/highcharts/highcharts-page.js */ 9);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 1:\n/*!*********************************!*\\\n  !*** ./~/jquery/dist/jquery.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v1.11.2\n\t * http://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-12-17T15:27Z\n\t */\n\n\t(function( global, factory ) {\n\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t\t// execute the factory and get jQuery\n\t\t\t// For environments that do not inherently posses a window with a document\n\t\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t\t// This accentuates the need for the creation of a real window\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\n\t// Pass this if window is not defined yet\n\t}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n\t// Can't do this because several apps including ASP.NET trace\n\t// the stack via arguments.caller.callee and Firefox dies if\n\t// you try to trace through \"use strict\" call chains. (#13335)\n\t// Support: Firefox 18+\n\t//\n\n\tvar deletedIds = [];\n\n\tvar slice = deletedIds.slice;\n\n\tvar concat = deletedIds.concat;\n\n\tvar push = deletedIds.push;\n\n\tvar indexOf = deletedIds.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar support = {};\n\n\n\n\tvar\n\t\tversion = \"1.11.2\",\n\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\n\t\t// Support: Android<4.1, IE<9\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([\\da-z])/gi,\n\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\n\tjQuery.fn = jQuery.prototype = {\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// Start with an empty selector\n\t\tselector: \"\",\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\t\treturn num != null ?\n\n\t\t\t\t// Return just the one element from the set\n\t\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t\t// Return all the elements in a clean array\n\t\t\t\tslice.call( this );\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\t\tret.context = this.context;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\t// (You can seed the arguments with an array of args, but this is\n\t\t// only used internally.)\n\t\teach: function( callback, args ) {\n\t\t\treturn jQuery.each( this, callback, args );\n\t\t},\n\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t}));\n\t\t},\n\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t\t},\n\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: deletedIds.sort,\n\t\tsplice: deletedIds.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar src, copyIsArray, copy, name, options, clone,\n\t\t\ttarget = arguments[0] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\n\t\t\t// skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor ( ; i < length; i++ ) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\n\t\tnoop: function() {},\n\n\t\t// See test/unit/core.js for details concerning isFunction.\n\t\t// Since version 1.3, DOM methods and functions like alert\n\t\t// aren't supported. They return false on IE (#2968).\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type(obj) === \"function\";\n\t\t},\n\n\t\tisArray: Array.isArray || function( obj ) {\n\t\t\treturn jQuery.type(obj) === \"array\";\n\t\t},\n\n\t\tisWindow: function( obj ) {\n\t\t\t/* jshint eqeqeq: false */\n\t\t\treturn obj != null && obj == obj.window;\n\t\t},\n\n\t\tisNumeric: function( obj ) {\n\t\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t\t},\n\n\t\tisEmptyObject: function( obj ) {\n\t\t\tvar name;\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tisPlainObject: function( obj ) {\n\t\t\tvar key;\n\n\t\t\t// Must be an Object.\n\t\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Not own constructor property must be Object\n\t\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t\t!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch ( e ) {\n\t\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Handle iteration over inherited properties before own properties.\n\t\t\tif ( support.ownLast ) {\n\t\t\t\tfor ( key in obj ) {\n\t\t\t\t\treturn hasOwn.call( obj, key );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t\t// if last one is own, then all properties are own.\n\t\t\tfor ( key in obj ) {}\n\n\t\t\treturn key === undefined || hasOwn.call( obj, key );\n\t\t},\n\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\t// Workarounds based on findings by Jim Driscoll\n\t\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\t\tglobalEval: function( data ) {\n\t\t\tif ( data && jQuery.trim( data ) ) {\n\t\t\t\t// We use execScript on Internet Explorer\n\t\t\t\t// We use an anonymous function so that context is window\n\t\t\t\t// rather than jQuery in Firefox\n\t\t\t\t( window.execScript || function( data ) {\n\t\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t\t} )( data );\n\t\t\t}\n\t\t},\n\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\n\t\t// args is for internal usage only\n\t\teach: function( obj, callback, args ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = obj.length,\n\t\t\t\tisArray = isArraylike( obj );\n\n\t\t\tif ( args ) {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// A special, fast, case for the most common use of each\n\t\t\t} else {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Support: Android<4.1, IE<9\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function( elem, arr, i ) {\n\t\t\tvar len;\n\n\t\t\tif ( arr ) {\n\t\t\t\tif ( indexOf ) {\n\t\t\t\t\treturn indexOf.call( arr, elem, i );\n\t\t\t\t}\n\n\t\t\t\tlen = arr.length;\n\t\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t},\n\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\n\t\t\twhile ( j < len ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\t\t\tif ( len !== len ) {\n\t\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tisArray = isArraylike( elems ),\n\t\t\t\tret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar args, proxy, tmp;\n\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tnow: function() {\n\t\t\treturn +( new Date() );\n\t\t},\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t});\n\n\tfunction isArraylike( obj ) {\n\t\tvar length = obj.length,\n\t\t\ttype = jQuery.type( obj );\n\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.nodeType === 1 && length ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.2.0-pre\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-12-16\n\t */\n\t(function( window ) {\n\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// General-purpose constants\n\t\tMAX_NEGATIVE = 1 << 31,\n\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// http://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t\t// Regular expressions\n\n\t\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\t// http://www.w3.org/TR/css3-syntax/#characters\n\t\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t\t// Loosely modeled on CSS identifier characters\n\t\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\n\t\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\t\trsibling = /[+~]/,\n\t\trescape = /'|\\\\/g,\n\n\t\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t};\n\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar match, elem, m, nodeType,\n\t\t\t// QSA vars\n\t\t\ti, groups, old, nid, newContext, newSelector;\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\n\t\tcontext = context || document;\n\t\tresults = results || [];\n\t\tnodeType = context.nodeType;\n\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\t\treturn results;\n\t\t}\n\n\t\tif ( !seed && documentIsHTML ) {\n\n\t\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\tif ( (m = match[1]) ) {\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Context is not a document\n\t\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// QSA path\n\t\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\t\tnid = old = expando;\n\t\t\t\tnewContext = context;\n\t\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t\t}\n\t\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch(qsaError) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created div and expects a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar div = document.createElement(\"div\");\n\n\t\ttry {\n\t\t\treturn !!fn( div );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( div.parentNode ) {\n\t\t\t\tdiv.parentNode.removeChild( div );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tdiv = null;\n\t\t}\n\t}\n\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = attrs.length;\n\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a ? 1 : -1;\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, parent,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t// If no document and documentElement is available, return\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\n\t\t// Set our document\n\t\tdocument = doc;\n\t\tdocElem = doc.documentElement;\n\t\tparent = doc.defaultView;\n\n\t\t// Support: IE>8\n\t\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t\t// IE6-8 do not support the defaultView property so parent will be undefined\n\t\tif ( parent && parent !== parent.top ) {\n\t\t\t// IE11 does not have attachEvent, so all must suffer\n\t\t\tif ( parent.addEventListener ) {\n\t\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t\t} else if ( parent.attachEvent ) {\n\t\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\n\t\t/* Support tests\n\t\t---------------------------------------------------------------------- */\n\t\tdocumentIsHTML = !isXML( doc );\n\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( div ) {\n\t\t\tdiv.className = \"i\";\n\t\t\treturn !div.getAttribute(\"className\");\n\t\t});\n\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( div ) {\n\t\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t});\n\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( div ) {\n\t\t\tdocElem.appendChild( div ).id = expando;\n\t\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t\t});\n\n\t\t// ID find and filter\n\t\tif ( support.getById ) {\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\t// Support: IE6/7\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tdelete Expr.find[\"ID\"];\n\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\n\t\t// QSA and matchesSelector support\n\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See http://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\n\t\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( div ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\n\t\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert(function( div ) {\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = doc.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\t\tassert(function( div ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t\t// Element contains another\n\t\t// Purposefully does not implement inclusive descendent\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === doc ? -1 :\n\t\t\t\t\tb === doc ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\n\t\treturn doc;\n\t};\n\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\n\t\treturn results;\n\t};\n\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\n\t\treturn ret;\n\t};\n\n\tExpr = Sizzle.selectors = {\n\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\n\t\tcreatePseudo: markFunction,\n\n\t\tmatch: matchExpr,\n\n\t\tattrHandle: {},\n\n\t\tfind: {},\n\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\treturn match;\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\n\t\tfilter: {\n\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\n\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === false;\n\t\t\t},\n\n\t\t\t\"disabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === true;\n\t\t\t},\n\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\n\t\twhile ( soFar ) {\n\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\n\t\t\tmatched = false;\n\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\t\tdoneName = done++;\n\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t}\n\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newUnmatched;\n\t}\n\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\n\t\treturn elementMatcher( matchers );\n\t}\n\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\tmatchedCount += i;\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\t\tresults = results || [];\n\n\t\t// Try to minimize operations if there is no seed and only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\n\t// One-time assignments\n\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t// Initialize against the default document\n\tsetDocument();\n\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( div1 ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n\t});\n\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( div ) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( div ) {\n\t\tdiv.innerHTML = \"<input/>\";\n\t\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( div ) {\n\t\treturn div.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Sizzle;\n\n\t})( window );\n\n\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\n\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\t/* jshint -W018 */\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t});\n\n\t\t}\n\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t});\n\n\t\t}\n\n\t\tif ( typeof qualifier === \"string\" ) {\n\t\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t\t}\n\n\t\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\t}\n\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n\t\t});\n\t}\n\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function( selector ) {\n\t\t\tvar i,\n\t\t\t\tret = [],\n\t\t\t\tself = this,\n\t\t\t\tlen = self.length;\n\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) );\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\n\t\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\t\treturn ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t});\n\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\t\t// Use the correct document accordingly with window argument (sandbox)\n\t\tdocument = window.document,\n\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t\tinit = jQuery.fn.init = function( selector, context ) {\n\t\t\tvar match, elem;\n\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[1] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.context = document;\n\t\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis.context = this[0] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\n\t\t\tif ( selector.selector !== undefined ) {\n\t\t\t\tthis.selector = selector.selector;\n\t\t\t\tthis.context = selector.context;\n\t\t\t}\n\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\t// methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\n\tjQuery.extend({\n\t\tdir: function( elem, dir, until ) {\n\t\t\tvar matched = [],\n\t\t\t\tcur = elem[ dir ];\n\n\t\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t}\n\t\t\t\tcur = cur[dir];\n\t\t\t}\n\t\t\treturn matched;\n\t\t},\n\n\t\tsibling: function( n, elem ) {\n\t\t\tvar r = [];\n\n\t\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\t\tr.push( n );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn r;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\thas: function( target ) {\n\t\t\tvar i,\n\t\t\t\ttargets = jQuery( target, this ),\n\t\t\t\tlen = targets.length;\n\n\t\t\treturn this.filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t\t0;\n\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t\t},\n\n\t\t// Determine the position of an element within\n\t\t// the matched set of elements\n\t\tindex: function( elem ) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn jQuery.inArray(\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[0] : elem, this );\n\t\t},\n\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.unique(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t\t);\n\t\t}\n\t});\n\n\tfunction sibling( cur, dir ) {\n\t\tdo {\n\t\t\tcur = cur[ dir ];\n\t\t} while ( cur && cur.nodeType !== 1 );\n\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn jQuery.sibling( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\t\tjQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tret = jQuery.filter( selector, ret );\n\t\t\t}\n\n\t\t\tif ( this.length > 1 ) {\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tret = jQuery.unique( ret );\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tret = ret.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t});\n\tvar rnotwhite = (/\\S+/g);\n\n\n\n\t// String to Object options format cache\n\tvar optionsCache = {};\n\n\t// Convert String-formatted options into Object-formatted ones and store in cache\n\tfunction createOptions( options ) {\n\t\tvar object = optionsCache[ options ] = {};\n\t\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\t\tjQuery.extend( {}, options );\n\n\t\tvar // Flag to know if list is currently firing\n\t\t\tfiring,\n\t\t\t// Last fire value (for non-forgettable lists)\n\t\t\tmemory,\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\t\t// End of the loop when firing\n\t\t\tfiringLength,\n\t\t\t// Index of currently firing callback (modified by remove if needed)\n\t\t\tfiringIndex,\n\t\t\t// First callback to fire (used internally by add and fireWith)\n\t\t\tfiringStart,\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\t\t// Stack of fire calls for repeatable lists\n\t\t\tstack = !options.once && [],\n\t\t\t// Fire callbacks\n\t\t\tfire = function( data ) {\n\t\t\t\tmemory = options.memory && data;\n\t\t\t\tfired = true;\n\t\t\t\tfiringIndex = firingStart || 0;\n\t\t\t\tfiringStart = 0;\n\t\t\t\tfiringLength = list.length;\n\t\t\t\tfiring = true;\n\t\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfiring = false;\n\t\t\t\tif ( list ) {\n\t\t\t\t\tif ( stack ) {\n\t\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\t// First, we save the current length\n\t\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})( arguments );\n\t\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t\t// current firing batch?\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\t\tvar index;\n\t\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t\t},\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tlist = [];\n\t\t\t\t\tfiringLength = 0;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Have the list do nothing anymore\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it disabled?\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\t\t\t// Lock the list in its current state\n\t\t\t\tlock: function() {\n\t\t\t\t\tstack = undefined;\n\t\t\t\t\tif ( !memory ) {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it locked?\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !stack;\n\t\t\t\t},\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfire( args );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\n\t\treturn self;\n\t};\n\n\n\tjQuery.extend({\n\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t}).promise();\n\t\t\t\t\t},\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\n\t\t\t// Keep pipe for back-compat\n\t\t\tpromise.pipe = promise.then;\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(function() {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\tstate = stateString;\n\n\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t\t}\n\n\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\t\tvar i = 0,\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\t\t\tlength = resolveValues.length,\n\n\t\t\t\t// the count of uncompleted subordinates\n\t\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t\t// Update function for both resolve and progress values\n\t\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\n\t\t\t\t\t\t} else if ( !(--remaining) ) {\n\t\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\t\tif ( length > 1 ) {\n\t\t\t\tprogressValues = new Array( length );\n\t\t\t\tprogressContexts = new Array( length );\n\t\t\t\tresolveContexts = new Array( length );\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we're not waiting on anything, resolve the master\n\t\t\tif ( !remaining ) {\n\t\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\n\n\t// The deferred used on DOM ready\n\tvar readyList;\n\n\tjQuery.fn.ready = function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\t\tif ( !document.body ) {\n\t\t\t\treturn setTimeout( jQuery.ready );\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\t\tjQuery( document ).off( \"ready\" );\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * Clean-up method for dom ready events\n\t */\n\tfunction detach() {\n\t\tif ( document.addEventListener ) {\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\t\twindow.removeEventListener( \"load\", completed, false );\n\n\t\t} else {\n\t\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\t\twindow.detachEvent( \"onload\", completed );\n\t\t}\n\t}\n\n\t/**\n\t * The ready event handler and self cleanup method\n\t */\n\tfunction completed() {\n\t\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\t\t\tdetach();\n\t\t\tjQuery.ready();\n\t\t}\n\t}\n\n\tjQuery.ready.promise = function( obj ) {\n\t\tif ( !readyList ) {\n\n\t\t\treadyList = jQuery.Deferred();\n\n\t\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\t\tsetTimeout( jQuery.ready );\n\n\t\t\t// Standards-based browsers support DOMContentLoaded\n\t\t\t} else if ( document.addEventListener ) {\n\t\t\t\t// Use the handy event callback\n\t\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.addEventListener( \"load\", completed, false );\n\n\t\t\t// If IE event model is used\n\t\t\t} else {\n\t\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t\t// If IE and not a frame\n\t\t\t\t// continually check to see if the document is ready\n\t\t\t\tvar top = false;\n\n\t\t\t\ttry {\n\t\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t\t} catch(e) {}\n\n\t\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn readyList.promise( obj );\n\t};\n\n\n\tvar strundefined = typeof undefined;\n\n\n\n\t// Support: IE<9\n\t// Iteration over object's inherited properties before its own\n\tvar i;\n\tfor ( i in jQuery( support ) ) {\n\t\tbreak;\n\t}\n\tsupport.ownLast = i !== \"0\";\n\n\t// Note: most support tests are defined in their respective modules.\n\t// false until the test is run\n\tsupport.inlineBlockNeedsLayout = false;\n\n\t// Execute ASAP in case we need to set body.style.zoom\n\tjQuery(function() {\n\t\t// Minified: var a,b,c,d\n\t\tvar val, div, body, container;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t\t// Support: IE<8\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\tdiv.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n\n\t\t\tsupport.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n\t\t\tif ( val ) {\n\t\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t\t// Support: IE<8\n\t\t\t\tbody.style.zoom = 1;\n\t\t\t}\n\t\t}\n\n\t\tbody.removeChild( container );\n\t});\n\n\n\n\n\t(function() {\n\t\tvar div = document.createElement( \"div\" );\n\n\t\t// Execute the test only if not already executed in another module.\n\t\tif (support.deleteExpando == null) {\n\t\t\t// Support: IE<9\n\t\t\tsupport.deleteExpando = true;\n\t\t\ttry {\n\t\t\t\tdelete div.test;\n\t\t\t} catch( e ) {\n\t\t\t\tsupport.deleteExpando = false;\n\t\t\t}\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE.\n\t\tdiv = null;\n\t})();\n\n\n\t/**\n\t * Determines whether an object can have data\n\t */\n\tjQuery.acceptData = function( elem ) {\n\t\tvar noData = jQuery.noData[ (elem.nodeName + \" \").toLowerCase() ],\n\t\t\tnodeType = +elem.nodeType || 1;\n\n\t\t// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\t\treturn nodeType !== 1 && nodeType !== 9 ?\n\t\t\tfalse :\n\n\t\t\t// Nodes accept data unless otherwise specified; rejection can be conditional\n\t\t\t!noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\t};\n\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /([A-Z])/g;\n\n\tfunction dataAttr( elem, key, data ) {\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\t\tdata = elem.getAttribute( name );\n\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\t\tdata;\n\t\t\t\t} catch( e ) {}\n\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tjQuery.data( elem, key, data );\n\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t// checks a cache object for emptiness\n\tfunction isEmptyDataObject( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\n\t\t\t// if the public data object is empty, the private is still empty\n\t\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( name !== \"toJSON\" ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ret, thisCache,\n\t\t\tinternalKey = jQuery.expando,\n\n\t\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t\t// can't GC object references properly across the DOM-JS boundary\n\t\t\tisNode = elem.nodeType,\n\n\t\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t\t// attached directly to the object so GC can occur automatically\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t\t// Avoid doing any more work than we need to when trying to get data on an\n\t\t// object that has no data at all\n\t\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === \"string\" ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !id ) {\n\t\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t\t// ends up in the global cache\n\t\t\tif ( isNode ) {\n\t\t\t\tid = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n\t\t\t} else {\n\t\t\t\tid = internalKey;\n\t\t\t}\n\t\t}\n\n\t\tif ( !cache[ id ] ) {\n\t\t\t// Avoid exposing jQuery metadata on plain JS objects when the object\n\t\t\t// is serialized using JSON.stringify\n\t\t\tcache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n\t\t}\n\n\t\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t\t// shallow copied over onto the existing cache\n\t\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\t\tif ( pvt ) {\n\t\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t\t} else {\n\t\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t\t}\n\t\t}\n\n\t\tthisCache = cache[ id ];\n\n\t\t// jQuery data() is stored in a separate object inside the object's internal data\n\t\t// cache in order to avoid key collisions between internal data and user-defined\n\t\t// data.\n\t\tif ( !pvt ) {\n\t\t\tif ( !thisCache.data ) {\n\t\t\t\tthisCache.data = {};\n\t\t\t}\n\n\t\t\tthisCache = thisCache.data;\n\t\t}\n\n\t\tif ( data !== undefined ) {\n\t\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t\t}\n\n\t\t// Check for both converted-to-camel and non-converted data property names\n\t\t// If a data property was specified\n\t\tif ( typeof name === \"string\" ) {\n\n\t\t\t// First Try to find as-is property data\n\t\t\tret = thisCache[ name ];\n\n\t\t\t// Test for null|undefined property data\n\t\t\tif ( ret == null ) {\n\n\t\t\t\t// Try to find the camelCased property\n\t\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t\t}\n\t\t} else {\n\t\t\tret = thisCache;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tfunction internalRemoveData( elem, name, pvt ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar thisCache, i,\n\t\t\tisNode = elem.nodeType,\n\n\t\t\t// See jQuery.data for more information\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\t\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t\t// If there is already no cache entry for this object, there is no\n\t\t// purpose in continuing\n\t\tif ( !cache[ id ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( name ) {\n\n\t\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\t\tif ( thisCache ) {\n\n\t\t\t\t// Support array or space separated string names for data keys\n\t\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t\t}\n\n\t\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t\t// and let the cache object itself get destroyed\n\t\t\t\tif ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// See jQuery.data for more information\n\t\tif ( !pvt ) {\n\t\t\tdelete cache[ id ].data;\n\n\t\t\t// Don't destroy the parent cache unless the internal data object\n\t\t\t// had been the only thing left in it\n\t\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Destroy the cache\n\t\tif ( isNode ) {\n\t\t\tjQuery.cleanData( [ elem ], true );\n\n\t\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t\t/* jshint eqeqeq: false */\n\t\t} else if ( support.deleteExpando || cache != cache.window ) {\n\t\t\t/* jshint eqeqeq: true */\n\t\t\tdelete cache[ id ];\n\n\t\t// When all else fails, null\n\t\t} else {\n\t\t\tcache[ id ] = null;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tcache: {},\n\n\t\t// The following elements (space-suffixed to avoid Object.prototype collisions)\n\t\t// throw uncatchable exceptions if you attempt to set expando properties\n\t\tnoData: {\n\t\t\t\"applet \": true,\n\t\t\t\"embed \": true,\n\t\t\t// ...but Flash objects (which have this classid) *can* handle expandos\n\t\t\t\"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n\t\t},\n\n\t\thasData: function( elem ) {\n\t\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\t\treturn !!elem && !isEmptyDataObject( elem );\n\t\t},\n\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn internalData( elem, name, data );\n\t\t},\n\n\t\tremoveData: function( elem, name ) {\n\t\t\treturn internalRemoveData( elem, name );\n\t\t},\n\n\t\t// For internal use only.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn internalData( elem, name, data, true );\n\t\t},\n\n\t\t_removeData: function( elem, name ) {\n\t\t\treturn internalRemoveData( elem, name, true );\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[0],\n\t\t\t\tattrs = elem && elem.attributes;\n\n\t\t\t// Special expections of .data basically thwart jQuery.access,\n\t\t\t// so implement the relevant behavior ourselves\n\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tjQuery.data( this, key );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn arguments.length > 1 ?\n\n\t\t\t\t// Sets one value\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tjQuery.data( this, key, value );\n\t\t\t\t}) :\n\n\t\t\t\t// Gets one value\n\t\t\t\t// Try to fetch any internally stored data first\n\t\t\t\telem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n\t\t},\n\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.removeData( this, key );\n\t\t\t});\n\t\t}\n\t});\n\n\n\tjQuery.extend({\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\n\t\t\t\t// clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[0], type );\n\t\t\t}\n\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t\t// ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t});\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t});\n\tvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\n\tvar isHidden = function( elem, el ) {\n\t\t\t// isHidden might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t\t};\n\n\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t};\n\tvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n\t(function() {\n\t\t// Minified: var a,b,c\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tdiv = document.createElement( \"div\" ),\n\t\t\tfragment = document.createDocumentFragment();\n\n\t\t// Setup\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tsupport.leadingWhitespace = div.firstChild.nodeType === 3;\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\tsupport.tbody = !div.getElementsByTagName( \"tbody\" ).length;\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\tsupport.htmlSerialize = !!div.getElementsByTagName( \"link\" ).length;\n\n\t\t// Makes sure cloning an html5 element does not cause problems\n\t\t// Where outerHTML is undefined, this still works\n\t\tsupport.html5Clone =\n\t\t\tdocument.createElement( \"nav\" ).cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n\t\t// Check if a disconnected checkbox will retain its checked\n\t\t// value of true after appended to the DOM (IE6/7)\n\t\tinput.type = \"checkbox\";\n\t\tinput.checked = true;\n\t\tfragment.appendChild( input );\n\t\tsupport.appendChecked = input.checked;\n\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\t// Support: IE6-IE11+\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t\t// #11217 - WebKit loses check when the name is after the checked attribute\n\t\tfragment.appendChild( div );\n\t\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t\t// old WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t\t// Support: IE<9\n\t\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\t\tsupport.noCloneEvent = true;\n\t\tif ( div.attachEvent ) {\n\t\t\tdiv.attachEvent( \"onclick\", function() {\n\t\t\t\tsupport.noCloneEvent = false;\n\t\t\t});\n\n\t\t\tdiv.cloneNode( true ).click();\n\t\t}\n\n\t\t// Execute the test only if not already executed in another module.\n\t\tif (support.deleteExpando == null) {\n\t\t\t// Support: IE<9\n\t\t\tsupport.deleteExpando = true;\n\t\t\ttry {\n\t\t\t\tdelete div.test;\n\t\t\t} catch( e ) {\n\t\t\t\tsupport.deleteExpando = false;\n\t\t\t}\n\t\t}\n\t})();\n\n\n\t(function() {\n\t\tvar i, eventName,\n\t\t\tdiv = document.createElement( \"div\" );\n\n\t\t// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)\n\t\tfor ( i in { submit: true, change: true, focusin: true }) {\n\t\t\teventName = \"on\" + i;\n\n\t\t\tif ( !(support[ i + \"Bubbles\" ] = eventName in window) ) {\n\t\t\t\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\t\t\t\tdiv.setAttribute( eventName, \"t\" );\n\t\t\t\tsupport[ i + \"Bubbles\" ] = div.attributes[ eventName ].expando === false;\n\t\t\t}\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE.\n\t\tdiv = null;\n\t})();\n\n\n\tvar rformElems = /^(?:input|select|textarea)$/i,\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\t\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function( elem, types, handler, data, selector ) {\n\t\t\tvar tmp, events, t, handleObjIn,\n\t\t\t\tspecial, eventHandle, handleObj,\n\t\t\t\thandlers, type, namespaces, origType,\n\t\t\t\telemData = jQuery._data( elem );\n\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !(events = elemData.events) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\t\tundefined;\n\t\t\t\t};\n\t\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\t\teventHandle.elem = elem;\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn );\n\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\n\t\t\t// Nullify elem to prevent memory leaks in IE\n\t\t\telem = null;\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\t\tvar j, handleObj, tmp,\n\t\t\t\torigCount, t, events,\n\t\t\t\tspecial, handlers, type,\n\t\t\t\tnamespaces, origType,\n\t\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdelete elemData.handle;\n\n\t\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t\t// so use it instead of delete\n\t\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t\t}\n\t\t},\n\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\t\tvar handle, ontype, cur,\n\t\t\t\tbubbleType, special, tmp, i,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\t\tcur = tmp = elem = elem || document;\n\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.namespace_re = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\tdispatch: function( event ) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( event );\n\n\t\t\tvar i, ret, handleObj, matched, j,\n\t\t\t\thandlerQueue = [],\n\t\t\t\targs = slice.call( arguments ),\n\t\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar sel, handleObj, matches, i,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\t\t/* jshint eqeqeq: false */\n\t\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\t\t\t\t\t/* jshint eqeqeq: true */\n\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\tfix: function( event ) {\n\t\t\tif ( event[ jQuery.expando ] ) {\n\t\t\t\treturn event;\n\t\t\t}\n\n\t\t\t// Create a writable copy of the event object and normalize some properties\n\t\t\tvar i, prop, copy,\n\t\t\t\ttype = event.type,\n\t\t\t\toriginalEvent = event,\n\t\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\t\tif ( !fixHook ) {\n\t\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t\t{};\n\t\t\t}\n\t\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\t\tevent = new jQuery.Event( originalEvent );\n\n\t\t\ti = copy.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = copy[ i ];\n\t\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Fix target property (#1925)\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t\t}\n\n\t\t\t// Support: Chrome 23+, Safari?\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tif ( event.target.nodeType === 3 ) {\n\t\t\t\tevent.target = event.target.parentNode;\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\t\tevent.metaKey = !!event.metaKey;\n\n\t\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t\t},\n\n\t\t// Includes some event props shared by KeyEvent and MouseEvent\n\t\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\t\tfixHooks: {},\n\n\t\tkeyHooks: {\n\t\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\n\t\t\t\t// Add which for key events\n\t\t\t\tif ( event.which == null ) {\n\t\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tmouseHooks: {\n\t\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\t\t\t\tvar body, eventDoc, doc,\n\t\t\t\t\tbutton = original.button,\n\t\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t\t}\n\n\t\t\t\t// Add relatedTarget, if necessary\n\t\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t\t}\n\n\t\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t\t// Note: button is not normalized, so don't use it\n\t\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsimulate: function( type, elem, event, bubble ) {\n\t\t\t// Piggyback on a donor event to simulate a different one.\n\t\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t\t// simulated event prevents default then we do the same on the donor.\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true,\n\t\t\t\t\toriginalEvent: {}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( bubble ) {\n\t\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t\t} else {\n\t\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t\t}\n\t\t\tif ( e.isDefaultPrevented() ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = document.removeEventListener ?\n\t\tfunction( elem, type, handle ) {\n\t\t\tif ( elem.removeEventListener ) {\n\t\t\t\telem.removeEventListener( type, handle, false );\n\t\t\t}\n\t\t} :\n\t\tfunction( elem, type, handle ) {\n\t\t\tvar name = \"on\" + type;\n\n\t\t\tif ( elem.detachEvent ) {\n\n\t\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\t\tif ( typeof elem[ name ] === strundefined ) {\n\t\t\t\t\telem[ name ] = null;\n\t\t\t\t}\n\n\t\t\t\telem.detachEvent( name, handle );\n\t\t\t}\n\t\t};\n\n\tjQuery.Event = function( src, props ) {\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !(this instanceof jQuery.Event) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t\t// Support: IE < 9, Android < 4.0\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\t\tif ( !e ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If preventDefault exists, run it on the original event\n\t\t\tif ( e.preventDefault ) {\n\t\t\t\te.preventDefault();\n\n\t\t\t// Support: IE\n\t\t\t// Otherwise set the returnValue property of the original event to false\n\t\t\t} else {\n\t\t\t\te.returnValue = false;\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\t\tif ( !e ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If stopPropagation exists, run it on the original event\n\t\t\tif ( e.stopPropagation ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// Set the cancelBubble property of the original event to true\n\t\t\te.cancelBubble = true;\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\t// IE submit delegation\n\tif ( !support.submitBubbles ) {\n\n\t\tjQuery.event.special.submit = {\n\t\t\tsetup: function() {\n\t\t\t\t// Only need this for delegated form submit events\n\t\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\t\tvar elem = e.target,\n\t\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\t\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// return undefined since we don't need an event listener\n\t\t\t},\n\n\t\t\tpostDispatch: function( event ) {\n\t\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\t\tif ( event._submit_bubble ) {\n\t\t\t\t\tdelete event._submit_bubble;\n\t\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function() {\n\t\t\t\t// Only need this for delegated form submit events\n\t\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t\t}\n\t\t};\n\t}\n\n\t// IE change delegation and checkbox/radio fix\n\tif ( !support.changeBubbles ) {\n\n\t\tjQuery.event.special.change = {\n\n\t\t\tsetup: function() {\n\n\t\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\t\tvar elem = e.target;\n\n\t\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\t\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\thandle: function( event ) {\n\t\t\t\tvar elem = event.target;\n\n\t\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function() {\n\t\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\t\treturn !rformElems.test( this.nodeName );\n\t\t\t}\n\t\t};\n\t}\n\n\t// Create \"bubbling\" focus and blur events\n\tif ( !support.focusinBubbles ) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t\t};\n\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = jQuery._data( doc, fix );\n\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = jQuery._data( doc, fix ) - 1;\n\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tjQuery._removeData( doc, fix );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery._data( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tjQuery.fn.extend({\n\n\t\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\t\tvar type, origFn;\n\n\t\t\t// Types can be a map of types/handlers\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif ( data == null && fn == null ) {\n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if ( fn == null ) {\n\t\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t} else if ( !fn ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif ( one === 1 ) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function( event ) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off( event );\n\t\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t\t});\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t});\n\t\t},\n\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[0];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t});\n\n\n\tfunction createSafeFragment( document ) {\n\t\tvar list = nodeNames.split( \"|\" ),\n\t\t\tsafeFrag = document.createDocumentFragment();\n\n\t\tif ( safeFrag.createElement ) {\n\t\t\twhile ( list.length ) {\n\t\t\t\tsafeFrag.createElement(\n\t\t\t\t\tlist.pop()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn safeFrag;\n\t}\n\n\tvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\t\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\t\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\t\trleadingWhitespace = /^\\s+/,\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t\trtagName = /<([\\w:]+)/,\n\t\trtbody = /<tbody/i,\n\t\trhtml = /<|&#?\\w+;/,\n\t\trnoInnerhtml = /<(?:script|style|link)/i,\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t\t// We have to close these tags to support XHTML (#13200)\n\t\twrapMap = {\n\t\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\t\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t\t_default: support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\t\t},\n\t\tsafeFragment = createSafeFragment( document ),\n\t\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\n\twrapMap.optgroup = wrapMap.option;\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\tfunction getAll( context, tag ) {\n\t\tvar elems, elem,\n\t\t\ti = 0,\n\t\t\tfound = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\t\ttypeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t\tundefined;\n\n\t\tif ( !found ) {\n\t\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\t\tfound.push( elem );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\t\tjQuery.merge( [ context ], found ) :\n\t\t\tfound;\n\t}\n\n\t// Used in buildFragment, fixes the defaultChecked property\n\tfunction fixDefaultChecked( elem ) {\n\t\tif ( rcheckableType.test( elem.type ) ) {\n\t\t\telem.defaultChecked = elem.checked;\n\t\t}\n\t}\n\n\t// Support: IE<8\n\t// Manipulating tables requires a tbody\n\tfunction manipulationTarget( elem, content ) {\n\t\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\t\telem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = (jQuery.find.attr( elem, \"type\" ) !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\t\tif ( match ) {\n\t\t\telem.type = match[1];\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\t\treturn elem;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar elem,\n\t\t\ti = 0;\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\t\t}\n\t}\n\n\tfunction cloneCopyEvent( src, dest ) {\n\n\t\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type, i, l,\n\t\t\toldData = jQuery._data( src ),\n\t\t\tcurData = jQuery._data( dest, oldData ),\n\t\t\tevents = oldData.events;\n\n\t\tif ( events ) {\n\t\t\tdelete curData.handle;\n\t\t\tcurData.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make the cloned public data object a copy from the original\n\t\tif ( curData.data ) {\n\t\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t\t}\n\t}\n\n\tfunction fixCloneNodeIssues( src, dest ) {\n\t\tvar nodeName, e, data;\n\n\t\t// We do not need to do anything for non-Elements\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = dest.nodeName.toLowerCase();\n\n\t\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\t\tif ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\t\tdata = jQuery._data( dest );\n\n\t\t\tfor ( e in data.events ) {\n\t\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t\t}\n\n\t\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\t\tdest.removeAttribute( jQuery.expando );\n\t\t}\n\n\t\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\t\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\t\tdisableScript( dest ).text = src.text;\n\t\t\trestoreScript( dest );\n\n\t\t// IE6-10 improperly clones children of object elements using classid.\n\t\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t\t} else if ( nodeName === \"object\" ) {\n\t\t\tif ( dest.parentNode ) {\n\t\t\t\tdest.outerHTML = src.outerHTML;\n\t\t\t}\n\n\t\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t\t// If the src has innerHTML and the destination does not,\n\t\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\t\tif ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\t\t\t\tdest.innerHTML = src.innerHTML;\n\t\t\t}\n\n\t\t} else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\t\tif ( dest.value !== src.value ) {\n\t\t\t\tdest.value = src.value;\n\t\t\t}\n\n\t\t// IE6-8 fails to return the selected option to the default selected\n\t\t// state when cloning options\n\t\t} else if ( nodeName === \"option\" ) {\n\t\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t\t// IE6-8 fails to set the defaultValue to the correct value when\n\t\t// cloning other types of input fields\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar destElements, node, clone, i, srcElements,\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\tif ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\t\tclone = elem.cloneNode( true );\n\n\t\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t\t} else {\n\t\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t\t}\n\n\t\t\tif ( (!support.noCloneEvent || !support.noCloneChecked) &&\n\t\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\n\t\t\t\t// Fix all IE cloning issues\n\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\t\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\n\t\t\tdestElements = srcElements = node = null;\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\t\tvar j, elem, contains,\n\t\t\t\ttmp, tag, tbody, wrap,\n\t\t\t\tl = elems.length,\n\n\t\t\t\t// Ensure a safe fragment\n\t\t\t\tsafe = createSafeFragment( context ),\n\n\t\t\t\tnodes = [],\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\telem = elems[ i ];\n\n\t\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t\t// Add nodes directly\n\t\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\t\ttag = (rtagName.exec( elem ) || [ \"\", \"\" ])[ 1 ].toLowerCase();\n\t\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n\t\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\t\tj = wrap[0];\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\t\tif ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\t\tif ( !support.tbody ) {\n\n\t\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t\t\t0;\n\n\t\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\t\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fix #11356: Clear elements from fragment\n\t\t\tif ( tmp ) {\n\t\t\t\tsafe.removeChild( tmp );\n\t\t\t}\n\n\t\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\t\tif ( !support.appendChecked ) {\n\t\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t\t// that element, do not do anything\n\t\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t\t// Append to fragment\n\t\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t\t\t// Preserve script evaluation history\n\t\t\t\tif ( contains ) {\n\t\t\t\t\tsetGlobalEval( tmp );\n\t\t\t\t}\n\n\t\t\t\t// Capture executables\n\t\t\t\tif ( scripts ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp = null;\n\n\t\t\treturn safe;\n\t\t},\n\n\t\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\t\tvar elem, type, id, data,\n\t\t\t\ti = 0,\n\t\t\t\tinternalKey = jQuery.expando,\n\t\t\t\tcache = jQuery.cache,\n\t\t\t\tdeleteExpando = support.deleteExpando,\n\t\t\t\tspecial = jQuery.event.special;\n\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\t\tid = elem[ internalKey ];\n\t\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\t\tif ( data ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== strundefined ) {\n\t\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdeletedIds.push( id );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\n\t\tappend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\t\tvar elem,\n\t\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t}\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\twhile ( elem.firstChild ) {\n\t\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t\t}\n\n\t\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t\t// Support: IE<9\n\t\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\t\telem.options.length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t});\n\t\t},\n\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\t\tundefined;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t\t!wrapMap[ (rtagName.exec( value ) || [ \"\", \"\" ])[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\n\t\treplaceWith: function() {\n\t\t\tvar arg = arguments[ 0 ];\n\n\t\t\t// Make the changes, replacing each context element with the new content\n\t\t\tthis.domManip( arguments, function( elem ) {\n\t\t\t\targ = this.parentNode;\n\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\t\tif ( arg ) {\n\t\t\t\t\targ.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t\t},\n\n\t\tdetach: function( selector ) {\n\t\t\treturn this.remove( selector, true );\n\t\t},\n\n\t\tdomManip: function( args, callback ) {\n\n\t\t\t// Flatten any nested arrays\n\t\t\targs = concat.apply( [], args );\n\n\t\t\tvar first, node, hasScripts,\n\t\t\t\tscripts, doc, fragment,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tset = this,\n\t\t\t\tiNoClone = l - 1,\n\t\t\t\tvalue = args[0],\n\t\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\t\tif ( isFunction ||\n\t\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\t\treturn this.each(function( index ) {\n\t\t\t\t\tvar self = set.eq( index );\n\t\t\t\t\tif ( isFunction ) {\n\t\t\t\t\t\targs[0] = value.call( this, index, self.html() );\n\t\t\t\t\t}\n\t\t\t\t\tself.domManip( args, callback );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( l ) {\n\t\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\t\tfirst = fragment.firstChild;\n\n\t\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\t\tfragment = first;\n\t\t\t\t}\n\n\t\t\t\tif ( first ) {\n\t\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback.call( this[i], node, i );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t\t// Reenable scripts\n\t\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\t\tfragment = first = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\ti = 0,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1;\n\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone(true);\n\t\t\t\tjQuery( insert[i] )[ original ]( elems );\n\n\t\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t});\n\n\n\tvar iframe,\n\t\telemdisplay = {};\n\n\t/**\n\t * Retrieve the actual display of a element\n\t * @param {String} name nodeName of the element\n\t * @param {Object} doc Document object\n\t */\n\t// Called only from within defaultDisplay\n\tfunction actualDisplay( name, doc ) {\n\t\tvar style,\n\t\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t\t// since it was removed from specification and supported only in FF\n\t\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t\t// We don't have any data stored on the element,\n\t\t// so use \"detach\" method as fast way to get rid of the element\n\t\telem.detach();\n\n\t\treturn display;\n\t}\n\n\t/**\n\t * Try to determine the default display value of an element\n\t * @param {String} nodeName\n\t */\n\tfunction defaultDisplay( nodeName ) {\n\t\tvar doc = document,\n\t\t\tdisplay = elemdisplay[ nodeName ];\n\n\t\tif ( !display ) {\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t\t// If the simple way fails, read from inside an iframe\n\t\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t\t// Use the already-created iframe if possible\n\t\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\t\tdoc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n\t\t\t\t// Support: IE\n\t\t\t\tdoc.write();\n\t\t\t\tdoc.close();\n\n\t\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\t\tiframe.detach();\n\t\t\t}\n\n\t\t\t// Store the correct default display\n\t\t\telemdisplay[ nodeName ] = display;\n\t\t}\n\n\t\treturn display;\n\t}\n\n\n\t(function() {\n\t\tvar shrinkWrapBlocksVal;\n\n\t\tsupport.shrinkWrapBlocks = function() {\n\t\t\tif ( shrinkWrapBlocksVal != null ) {\n\t\t\t\treturn shrinkWrapBlocksVal;\n\t\t\t}\n\n\t\t\t// Will be changed later if needed.\n\t\t\tshrinkWrapBlocksVal = false;\n\n\t\t\t// Minified: var b,c,d\n\t\t\tvar div, body, container;\n\n\t\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\t\tif ( !body || !body.style ) {\n\t\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Setup\n\t\t\tdiv = document.createElement( \"div\" );\n\t\t\tcontainer = document.createElement( \"div\" );\n\t\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t\t// Support: IE6\n\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border\n\t\t\t\tdiv.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;\" +\n\t\t\t\t\t\"padding:1px;width:1px;zoom:1\";\n\t\t\t\tdiv.appendChild( document.createElement( \"div\" ) ).style.width = \"5px\";\n\t\t\t\tshrinkWrapBlocksVal = div.offsetWidth !== 3;\n\t\t\t}\n\n\t\t\tbody.removeChild( container );\n\n\t\t\treturn shrinkWrapBlocksVal;\n\t\t};\n\n\t})();\n\tvar rmargin = (/^margin/);\n\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\n\n\n\tvar getStyles, curCSS,\n\t\trposition = /^(top|right|bottom|left)$/;\n\n\tif ( window.getComputedStyle ) {\n\t\tgetStyles = function( elem ) {\n\t\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t\t}\n\n\t\t\treturn window.getComputedStyle( elem, null );\n\t\t};\n\n\t\tcurCSS = function( elem, name, computed ) {\n\t\t\tvar width, minWidth, maxWidth, ret,\n\t\t\t\tstyle = elem.style;\n\n\t\t\tcomputed = computed || getStyles( elem );\n\n\t\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t\t\tif ( computed ) {\n\n\t\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t\t}\n\n\t\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t\t// Remember the original values\n\t\t\t\t\twidth = style.width;\n\t\t\t\t\tminWidth = style.minWidth;\n\t\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\t\tret = computed.width;\n\n\t\t\t\t\t// Revert the changed values\n\t\t\t\t\tstyle.width = width;\n\t\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\treturn ret === undefined ?\n\t\t\t\tret :\n\t\t\t\tret + \"\";\n\t\t};\n\t} else if ( document.documentElement.currentStyle ) {\n\t\tgetStyles = function( elem ) {\n\t\t\treturn elem.currentStyle;\n\t\t};\n\n\t\tcurCSS = function( elem, name, computed ) {\n\t\t\tvar left, rs, rsLeft, ret,\n\t\t\t\tstyle = elem.style;\n\n\t\t\tcomputed = computed || getStyles( elem );\n\t\t\tret = computed ? computed[ name ] : undefined;\n\n\t\t\t// Avoid setting ret to empty string here\n\t\t\t// so we don't default to auto\n\t\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\t\tret = style[ name ];\n\t\t\t}\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\tleft = style.left;\n\t\t\t\trs = elem.runtimeStyle;\n\t\t\t\trsLeft = rs && rs.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tif ( rsLeft ) {\n\t\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t\t}\n\t\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;\n\t\t\t\tif ( rsLeft ) {\n\t\t\t\t\trs.left = rsLeft;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\treturn ret === undefined ?\n\t\t\t\tret :\n\t\t\t\tret + \"\" || \"auto\";\n\t\t};\n\t}\n\n\n\n\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tvar condition = conditionFn();\n\n\t\t\t\tif ( condition == null ) {\n\t\t\t\t\t// The test was not ready at this point; screw the hook this time\n\t\t\t\t\t// but check again when needed next time.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( condition ) {\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t\t// remove it.\n\t\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\n\n\t(function() {\n\t\t// Minified: var b,c,d,e,f,g, h,i\n\t\tvar div, style, a, pixelPositionVal, boxSizingReliableVal,\n\t\t\treliableHiddenOffsetsVal, reliableMarginRightVal;\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\t\ta = div.getElementsByTagName( \"a\" )[ 0 ];\n\t\tstyle = a && a.style;\n\n\t\t// Finish early in limited (non-browser) environments\n\t\tif ( !style ) {\n\t\t\treturn;\n\t\t}\n\n\t\tstyle.cssText = \"float:left;opacity:.5\";\n\n\t\t// Support: IE<9\n\t\t// Make sure that element opacity exists (as opposed to filter)\n\t\tsupport.opacity = style.opacity === \"0.5\";\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tsupport.cssFloat = !!style.cssFloat;\n\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\t// Support: Firefox<29, Android 2.3\n\t\t// Vendor-prefix box-sizing\n\t\tsupport.boxSizing = style.boxSizing === \"\" || style.MozBoxSizing === \"\" ||\n\t\t\tstyle.WebkitBoxSizing === \"\";\n\n\t\tjQuery.extend(support, {\n\t\t\treliableHiddenOffsets: function() {\n\t\t\t\tif ( reliableHiddenOffsetsVal == null ) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn reliableHiddenOffsetsVal;\n\t\t\t},\n\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\n\t\t\tpixelPosition: function() {\n\t\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\n\t\t\t// Support: Android 2.3\n\t\t\treliableMarginRight: function() {\n\t\t\t\tif ( reliableMarginRightVal == null ) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn reliableMarginRightVal;\n\t\t\t}\n\t\t});\n\n\t\tfunction computeStyleTests() {\n\t\t\t// Minified: var b,c,d,j\n\t\t\tvar div, body, container, contents;\n\n\t\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\t\tif ( !body || !body.style ) {\n\t\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Setup\n\t\t\tdiv = document.createElement( \"div\" );\n\t\t\tcontainer = document.createElement( \"div\" );\n\t\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t\tdiv.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\n\t\t\t// Support: IE<9\n\t\t\t// Assume reasonable values in the absence of getComputedStyle\n\t\t\tpixelPositionVal = boxSizingReliableVal = false;\n\t\t\treliableMarginRightVal = true;\n\n\t\t\t// Check for getComputedStyle so that this code is not run in IE<9.\n\t\t\tif ( window.getComputedStyle ) {\n\t\t\t\tpixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\t\tboxSizingReliableVal =\n\t\t\t\t\t( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\tcontents = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tcontents.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tcontents.style.marginRight = contents.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\n\t\t\t\treliableMarginRightVal =\n\t\t\t\t\t!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );\n\n\t\t\t\tdiv.removeChild( contents );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t\t// to display:none and there are still other visible table cells in a\n\t\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t\t// determining if an element has been hidden directly using\n\t\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\t\tcontents = div.getElementsByTagName( \"td\" );\n\t\t\tcontents[ 0 ].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t\tif ( reliableHiddenOffsetsVal ) {\n\t\t\t\tcontents[ 0 ].style.display = \"\";\n\t\t\t\tcontents[ 1 ].style.display = \"none\";\n\t\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t\t}\n\n\t\t\tbody.removeChild( container );\n\t\t}\n\n\t})();\n\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\tjQuery.swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\n\tvar\n\t\t\tralpha = /alpha\\([^)]*\\)/i,\n\t\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\n\t\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\t\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\n\t\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n\n\t// return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( style, name ) {\n\n\t\t// shortcut for names that are not vendor prefixed\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// check for vendor prefixed names\n\t\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\t\torigName = name,\n\t\t\ti = cssPrefixes.length;\n\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in style ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\treturn origName;\n\t}\n\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem, hidden,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of most of the elements in a second loop\n\t\t// to avoid the constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\tvar matches = rnumsplit.exec( value );\n\t\treturn matches ?\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t\t// If we already have the right measurement, avoid augmentation\n\t\t\t4 :\n\t\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t\tname === \"width\" ? 1 : 0,\n\n\t\t\tval = 0;\n\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\t\t// both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\tif ( isBorderBox ) {\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\n\t\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// at this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t}\n\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar valueIsBorderBox = true,\n\t\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test(val) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\n\t\t// use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\n\tjQuery.extend({\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t// normalize float css property\n\t\t\t\"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t\t},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t\t// gets hook for the prefixed version\n\t\t\t// followed by the unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\n\t\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\t\tvalue += \"px\";\n\t\t\t\t}\n\n\t\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n\t\t\t\t\t// Support: IE\n\t\t\t\t\t// Swallow errors from 'invalid' CSS values (#5509)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar num, val, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t\t// gets hook for the prefixed version\n\t\t\t// followed by the unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\n\t\t\t//convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\n\t\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar styles = extra && getStyles( elem );\n\t\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tsupport.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) : 0\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t});\n\n\tif ( !support.opacity ) {\n\t\tjQuery.cssHooks.opacity = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\t// IE uses filters for opacity\n\t\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar style = elem.style,\n\t\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\tstyle.zoom = 1;\n\n\t\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// otherwise, set new filter values\n\t\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\t\tfilter + \" \" + opacity;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t}\n\t\t}\n\t);\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\n\t\t\t\t\t// assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t},\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( isHidden( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || \"swing\";\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\n\t\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\n\t\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t\t// available and use plain properties where available\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE <=9\n\t// Panic based approach to setting things on disconnected nodes\n\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t}\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back Compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\n\n\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\t\trrun = /queueHooks$/,\n\t\tanimationPrefilters = [ defaultPrefilter ],\n\t\ttweeners = {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\t\ttarget = tween.cur(),\n\t\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\t\tscale = 1,\n\t\t\t\t\tmaxIterations = 20;\n\n\t\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\t\tparts = parts || [];\n\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\tstart = +target || 1;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t\t}\n\n\t\t\t\t// Update tween properties\n\t\t\t\tif ( parts ) {\n\t\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\t\ttween.unit = unit;\n\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t\t+parts[ 2 ];\n\t\t\t\t}\n\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t};\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\tsetTimeout(function() {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\tattrs = { height: type },\n\t\t\ti = 0;\n\n\t\t// if we include width, step value is 1 to do all cssExpand values,\n\t\t// if we don't include width, step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t\t// we're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\t/* jshint validthis: true */\n\t\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHidden( elem ),\n\t\t\tdataShow = jQuery._data( elem, \"fxshow\" );\n\n\t\t// handle queue: false promises\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function() {\n\t\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t\t// before this completes\n\t\t\t\tanim.always(function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// height/width overflow pass\n\t\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t\t// Make sure that nothing sneaks out\n\t\t\t// Record all 3 overflow attributes because IE does not\n\t\t\t// change the overflow attribute when overflowX and\n\t\t\t// overflowY are set to the same value\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t\t// Set display property to inline-block for height/width\n\t\t\t// animations on inline elements that are having width/height animated\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t\t// Test default display if display is currently \"none\"\n\t\t\tcheckDisplay = display === \"none\" ?\n\t\t\t\tjQuery._data( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// inline-level elements accept inline-block;\n\t\t\t\t// block-level elements need to be inline with layout\n\t\t\t\tif ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t} else {\n\t\t\t\t\tstyle.zoom = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tif ( !support.shrinkWrapBlocks() ) {\n\t\t\t\tanim.always(function() {\n\t\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// show/hide pass\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t\t// Any non-fx value stops us from restoring the original display value\n\t\t\t} else {\n\t\t\t\tdisplay = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = jQuery._data( elem, \"fxshow\", {} );\n\t\t\t}\n\n\t\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\t\t\tif ( hidden ) {\n\t\t\t\tjQuery( elem ).show();\n\t\t\t} else {\n\t\t\t\tanim.done(function() {\n\t\t\t\t\tjQuery( elem ).hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\tanim.done(function() {\n\t\t\t\tvar prop;\n\t\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor ( prop in orig ) {\n\t\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\t\tif ( hidden ) {\n\t\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\t\tstyle.display = display;\n\t\t}\n\t}\n\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\n\t\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = animationPrefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t\t// don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t}),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise({\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// resolve when we played the last frame\n\t\t\t\t\t// otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}),\n\t\t\tprops = animation.props;\n\n\t\tpropFilter( props, animation.opts.specialEasing );\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map( props, createTween, animation );\n\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t})\n\t\t);\n\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\n\tjQuery.Animation = jQuery.extend( Animation, {\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.split(\" \");\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\t\ttweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tanimationPrefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tanimationPrefilters.push( callback );\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t\t// show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t\t// animate to the value specified\n\t\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = jQuery._data( this );\n\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t\t// but only if they were gotoEnd\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t\t// enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\n\t\t\t\t// look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ttimers = jQuery.timers,\n\t\t\ti = 0;\n\n\t\tfxNow = jQuery.now();\n\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\n\tjQuery.fx.interval = 13;\n\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\n\tjQuery.fx.stop = function() {\n\t\tclearInterval( timerId );\n\t\ttimerId = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t};\n\n\n\t(function() {\n\t\t// Minified: var a,b,c,d,e\n\t\tvar input, div, select, a, opt;\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tdiv.setAttribute( \"className\", \"t\" );\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\t\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\n\t\t// First batch of tests.\n\t\tselect = document.createElement(\"select\");\n\t\topt = select.appendChild( document.createElement(\"option\") );\n\t\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\t\ta.style.cssText = \"top:1px\";\n\n\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\t\tsupport.getSetAttribute = div.className !== \"t\";\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText instead)\n\t\tsupport.style = /top/.test( a.getAttribute(\"style\") );\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\tsupport.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n\t\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\t\tsupport.checkOn = !!input.value;\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Tests for enctype support on a form (#6743)\n\t\tsupport.enctype = !!document.createElement(\"form\").enctype;\n\n\t\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t\t// (WebKit marks them as disabled)\n\t\tselect.disabled = true;\n\t\tsupport.optDisabled = !opt.disabled;\n\n\t\t// Support: IE8 only\n\t\t// Check if we can trust getAttribute(\"value\")\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.setAttribute( \"value\", \"\" );\n\t\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t\t// Check if an input maintains its value after becoming a radio\n\t\tinput.value = \"t\";\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tsupport.radioValue = input.value === \"t\";\n\t})();\n\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[0];\n\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t\t// handle most common string cases\n\t\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tvar val;\n\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\t\tmax :\n\t\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t\tif ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {\n\n\t\t\t\t\t\t\t// Support: IE6\n\t\t\t\t\t\t\t// When new option element is added to select box we need to\n\t\t\t\t\t\t\t// force reflow of newly added node in order to workaround delay\n\t\t\t\t\t\t\t// of initialization properties\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toption.selected = optionSet = true;\n\n\t\t\t\t\t\t\t} catch ( _ ) {\n\n\t\t\t\t\t\t\t\t// Will be executed only in IE6\n\t\t\t\t\t\t\t\toption.scrollHeight;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toption.selected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn options;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\t// Support: Webkit\n\t\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\n\n\n\tvar nodeHook, boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle,\n\t\truseDefault = /^(?:checked|selected)$/i,\n\t\tgetSetAttribute = support.getSetAttribute,\n\t\tgetSetInput = support.input;\n\n\tjQuery.fn.extend({\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar hooks, ret,\n\t\t\t\tnType = elem.nodeType;\n\n\t\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\n\t\t\t// All attributes are lowercase\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t\t}\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\n\t\t\t\t} else {\n\t\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\t\treturn ret == null ?\n\t\t\t\t\tundefined :\n\t\t\t\t\tret;\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name, propName,\n\t\t\t\ti = 0,\n\t\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\t\tif ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hook for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t\t// IE<8 needs the *property* name\n\t\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t\t} else {\n\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\t};\n\n\t// Retrieve booleans specially\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\t\tattrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n\t\t\tfunction( elem, name, isXML ) {\n\t\t\t\tvar ret, handle;\n\t\t\t\tif ( !isXML ) {\n\t\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\t\tnull;\n\t\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t} :\n\t\t\tfunction( elem, name, isXML ) {\n\t\t\t\tif ( !isXML ) {\n\t\t\t\t\treturn elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n\t\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\t\tnull;\n\t\t\t\t}\n\t\t\t};\n\t});\n\n\t// fix oldIE attroperties\n\tif ( !getSetInput || !getSetAttribute ) {\n\t\tjQuery.attrHooks.value = {\n\t\t\tset: function( elem, value, name ) {\n\t\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\t\telem.defaultValue = value;\n\t\t\t\t} else {\n\t\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// IE6/7 do not support getting/setting some attributes with get/setAttribute\n\tif ( !getSetAttribute ) {\n\n\t\t// Use this for any attribute in IE6/7\n\t\t// This fixes almost every IE6/7 issue\n\t\tnodeHook = {\n\t\t\tset: function( elem, value, name ) {\n\t\t\t\t// Set the existing or create a new attribute node\n\t\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\t\tif ( !ret ) {\n\t\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tret.value = value += \"\";\n\n\t\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\t\tif ( name === \"value\" || value === elem.getAttribute( name ) ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Some attributes are constructed with empty-string values when not defined\n\t\tattrHandle.id = attrHandle.name = attrHandle.coords =\n\t\t\tfunction( elem, name, isXML ) {\n\t\t\t\tvar ret;\n\t\t\t\tif ( !isXML ) {\n\t\t\t\t\treturn (ret = elem.getAttributeNode( name )) && ret.value !== \"\" ?\n\t\t\t\t\t\tret.value :\n\t\t\t\t\t\tnull;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Fixing value retrieval on a button requires this module\n\t\tjQuery.valHooks.button = {\n\t\t\tget: function( elem, name ) {\n\t\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\t\tif ( ret && ret.specified ) {\n\t\t\t\t\treturn ret.value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: nodeHook.set\n\t\t};\n\n\t\t// Set contenteditable to false on removals(#10429)\n\t\t// Setting to empty string throws an error as an invalid value\n\t\tjQuery.attrHooks.contenteditable = {\n\t\t\tset: function( elem, value, name ) {\n\t\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t\t}\n\t\t};\n\n\t\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t\t// This is for removals\n\t\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\t\tjQuery.attrHooks[ name ] = {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tif ( !support.style ) {\n\t\tjQuery.attrHooks.style = {\n\t\t\tget: function( elem ) {\n\t\t\t\t// Return undefined in the case of empty string\n\t\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\t\treturn elem.style.cssText || undefined;\n\t\t\t},\n\t\t\tset: function( elem, value ) {\n\t\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t\t}\n\t\t};\n\t}\n\n\n\n\n\tvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n\t\trclickable = /^(?:a|area)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\n\t\tremoveProp: function( name ) {\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\treturn this.each(function() {\n\t\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\t\ttry {\n\t\t\t\t\tthis[ name ] = undefined;\n\t\t\t\t\tdelete this[ name ];\n\t\t\t\t} catch( e ) {}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t},\n\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks, notxml,\n\t\t\t\tnType = elem.nodeType;\n\n\t\t\t// don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\t\tif ( notxml ) {\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\n\t\t\tif ( value !== undefined ) {\n\t\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\t\tret :\n\t\t\t\t\t( elem[ name ] = value );\n\n\t\t\t} else {\n\t\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\t\tret :\n\t\t\t\t\telem[ name ];\n\t\t\t}\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\t\treturn tabindex ?\n\t\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\t-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Some attributes require a special call on IE\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !support.hrefNormalized ) {\n\t\t// href/src property should get the full normalized URL (#10299/#12915)\n\t\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\t\t\tjQuery.propHooks[ name ] = {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t// Support: Safari, IE9+\n\t// mis-reports the default selected property of an option\n\t// Accessing the parent's selectedIndex property fixes it\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar parent = elem.parentNode;\n\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each([\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t});\n\n\t// IE6/7 call enctype encoding\n\tif ( !support.enctype ) {\n\t\tjQuery.propFix.enctype = \"encoding\";\n\t}\n\n\n\n\n\tvar rclass = /[\\t\\r\\n\\f]/g;\n\n\tjQuery.fn.extend({\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length,\n\t\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( proceed ) {\n\t\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\" \"\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length,\n\t\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ( proceed ) {\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( type === \"string\" ) {\n\t\t\t\t\t// toggle individual class names\n\t\t\t\t\tvar className,\n\t\t\t\t\t\ti = 0,\n\t\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\t\tif ( this.className ) {\n\t\t\t\t\t\t// store className if set\n\t\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function( selector ) {\n\t\t\tvar className = \" \" + selector + \" \",\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\n\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tjQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t},\n\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t\t}\n\t});\n\n\n\tvar nonce = jQuery.now();\n\n\tvar rquery = (/\\?/);\n\n\n\n\tvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\n\tjQuery.parseJSON = function( data ) {\n\t\t// Attempt to parse using the native JSON parser first\n\t\tif ( window.JSON && window.JSON.parse ) {\n\t\t\t// Support: Android 2.3\n\t\t\t// Workaround failure to string-cast null input\n\t\t\treturn window.JSON.parse( data + \"\" );\n\t\t}\n\n\t\tvar requireNonComma,\n\t\t\tdepth = null,\n\t\t\tstr = jQuery.trim( data + \"\" );\n\n\t\t// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n\t\t// after removing valid tokens\n\t\treturn str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n\t\t\t// Force termination if we see a misplaced comma\n\t\t\tif ( requireNonComma && comma ) {\n\t\t\t\tdepth = 0;\n\t\t\t}\n\n\t\t\t// Perform no more replacements after returning to outermost depth\n\t\t\tif ( depth === 0 ) {\n\t\t\t\treturn token;\n\t\t\t}\n\n\t\t\t// Commas must not follow \"[\", \"{\", or \",\"\n\t\t\trequireNonComma = open || comma;\n\n\t\t\t// Determine new depth\n\t\t\t// array/object open (\"[\" or \"{\"): depth += true - false (increment)\n\t\t\t// array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n\t\t\t// other cases (\",\" or primitive): depth += true - true (numeric cast)\n\t\t\tdepth += !close - !open;\n\n\t\t\t// Remove this token\n\t\t\treturn \"\";\n\t\t}) ) ?\n\t\t\t( Function( \"return \" + str ) )() :\n\t\t\tjQuery.error( \"Invalid JSON: \" + data );\n\t};\n\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tif ( window.DOMParser ) { // Standard\n\t\t\t\ttmp = new DOMParser();\n\t\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t\t} else { // IE\n\t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\t\txml.async = \"false\";\n\t\t\t\txml.loadXML( data );\n\t\t\t}\n\t\t} catch( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\n\n\tvar\n\t\t// Document location\n\t\tajaxLocParts,\n\t\tajaxLocation,\n\n\t\trhash = /#.*$/,\n\t\trts = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat(\"*\");\n\n\t// #8138, IE may throw an exception when accessing\n\t// a field from window.location if document.domain has been set\n\ttry {\n\t\tajaxLocation = location.href;\n\t} catch( e ) {\n\t\t// Use the href attribute of an A element\n\t\t// since IE will modify it given document.location\n\t\tajaxLocation = document.createElement( \"a\" );\n\t\tajaxLocation.href = \"\";\n\t\tajaxLocation = ajaxLocation.href;\n\t}\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType.charAt( 0 ) === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar deep, key,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\t\tvar firstDataType, ct, finalDataType, type,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif ( current ) {\n\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: \"success\", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar // Cross-domain detection vars\n\t\t\t\tparts,\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\t\t\t// Response headers as string\n\t\t\t\tresponseHeadersString,\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\n\t\t\t\ttransport,\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeaders,\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\t\t\t// The jqXHR state\n\t\t\t\tstate = 0,\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail;\n\n\t\t\t// Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\tcacheURL = s.url;\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add anti-cache in url if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t\t}\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\tdone( -1, e );\n\t\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t\t// Called once\n\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// State is \"done\" now\n\t\t\t\tstate = 2;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// We extract error from statusText\n\t\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t});\n\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t\t// shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\n\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\n\n\tjQuery.fn.extend({\n\t\twrapAll: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function(i) {\n\t\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( this[0] ) {\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\t\tif ( this[0].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t\t}\n\n\t\t\t\twrap.map(function() {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append( this );\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function(i) {\n\t\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function() {\n\t\t\treturn this.parent().each(function() {\n\t\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t\t}\n\t\t\t}).end();\n\t\t}\n\t});\n\n\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\t\t\t(!support.reliableHiddenOffsets() &&\n\t\t\t\t((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n\n\n\n\n\tvar r20 = /%20/g,\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\n\t\t\t\t} else {\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, value ) {\n\t\t\t\t// If value is a function, invoke it and return its value\n\t\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t\t};\n\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif ( traditional === undefined ) {\n\t\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t\t}\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t});\n\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" ).replace( r20, \"+\" );\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t})\n\t\t\t.filter(function() {\n\t\t\t\tvar type = this.type;\n\t\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t})\n\t\t\t.map(function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\n\t\t\t\treturn val == null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\n\t// Create the request object\n\t// (This is still attached to ajaxSettings for backward compatibility)\n\tjQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\t\t// Support: IE6+\n\t\tfunction() {\n\n\t\t\t// XHR cannot access local files, always use ActiveX for that case\n\t\t\treturn !this.isLocal &&\n\n\t\t\t\t// Support: IE7-8\n\t\t\t\t// oldIE XHR does not support non-RFC2616 methods (#13240)\n\t\t\t\t// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n\t\t\t\t// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n\t\t\t\t// Although this check for six methods instead of eight\n\t\t\t\t// since IE also does not support \"trace\" and \"connect\"\n\t\t\t\t/^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n\n\t\t\t\tcreateStandardXHR() || createActiveXHR();\n\t\t} :\n\t\t// For all other browsers, use the standard XMLHttpRequest object\n\t\tcreateStandardXHR;\n\n\tvar xhrId = 0,\n\t\txhrCallbacks = {},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\n\t// Support: IE<10\n\t// Open requests must be manually aborted on unload (#5280)\n\t// See https://support.microsoft.com/kb/2856746 for more info\n\tif ( window.attachEvent ) {\n\t\twindow.attachEvent( \"onunload\", function() {\n\t\t\tfor ( var key in xhrCallbacks ) {\n\t\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t\t}\n\t\t});\n\t}\n\n\t// Determine support properties\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\txhrSupported = support.ajax = !!xhrSupported;\n\n\t// Create transport if the browser can provide an xhr\n\tif ( xhrSupported ) {\n\n\t\tjQuery.ajaxTransport(function( options ) {\n\t\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\t\tif ( !options.crossDomain || support.cors ) {\n\n\t\t\t\tvar callback;\n\n\t\t\t\treturn {\n\t\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\t\tvar i,\n\t\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\t\t\t// Open the socket\n\t\t\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set headers\n\t\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t\t// IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n\t\t\t\t\t\t\t// request header to a null-value.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// To keep consistent with other XHR implementations, cast the value\n\t\t\t\t\t\t\t// to string and ignore `undefined`.\n\t\t\t\t\t\t\tif ( headers[ i ] !== undefined ) {\n\t\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] + \"\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do send the request\n\t\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\t\txhr.send( ( options.hasContent && options.data ) || null );\n\n\t\t\t\t\t\t// Listener\n\t\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\t\tvar status, statusText, responses;\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\t\t\t\t\t\t\t\t// Clean up\n\t\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\t\tcallback = undefined;\n\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\n\t\t\t\t\t\t\t\t// Abort manually if needed\n\t\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\n\t\t\t\t\t\t\t\t\t// Support: IE<10\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif ( !status && options.isLocal && !options.crossDomain ) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\t\tcomplete( status, statusText, responses, xhr.getAllResponseHeaders() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( !options.async ) {\n\t\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\t\tsetTimeout( callback );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Add to the list of active xhr callbacks\n\t\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tabort: function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\t// Functions to create xhrs\n\tfunction createStandardXHR() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch( e ) {}\n\t}\n\n\tfunction createActiveXHR() {\n\t\ttry {\n\t\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t\t} catch( e ) {}\n\t}\n\n\n\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /(?:java|ecma)script/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache's special case and global\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t\ts.global = false;\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function(s) {\n\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\n\t\t\tvar script,\n\t\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\t\treturn {\n\n\t\t\t\tsend: function( _, callback ) {\n\n\t\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\t\tscript.async = true;\n\n\t\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t\t}\n\n\t\t\t\t\tscript.src = s.url;\n\n\t\t\t\t\t// Attach handlers for all browsers\n\t\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( script ) {\n\t\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\n\n\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\n\t\t\t// force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function() {\n\t\t\t\t// Restore preexisting value\n\t\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\n\n\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\n\n\t// Keep a copy of the old load method\n\tvar _load = jQuery.fn.load;\n\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" && _load ) {\n\t\t\treturn _load.apply( this, arguments );\n\t\t}\n\n\t\tvar selector, response, type,\n\t\t\tself = this,\n\t\t\toff = url.indexOf(\" \");\n\n\t\tif ( off >= 0 ) {\n\t\t\tselector = jQuery.trim( url.slice( off, url.length ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\t\ttype: type,\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function( responseText ) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html( selector ?\n\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\n\t\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\n\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t});\n\n\n\n\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\n\n\n\n\tvar docElem = window.document.documentElement;\n\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ?\n\t\t\telem :\n\t\t\telem.nodeType === 9 ?\n\t\t\t\telem.defaultView || elem.parentWindow :\n\t\t\t\tfalse;\n\t}\n\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\n\t\t\t// set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\tjQuery.inArray(\"auto\", [ curCSSTop, curCSSLeft ] ) > -1;\n\n\t\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\t\toptions = options.call( elem, i, curOffset );\n\t\t\t}\n\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\t\toffset: function( options ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar docElem, win,\n\t\t\t\tbox = { top: 0, left: 0 },\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\t\tif ( !doc ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\t// Make sure it's not a disconnected DOM node\n\t\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\t\treturn box;\n\t\t\t}\n\n\t\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\t\tbox = elem.getBoundingClientRect();\n\t\t\t}\n\t\t\twin = getWindow( doc );\n\t\t\treturn {\n\t\t\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\t\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t\t\t};\n\t\t},\n\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent, offset,\n\t\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\t\telem = this[ 0 ];\n\n\t\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\t\t} else {\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\t\treturn {\n\t\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\t\t\t};\n\t\t},\n\n\t\toffsetParent: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\t\t\treturn offsetParent || docElem;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = /Y/.test( prop );\n\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\t\telem[ method ];\n\t\t\t\t}\n\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length, null );\n\t\t};\n\t});\n\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t});\n\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t\t// margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t\t};\n\t\t});\n\t});\n\n\n\t// The number of elements contained in the matched element set\n\tjQuery.fn.size = function() {\n\t\treturn this.length;\n\t};\n\n\tjQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\n\n\n\tvar\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in\n\t// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( typeof noGlobal === strundefined ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\n\n\n\treturn jQuery;\n\n\t}));\n\n\n/***/ },\n\n/***/ 9:\n/*!***********************************************************!*\\\n  !*** ./src/webpack_example/highcharts/highcharts-page.js ***!\n  \\***********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar $ = __webpack_require__(/*! jquery */ 1);\n\tvar Highcharts = __webpack_require__(/*! highcharts-commonjs */ 20);\n\n\texports.display = function() {\n\n\t    var chartOptions = {\n\t        title: {\n\t            text: 'Monthly Average Temperature',\n\t            x: -20 //center\n\t        },\n\t        subtitle: {\n\t            text: 'Source: WorldClimate.com',\n\t            x: -20\n\t        },\n\t        xAxis: {\n\t            categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n\t                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\t        },\n\t        yAxis: {\n\t            title: {\n\t                text: 'Temperature (C)'\n\t            },\n\t            plotLines: [{\n\t                value: 0,\n\t                width: 1,\n\t                color: '#808080'\n\t            }]\n\t        },\n\t        tooltip: {\n\t            valueSuffix: 'C'\n\t        },\n\t        legend: {\n\t            layout: 'vertical',\n\t            align: 'right',\n\t            verticalAlign: 'middle',\n\t            borderWidth: 0\n\t        },\n\t        series: [{\n\t            name: 'Tokyo',\n\t            data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6]\n\t        }, {\n\t            name: 'New York',\n\t            data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5]\n\t        }, {\n\t            name: 'Berlin',\n\t            data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0]\n\t        }, {\n\t            name: 'London',\n\t            data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8]\n\t        }]\n\t    };\n\n\t    Highcharts.createChart(\n\t        document.getElementById(\"container\"),\n\t        chartOptions\n\t    );\n\n\n\t};\n\n\n\n/***/ },\n\n/***/ 20:\n/*!****************************************!*\\\n  !*** ./~/highcharts-commonjs/index.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Highcharts = __webpack_require__(/*! ./src/highcharts.src.js */ 50);\n\n\tmodule.exports = {\n\t  createChart: function(div, options, callback) {\n\t    options.chart = options.chart || {};\n\t    options.chart.renderTo = div;\n\t    return new Highcharts.Chart(options, callback);\n\t  },\n\t  destroy: function(chart) {\n\t    chart.destroy();\n\t  }\n\t};\n\n\n/***/ },\n\n/***/ 50:\n/*!*****************************************************!*\\\n  !*** ./~/highcharts-commonjs/src/highcharts.src.js ***!\n  \\*****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*eslint-disable*/\n\t'use strict';\n\tvar jquery = __webpack_require__(/*! jquery */ 156);\n\tvar Highcharts;\n\tvar HighchartsAdapter;\n\n\t// ==ClosureCompiler==\n\t// @compilation_level SIMPLE_OPTIMIZATIONS\n\n\t/**\n\t * @license Highcharts JS v4.1.4 (2015-03-10)\n\t *\n\t * (c) 2009-2014 Torstein Honsi\n\t *\n\t * License: www.highcharts.com/license\n\t */\n\n\t// JSLint options:\n\t/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */\n\t/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */\n\t// encapsulated variables\n\tvar UNDEFINED,\n\t\tdoc = document,\n\t\twin = window,\n\t\tmath = Math,\n\t\tmathRound = math.round,\n\t\tmathFloor = math.floor,\n\t\tmathCeil = math.ceil,\n\t\tmathMax = math.max,\n\t\tmathMin = math.min,\n\t\tmathAbs = math.abs,\n\t\tmathCos = math.cos,\n\t\tmathSin = math.sin,\n\t\tmathPI = math.PI,\n\t\tdeg2rad = mathPI * 2 / 360,\n\n\n\t\t// some variables\n\t\tuserAgent = navigator.userAgent,\n\t\tisOpera = win.opera,\n\t\tisIE = /(msie|trident)/i.test(userAgent) && !isOpera,\n\t\tdocMode8 = doc.documentMode === 8,\n\t\tisWebKit = /AppleWebKit/.test(userAgent),\n\t\tisFirefox = /Firefox/.test(userAgent),\n\t\tisTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n\t\tSVG_NS = 'http://www.w3.org/2000/svg',\n\t\thasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n\t\thasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n\t\tuseCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,\n\t\tRenderer,\n\t\thasTouch,\n\t\tsymbolSizes = {},\n\t\tidCounter = 0,\n\t\tgarbageBin,\n\t\tdefaultOptions,\n\t\tdateFormat, // function\n\t\tglobalAnimation,\n\t\tpathAnim,\n\t\ttimeUnits,\n\t\tnoop = function () { return UNDEFINED; },\n\t\tcharts = [],\n\t\tchartCount = 0,\n\t\tPRODUCT = 'Highcharts',\n\t\tVERSION = '4.1.4',\n\n\t\t// some constants for frequently used strings\n\t\tDIV = 'div',\n\t\tABSOLUTE = 'absolute',\n\t\tRELATIVE = 'relative',\n\t\tHIDDEN = 'hidden',\n\t\tPREFIX = 'highcharts-',\n\t\tVISIBLE = 'visible',\n\t\tPX = 'px',\n\t\tNONE = 'none',\n\t\tM = 'M',\n\t\tL = 'L',\n\t\tnumRegex = /^[0-9]+$/,\n\t\tNORMAL_STATE = '',\n\t\tHOVER_STATE = 'hover',\n\t\tSELECT_STATE = 'select',\n\t\tmarginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n\t\t\n\t\t// Object for extending Axis\n\t\tAxisPlotLineOrBandExtension,\n\n\t\t// constants for attributes\n\t\tSTROKE_WIDTH = 'stroke-width',\n\n\t\t// time methods, changed based on whether or not UTC is used\n\t\tDate,  // Allow using a different Date class\n\t\tmakeTime,\n\t\ttimezoneOffset,\n\t\tgetTimezoneOffset,\n\t\tgetMinutes,\n\t\tgetHours,\n\t\tgetDay,\n\t\tgetDate,\n\t\tgetMonth,\n\t\tgetFullYear,\n\t\tsetMinutes,\n\t\tsetHours,\n\t\tsetDate,\n\t\tsetMonth,\n\t\tsetFullYear,\n\n\n\t\t// lookup over the types and the associated classes\n\t\tseriesTypes = {},\n\t\tHighcharts;\n\n\t// The Highcharts namespace\n\tHighcharts = {};\n\n\tHighcharts.seriesTypes = seriesTypes;\n\n\t/**\n\t * Extend an object with the members of another\n\t * @param {Object} a The object to be extended\n\t * @param {Object} b The object to add to the first one\n\t */\n\tvar extend = Highcharts.extend = function (a, b) {\n\t\tvar n;\n\t\tif (!a) {\n\t\t\ta = {};\n\t\t}\n\t\tfor (n in b) {\n\t\t\ta[n] = b[n];\n\t\t}\n\t\treturn a;\n\t};\n\t\t\n\t/**\n\t * Deep merge two or more objects and return a third object. If the first argument is\n\t * true, the contents of the second object is copied into the first object.\n\t * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n\t * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n\t * it copied properties from extended prototypes. \n\t */\n\tfunction merge() {\n\t\tvar i,\n\t\t\targs = arguments,\n\t\t\tlen,\n\t\t\tret = {},\n\t\t\tdoCopy = function (copy, original) {\n\t\t\t\tvar value, key;\n\n\t\t\t\t// An object is replacing a primitive\n\t\t\t\tif (typeof copy !== 'object') {\n\t\t\t\t\tcopy = {};\n\t\t\t\t}\n\n\t\t\t\tfor (key in original) {\n\t\t\t\t\tif (original.hasOwnProperty(key)) {\n\t\t\t\t\t\tvalue = original[key];\n\n\t\t\t\t\t\t// Copy the contents of objects, but not arrays or DOM nodes\n\t\t\t\t\t\tif (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&\n\t\t\t\t\t\t\t\tkey !== 'renderTo' && typeof value.nodeType !== 'number') {\n\t\t\t\t\t\t\tcopy[key] = doCopy(copy[key] || {}, value);\n\t\t\t\t\t\n\t\t\t\t\t\t// Primitives and arrays are copied over directly\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcopy[key] = original[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn copy;\n\t\t\t};\n\n\t\t// If first argument is true, copy into the existing object. Used in setOptions.\n\t\tif (args[0] === true) {\n\t\t\tret = args[1];\n\t\t\targs = Array.prototype.slice.call(args, 2);\n\t\t}\n\n\t\t// For each argument, extend the return\n\t\tlen = args.length;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = doCopy(ret, args[i]);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Shortcut for parseInt\n\t * @param {Object} s\n\t * @param {Number} mag Magnitude\n\t */\n\tfunction pInt(s, mag) {\n\t\treturn parseInt(s, mag || 10);\n\t}\n\n\t/**\n\t * Check for string\n\t * @param {Object} s\n\t */\n\tfunction isString(s) {\n\t\treturn typeof s === 'string';\n\t}\n\n\t/**\n\t * Check for object\n\t * @param {Object} obj\n\t */\n\tfunction isObject(obj) {\n\t\treturn obj && typeof obj === 'object';\n\t}\n\n\t/**\n\t * Check for array\n\t * @param {Object} obj\n\t */\n\tfunction isArray(obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n\n\t/**\n\t * Check for number\n\t * @param {Object} n\n\t */\n\tfunction isNumber(n) {\n\t\treturn typeof n === 'number';\n\t}\n\n\tfunction log2lin(num) {\n\t\treturn math.log(num) / math.LN10;\n\t}\n\tfunction lin2log(num) {\n\t\treturn math.pow(10, num);\n\t}\n\n\t/**\n\t * Remove last occurence of an item from an array\n\t * @param {Array} arr\n\t * @param {Mixed} item\n\t */\n\tfunction erase(arr, item) {\n\t\tvar i = arr.length;\n\t\twhile (i--) {\n\t\t\tif (arr[i] === item) {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//return arr;\n\t}\n\n\t/**\n\t * Returns true if the object is not null or undefined. Like MooTools' $.defined.\n\t * @param {Object} obj\n\t */\n\tfunction defined(obj) {\n\t\treturn obj !== UNDEFINED && obj !== null;\n\t}\n\n\t/**\n\t * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n\t * it attempts to set expando properties on the SVG element, which is not allowed.\n\t *\n\t * @param {Object} elem The DOM element to receive the attribute(s)\n\t * @param {String|Object} prop The property or an abject of key-value pairs\n\t * @param {String} value The value if a single property is set\n\t */\n\tfunction attr(elem, prop, value) {\n\t\tvar key,\n\t\t\tret;\n\n\t\t// if the prop is a string\n\t\tif (isString(prop)) {\n\t\t\t// set the value\n\t\t\tif (defined(value)) {\n\t\t\t\telem.setAttribute(prop, value);\n\n\t\t\t// get the value\n\t\t\t} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n\t\t\t\tret = elem.getAttribute(prop);\n\t\t\t}\n\n\t\t// else if prop is defined, it is a hash of key/value pairs\n\t\t} else if (defined(prop) && isObject(prop)) {\n\t\t\tfor (key in prop) {\n\t\t\t\telem.setAttribute(key, prop[key]);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t/**\n\t * Check if an element is an array, and if not, make it into an array. Like\n\t * MooTools' $.splat.\n\t */\n\tfunction splat(obj) {\n\t\treturn isArray(obj) ? obj : [obj];\n\t}\n\n\n\t/**\n\t * Return the first value that is defined. Like MooTools' $.pick.\n\t */\n\tvar pick = Highcharts.pick = function () {\n\t\tvar args = arguments,\n\t\t\ti,\n\t\t\targ,\n\t\t\tlength = args.length;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\targ = args[i];\n\t\t\tif (arg !== UNDEFINED && arg !== null) {\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Set CSS on a given element\n\t * @param {Object} el\n\t * @param {Object} styles Style object with camel case property names\n\t */\n\tfunction css(el, styles) {\n\t\tif (isIE && !hasSVG) { // #2686\n\t\t\tif (styles && styles.opacity !== UNDEFINED) {\n\t\t\t\tstyles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n\t\t\t}\n\t\t}\n\t\textend(el.style, styles);\n\t}\n\n\t/**\n\t * Utility function to create element with attributes and styles\n\t * @param {Object} tag\n\t * @param {Object} attribs\n\t * @param {Object} styles\n\t * @param {Object} parent\n\t * @param {Object} nopad\n\t */\n\tfunction createElement(tag, attribs, styles, parent, nopad) {\n\t\tvar el = doc.createElement(tag);\n\t\tif (attribs) {\n\t\t\textend(el, attribs);\n\t\t}\n\t\tif (nopad) {\n\t\t\tcss(el, {padding: 0, border: NONE, margin: 0});\n\t\t}\n\t\tif (styles) {\n\t\t\tcss(el, styles);\n\t\t}\n\t\tif (parent) {\n\t\t\tparent.appendChild(el);\n\t\t}\n\t\treturn el;\n\t}\n\n\t/**\n\t * Extend a prototyped class by new members\n\t * @param {Object} parent\n\t * @param {Object} members\n\t */\n\tfunction extendClass(parent, members) {\n\t\tvar object = function () { return UNDEFINED; };\n\t\tobject.prototype = new parent();\n\t\textend(object.prototype, members);\n\t\treturn object;\n\t}\n\n\t/**\n\t * Pad a string to a given length by adding 0 to the beginning\n\t * @param {Number} number\n\t * @param {Number} length\n\t */\n\tfunction pad(number, length) {\n\t\t// Create an array of the remaining length +1 and join it with 0's\n\t\treturn new Array((length || 2) + 1 - String(number).length).join(0) + number;\n\t}\n\n\t/**\n\t * Wrap a method with extended functionality, preserving the original function\n\t * @param {Object} obj The context object that the method belongs to \n\t * @param {String} method The name of the method to extend\n\t * @param {Function} func A wrapper function callback. This function is called with the same arguments\n\t * as the original function, except that the original function is unshifted and passed as the first \n\t * argument. \n\t */\n\tvar wrap = Highcharts.wrap = function (obj, method, func) {\n\t\tvar proceed = obj[method];\n\t\tobj[method] = function () {\n\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\targs.unshift(proceed);\n\t\t\treturn func.apply(this, args);\n\t\t};\n\t};\n\n\n\tfunction getTZOffset(timestamp) {\n\t\treturn ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;\n\t}\n\n\t/**\n\t * Based on http://www.php.net/manual/en/function.strftime.php\n\t * @param {String} format\n\t * @param {Number} timestamp\n\t * @param {Boolean} capitalize\n\t */\n\tdateFormat = function (format, timestamp, capitalize) {\n\t\tif (!defined(timestamp) || isNaN(timestamp)) {\n\t\t\treturn 'Invalid date';\n\t\t}\n\t\tformat = pick(format, '%Y-%m-%d %H:%M:%S');\n\n\t\tvar date = new Date(timestamp - getTZOffset(timestamp)),\n\t\t\tkey, // used in for constuct below\n\t\t\t// get the basic time values\n\t\t\thours = date[getHours](),\n\t\t\tday = date[getDay](),\n\t\t\tdayOfMonth = date[getDate](),\n\t\t\tmonth = date[getMonth](),\n\t\t\tfullYear = date[getFullYear](),\n\t\t\tlang = defaultOptions.lang,\n\t\t\tlangWeekdays = lang.weekdays,\n\n\t\t\t// List all format keys. Custom formats can be added from the outside. \n\t\t\treplacements = extend({\n\n\t\t\t\t// Day\n\t\t\t\t'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n\t\t\t\t'A': langWeekdays[day], // Long weekday, like 'Monday'\n\t\t\t\t'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n\t\t\t\t'e': dayOfMonth, // Day of the month, 1 through 31\n\t\t\t\t'w': day,\n\n\t\t\t\t// Week (none implemented)\n\t\t\t\t//'W': weekNumber(),\n\n\t\t\t\t// Month\n\t\t\t\t'b': lang.shortMonths[month], // Short month, like 'Jan'\n\t\t\t\t'B': lang.months[month], // Long month, like 'January'\n\t\t\t\t'm': pad(month + 1), // Two digit month number, 01 through 12\n\n\t\t\t\t// Year\n\t\t\t\t'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n\t\t\t\t'Y': fullYear, // Four digits year, like 2009\n\n\t\t\t\t// Time\n\t\t\t\t'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n\t\t\t\t'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n\t\t\t\t'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n\t\t\t\t'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n\t\t\t\t'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n\t\t\t\t'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n\t\t\t\t'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n\t\t\t\t'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n\t\t\t}, Highcharts.dateFormats);\n\n\n\t\t// do the replaces\n\t\tfor (key in replacements) {\n\t\t\twhile (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n\t\t\t\tformat = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n\t\t\t}\n\t\t}\n\n\t\t// Optionally capitalize the string and return\n\t\treturn capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n\t};\n\n\t/** \n\t * Format a single variable. Similar to sprintf, without the % prefix.\n\t */\n\tfunction formatSingle(format, val) {\n\t\tvar floatRegex = /f$/,\n\t\t\tdecRegex = /\\.([0-9])/,\n\t\t\tlang = defaultOptions.lang,\n\t\t\tdecimals;\n\n\t\tif (floatRegex.test(format)) { // float\n\t\t\tdecimals = format.match(decRegex);\n\t\t\tdecimals = decimals ? decimals[1] : -1;\n\t\t\tif (val !== null) {\n\t\t\t\tval = Highcharts.numberFormat(\n\t\t\t\t\tval,\n\t\t\t\t\tdecimals,\n\t\t\t\t\tlang.decimalPoint,\n\t\t\t\t\tformat.indexOf(',') > -1 ? lang.thousandsSep : ''\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tval = dateFormat(format, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t * Format a string according to a subset of the rules of Python's String.format method.\n\t */\n\tfunction format(str, ctx) {\n\t\tvar splitter = '{',\n\t\t\tisInside = false,\n\t\t\tsegment,\n\t\t\tvalueAndFormat,\n\t\t\tpath,\n\t\t\ti,\n\t\t\tlen,\n\t\t\tret = [],\n\t\t\tval,\n\t\t\tindex;\n\t\t\n\t\twhile ((index = str.indexOf(splitter)) !== -1) {\n\t\t\t\n\t\t\tsegment = str.slice(0, index);\n\t\t\tif (isInside) { // we're on the closing bracket looking back\n\t\t\t\t\n\t\t\t\tvalueAndFormat = segment.split(':');\n\t\t\t\tpath = valueAndFormat.shift().split('.'); // get first and leave format\n\t\t\t\tlen = path.length;\n\t\t\t\tval = ctx;\n\n\t\t\t\t// Assign deeper paths\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tval = val[path[i]];\n\t\t\t\t}\n\n\t\t\t\t// Format the replacement\n\t\t\t\tif (valueAndFormat.length) {\n\t\t\t\t\tval = formatSingle(valueAndFormat.join(':'), val);\n\t\t\t\t}\n\n\t\t\t\t// Push the result and advance the cursor\n\t\t\t\tret.push(val);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tret.push(segment);\n\t\t\t\t\n\t\t\t}\n\t\t\tstr = str.slice(index + 1); // the rest\n\t\t\tisInside = !isInside; // toggle\n\t\t\tsplitter = isInside ? '}' : '{'; // now look for next matching bracket\n\t\t}\n\t\tret.push(str);\n\t\treturn ret.join('');\n\t}\n\n\t/**\n\t * Get the magnitude of a number\n\t */\n\tfunction getMagnitude(num) {\n\t\treturn math.pow(10, mathFloor(math.log(num) / math.LN10));\n\t}\n\n\t/**\n\t * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n\t * @param {Number} interval\n\t * @param {Array} multiples\n\t * @param {Number} magnitude\n\t * @param {Object} options\n\t */\n\tfunction normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {\n\t\tvar normalized, \n\t\t\ti,\n\t\t\tretInterval = interval;\n\n\t\t// round to a tenfold of 1, 2, 2.5 or 5\n\t\tmagnitude = pick(magnitude, 1);\n\t\tnormalized = interval / magnitude;\n\n\t\t// multiples for a linear scale\n\t\tif (!multiples) {\n\t\t\tmultiples = [1, 2, 2.5, 5, 10];\n\n\t\t\t// the allowDecimals option\n\t\t\tif (allowDecimals === false) {\n\t\t\t\tif (magnitude === 1) {\n\t\t\t\t\tmultiples = [1, 2, 5, 10];\n\t\t\t\t} else if (magnitude <= 0.1) {\n\t\t\t\t\tmultiples = [1 / magnitude];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// normalize the interval to the nearest multiple\n\t\tfor (i = 0; i < multiples.length; i++) {\n\t\t\tretInterval = multiples[i];\n\t\t\tif ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n\t\t\t\t(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// multiply back to the correct magnitude\n\t\tretInterval *= magnitude;\n\t\t\n\t\treturn retInterval;\n\t}\n\n\n\t/**\n\t * Utility method that sorts an object array and keeping the order of equal items.\n\t * ECMA script standard does not specify the behaviour when items are equal.\n\t */\n\tfunction stableSort(arr, sortFunction) {\n\t\tvar length = arr.length,\n\t\t\tsortValue,\n\t\t\ti;\n\n\t\t// Add index to each item\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tarr[i].ss_i = i; // stable sort index\n\t\t}\n\n\t\tarr.sort(function (a, b) {\n\t\t\tsortValue = sortFunction(a, b);\n\t\t\treturn sortValue === 0 ? a.ss_i - b.ss_i : sortValue;\n\t\t});\n\n\t\t// Remove index from items\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tdelete arr[i].ss_i; // stable sort index\n\t\t}\n\t}\n\n\t/**\n\t * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n\t * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n\t * method is slightly slower, but safe.\n\t */\n\tfunction arrayMin(data) {\n\t\tvar i = data.length,\n\t\t\tmin = data[0];\n\n\t\twhile (i--) {\n\t\t\tif (data[i] < min) {\n\t\t\t\tmin = data[i];\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\n\t/**\n\t * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n\t * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n\t * method is slightly slower, but safe.\n\t */\n\tfunction arrayMax(data) {\n\t\tvar i = data.length,\n\t\t\tmax = data[0];\n\n\t\twhile (i--) {\n\t\t\tif (data[i] > max) {\n\t\t\t\tmax = data[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\t/**\n\t * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n\t * It loops all properties and invokes destroy if there is a destroy method. The property is\n\t * then delete'ed.\n\t * @param {Object} The object to destroy properties on\n\t * @param {Object} Exception, do not destroy this property, only delete it.\n\t */\n\tfunction destroyObjectProperties(obj, except) {\n\t\tvar n;\n\t\tfor (n in obj) {\n\t\t\t// If the object is non-null and destroy is defined\n\t\t\tif (obj[n] && obj[n] !== except && obj[n].destroy) {\n\t\t\t\t// Invoke the destroy\n\t\t\t\tobj[n].destroy();\n\t\t\t}\n\n\t\t\t// Delete the property from the object.\n\t\t\tdelete obj[n];\n\t\t}\n\t}\n\n\n\t/**\n\t * Discard an element by moving it to the bin and delete\n\t * @param {Object} The HTML node to discard\n\t */\n\tfunction discardElement(element) {\n\t\t// create a garbage bin element, not part of the DOM\n\t\tif (!garbageBin) {\n\t\t\tgarbageBin = createElement(DIV);\n\t\t}\n\n\t\t// move the node and empty bin\n\t\tif (element) {\n\t\t\tgarbageBin.appendChild(element);\n\t\t}\n\t\tgarbageBin.innerHTML = '';\n\t}\n\n\t/**\n\t * Provide error messages for debugging, with links to online explanation \n\t */\n\tfunction error (code, stop) {\n\t\tvar msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n\t\tif (stop) {\n\t\t\tthrow msg;\n\t\t}\n\t\t// else ...\n\t\tif (win.console) {\n\t\t\tconsole.log(msg);\n\t\t}\n\t}\n\n\t/**\n\t * Fix JS round off float errors\n\t * @param {Number} num\n\t */\n\tfunction correctFloat(num) {\n\t\treturn parseFloat(\n\t\t\tnum.toPrecision(14)\n\t\t);\n\t}\n\n\t/**\n\t * Set the global animation to either a given value, or fall back to the\n\t * given chart's animation option\n\t * @param {Object} animation\n\t * @param {Object} chart\n\t */\n\tfunction setAnimation(animation, chart) {\n\t\tglobalAnimation = pick(animation, chart.animation);\n\t}\n\n\t/**\n\t * The time unit lookup\n\t */\n\ttimeUnits = {\n\t\tmillisecond: 1,\n\t\tsecond: 1000,\n\t\tminute: 60000,\n\t\thour: 3600000,\n\t\tday: 24 * 3600000,\n\t\tweek: 7 * 24 * 3600000,\n\t\tmonth: 28 * 24 * 3600000,\n\t\tyear: 364 * 24 * 3600000\n\t};\n\n\n\t/**\n\t * Format a number and return a string based on input settings\n\t * @param {Number} number The input number to format\n\t * @param {Number} decimals The amount of decimals\n\t * @param {String} decPoint The decimal point, defaults to the one given in the lang options\n\t * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n\t */\n\tHighcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {\n\t\tvar lang = defaultOptions.lang,\n\t\t\t// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/\n\t\t\tn = +number || 0,\n\t\t\tc = decimals === -1 ?\n\t\t\t\tmathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).\n\t\t\t\t(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),\n\t\t\td = decPoint === undefined ? lang.decimalPoint : decPoint,\n\t\t\tt = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,\n\t\t\ts = n < 0 ? \"-\" : \"\",\n\t\t\ti = String(pInt(n = mathAbs(n).toFixed(c))),\n\t\t\tj = i.length > 3 ? i.length % 3 : 0;\n\n\t\treturn (s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) +\n\t\t\t\t(c ? d + mathAbs(n - i).toFixed(c).slice(2) : \"\"));\n\t};\n\t/**\n\t * Path interpolation algorithm used across adapters\n\t */\n\tpathAnim = {\n\t\t/**\n\t\t * Prepare start and end values so that the path can be animated one to one\n\t\t */\n\t\tinit: function (elem, fromD, toD) {\n\t\t\tfromD = fromD || '';\n\t\t\tvar shift = elem.shift,\n\t\t\t\tbezier = fromD.indexOf('C') > -1,\n\t\t\t\tnumParams = bezier ? 7 : 3,\n\t\t\t\tendLength,\n\t\t\t\tslice,\n\t\t\t\ti,\n\t\t\t\tstart = fromD.split(' '),\n\t\t\t\tend = [].concat(toD), // copy\n\t\t\t\tstartBaseLine,\n\t\t\t\tendBaseLine,\n\t\t\t\tsixify = function (arr) { // in splines make move points have six parameters like bezier curves\n\t\t\t\t\ti = arr.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (arr[i] === M) {\n\t\t\t\t\t\t\tarr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tif (bezier) {\n\t\t\t\tsixify(start);\n\t\t\t\tsixify(end);\n\t\t\t}\n\n\t\t\t// pull out the base lines before padding\n\t\t\tif (elem.isArea) {\n\t\t\t\tstartBaseLine = start.splice(start.length - 6, 6);\n\t\t\t\tendBaseLine = end.splice(end.length - 6, 6);\n\t\t\t}\n\n\t\t\t// if shifting points, prepend a dummy point to the end path\n\t\t\tif (shift <= end.length / numParams && start.length === end.length) {\n\t\t\t\twhile (shift--) {\n\t\t\t\t\tend = [].concat(end).splice(0, numParams).concat(end);\n\t\t\t\t}\n\t\t\t}\n\t\t\telem.shift = 0; // reset for following animations\n\n\t\t\t// copy and append last point until the length matches the end length\n\t\t\tif (start.length) {\n\t\t\t\tendLength = end.length;\n\t\t\t\twhile (start.length < endLength) {\n\n\t\t\t\t\t//bezier && sixify(start);\n\t\t\t\t\tslice = [].concat(start).splice(start.length - numParams, numParams);\n\t\t\t\t\tif (bezier) { // disable first control point\n\t\t\t\t\t\tslice[numParams - 6] = slice[numParams - 2];\n\t\t\t\t\t\tslice[numParams - 5] = slice[numParams - 1];\n\t\t\t\t\t}\n\t\t\t\t\tstart = start.concat(slice);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (startBaseLine) { // append the base lines for areas\n\t\t\t\tstart = start.concat(startBaseLine);\n\t\t\t\tend = end.concat(endBaseLine);\n\t\t\t}\n\t\t\treturn [start, end];\n\t\t},\n\n\t\t/**\n\t\t * Interpolate each value of the path and return the array\n\t\t */\n\t\tstep: function (start, end, pos, complete) {\n\t\t\tvar ret = [],\n\t\t\t\ti = start.length,\n\t\t\t\tstartVal;\n\n\t\t\tif (pos === 1) { // land on the final path without adjustment points appended in the ends\n\t\t\t\tret = complete;\n\n\t\t\t} else if (i === end.length && pos < 1) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\tstartVal = parseFloat(start[i]);\n\t\t\t\t\tret[i] =\n\t\t\t\t\t\tisNaN(startVal) ? // a letter instruction like M or L\n\t\t\t\t\t\t\tstart[i] :\n\t\t\t\t\t\t\tpos * (parseFloat(end[i] - startVal)) + startVal;\n\n\t\t\t\t}\n\t\t\t} else { // if animation is finished or length not matching, land on right value\n\t\t\t\tret = end;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n\n\t(function ($) {\n\t\t/**\n\t\t * The default HighchartsAdapter for jQuery\n\t\t */\n\t\tHighchartsAdapter =  ($ && {\n\t\t\t\n\t\t\t/**\n\t\t\t * Initialize the adapter by applying some extensions to jQuery\n\t\t\t */\n\t\t\tinit: function (pathAnim) {\n\t\t\t\t\n\t\t\t\t// extend the animate function to allow SVG animations\n\t\t\t\tvar Fx = $.fx;\n\t\t\t\t\n\t\t\t\t/*jslint unparam: true*//* allow unused param x in this function */\n\t\t\t\t$.extend($.easing, {\n\t\t\t\t\teaseOutQuad: function (x, t, b, c, d) {\n\t\t\t\t\t\treturn -c * (t /= d) * (t - 2) + b;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t/*jslint unparam: false*/\n\t\t\t\n\t\t\t\t// extend some methods to check for elem.attr, which means it is a Highcharts SVG object\n\t\t\t\t$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {\n\t\t\t\t\tvar obj = Fx.step,\n\t\t\t\t\t\tbase;\n\t\t\t\t\t\t\n\t\t\t\t\t// Handle different parent objects\n\t\t\t\t\tif (fn === 'cur') {\n\t\t\t\t\t\tobj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype\n\t\t\t\t\t\n\t\t\t\t\t} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model\n\t\t\t\t\t\tobj = $.Tween.propHooks[fn];\n\t\t\t\t\t\tfn = 'set';\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t// Overwrite the method\n\t\t\t\t\tbase = obj[fn];\n\t\t\t\t\tif (base) { // step.width and step.height don't exist in jQuery < 1.7\n\t\t\t\n\t\t\t\t\t\t// create the extended function replacement\n\t\t\t\t\t\tobj[fn] = function (fx) {\n\n\t\t\t\t\t\t\tvar elem;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Fx.prototype.cur does not use fx argument\n\t\t\t\t\t\t\tfx = i ? fx : this;\n\n\t\t\t\t\t\t\t// Don't run animations on textual properties like align (#1821)\n\t\t\t\t\t\t\tif (fx.prop === 'align') {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t\t\t// shortcut\n\t\t\t\t\t\t\telem = fx.elem;\n\t\t\t\n\t\t\t\t\t\t\t// Fx.prototype.cur returns the current value. The other ones are setters\n\t\t\t\t\t\t\t// and returning a value has no effect.\n\t\t\t\t\t\t\treturn elem.attr ? // is SVG element wrapper\n\t\t\t\t\t\t\t\telem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method\n\t\t\t\t\t\t\t\tbase.apply(this, arguments); // use jQuery's built-in method\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+\n\t\t\t\twrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {\n\t\t\t\t\treturn elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Define the setter function for d (path definitions)\n\t\t\t\tthis.addAnimSetter('d', function (fx) {\n\t\t\t\t\tvar elem = fx.elem,\n\t\t\t\t\t\tends;\n\t\t\t\n\t\t\t\t\t// Normally start and end should be set in state == 0, but sometimes,\n\t\t\t\t\t// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped\n\t\t\t\t\t// in these cases\n\t\t\t\t\tif (!fx.started) {\n\t\t\t\t\t\tends = pathAnim.init(elem, elem.d, elem.toD);\n\t\t\t\t\t\tfx.start = ends[0];\n\t\t\t\t\t\tfx.end = ends[1];\n\t\t\t\t\t\tfx.started = true;\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\t// Interpolate each value of the path\n\t\t\t\t\telem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t/**\n\t\t\t\t * Utility for iterating over an array. Parameters are reversed compared to jQuery.\n\t\t\t\t * @param {Array} arr\n\t\t\t\t * @param {Function} fn\n\t\t\t\t */\n\t\t\t\tthis.each = Array.prototype.forEach ?\n\t\t\t\t\tfunction (arr, fn) { // modern browsers\n\t\t\t\t\t\treturn Array.prototype.forEach.call(arr, fn);\n\t\t\t\t\t\t\n\t\t\t\t\t} : \n\t\t\t\t\tfunction (arr, fn) { // legacy\n\t\t\t\t\t\tvar i, \n\t\t\t\t\t\t\tlen = arr.length;\n\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\tif (fn.call(arr[i], arr[i], i, arr) === false) {\n\t\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Add an animation setter for a specific property\n\t\t\t */\n\t\t\taddAnimSetter: function (prop, setter) {\n\t\t\t\t// jQuery 1.8 style\n\t\t\t\tif ($.Tween) {\n\t\t\t\t\t$.Tween.propHooks[prop] = {\n\t\t\t\t\t\tset: setter\n\t\t\t\t\t};\n\t\t\t\t// pre 1.8\n\t\t\t\t} else {\n\t\t\t\t\t$.fx.step[prop] = setter;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Downloads a script and executes a callback when done.\n\t\t\t * @param {String} scriptLocation\n\t\t\t * @param {Function} callback\n\t\t\t */\n\t\t\tgetScript: $.getScript,\n\t\t\t\n\t\t\t/**\n\t\t\t * Return the index of an item in an array, or -1 if not found\n\t\t\t */\n\t\t\tinArray: $.inArray,\n\t\t\t\n\t\t\t/**\n\t\t\t * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.\n\t\t\t * @param {Object} elem The HTML element\n\t\t\t * @param {String} method Which method to run on the wrapped element\n\t\t\t */\n\t\t\tadapterRun: function (elem, method) {\n\t\t\t\treturn $(elem)[method]();\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Filter an array\n\t\t\t */\n\t\t\tgrep: $.grep,\n\t\t\n\t\t\t/**\n\t\t\t * Map an array\n\t\t\t * @param {Array} arr\n\t\t\t * @param {Function} fn\n\t\t\t */\n\t\t\tmap: function (arr, fn) {\n\t\t\t\t//return jQuery.map(arr, fn);\n\t\t\t\tvar results = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\tlen = arr.length;\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\tresults[i] = fn.call(arr[i], arr[i], i, arr);\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Get the position of an element relative to the top left of the page\n\t\t\t */\n\t\t\toffset: function (el) {\n\t\t\t\treturn $(el).offset();\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Add an event listener\n\t\t\t * @param {Object} el A HTML element or custom object\n\t\t\t * @param {String} event The event type\n\t\t\t * @param {Function} fn The event handler\n\t\t\t */\n\t\t\taddEvent: function (el, event, fn) {\n\t\t\t\t$(el).bind(event, fn);\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Remove event added with addEvent\n\t\t\t * @param {Object} el The object\n\t\t\t * @param {String} eventType The event type. Leave blank to remove all events.\n\t\t\t * @param {Function} handler The function to remove\n\t\t\t */\n\t\t\tremoveEvent: function (el, eventType, handler) {\n\t\t\t\t// workaround for jQuery issue with unbinding custom events:\n\t\t\t\t// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2\n\t\t\t\tvar func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';\n\t\t\t\tif (doc[func] && el && !el[func]) {\n\t\t\t\t\tel[func] = function () {};\n\t\t\t\t}\n\t\t\n\t\t\t\t$(el).unbind(eventType, handler);\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Fire an event on a custom object\n\t\t\t * @param {Object} el\n\t\t\t * @param {String} type\n\t\t\t * @param {Object} eventArguments\n\t\t\t * @param {Function} defaultFunction\n\t\t\t */\n\t\t\tfireEvent: function (el, type, eventArguments, defaultFunction) {\n\t\t\t\tvar event = $.Event(type),\n\t\t\t\t\tdetachedType = 'detached' + type,\n\t\t\t\t\tdefaultPrevented;\n\t\t\n\t\t\t\t// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts\n\t\t\t\t// never uses these properties, Chrome includes them in the default click event and\n\t\t\t\t// raises the warning when they are copied over in the extend statement below.\n\t\t\t\t//\n\t\t\t\t// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid\n\t\t\t\t// testing if they are there (warning in chrome) the only option is to test if running IE.\n\t\t\t\tif (!isIE && eventArguments) {\n\t\t\t\t\tdelete eventArguments.layerX;\n\t\t\t\t\tdelete eventArguments.layerY;\n\t\t\t\t\tdelete eventArguments.returnValue;\n\t\t\t\t}\n\t\t\n\t\t\t\textend(event, eventArguments);\n\t\t\n\t\t\t\t// Prevent jQuery from triggering the object method that is named the\n\t\t\t\t// same as the event. For example, if the event is 'select', jQuery\n\t\t\t\t// attempts calling el.select and it goes into a loop.\n\t\t\t\tif (el[type]) {\n\t\t\t\t\tel[detachedType] = el[type];\n\t\t\t\t\tel[type] = null;\n\t\t\t\t}\n\t\t\n\t\t\t\t// Wrap preventDefault and stopPropagation in try/catch blocks in\n\t\t\t\t// order to prevent JS errors when cancelling events on non-DOM\n\t\t\t\t// objects. #615.\n\t\t\t\t/*jslint unparam: true*/\n\t\t\t\t$.each(['preventDefault', 'stopPropagation'], function (i, fn) {\n\t\t\t\t\tvar base = event[fn];\n\t\t\t\t\tevent[fn] = function () {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tbase.call(event);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (fn === 'preventDefault') {\n\t\t\t\t\t\t\t\tdefaultPrevented = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\t/*jslint unparam: false*/\n\t\t\n\t\t\t\t// trigger it\n\t\t\t\t$(el).trigger(event);\n\t\t\n\t\t\t\t// attach the method\n\t\t\t\tif (el[detachedType]) {\n\t\t\t\t\tel[type] = el[detachedType];\n\t\t\t\t\tel[detachedType] = null;\n\t\t\t\t}\n\t\t\n\t\t\t\tif (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {\n\t\t\t\t\tdefaultFunction(event);\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Extension method needed for MooTools\n\t\t\t */\n\t\t\twashMouseEvent: function (e) {\n\t\t\t\tvar ret = e.originalEvent || e;\n\t\t\t\t\n\t\t\t\t// computed by jQuery, needed by IE8\n\t\t\t\tif (ret.pageX === UNDEFINED) { // #1236\n\t\t\t\t\tret.pageX = e.pageX;\n\t\t\t\t\tret.pageY = e.pageY;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn ret;\n\t\t\t},\n\t\t\n\t\t\t/**\n\t\t\t * Animate a HTML element or SVG element wrapper\n\t\t\t * @param {Object} el\n\t\t\t * @param {Object} params\n\t\t\t * @param {Object} options jQuery-like animation options: duration, easing, callback\n\t\t\t */\n\t\t\tanimate: function (el, params, options) {\n\t\t\t\tvar $el = $(el);\n\t\t\t\tif (!el.style) {\n\t\t\t\t\tel.style = {}; // #1881\n\t\t\t\t}\n\t\t\t\tif (params.d) {\n\t\t\t\t\tel.toD = params.d; // keep the array form for paths, used in $.fx.step.d\n\t\t\t\t\tparams.d = 1; // because in jQuery, animating to an array has a different meaning\n\t\t\t\t}\n\t\t\n\t\t\t\t$el.stop();\n\t\t\t\tif (params.opacity !== UNDEFINED && el.attr) {\n\t\t\t\t\tparams.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)\n\t\t\t\t}\n\t\t\t\tel.hasAnim = 1; // #3342\n\t\t\t\t$el.animate(params, options);\n\t\t\n\t\t\t},\n\t\t\t/**\n\t\t\t * Stop running animation\n\t\t\t */\n\t\t\tstop: function (el) {\n\t\t\t\tif (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy\n\t\t\t\t\t$(el).stop();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}(jquery));\n\n\n\t// check for a custom HighchartsAdapter defined prior to this file\n\tvar globalAdapter = HighchartsAdapter,\n\t\tadapter = globalAdapter || {};\n\t\t\n\t// Initialize the adapter\n\tif (globalAdapter) {\n\t\tglobalAdapter.init.call(globalAdapter, pathAnim);\n\t}\n\n\n\t// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object\n\t// and all the utility functions will be null. In that case they are populated by the\n\t// default adapters below.\n\tvar adapterRun = adapter.adapterRun,\n\t\tgetScript = adapter.getScript,\n\t\tinArray = adapter.inArray,\n\t\teach = Highcharts.each = adapter.each,\n\t\tgrep = adapter.grep,\n\t\toffset = adapter.offset,\n\t\tmap = adapter.map,\n\t\taddEvent = adapter.addEvent,\n\t\tremoveEvent = adapter.removeEvent,\n\t\tfireEvent = adapter.fireEvent,\n\t\twashMouseEvent = adapter.washMouseEvent,\n\t\tanimate = adapter.animate,\n\t\tstop = adapter.stop;\n\n\n\n\t/* ****************************************************************************\n\t * Handle the options                                                         *\n\t *****************************************************************************/\n\tdefaultOptions = {\n\t\tcolors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', \n\t\t\t    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n\t\tsymbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n\t\tlang: {\n\t\t\tloading: 'Loading...',\n\t\t\tmonths: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n\t\t\t\t\t'August', 'September', 'October', 'November', 'December'],\n\t\t\tshortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n\t\t\tweekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n\t\t\tdecimalPoint: '.',\n\t\t\tnumericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n\t\t\tresetZoom: 'Reset zoom',\n\t\t\tresetZoomTitle: 'Reset zoom level 1:1',\n\t\t\tthousandsSep: ' '\n\t\t},\n\t\tglobal: {\n\t\t\tuseUTC: true,\n\t\t\t//timezoneOffset: 0,\n\t\t\tcanvasToolsURL: 'http://code.highcharts.com/4.1.4/modules/canvas-tools.js',\n\t\t\tVMLRadialGradientURL: 'http://code.highcharts.com/4.1.4/gfx/vml-radial-gradient.png'\n\t\t},\n\t\tchart: {\n\t\t\t//animation: true,\n\t\t\t//alignTicks: false,\n\t\t\t//reflow: true,\n\t\t\t//className: null,\n\t\t\t//events: { load, selection },\n\t\t\t//margin: [null],\n\t\t\t//marginTop: null,\n\t\t\t//marginRight: null,\n\t\t\t//marginBottom: null,\n\t\t\t//marginLeft: null,\n\t\t\tborderColor: '#4572A7',\n\t\t\t//borderWidth: 0,\n\t\t\tborderRadius: 0,\n\t\t\tdefaultSeriesType: 'line',\n\t\t\tignoreHiddenSeries: true,\n\t\t\t//inverted: false,\n\t\t\t//shadow: false,\n\t\t\tspacing: [10, 10, 15, 10],\n\t\t\t//spacingTop: 10,\n\t\t\t//spacingRight: 10,\n\t\t\t//spacingBottom: 15,\n\t\t\t//spacingLeft: 10,\n\t\t\t//style: {\n\t\t\t//\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n\t\t\t//\tfontSize: '12px'\n\t\t\t//},\n\t\t\tbackgroundColor: '#FFFFFF',\n\t\t\t//plotBackgroundColor: null,\n\t\t\tplotBorderColor: '#C0C0C0',\n\t\t\t//plotBorderWidth: 0,\n\t\t\t//plotShadow: false,\n\t\t\t//zoomType: ''\n\t\t\tresetZoomButton: {\n\t\t\t\ttheme: {\n\t\t\t\t\tzIndex: 20\n\t\t\t\t},\n\t\t\t\tposition: {\n\t\t\t\t\talign: 'right',\n\t\t\t\t\tx: -10,\n\t\t\t\t\t//verticalAlign: 'top',\n\t\t\t\t\ty: 10\n\t\t\t\t}\n\t\t\t\t// relativeTo: 'plot'\n\t\t\t}\n\t\t},\n\t\ttitle: {\n\t\t\ttext: 'Chart title',\n\t\t\talign: 'center',\n\t\t\t// floating: false,\n\t\t\tmargin: 15,\n\t\t\t// x: 0,\n\t\t\t// verticalAlign: 'top',\n\t\t\t// y: null,\n\t\t\tstyle: {\n\t\t\t\tcolor: '#333333',\n\t\t\t\tfontSize: '18px'\n\t\t\t}\n\n\t\t},\n\t\tsubtitle: {\n\t\t\ttext: '',\n\t\t\talign: 'center',\n\t\t\t// floating: false\n\t\t\t// x: 0,\n\t\t\t// verticalAlign: 'top',\n\t\t\t// y: null,\n\t\t\tstyle: {\n\t\t\t\tcolor: '#555555'\n\t\t\t}\n\t\t},\n\n\t\tplotOptions: {\n\t\t\tline: { // base series options\n\t\t\t\tallowPointSelect: false,\n\t\t\t\tshowCheckbox: false,\n\t\t\t\tanimation: {\n\t\t\t\t\tduration: 1000\n\t\t\t\t},\n\t\t\t\t//connectNulls: false,\n\t\t\t\t//cursor: 'default',\n\t\t\t\t//clip: true,\n\t\t\t\t//dashStyle: null,\n\t\t\t\t//enableMouseTracking: true,\n\t\t\t\tevents: {},\n\t\t\t\t//legendIndex: 0,\n\t\t\t\t//linecap: 'round',\n\t\t\t\tlineWidth: 2,\n\t\t\t\t//shadow: false,\n\t\t\t\t// stacking: null,\n\t\t\t\tmarker: {\n\t\t\t\t\t//enabled: true,\n\t\t\t\t\t//symbol: null,\n\t\t\t\t\tlineWidth: 0,\n\t\t\t\t\tradius: 4,\n\t\t\t\t\tlineColor: '#FFFFFF',\n\t\t\t\t\t//fillColor: null,\n\t\t\t\t\tstates: { // states for a single point\n\t\t\t\t\t\thover: {\n\t\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\t\tlineWidthPlus: 1,\n\t\t\t\t\t\t\tradiusPlus: 2\n\t\t\t\t\t\t},\n\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\tfillColor: '#FFFFFF',\n\t\t\t\t\t\t\tlineColor: '#000000',\n\t\t\t\t\t\t\tlineWidth: 2\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tpoint: {\n\t\t\t\t\tevents: {}\n\t\t\t\t},\n\t\t\t\tdataLabels: {\n\t\t\t\t\talign: 'center',\n\t\t\t\t\t// defer: true,\n\t\t\t\t\t// enabled: false,\n\t\t\t\t\tformatter: function () {\n\t\t\t\t\t\treturn this.y === null ? '' : Highcharts.numberFormat(this.y, -1);\n\t\t\t\t\t},\n\t\t\t\t\tstyle: {\n\t\t\t\t\t\tcolor: 'contrast',\n\t\t\t\t\t\tfontSize: '11px',\n\t\t\t\t\t\tfontWeight: 'bold',\n\t\t\t\t\t\ttextShadow: '0 0 6px contrast, 0 0 3px contrast'\n\t\t\t\t\t},\n\t\t\t\t\tverticalAlign: 'bottom', // above singular point\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 0,\n\t\t\t\t\t// backgroundColor: undefined,\n\t\t\t\t\t// borderColor: undefined,\n\t\t\t\t\t// borderRadius: undefined,\n\t\t\t\t\t// borderWidth: undefined,\n\t\t\t\t\tpadding: 5\n\t\t\t\t\t// shadow: false\n\t\t\t\t},\n\t\t\t\tcropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n\t\t\t\tpointRange: 0,\n\t\t\t\t//pointStart: 0,\n\t\t\t\t//pointInterval: 1,\n\t\t\t\t//showInLegend: null, // auto: true for standalone series, false for linked series\n\t\t\t\tstates: { // states for the entire series\n\t\t\t\t\thover: {\n\t\t\t\t\t\t//enabled: false,\n\t\t\t\t\t\tlineWidthPlus: 1,\n\t\t\t\t\t\tmarker: {\n\t\t\t\t\t\t\t// lineWidth: base + 1,\n\t\t\t\t\t\t\t// radius: base + 1\n\t\t\t\t\t\t},\n\t\t\t\t\t\thalo: {\n\t\t\t\t\t\t\tsize: 10,\n\t\t\t\t\t\t\topacity: 0.25\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tselect: {\n\t\t\t\t\t\tmarker: {}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tstickyTracking: true,\n\t\t\t\t//tooltip: {\n\t\t\t\t\t//pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b>'\n\t\t\t\t\t//valueDecimals: null,\n\t\t\t\t\t//xDateFormat: '%A, %b %e, %Y',\n\t\t\t\t\t//valuePrefix: '',\n\t\t\t\t\t//ySuffix: ''\t\t\t\t\n\t\t\t\t//}\n\t\t\t\tturboThreshold: 1000\n\t\t\t\t// zIndex: null\n\t\t\t}\n\t\t},\n\t\tlabels: {\n\t\t\t//items: [],\n\t\t\tstyle: {\n\t\t\t\t//font: defaultFont,\n\t\t\t\tposition: ABSOLUTE,\n\t\t\t\tcolor: '#3E576F'\n\t\t\t}\n\t\t},\n\t\tlegend: {\n\t\t\tenabled: true,\n\t\t\talign: 'center',\n\t\t\t//floating: false,\n\t\t\tlayout: 'horizontal',\n\t\t\tlabelFormatter: function () {\n\t\t\t\treturn this.name;\n\t\t\t},\n\t\t\t//borderWidth: 0,\n\t\t\tborderColor: '#909090',\n\t\t\tborderRadius: 0,\n\t\t\tnavigation: {\n\t\t\t\t// animation: true,\n\t\t\t\tactiveColor: '#274b6d',\n\t\t\t\t// arrowSize: 12\n\t\t\t\tinactiveColor: '#CCC'\n\t\t\t\t// style: {} // text styles\n\t\t\t},\n\t\t\t// margin: 20,\n\t\t\t// reversed: false,\n\t\t\tshadow: false,\n\t\t\t// backgroundColor: null,\n\t\t\t/*style: {\n\t\t\t\tpadding: '5px'\n\t\t\t},*/\n\t\t\titemStyle: {\t\t\t\n\t\t\t\tcolor: '#333333',\n\t\t\t\tfontSize: '12px',\n\t\t\t\tfontWeight: 'bold'\n\t\t\t},\n\t\t\titemHoverStyle: {\n\t\t\t\t//cursor: 'pointer', removed as of #601\n\t\t\t\tcolor: '#000'\n\t\t\t},\n\t\t\titemHiddenStyle: {\n\t\t\t\tcolor: '#CCC'\n\t\t\t},\n\t\t\titemCheckboxStyle: {\n\t\t\t\tposition: ABSOLUTE,\n\t\t\t\twidth: '13px', // for IE precision\n\t\t\t\theight: '13px'\n\t\t\t},\n\t\t\t// itemWidth: undefined,\n\t\t\t// symbolRadius: 0,\n\t\t\t// symbolWidth: 16,\n\t\t\tsymbolPadding: 5,\n\t\t\tverticalAlign: 'bottom',\n\t\t\t// width: undefined,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\ttitle: {\n\t\t\t\t//text: null,\n\t\t\t\tstyle: {\n\t\t\t\t\tfontWeight: 'bold'\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t},\n\n\t\tloading: {\n\t\t\t// hideDuration: 100,\n\t\t\tlabelStyle: {\n\t\t\t\tfontWeight: 'bold',\n\t\t\t\tposition: RELATIVE,\n\t\t\t\ttop: '45%'\n\t\t\t},\n\t\t\t// showDuration: 0,\n\t\t\tstyle: {\n\t\t\t\tposition: ABSOLUTE,\n\t\t\t\tbackgroundColor: 'white',\n\t\t\t\topacity: 0.5,\n\t\t\t\ttextAlign: 'center'\n\t\t\t}\n\t\t},\n\n\t\ttooltip: {\n\t\t\tenabled: true,\n\t\t\tanimation: hasSVG,\n\t\t\t//crosshairs: null,\n\t\t\tbackgroundColor: 'rgba(249, 249, 249, .85)',\n\t\t\tborderWidth: 1,\n\t\t\tborderRadius: 3,\n\t\t\tdateTimeLabelFormats: { \n\t\t\t\tmillisecond: '%A, %b %e, %H:%M:%S.%L',\n\t\t\t\tsecond: '%A, %b %e, %H:%M:%S',\n\t\t\t\tminute: '%A, %b %e, %H:%M',\n\t\t\t\thour: '%A, %b %e, %H:%M',\n\t\t\t\tday: '%A, %b %e, %Y',\n\t\t\t\tweek: 'Week from %A, %b %e, %Y',\n\t\t\t\tmonth: '%B %Y',\n\t\t\t\tyear: '%Y'\n\t\t\t},\n\t\t\tfooterFormat: '',\n\t\t\t//formatter: defaultFormatter,\n\t\t\theaderFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n\t\t\tpointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n\t\t\tshadow: true,\n\t\t\t//shape: 'callout',\n\t\t\t//shared: false,\n\t\t\tsnap: isTouchDevice ? 25 : 10,\n\t\t\tstyle: {\n\t\t\t\tcolor: '#333333',\n\t\t\t\tcursor: 'default',\n\t\t\t\tfontSize: '12px',\n\t\t\t\tpadding: '8px',\n\t\t\t\twhiteSpace: 'nowrap'\n\t\t\t}\n\t\t\t//xDateFormat: '%A, %b %e, %Y',\n\t\t\t//valueDecimals: null,\n\t\t\t//valuePrefix: '',\n\t\t\t//valueSuffix: ''\n\t\t},\n\n\t\tcredits: {\n\t\t\tenabled: true,\n\t\t\ttext: 'Highcharts.com',\n\t\t\thref: 'http://www.highcharts.com',\n\t\t\tposition: {\n\t\t\t\talign: 'right',\n\t\t\t\tx: -10,\n\t\t\t\tverticalAlign: 'bottom',\n\t\t\t\ty: -5\n\t\t\t},\n\t\t\tstyle: {\n\t\t\t\tcursor: 'pointer',\n\t\t\t\tcolor: '#909090',\n\t\t\t\tfontSize: '9px'\n\t\t\t}\n\t\t}\n\t};\n\n\n\n\n\t// Series defaults\n\tvar defaultPlotOptions = defaultOptions.plotOptions,\n\t\tdefaultSeriesOptions = defaultPlotOptions.line;\n\n\t// set the default time methods\n\tsetTimeMethods();\n\n\n\n\t/**\n\t * Set the time methods globally based on the useUTC option. Time method can be either\n\t * local time or UTC (default).\n\t */\n\tfunction setTimeMethods() {\n\t\tvar globalOptions = defaultOptions.global,\n\t\t\tuseUTC = globalOptions.useUTC,\n\t\t\tGET = useUTC ? 'getUTC' : 'get',\n\t\t\tSET = useUTC ? 'setUTC' : 'set';\n\n\n\t\tDate = globalOptions.Date || window.Date;\n\t\ttimezoneOffset = useUTC && globalOptions.timezoneOffset;\n\t\tgetTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n\t\tmakeTime = function (year, month, date, hours, minutes, seconds) {\n\t\t\tvar d;\n\t\t\tif (useUTC) {\n\t\t\t\td = Date.UTC.apply(0, arguments);\n\t\t\t\td += getTZOffset(d);\n\t\t\t} else {\n\t\t\t\td = new Date(\n\t\t\t\t\tyear,\n\t\t\t\t\tmonth,\n\t\t\t\t\tpick(date, 1),\n\t\t\t\t\tpick(hours, 0),\n\t\t\t\t\tpick(minutes, 0),\n\t\t\t\t\tpick(seconds, 0)\n\t\t\t\t).getTime();\n\t\t\t}\n\t\t\treturn d;\n\t\t};\n\t\tgetMinutes =  GET + 'Minutes';\n\t\tgetHours =    GET + 'Hours';\n\t\tgetDay =      GET + 'Day';\n\t\tgetDate =     GET + 'Date';\n\t\tgetMonth =    GET + 'Month';\n\t\tgetFullYear = GET + 'FullYear';\n\t\tsetMinutes =  SET + 'Minutes';\n\t\tsetHours =    SET + 'Hours';\n\t\tsetDate =     SET + 'Date';\n\t\tsetMonth =    SET + 'Month';\n\t\tsetFullYear = SET + 'FullYear';\n\n\t}\n\n\t/**\n\t * Merge the default options with custom options and return the new options structure\n\t * @param {Object} options The new custom options\n\t */\n\tfunction setOptions(options) {\n\t\t\n\t\t// Copy in the default options\n\t\tdefaultOptions = merge(true, defaultOptions, options);\n\t\t\n\t\t// Apply UTC\n\t\tsetTimeMethods();\n\n\t\treturn defaultOptions;\n\t}\n\n\t/**\n\t * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n\t * wasn't enough because the setOptions method created a new object.\n\t */\n\tfunction getOptions() {\n\t\treturn defaultOptions;\n\t}\n\n\n\t/**\n\t * Handle color operations. The object methods are chainable.\n\t * @param {String} input The input color in either rbga or hex format\n\t */\n\tvar rgbaRegEx = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n\t\thexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n\t\trgbRegEx = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/;\n\n\tvar Color = function (input) {\n\t\t// declare variables\n\t\tvar rgba = [], result, stops;\n\n\t\t/**\n\t\t * Parse the input color to rgba array\n\t\t * @param {String} input\n\t\t */\n\t\tfunction init(input) {\n\n\t\t\t// Gradients\n\t\t\tif (input && input.stops) {\n\t\t\t\tstops = map(input.stops, function (stop) {\n\t\t\t\t\treturn Color(stop[1]);\n\t\t\t\t});\n\n\t\t\t// Solid colors\n\t\t\t} else {\n\t\t\t\t// rgba\n\t\t\t\tresult = rgbaRegEx.exec(input);\n\t\t\t\tif (result) {\n\t\t\t\t\trgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n\t\t\t\t} else { \n\t\t\t\t\t// hex\n\t\t\t\t\tresult = hexRegEx.exec(input);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\trgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// rgb\n\t\t\t\t\t\tresult = rgbRegEx.exec(input);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\trgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\t\t}\n\t\t/**\n\t\t * Return the color a specified format\n\t\t * @param {String} format\n\t\t */\n\t\tfunction get(format) {\n\t\t\tvar ret;\n\n\t\t\tif (stops) {\n\t\t\t\tret = merge(input);\n\t\t\t\tret.stops = [].concat(ret.stops);\n\t\t\t\teach(stops, function (stop, i) {\n\t\t\t\t\tret.stops[i] = [ret.stops[i][0], stop.get(format)];\n\t\t\t\t});\n\n\t\t\t// it's NaN if gradient colors on a column chart\n\t\t\t} else if (rgba && !isNaN(rgba[0])) {\n\t\t\t\tif (format === 'rgb') {\n\t\t\t\t\tret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n\t\t\t\t} else if (format === 'a') {\n\t\t\t\t\tret = rgba[3];\n\t\t\t\t} else {\n\t\t\t\t\tret = 'rgba(' + rgba.join(',') + ')';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = input;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t/**\n\t\t * Brighten the color\n\t\t * @param {Number} alpha\n\t\t */\n\t\tfunction brighten(alpha) {\n\t\t\tif (stops) {\n\t\t\t\teach(stops, function (stop) {\n\t\t\t\t\tstop.brighten(alpha);\n\t\t\t\t});\n\t\t\t\n\t\t\t} else if (isNumber(alpha) && alpha !== 0) {\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\trgba[i] += pInt(alpha * 255);\n\n\t\t\t\t\tif (rgba[i] < 0) {\n\t\t\t\t\t\trgba[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (rgba[i] > 255) {\n\t\t\t\t\t\trgba[i] = 255;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t/**\n\t\t * Set the color's opacity to a given alpha value\n\t\t * @param {Number} alpha\n\t\t */\n\t\tfunction setOpacity(alpha) {\n\t\t\trgba[3] = alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\t// initialize: parse the input\n\t\tinit(input);\n\n\t\t// public methods\n\t\treturn {\n\t\t\tget: get,\n\t\t\tbrighten: brighten,\n\t\t\trgba: rgba,\n\t\t\tsetOpacity: setOpacity,\n\t\t\traw: input\n\t\t};\n\t};\n\n\n\t/**\n\t * A wrapper object for SVG elements\n\t */\n\tfunction SVGElement() {}\n\n\tSVGElement.prototype = {\n\t\t\n\t\t// Default base for animation\n\t\topacity: 1,\n\t\t// For labels, these CSS properties are applied to the <text> node directly\n\t\ttextProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', \n\t\t\t'lineHeight', 'width', 'textDecoration', 'textShadow'],\n\t\t\n\t\t/**\n\t\t * Initialize the SVG renderer\n\t\t * @param {Object} renderer\n\t\t * @param {String} nodeName\n\t\t */\n\t\tinit: function (renderer, nodeName) {\n\t\t\tvar wrapper = this;\n\t\t\twrapper.element = nodeName === 'span' ?\n\t\t\t\tcreateElement(nodeName) :\n\t\t\t\tdoc.createElementNS(SVG_NS, nodeName);\n\t\t\twrapper.renderer = renderer;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Animate a given attribute\n\t\t * @param {Object} params\n\t\t * @param {Number} options The same options as in jQuery animation\n\t\t * @param {Function} complete Function to perform at the end of animation\n\t\t */\n\t\tanimate: function (params, options, complete) {\n\t\t\tvar animOptions = pick(options, globalAnimation, true);\n\t\t\tstop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n\t\t\tif (animOptions) {\n\t\t\t\tanimOptions = merge(animOptions, {}); //#2625\n\t\t\t\tif (complete) { // allows using a callback with the global animation without overwriting it\n\t\t\t\t\tanimOptions.complete = complete;\n\t\t\t\t}\n\t\t\t\tanimate(this, params, animOptions);\n\t\t\t} else {\n\t\t\t\tthis.attr(params);\n\t\t\t\tif (complete) {\n\t\t\t\t\tcomplete();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Build an SVG gradient out of a common JavaScript configuration object\n\t\t */\n\t\tcolorGradient: function (color, prop, elem) {\n\t\t\tvar renderer = this.renderer,\n\t\t\t\tcolorObject,\n\t\t\t\tgradName,\n\t\t\t\tgradAttr,\n\t\t\t\tgradients,\n\t\t\t\tgradientObject,\n\t\t\t\tstops,\n\t\t\t\tstopColor,\n\t\t\t\tstopOpacity,\n\t\t\t\tradialReference,\n\t\t\t\tn,\n\t\t\t\tid,\n\t\t\t\tkey = [];\n\n\t\t\t// Apply linear or radial gradients\n\t\t\tif (color.linearGradient) {\n\t\t\t\tgradName = 'linearGradient';\n\t\t\t} else if (color.radialGradient) {\n\t\t\t\tgradName = 'radialGradient';\n\t\t\t}\n\n\t\t\tif (gradName) {\n\t\t\t\tgradAttr = color[gradName];\n\t\t\t\tgradients = renderer.gradients;\n\t\t\t\tstops = color.stops;\n\t\t\t\tradialReference = elem.radialReference;\n\n\t\t\t\t// Keep < 2.2 kompatibility\n\t\t\t\tif (isArray(gradAttr)) {\n\t\t\t\t\tcolor[gradName] = gradAttr = {\n\t\t\t\t\t\tx1: gradAttr[0],\n\t\t\t\t\t\ty1: gradAttr[1],\n\t\t\t\t\t\tx2: gradAttr[2],\n\t\t\t\t\t\ty2: gradAttr[3],\n\t\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Correct the radial gradient for the radial reference system\n\t\t\t\tif (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n\t\t\t\t\tgradAttr = merge(gradAttr, {\n\t\t\t\t\t\tcx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n\t\t\t\t\t\tcy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n\t\t\t\t\t\tr: gradAttr.r * radialReference[2],\n\t\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Build the unique key to detect whether we need to create a new element (#1282)\n\t\t\t\tfor (n in gradAttr) {\n\t\t\t\t\tif (n !== 'id') {\n\t\t\t\t\t\tkey.push(n, gradAttr[n]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (n in stops) {\n\t\t\t\t\tkey.push(stops[n]);\n\t\t\t\t}\n\t\t\t\tkey = key.join(',');\n\n\t\t\t\t// Check if a gradient object with the same config object is created within this renderer\n\t\t\t\tif (gradients[key]) {\n\t\t\t\t\tid = gradients[key].attr('id');\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Set the id and create the element\n\t\t\t\t\tgradAttr.id = id = PREFIX + idCounter++;\n\t\t\t\t\tgradients[key] = gradientObject = renderer.createElement(gradName)\n\t\t\t\t\t\t.attr(gradAttr)\n\t\t\t\t\t\t.add(renderer.defs);\n\n\n\t\t\t\t\t// The gradient needs to keep a list of stops to be able to destroy them\n\t\t\t\t\tgradientObject.stops = [];\n\t\t\t\t\teach(stops, function (stop) {\n\t\t\t\t\t\tvar stopObject;\n\t\t\t\t\t\tif (stop[1].indexOf('rgba') === 0) {\n\t\t\t\t\t\t\tcolorObject = Color(stop[1]);\n\t\t\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstopObject = renderer.createElement('stop').attr({\n\t\t\t\t\t\t\toffset: stop[0],\n\t\t\t\t\t\t\t'stop-color': stopColor,\n\t\t\t\t\t\t\t'stop-opacity': stopOpacity\n\t\t\t\t\t\t}).add(gradientObject);\n\n\t\t\t\t\t\t// Add the stop element to the gradient\n\t\t\t\t\t\tgradientObject.stops.push(stopObject);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Set the reference to the gradient object\n\t\t\t\telem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');\n\t\t\t} \n\t\t},\n\n\t\t/**\n\t\t * Apply a polyfill to the text-stroke CSS property, by copying the text element\n\t\t * and apply strokes to the copy.\n\t\t *\n\t\t * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color\n\t\t * TODO: \n\t\t * - update defaults\n\t\t */\n\t\tapplyTextShadow: function (textShadow) {\n\t\t\tvar elem = this.element,\n\t\t\t\ttspans,\n\t\t\t\thasContrast = textShadow.indexOf('contrast') !== -1,\n\t\t\t\t// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n\t\t\t\t// this again with new IE release. In exports, the rendering is passed to PhantomJS. \n\t\t\t\tsupports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);\n\n\t\t\t// When the text shadow is set to contrast, use dark stroke for light text and vice versa\n\t\t\tif (hasContrast) {\n\t\t\t\ttextShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n\t\t\t}\n\n\t\t\t/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n\t\t\tif (elem.textContent.indexOf('2.') === 0) {\n\t\t\t\telem.style['text-shadow'] = 'none';\n\t\t\t\tsupports = false;\n\t\t\t}\n\t\t\t// */\n\n\t\t\t// No reason to polyfill, we've got native support\n\t\t\tif (supports) {\n\t\t\t\tif (hasContrast) { // Apply the altered style\n\t\t\t\t\tcss(elem, {\n\t\t\t\t\t\ttextShadow: textShadow\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tthis.fakeTS = true; // Fake text shadow\n\n\t\t\t\t// In order to get the right y position of the clones, \n\t\t\t\t// copy over the y setter\n\t\t\t\tthis.ySetter = this.xSetter;\n\n\t\t\t\ttspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\t\t\t\teach(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n\t\t\t\t\tvar firstChild = elem.firstChild,\n\t\t\t\t\t\tcolor,\n\t\t\t\t\t\tstrokeWidth;\n\t\t\t\t\t\n\t\t\t\t\ttextShadow = textShadow.split(' ');\n\t\t\t\t\tcolor = textShadow[textShadow.length - 1];\n\n\t\t\t\t\t// Approximately tune the settings to the text-shadow behaviour\n\t\t\t\t\tstrokeWidth = textShadow[textShadow.length - 2];\n\n\t\t\t\t\tif (strokeWidth) {\n\t\t\t\t\t\teach(tspans, function (tspan, y) {\n\t\t\t\t\t\t\tvar clone;\n\n\t\t\t\t\t\t\t// Let the first line start at the correct X position\n\t\t\t\t\t\t\tif (y === 0) {\n\t\t\t\t\t\t\t\ttspan.setAttribute('x', elem.getAttribute('x'));\n\t\t\t\t\t\t\t\ty = elem.getAttribute('y');\n\t\t\t\t\t\t\t\ttspan.setAttribute('y', y || 0);\n\t\t\t\t\t\t\t\tif (y === null) {\n\t\t\t\t\t\t\t\t\telem.setAttribute('y', 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create the clone and apply shadow properties\n\t\t\t\t\t\t\tclone = tspan.cloneNode(1);\n\t\t\t\t\t\t\tattr(clone, {\n\t\t\t\t\t\t\t\t'class': PREFIX + 'text-shadow',\n\t\t\t\t\t\t\t\t'fill': color,\n\t\t\t\t\t\t\t\t'stroke': color,\n\t\t\t\t\t\t\t\t'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),\n\t\t\t\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\telem.insertBefore(clone, firstChild);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set or get a given attribute\n\t\t * @param {Object|String} hash\n\t\t * @param {Mixed|Undefined} val\n\t\t */\n\t\tattr: function (hash, val) {\n\t\t\tvar key,\n\t\t\t\tvalue,\n\t\t\t\telement = this.element,\n\t\t\t\thasSetSymbolSize,\n\t\t\t\tret = this,\n\t\t\t\tskipAttr;\n\n\t\t\t// single key-value pair\n\t\t\tif (typeof hash === 'string' && val !== UNDEFINED) {\n\t\t\t\tkey = hash;\n\t\t\t\thash = {};\n\t\t\t\thash[key] = val;\n\t\t\t}\n\n\t\t\t// used as a getter: first argument is a string, second is undefined\n\t\t\tif (typeof hash === 'string') {\n\t\t\t\tret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\t\t\t\n\t\t\t// setter\n\t\t\t} else {\n\n\t\t\t\tfor (key in hash) {\n\t\t\t\t\tvalue = hash[key];\n\t\t\t\t\tskipAttr = false;\n\n\n\n\t\t\t\t\tif (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n\t\t\t\t\t\tif (!hasSetSymbolSize) {\n\t\t\t\t\t\t\tthis.symbolAttr(hash);\n\t\t\t\t\t\t\thasSetSymbolSize = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskipAttr = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.rotation && (key === 'x' || key === 'y')) {\n\t\t\t\t\t\tthis.doTransform = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!skipAttr) {\n\t\t\t\t\t\t(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Let the shadow follow the main element\n\t\t\t\t\tif (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n\t\t\t\t\t\tthis.updateShadows(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update transform. Do this outside the loop to prevent redundant updating for batch setting\n\t\t\t\t// of attributes.\n\t\t\t\tif (this.doTransform) {\n\t\t\t\t\tthis.updateTransform();\n\t\t\t\t\tthis.doTransform = false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tupdateShadows: function (key, value) {\n\t\t\tvar shadows = this.shadows,\n\t\t\t\ti = shadows.length;\n\t\t\twhile (i--) {\n\t\t\t\tshadows[i].setAttribute(\n\t\t\t\t\tkey,\n\t\t\t\t\tkey === 'height' ?\n\t\t\t\t\t\tmathMax(value - (shadows[i].cutHeight || 0), 0) :\n\t\t\t\t\t\tkey === 'd' ? this.d : value\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Add a class name to an element\n\t\t */\n\t\taddClass: function (className) {\n\t\t\tvar element = this.element,\n\t\t\t\tcurrentClassName = attr(element, 'class') || '';\n\n\t\t\tif (currentClassName.indexOf(className) === -1) {\n\t\t\t\tattr(element, 'class', currentClassName + ' ' + className);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/* hasClass and removeClass are not (yet) needed\n\t\thasClass: function (className) {\n\t\t\treturn attr(this.element, 'class').indexOf(className) !== -1;\n\t\t},\n\t\tremoveClass: function (className) {\n\t\t\tattr(this.element, 'class', attr(this.element, 'class').replace(className, ''));\n\t\t\treturn this;\n\t\t},\n\t\t*/\n\n\t\t/**\n\t\t * If one of the symbol size affecting parameters are changed,\n\t\t * check all the others only once for each call to an element's\n\t\t * .attr() method\n\t\t * @param {Object} hash\n\t\t */\n\t\tsymbolAttr: function (hash) {\n\t\t\tvar wrapper = this;\n\n\t\t\teach(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n\t\t\t\twrapper[key] = pick(hash[key], wrapper[key]);\n\t\t\t});\n\n\t\t\twrapper.attr({\n\t\t\t\td: wrapper.renderer.symbols[wrapper.symbolName](\n\t\t\t\t\twrapper.x,\n\t\t\t\t\twrapper.y,\n\t\t\t\t\twrapper.width,\n\t\t\t\t\twrapper.height,\n\t\t\t\t\twrapper\n\t\t\t\t)\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Apply a clipping path to this object\n\t\t * @param {String} id\n\t\t */\n\t\tclip: function (clipRect) {\n\t\t\treturn this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n\t\t},\n\n\t\t/**\n\t\t * Calculate the coordinates needed for drawing a rectangle crisply and return the\n\t\t * calculated attributes\n\t\t * @param {Number} strokeWidth\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\tcrisp: function (rect) {\n\n\t\t\tvar wrapper = this,\n\t\t\t\tkey,\n\t\t\t\tattribs = {},\n\t\t\t\tnormalizer,\n\t\t\t\tstrokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;\n\n\t\t\tnormalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n\t\t\t// normalize for crisp edges\n\t\t\trect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;\n\t\t\trect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;\n\t\t\trect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);\n\t\t\trect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);\n\t\t\trect.strokeWidth = strokeWidth;\n\n\t\t\tfor (key in rect) {\n\t\t\t\tif (wrapper[key] !== rect[key]) { // only set attribute if changed\n\t\t\t\t\twrapper[key] = attribs[key] = rect[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attribs;\n\t\t},\n\n\t\t/**\n\t\t * Set styles for the element\n\t\t * @param {Object} styles\n\t\t */\n\t\tcss: function (styles) {\n\t\t\tvar elemWrapper = this,\n\t\t\t\toldStyles = elemWrapper.styles,\n\t\t\t\tnewStyles = {},\n\t\t\t\telem = elemWrapper.element,\n\t\t\t\ttextWidth,\n\t\t\t\tn,\n\t\t\t\tserializedCss = '',\n\t\t\t\thyphenate,\n\t\t\t\thasNew = !oldStyles;\n\n\t\t\t// convert legacy\n\t\t\tif (styles && styles.color) {\n\t\t\t\tstyles.fill = styles.color;\n\t\t\t}\n\n\t\t\t// Filter out existing styles to increase performance (#2640)\n\t\t\tif (oldStyles) {\n\t\t\t\tfor (n in styles) {\n\t\t\t\t\tif (styles[n] !== oldStyles[n]) {\n\t\t\t\t\t\tnewStyles[n] = styles[n];\n\t\t\t\t\t\thasNew = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasNew) {\n\t\t\t\ttextWidth = elemWrapper.textWidth = \n\t\t\t\t\t(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || \n\t\t\t\t\telemWrapper.textWidth; // #3501\n\n\t\t\t\t// Merge the new styles with the old ones\n\t\t\t\tif (oldStyles) {\n\t\t\t\t\tstyles = extend(\n\t\t\t\t\t\toldStyles,\n\t\t\t\t\t\tnewStyles\n\t\t\t\t\t);\n\t\t\t\t}\t\t\n\n\t\t\t\t// store object\n\t\t\t\telemWrapper.styles = styles;\n\n\t\t\t\tif (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {\n\t\t\t\t\tdelete styles.width;\n\t\t\t\t}\n\n\t\t\t\t// serialize and set style attribute\n\t\t\t\tif (isIE && !hasSVG) {\n\t\t\t\t\tcss(elemWrapper.element, styles);\n\t\t\t\t} else {\n\t\t\t\t\t/*jslint unparam: true*/\n\t\t\t\t\thyphenate = function (a, b) { return '-' + b.toLowerCase(); };\n\t\t\t\t\t/*jslint unparam: false*/\n\t\t\t\t\tfor (n in styles) {\n\t\t\t\t\t\tserializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n\t\t\t\t\t}\n\t\t\t\t\tattr(elem, 'style', serializedCss); // #1881\n\t\t\t\t}\n\n\n\t\t\t\t// re-build text\n\t\t\t\tif (textWidth && elemWrapper.added) {\n\t\t\t\t\telemWrapper.renderer.buildText(elemWrapper);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn elemWrapper;\n\t\t},\n\n\t\t/**\n\t\t * Add an event listener\n\t\t * @param {String} eventType\n\t\t * @param {Function} handler\n\t\t */\n\t\ton: function (eventType, handler) {\n\t\t\tvar svgElement = this,\n\t\t\t\telement = svgElement.element;\n\t\t\t\n\t\t\t// touch\n\t\t\tif (hasTouch && eventType === 'click') {\n\t\t\t\telement.ontouchstart = function (e) {\t\t\t\n\t\t\t\t\tsvgElement.touchEventFired = Date.now();\t\t\t\t\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\thandler.call(element, e);\n\t\t\t\t};\n\t\t\t\telement.onclick = function (e) {\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tif (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n\t\t\t\t\t\thandler.call(element, e);\n\t\t\t\t\t}\n\t\t\t\t};\t\t\t\n\t\t\t} else {\n\t\t\t\t// simplest possible event model for internal use\n\t\t\t\telement['on' + eventType] = handler;\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Set the coordinates needed to draw a consistent radial gradient across\n\t\t * pie slices regardless of positioning inside the chart. The format is\n\t\t * [centerX, centerY, diameter] in pixels.\n\t\t */\n\t\tsetRadialReference: function (coordinates) {\n\t\t\tthis.element.radialReference = coordinates;\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Move an object and its children by x and y values\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t */\n\t\ttranslate: function (x, y) {\n\t\t\treturn this.attr({\n\t\t\t\ttranslateX: x,\n\t\t\t\ttranslateY: y\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Invert a group, rotate and flip\n\t\t */\n\t\tinvert: function () {\n\t\t\tvar wrapper = this;\n\t\t\twrapper.inverted = true;\n\t\t\twrapper.updateTransform();\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * Private method to update the transform attribute based on internal\n\t\t * properties\n\t\t */\n\t\tupdateTransform: function () {\n\t\t\tvar wrapper = this,\n\t\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\t\tscaleX = wrapper.scaleX,\n\t\t\t\tscaleY = wrapper.scaleY,\n\t\t\t\tinverted = wrapper.inverted,\n\t\t\t\trotation = wrapper.rotation,\n\t\t\t\telement = wrapper.element,\n\t\t\t\ttransform;\n\n\t\t\t// flipping affects translate as adjustment for flipping around the group's axis\n\t\t\tif (inverted) {\n\t\t\t\ttranslateX += wrapper.attr('width');\n\t\t\t\ttranslateY += wrapper.attr('height');\n\t\t\t}\n\n\t\t\t// Apply translate. Nearly all transformed elements have translation, so instead\n\t\t\t// of checking for translate = 0, do it always (#1767, #1846).\n\t\t\ttransform = ['translate(' + translateX + ',' + translateY + ')'];\n\n\t\t\t// apply rotation\n\t\t\tif (inverted) {\n\t\t\t\ttransform.push('rotate(90) scale(-1,1)');\n\t\t\t} else if (rotation) { // text rotation\n\t\t\t\ttransform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\t\t\t\t\n\t\t\t\t// Delete bBox memo when the rotation changes\n\t\t\t\t//delete wrapper.bBox;\n\t\t\t}\n\n\t\t\t// apply scale\n\t\t\tif (defined(scaleX) || defined(scaleY)) {\n\t\t\t\ttransform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n\t\t\t}\n\n\t\t\tif (transform.length) {\n\t\t\t\telement.setAttribute('transform', transform.join(' '));\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Bring the element to the front\n\t\t */\n\t\ttoFront: function () {\n\t\t\tvar element = this.element;\n\t\t\telement.parentNode.appendChild(element);\n\t\t\treturn this;\n\t\t},\n\n\n\t\t/**\n\t\t * Break down alignment options like align, verticalAlign, x and y\n\t\t * to x and y relative to the chart.\n\t\t *\n\t\t * @param {Object} alignOptions\n\t\t * @param {Boolean} alignByTranslate\n\t\t * @param {String[Object} box The box to align to, needs a width and height. When the\n\t\t *\t\tbox is a string, it refers to an object in the Renderer. For example, when\n\t\t *\t\tbox is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n\t\t *\t\tx and y properties.\n\t\t *\n\t\t */\n\t\talign: function (alignOptions, alignByTranslate, box) {\n\t\t\tvar align,\n\t\t\t\tvAlign,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tattribs = {},\n\t\t\t\talignTo,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\talignedObjects = renderer.alignedObjects;\n\n\t\t\t// First call on instanciate\n\t\t\tif (alignOptions) {\n\t\t\t\tthis.alignOptions = alignOptions;\n\t\t\t\tthis.alignByTranslate = alignByTranslate;\n\t\t\t\tif (!box || isString(box)) { // boxes other than renderer handle this internally\n\t\t\t\t\tthis.alignTo = alignTo = box || 'renderer';\n\t\t\t\t\terase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n\t\t\t\t\talignedObjects.push(this);\n\t\t\t\t\tbox = null; // reassign it below\n\t\t\t\t}\n\n\t\t\t// When called on resize, no arguments are supplied\n\t\t\t} else {\n\t\t\t\talignOptions = this.alignOptions;\n\t\t\t\talignByTranslate = this.alignByTranslate;\n\t\t\t\talignTo = this.alignTo;\n\t\t\t}\n\n\t\t\tbox = pick(box, renderer[alignTo], renderer);\n\n\t\t\t// Assign variables\n\t\t\talign = alignOptions.align;\n\t\t\tvAlign = alignOptions.verticalAlign;\n\t\t\tx = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\t\t\ty = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n\t\t\t// Align\n\t\t\tif (align === 'right' || align === 'center') {\n\t\t\t\tx += (box.width - (alignOptions.width || 0)) /\n\t\t\t\t\t\t{ right: 1, center: 2 }[align];\n\t\t\t}\n\t\t\tattribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n\t\t\t// Vertical align\n\t\t\tif (vAlign === 'bottom' || vAlign === 'middle') {\n\t\t\t\ty += (box.height - (alignOptions.height || 0)) /\n\t\t\t\t\t\t({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n\t\t\t}\n\t\t\tattribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n\t\t\t// Animate only if already placed\n\t\t\tthis[this.placed ? 'animate' : 'attr'](attribs);\n\t\t\tthis.placed = true;\n\t\t\tthis.alignAttr = attribs;\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Get the bounding box (width, height, x and y) for the element\n\t\t */\n\t\tgetBBox: function (reload) {\n\t\t\tvar wrapper = this,\n\t\t\t\tbBox,// = wrapper.bBox,\n\t\t\t\trenderer = wrapper.renderer,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\trotation = wrapper.rotation,\n\t\t\t\telement = wrapper.element,\n\t\t\t\tstyles = wrapper.styles,\n\t\t\t\trad = rotation * deg2rad,\n\t\t\t\ttextStr = wrapper.textStr,\n\t\t\t\ttextShadow,\n\t\t\t\telemStyle = element.style,\n\t\t\t\ttoggleTextShadowShim,\n\t\t\t\tcacheKey;\n\n\t\t\tif (textStr !== UNDEFINED) {\n\n\t\t\t\t// Properties that affect bounding box\n\t\t\t\tcacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n\t\t\t\t// Since numbers are monospaced, and numerical labels appear a lot in a chart,\n\t\t\t\t// we assume that a label of n characters has the same bounding box as others \n\t\t\t\t// of the same length.\n\t\t\t\tif (textStr === '' || numRegex.test(textStr)) {\n\t\t\t\t\tcacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n\t\t\t\t// Caching all strings reduces rendering time by 4-5%.\n\t\t\t\t} else {\n\t\t\t\t\tcacheKey = textStr + cacheKey;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cacheKey && !reload) {\n\t\t\t\tbBox = renderer.cache[cacheKey];\n\t\t\t}\n\n\t\t\t// No cache found\n\t\t\tif (!bBox) {\n\n\t\t\t\t// SVG elements\n\t\t\t\tif (element.namespaceURI === SVG_NS || renderer.forExport) {\n\t\t\t\t\ttry { // Fails in Firefox if the container has display: none.\n\n\t\t\t\t\t\t// When the text shadow shim is used, we need to hide the fake shadows\n\t\t\t\t\t\t// to get the correct bounding box (#3872)\n\t\t\t\t\t\ttoggleTextShadowShim = this.fakeTS && function (display) {\n\t\t\t\t\t\t\teach(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {\n\t\t\t\t\t\t\t\ttspan.style.display = display;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Workaround for #3842, Firefox reporting wrong bounding box for shadows\n\t\t\t\t\t\tif (isFirefox && elemStyle.textShadow) {\n\t\t\t\t\t\t\ttextShadow = elemStyle.textShadow;\n\t\t\t\t\t\t\telemStyle.textShadow = '';\n\t\t\t\t\t\t} else if (toggleTextShadowShim) {\n\t\t\t\t\t\t\ttoggleTextShadowShim(NONE);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbBox = element.getBBox ?\n\t\t\t\t\t\t\t// SVG: use extend because IE9 is not allowed to change width and height in case\n\t\t\t\t\t\t\t// of rotation (below)\n\t\t\t\t\t\t\textend({}, element.getBBox()) :\n\t\t\t\t\t\t\t// Canvas renderer and legacy IE in export mode\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twidth: element.offsetWidth,\n\t\t\t\t\t\t\t\theight: element.offsetHeight\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// #3842\n\t\t\t\t\t\tif (textShadow) {\n\t\t\t\t\t\t\telemStyle.textShadow = textShadow;\n\t\t\t\t\t\t} else if (toggleTextShadowShim) {\n\t\t\t\t\t\t\ttoggleTextShadowShim('');\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\t// If the bBox is not set, the try-catch block above failed. The other condition\n\t\t\t\t\t// is for Opera that returns a width of -Infinity on hidden elements.\n\t\t\t\t\tif (!bBox || bBox.width < 0) {\n\t\t\t\t\t\tbBox = { width: 0, height: 0 };\n\t\t\t\t\t}\n\n\n\t\t\t\t// VML Renderer or useHTML within SVG\n\t\t\t\t} else {\n\n\t\t\t\t\tbBox = wrapper.htmlGetBBox();\n\n\t\t\t\t}\n\n\t\t\t\t// True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n\t\t\t\t// need to compensated for rotation\n\t\t\t\tif (renderer.isSVG) {\n\t\t\t\t\twidth = bBox.width;\n\t\t\t\t\theight = bBox.height;\n\n\t\t\t\t\t// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n\t\t\t\t\tif (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n\t\t\t\t\t\tbBox.height = height = 14;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Adjust for rotated text\n\t\t\t\t\tif (rotation) {\n\t\t\t\t\t\tbBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n\t\t\t\t\t\tbBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache it\n\t\t\t\trenderer.cache[cacheKey] = bBox;\n\t\t\t}\n\t\t\treturn bBox;\n\t\t},\n\n\t\t/**\n\t\t * Show the element\n\t\t */\n\t\tshow: function (inherit) {\n\t\t\t// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)\n\t\t\tif (inherit && this.element.namespaceURI === SVG_NS) {\n\t\t\t\tthis.element.removeAttribute('visibility');\n\t\t\t} else {\n\t\t\t\tthis.attr({ visibility: inherit ? 'inherit' : VISIBLE });\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Hide the element\n\t\t */\n\t\thide: function () {\n\t\t\treturn this.attr({ visibility: HIDDEN });\n\t\t},\n\n\t\tfadeOut: function (duration) {\n\t\t\tvar elemWrapper = this;\n\t\t\telemWrapper.animate({\n\t\t\t\topacity: 0\n\t\t\t}, {\n\t\t\t\tduration: duration || 150,\n\t\t\t\tcomplete: function () {\n\t\t\t\t\telemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Add the element\n\t\t * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n\t\t *\tto append the element to the renderer.box.\n\t\t */\n\t\tadd: function (parent) {\n\n\t\t\tvar renderer = this.renderer,\n\t\t\t\telement = this.element,\n\t\t\t\tinserted;\n\n\t\t\tif (parent) {\n\t\t\t\tthis.parentGroup = parent;\n\t\t\t}\n\n\t\t\t// mark as inverted\n\t\t\tthis.parentInverted = parent && parent.inverted;\n\n\t\t\t// build formatted text\n\t\t\tif (this.textStr !== undefined) {\n\t\t\t\trenderer.buildText(this);\n\t\t\t}\n\n\t\t\t// Mark as added\n\t\t\tthis.added = true;\n\n\t\t\t// If we're adding to renderer root, or other elements in the group \n\t\t\t// have a z index, we need to handle it\n\t\t\tif (!parent || parent.handleZ || this.zIndex) {\n\t\t\t\tinserted = this.zIndexSetter();\n\t\t\t}\n\n\t\t\t// If zIndex is not handled, append at the end\n\t\t\tif (!inserted) {\n\t\t\t\t(parent ? parent.element : renderer.box).appendChild(element);\n\t\t\t}\n\n\t\t\t// fire an event for internal hooks\n\t\t\tif (this.onAdd) {\n\t\t\t\tthis.onAdd();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Removes a child either by removeChild or move to garbageBin.\n\t\t * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n\t\t */\n\t\tsafeRemoveChild: function (element) {\n\t\t\tvar parentNode = element.parentNode;\n\t\t\tif (parentNode) {\n\t\t\t\tparentNode.removeChild(element);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Destroy the element and element wrapper\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar wrapper = this,\n\t\t\t\telement = wrapper.element || {},\n\t\t\t\tshadows = wrapper.shadows,\n\t\t\t\tparentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n\t\t\t\tgrandParent,\n\t\t\t\tkey,\n\t\t\t\ti;\n\n\t\t\t// remove events\n\t\t\telement.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n\t\t\tstop(wrapper); // stop running animations\n\n\t\t\tif (wrapper.clipPath) {\n\t\t\t\twrapper.clipPath = wrapper.clipPath.destroy();\n\t\t\t}\n\n\t\t\t// Destroy stops in case this is a gradient object\n\t\t\tif (wrapper.stops) {\n\t\t\t\tfor (i = 0; i < wrapper.stops.length; i++) {\n\t\t\t\t\twrapper.stops[i] = wrapper.stops[i].destroy();\n\t\t\t\t}\n\t\t\t\twrapper.stops = null;\n\t\t\t}\n\n\t\t\t// remove element\n\t\t\twrapper.safeRemoveChild(element);\n\n\t\t\t// destroy shadows\n\t\t\tif (shadows) {\n\t\t\t\teach(shadows, function (shadow) {\n\t\t\t\t\twrapper.safeRemoveChild(shadow);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n\t\t\twhile (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n\t\t\t\tgrandParent = parentToClean.parentGroup;\n\t\t\t\twrapper.safeRemoveChild(parentToClean.div);\n\t\t\t\tdelete parentToClean.div;\n\t\t\t\tparentToClean = grandParent;\n\t\t\t}\n\n\t\t\t// remove from alignObjects\n\t\t\tif (wrapper.alignTo) {\n\t\t\t\terase(wrapper.renderer.alignedObjects, wrapper);\n\t\t\t}\n\n\t\t\tfor (key in wrapper) {\n\t\t\t\tdelete wrapper[key];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Add a shadow to the element. Must be done after the element is added to the DOM\n\t\t * @param {Boolean|Object} shadowOptions\n\t\t */\n\t\tshadow: function (shadowOptions, group, cutOff) {\n\t\t\tvar shadows = [],\n\t\t\t\ti,\n\t\t\t\tshadow,\n\t\t\t\telement = this.element,\n\t\t\t\tstrokeWidth,\n\t\t\t\tshadowWidth,\n\t\t\t\tshadowElementOpacity,\n\n\t\t\t\t// compensate for inverted plot area\n\t\t\t\ttransform;\n\n\n\t\t\tif (shadowOptions) {\n\t\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n\t\t\t\ttransform = this.parentInverted ?\n\t\t\t\t\t'(-1,-1)' :\n\t\t\t\t\t'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n\t\t\t\tfor (i = 1; i <= shadowWidth; i++) {\n\t\t\t\t\tshadow = element.cloneNode(0);\n\t\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\t\t\t\t\tattr(shadow, {\n\t\t\t\t\t\t'isShadow': 'true',\n\t\t\t\t\t\t'stroke': shadowOptions.color || 'black',\n\t\t\t\t\t\t'stroke-opacity': shadowElementOpacity * i,\n\t\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t\t'transform': 'translate' + transform,\n\t\t\t\t\t\t'fill': NONE\n\t\t\t\t\t});\n\t\t\t\t\tif (cutOff) {\n\t\t\t\t\t\tattr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n\t\t\t\t\t\tshadow.cutHeight = strokeWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (group) {\n\t\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t\t}\n\n\t\t\t\t\tshadows.push(shadow);\n\t\t\t\t}\n\n\t\t\t\tthis.shadows = shadows;\n\t\t\t}\n\t\t\treturn this;\n\n\t\t},\n\n\t\txGetter: function (key) {\n\t\t\tif (this.element.nodeName === 'circle') {\n\t\t\t\tkey = { x: 'cx', y: 'cy' }[key] || key;\n\t\t\t}\n\t\t\treturn this._defaultGetter(key);\n\t\t},\n\n\t\t/** \n\t\t * Get the current value of an attribute or pseudo attribute, used mainly\n\t\t * for animation.\n\t\t */\n\t\t_defaultGetter: function (key) {\n\t\t\tvar ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n\t\t\tif (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n\t\t\t\tret = parseFloat(ret);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\n\t\tdSetter: function (value, key, element) {\n\t\t\tif (value && value.join) { // join path\n\t\t\t\tvalue = value.join(' ');\n\t\t\t}\n\t\t\tif (/(NaN| {2}|^$)/.test(value)) {\n\t\t\t\tvalue = 'M 0 0';\n\t\t\t}\n\t\t\telement.setAttribute(key, value);\n\n\t\t\tthis[key] = value;\n\t\t},\n\t\tdashstyleSetter: function (value) {\n\t\t\tvar i;\n\t\t\tvalue = value && value.toLowerCase();\n\t\t\tif (value) {\n\t\t\t\tvalue = value\n\t\t\t\t\t.replace('shortdashdotdot', '3,1,1,1,1,1,')\n\t\t\t\t\t.replace('shortdashdot', '3,1,1,1')\n\t\t\t\t\t.replace('shortdot', '1,1,')\n\t\t\t\t\t.replace('shortdash', '3,1,')\n\t\t\t\t\t.replace('longdash', '8,3,')\n\t\t\t\t\t.replace(/dot/g, '1,3,')\n\t\t\t\t\t.replace('dash', '4,3,')\n\t\t\t\t\t.replace(/,$/, '')\n\t\t\t\t\t.split(','); // ending comma\n\n\t\t\t\ti = value.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tvalue[i] = pInt(value[i]) * this['stroke-width'];\n\t\t\t\t}\n\t\t\t\tvalue = value.join(',')\n\t\t\t\t\t.replace('NaN', 'none'); // #3226\n\t\t\t\tthis.element.setAttribute('stroke-dasharray', value);\n\t\t\t}\n\t\t},\n\t\talignSetter: function (value) {\n\t\t\tthis.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);\n\t\t},\n\t\topacitySetter: function (value, key, element) {\n\t\t\tthis[key] = value;\n\t\t\telement.setAttribute(key, value);\n\t\t},\n\t\ttitleSetter: function (value) {\n\t\t\tvar titleNode = this.element.getElementsByTagName('title')[0];\n\t\t\tif (!titleNode) {\n\t\t\t\ttitleNode = doc.createElementNS(SVG_NS, 'title');\n\t\t\t\tthis.element.appendChild(titleNode);\n\t\t\t}\n\t\t\ttitleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895\n\t\t},\n\t\ttextSetter: function (value) {\n\t\t\tif (value !== this.textStr) {\n\t\t\t\t// Delete bBox memo when the text changes\n\t\t\t\tdelete this.bBox;\n\t\t\t\n\t\t\t\tthis.textStr = value;\n\t\t\t\tif (this.added) {\n\t\t\t\t\tthis.renderer.buildText(this);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfillSetter: function (value, key, element) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\telement.setAttribute(key, value);\n\t\t\t} else if (value) {\n\t\t\t\tthis.colorGradient(value, key, element);\n\t\t\t}\n\t\t},\n\t\tzIndexSetter: function (value, key) {\n\t\t\tvar renderer = this.renderer,\n\t\t\t\tparentGroup = this.parentGroup,\n\t\t\t\tparentWrapper = parentGroup || renderer,\n\t\t\t\tparentNode = parentWrapper.element || renderer.box,\n\t\t\t\tchildNodes,\n\t\t\t\totherElement,\n\t\t\t\totherZIndex,\n\t\t\t\telement = this.element,\n\t\t\t\tinserted,\n\t\t\t\trun = this.added,\n\t\t\t\ti;\n\t\t\t\n\t\t\tif (defined(value)) {\n\t\t\t\telement.setAttribute(key, value); // So we can read it for other elements in the group\n\t\t\t\tvalue = +value;\n\t\t\t\tif (this[key] === value) { // Only update when needed (#3865)\n\t\t\t\t\trun = false;\n\t\t\t\t}\n\t\t\t\tthis[key] = value;\n\t\t\t}\n\n\t\t\t// Insert according to this and other elements' zIndex. Before .add() is called,\n\t\t\t// nothing is done. Then on add, or by later calls to zIndexSetter, the node\n\t\t\t// is placed on the right place in the DOM.\n\t\t\tif (run) {\n\t\t\t\tvalue = this.zIndex;\n\n\t\t\t\tif (value && parentGroup) {\n\t\t\t\t\tparentGroup.handleZ = true;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tchildNodes = parentNode.childNodes;\n\t\t\t\tfor (i = 0; i < childNodes.length && !inserted; i++) {\n\t\t\t\t\totherElement = childNodes[i];\n\t\t\t\t\totherZIndex = attr(otherElement, 'zIndex');\n\t\t\t\t\tif (otherElement !== element && (\n\t\t\t\t\t\t\t// Insert before the first element with a higher zIndex\n\t\t\t\t\t\t\tpInt(otherZIndex) > value ||\n\t\t\t\t\t\t\t// If no zIndex given, insert before the first element with a zIndex\n\t\t\t\t\t\t\t(!defined(value) && defined(otherZIndex))\n\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\tparentNode.insertBefore(element, otherElement);\n\t\t\t\t\t\tinserted = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!inserted) {\n\t\t\t\t\tparentNode.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn inserted;\n\t\t},\n\t\t_defaultSetter: function (value, key, element) {\n\t\t\telement.setAttribute(key, value);\n\t\t}\n\t};\n\n\t// Some shared setters and getters\n\tSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n\tSVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = \n\t\t\tSVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = \n\t\t\tSVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n\t\tthis[key] = value;\n\t\tthis.doTransform = true;\n\t};\n\n\t// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n\t// stroke attribute altogether. #1270, #1369, #3065, #3072.\n\tSVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n\t\tthis[key] = value;\n\t\t// Only apply the stroke attribute if the stroke width is defined and larger than 0\n\t\tif (this.stroke && this['stroke-width']) {\n\t\t\tthis.strokeWidth = this['stroke-width'];\n\t\t\tSVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n\t\t\telement.setAttribute('stroke-width', this['stroke-width']);\n\t\t\tthis.hasStroke = true;\n\t\t} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n\t\t\telement.removeAttribute('stroke');\n\t\t\tthis.hasStroke = false;\n\t\t}\n\t};\n\n\n\t/**\n\t * The default SVG renderer\n\t */\n\tvar SVGRenderer = function () {\n\t\tthis.init.apply(this, arguments);\n\t};\n\tSVGRenderer.prototype = {\n\t\tElement: SVGElement,\n\n\t\t/**\n\t\t * Initialize the SVGRenderer\n\t\t * @param {Object} container\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t * @param {Boolean} forExport\n\t\t */\n\t\tinit: function (container, width, height, style, forExport) {\n\t\t\tvar renderer = this,\n\t\t\t\tloc = location,\n\t\t\t\tboxWrapper,\n\t\t\t\telement,\n\t\t\t\tdesc;\n\n\t\t\tboxWrapper = renderer.createElement('svg')\n\t\t\t\t.attr({\n\t\t\t\t\tversion: '1.1'\n\t\t\t\t})\n\t\t\t\t.css(this.getStyle(style));\n\t\t\telement = boxWrapper.element;\n\t\t\tcontainer.appendChild(element);\n\n\t\t\t// For browsers other than IE, add the namespace attribute (#1978)\n\t\t\tif (container.innerHTML.indexOf('xmlns') === -1) {\n\t\t\t\tattr(element, 'xmlns', SVG_NS);\n\t\t\t}\n\n\t\t\t// object properties\n\t\t\trenderer.isSVG = true;\n\t\t\trenderer.box = element;\n\t\t\trenderer.boxWrapper = boxWrapper;\n\t\t\trenderer.alignedObjects = [];\n\n\t\t\t// Page url used for internal references. #24, #672, #1070\n\t\t\trenderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n\t\t\t\tloc.href\n\t\t\t\t\t.replace(/#.*?$/, '') // remove the hash\n\t\t\t\t\t.replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n\t\t\t\t\t.replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n\t\t\t\t'';\n\n\t\t\t// Add description\n\t\t\tdesc = this.createElement('desc').add();\n\t\t\tdesc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));\n\n\n\t\t\trenderer.defs = this.createElement('defs').add();\n\t\t\trenderer.forExport = forExport;\n\t\t\trenderer.gradients = {}; // Object where gradient SvgElements are stored\n\t\t\trenderer.cache = {}; // Cache for numerical bounding boxes\n\n\t\t\trenderer.setSize(width, height, false);\n\n\n\n\t\t\t// Issue 110 workaround:\n\t\t\t// In Firefox, if a div is positioned by percentage, its pixel position may land\n\t\t\t// between pixels. The container itself doesn't display this, but an SVG element\n\t\t\t// inside this container will be drawn at subpixel precision. In order to draw\n\t\t\t// sharp lines, this must be compensated for. This doesn't seem to work inside\n\t\t\t// iframes though (like in jsFiddle).\n\t\t\tvar subPixelFix, rect;\n\t\t\tif (isFirefox && container.getBoundingClientRect) {\n\t\t\t\trenderer.subPixelFix = subPixelFix = function () {\n\t\t\t\t\tcss(container, { left: 0, top: 0 });\n\t\t\t\t\trect = container.getBoundingClientRect();\n\t\t\t\t\tcss(container, {\n\t\t\t\t\t\tleft: (mathCeil(rect.left) - rect.left) + PX,\n\t\t\t\t\t\ttop: (mathCeil(rect.top) - rect.top) + PX\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\t// run the fix now\n\t\t\t\tsubPixelFix();\n\n\t\t\t\t// run it on resize\n\t\t\t\taddEvent(win, 'resize', subPixelFix);\n\t\t\t}\n\t\t},\n\n\t\tgetStyle: function (style) {\n\t\t\treturn (this.style = extend({\n\t\t\t\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n\t\t\t\tfontSize: '12px'\n\t\t\t}, style));\n\t\t},\n\n\t\t/**\n\t\t * Detect whether the renderer is hidden. This happens when one of the parent elements\n\t\t * has display: none. #608.\n\t\t */\n\t\tisHidden: function () {\n\t\t\treturn !this.boxWrapper.getBBox().width;\n\t\t},\n\n\t\t/**\n\t\t * Destroys the renderer and its allocated members.\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar renderer = this,\n\t\t\t\trendererDefs = renderer.defs;\n\t\t\trenderer.box = null;\n\t\t\trenderer.boxWrapper = renderer.boxWrapper.destroy();\n\n\t\t\t// Call destroy on all gradient elements\n\t\t\tdestroyObjectProperties(renderer.gradients || {});\n\t\t\trenderer.gradients = null;\n\n\t\t\t// Defs are null in VMLRenderer\n\t\t\t// Otherwise, destroy them here.\n\t\t\tif (rendererDefs) {\n\t\t\t\trenderer.defs = rendererDefs.destroy();\n\t\t\t}\n\n\t\t\t// Remove sub pixel fix handler\n\t\t\t// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n\t\t\t// See issue #982\n\t\t\tif (renderer.subPixelFix) {\n\t\t\t\tremoveEvent(win, 'resize', renderer.subPixelFix);\n\t\t\t}\n\n\t\t\trenderer.alignedObjects = null;\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Create a wrapper for an SVG element\n\t\t * @param {Object} nodeName\n\t\t */\n\t\tcreateElement: function (nodeName) {\n\t\t\tvar wrapper = new this.Element();\n\t\t\twrapper.init(this, nodeName);\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * Dummy function for use in canvas renderer\n\t\t */\n\t\tdraw: function () {},\n\n\t\t/**\n\t\t * Parse a simple HTML string into SVG tspans\n\t\t *\n\t\t * @param {Object} textNode The parent text SVG node\n\t\t */\n\t\tbuildText: function (wrapper) {\n\t\t\tvar textNode = wrapper.element,\n\t\t\t\trenderer = this,\n\t\t\t\tforExport = renderer.forExport,\n\t\t\t\ttextStr = pick(wrapper.textStr, '').toString(),\n\t\t\t\thasMarkup = textStr.indexOf('<') !== -1,\n\t\t\t\tlines,\n\t\t\t\tchildNodes = textNode.childNodes,\n\t\t\t\tstyleRegex,\n\t\t\t\threfRegex,\n\t\t\t\tparentX = attr(textNode, 'x'),\n\t\t\t\ttextStyles = wrapper.styles,\n\t\t\t\twidth = wrapper.textWidth,\n\t\t\t\ttextLineHeight = textStyles && textStyles.lineHeight,\n\t\t\t\ttextShadow = textStyles && textStyles.textShadow,\n\t\t\t\tellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n\t\t\t\ti = childNodes.length,\n\t\t\t\ttempParent = width && !wrapper.added && this.box,\n\t\t\t\tgetLineHeight = function (tspan) {\n\t\t\t\t\treturn textLineHeight ? \n\t\t\t\t\t\tpInt(textLineHeight) :\n\t\t\t\t\t\trenderer.fontMetrics(\n\t\t\t\t\t\t\t/(px|em)$/.test(tspan && tspan.style.fontSize) ?\n\t\t\t\t\t\t\t\ttspan.style.fontSize :\n\t\t\t\t\t\t\t\t((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),\n\t\t\t\t\t\t\ttspan\n\t\t\t\t\t\t).h;\n\t\t\t\t},\n\t\t\t\tunescapeAngleBrackets = function (inputStr) {\n\t\t\t\t\treturn inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n\t\t\t\t};\n\n\t\t\t/// remove old text\n\t\t\twhile (i--) {\n\t\t\t\ttextNode.removeChild(childNodes[i]);\n\t\t\t}\n\n\t\t\t// Skip tspans, add text directly to text node. The forceTSpan is a hook \n\t\t\t// used in text outline hack.\n\t\t\tif (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n\t\t\t\ttextNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\t\t\t\treturn;\n\n\t\t\t// Complex strings, add more logic\n\t\t\t} else {\n\n\t\t\t\tstyleRegex = /<.*style=\"([^\"]+)\".*>/;\n\t\t\t\threfRegex = /<.*href=\"(http[^\"]+)\".*>/;\n\n\t\t\t\tif (tempParent) {\n\t\t\t\t\ttempParent.appendChild(textNode); // attach it to the DOM to read offset width\n\t\t\t\t}\n\n\t\t\t\tif (hasMarkup) {\n\t\t\t\t\tlines = textStr\n\t\t\t\t\t\t.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n\t\t\t\t\t\t.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\t\t\t\t\t\t.replace(/<a/g, '<span')\n\t\t\t\t\t\t.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n\t\t\t\t\t\t.split(/<br.*?>/g);\n\n\t\t\t\t} else {\n\t\t\t\t\tlines = [textStr];\n\t\t\t\t}\n\n\n\t\t\t\t// remove empty line at end\n\t\t\t\tif (lines[lines.length - 1] === '') {\n\t\t\t\t\tlines.pop();\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t// build the lines\n\t\t\t\teach(lines, function (line, lineNo) {\n\t\t\t\t\tvar spans, spanNo = 0;\n\n\t\t\t\t\tline = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n\t\t\t\t\tspans = line.split('|||');\n\n\t\t\t\t\teach(spans, function (span) {\n\t\t\t\t\t\tif (span !== '' || spans.length === 1) {\n\t\t\t\t\t\t\tvar attributes = {},\n\t\t\t\t\t\t\t\ttspan = doc.createElementNS(SVG_NS, 'tspan'),\n\t\t\t\t\t\t\t\tspanStyle; // #390\n\t\t\t\t\t\t\tif (styleRegex.test(span)) {\n\t\t\t\t\t\t\t\tspanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n\t\t\t\t\t\t\t\tattr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n\t\t\t\t\t\t\t\tcss(tspan, { cursor: 'pointer' });\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tspan = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n\t\t\t\t\t\t\t// Nested tags aren't supported, and cause crash in Safari (#1596)\n\t\t\t\t\t\t\tif (span !== ' ') {\n\n\t\t\t\t\t\t\t\t// add the text node\n\t\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(span));\n\n\t\t\t\t\t\t\t\tif (!spanNo) { // first span in a line, align it to the left\n\t\t\t\t\t\t\t\t\tif (lineNo && parentX !== null) {\n\t\t\t\t\t\t\t\t\t\tattributes.x = parentX;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tattributes.dx = 0; // #16\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// add attributes\n\t\t\t\t\t\t\t\tattr(tspan, attributes);\n\n\t\t\t\t\t\t\t\t// Append it\n\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\n\t\t\t\t\t\t\t\t// first span on subsequent line, add the line height\n\t\t\t\t\t\t\t\tif (!spanNo && lineNo) {\n\n\t\t\t\t\t\t\t\t\t// allow getting the right offset height in exporting in IE\n\t\t\t\t\t\t\t\t\tif (!hasSVG && forExport) {\n\t\t\t\t\t\t\t\t\t\tcss(tspan, { display: 'block' });\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Set the line height based on the font size of either\n\t\t\t\t\t\t\t\t\t// the text element or the tspan element\n\t\t\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t\t'dy',\n\t\t\t\t\t\t\t\t\t\tgetLineHeight(tspan)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/*if (width) {\n\t\t\t\t\t\t\t\t\trenderer.breakText(wrapper, width);\n\t\t\t\t\t\t\t\t}*/\n\n\t\t\t\t\t\t\t\t// Check width and apply soft breaks or ellipsis\n\t\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\t\tvar words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n\t\t\t\t\t\t\t\t\t\thasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n\t\t\t\t\t\t\t\t\t\ttooLong,\n\t\t\t\t\t\t\t\t\t\twasTooLong,\n\t\t\t\t\t\t\t\t\t\tactualWidth,\n\t\t\t\t\t\t\t\t\t\trest = [],\n\t\t\t\t\t\t\t\t\t\tdy = getLineHeight(tspan),\n\t\t\t\t\t\t\t\t\t\tsoftLineNo = 1,\n\t\t\t\t\t\t\t\t\t\trotation = wrapper.rotation,\n\t\t\t\t\t\t\t\t\t\twordStr = span, // for ellipsis\n\t\t\t\t\t\t\t\t\t\tcursor = wordStr.length, // binary search cursor\n\t\t\t\t\t\t\t\t\t\tbBox;\n\n\t\t\t\t\t\t\t\t\twhile ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n\t\t\t\t\t\t\t\t\t\twrapper.rotation = 0; // discard rotation when computing box\n\t\t\t\t\t\t\t\t\t\tbBox = wrapper.getBBox(true);\n\t\t\t\t\t\t\t\t\t\tactualWidth = bBox.width;\n\n\t\t\t\t\t\t\t\t\t\t// Old IE cannot measure the actualWidth for SVG elements (#2314)\n\t\t\t\t\t\t\t\t\t\tif (!hasSVG && renderer.forExport) {\n\t\t\t\t\t\t\t\t\t\t\tactualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttooLong = actualWidth > width;\n\n\t\t\t\t\t\t\t\t\t\t// For ellipsis, do a binary search for the correct string length\n\t\t\t\t\t\t\t\t\t\tif (wasTooLong === undefined) {\n\t\t\t\t\t\t\t\t\t\t\twasTooLong = tooLong; // First time\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (ellipsis && wasTooLong) {\n\t\t\t\t\t\t\t\t\t\t\tcursor /= 2;\n\n\t\t\t\t\t\t\t\t\t\t\tif (wordStr === '' || (!tooLong && cursor < 0.5)) {\n\t\t\t\t\t\t\t\t\t\t\t\twords = []; // All ok, break out\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (tooLong) {\n\t\t\t\t\t\t\t\t\t\t\t\t\twasTooLong = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\twordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));\n\t\t\t\t\t\t\t\t\t\t\t\twords = [wordStr + '\\u2026'];\n\t\t\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Looping down, this is the first word sequence that is not too long,\n\t\t\t\t\t\t\t\t\t\t// so we can move on to build the next line.\n\t\t\t\t\t\t\t\t\t\t} else if (!tooLong || words.length === 1) {\n\t\t\t\t\t\t\t\t\t\t\twords = rest;\n\t\t\t\t\t\t\t\t\t\t\trest = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\t\t\tsoftLineNo++;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(SVG_NS, 'tspan');\n\t\t\t\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\tif (spanStyle) { // #390\n\t\t\t\t\t\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (actualWidth > width) { // a single word is pressing it out\n\t\t\t\t\t\t\t\t\t\t\t\twidth = actualWidth;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else { // append to existing line tspan\n\t\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\t\trest.unshift(words.pop());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (wasTooLong) {\n\t\t\t\t\t\t\t\t\t\twrapper.attr('title', wrapper.textStr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twrapper.rotation = rotation;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tspanNo++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tif (tempParent) {\n\t\t\t\t\ttempParent.removeChild(textNode); // attach it to the DOM to read offset width\n\t\t\t\t}\n\n\t\t\t\t// Apply the text shadow\n\t\t\t\tif (textShadow && wrapper.applyTextShadow) {\n\t\t\t\t\twrapper.applyTextShadow(textShadow);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t\n\n\t\t/*\n\t\tbreakText: function (wrapper, width) {\n\t\t\tvar bBox = wrapper.getBBox(),\n\t\t\t\tnode = wrapper.element,\n\t\t\t\ttextLength = node.textContent.length,\n\t\t\t\tpos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width\n\t\t\t\tincrement = 0,\n\t\t\t\tfinalPos;\n\n\t\t\tif (bBox.width > width) {\n\t\t\t\twhile (finalPos === undefined) {\n\t\t\t\t\ttextLength = node.getSubStringLength(0, pos);\n\n\t\t\t\t\tif (textLength <= width) {\n\t\t\t\t\t\tif (increment === -1) {\n\t\t\t\t\t\t\tfinalPos = pos;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (increment === 1) {\n\t\t\t\t\t\t\tfinalPos = pos - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos += increment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(finalPos, node.getSubStringLength(0, finalPos))\n\t\t},\n\t\t*/\n\n\t\t/** \n\t\t * Returns white for dark colors and black for bright colors\n\t\t */\n\t\tgetContrast: function (color) {\n\t\t\tcolor = Color(color).rgba;\n\t\t\treturn color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';\n\t\t},\n\n\t\t/**\n\t\t * Create a button with preset states\n\t\t * @param {String} text\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Function} callback\n\t\t * @param {Object} normalState\n\t\t * @param {Object} hoverState\n\t\t * @param {Object} pressedState\n\t\t */\n\t\tbutton: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n\t\t\tvar label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n\t\t\t\tcurState = 0,\n\t\t\t\tstateOptions,\n\t\t\t\tstateStyle,\n\t\t\t\tnormalStyle,\n\t\t\t\thoverStyle,\n\t\t\t\tpressedStyle,\n\t\t\t\tdisabledStyle,\n\t\t\t\tverticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n\t\t\t// Normal state - prepare the attributes\n\t\t\tnormalState = merge({\n\t\t\t\t'stroke-width': 1,\n\t\t\t\tstroke: '#CCCCCC',\n\t\t\t\tfill: {\n\t\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\t\tstops: [\n\t\t\t\t\t\t[0, '#FEFEFE'],\n\t\t\t\t\t\t[1, '#F6F6F6']\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tr: 2,\n\t\t\t\tpadding: 5,\n\t\t\t\tstyle: {\n\t\t\t\t\tcolor: 'black'\n\t\t\t\t}\n\t\t\t}, normalState);\n\t\t\tnormalStyle = normalState.style;\n\t\t\tdelete normalState.style;\n\n\t\t\t// Hover state\n\t\t\thoverState = merge(normalState, {\n\t\t\t\tstroke: '#68A',\n\t\t\t\tfill: {\n\t\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\t\tstops: [\n\t\t\t\t\t\t[0, '#FFF'],\n\t\t\t\t\t\t[1, '#ACF']\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}, hoverState);\n\t\t\thoverStyle = hoverState.style;\n\t\t\tdelete hoverState.style;\n\n\t\t\t// Pressed state\n\t\t\tpressedState = merge(normalState, {\n\t\t\t\tstroke: '#68A',\n\t\t\t\tfill: {\n\t\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\t\tstops: [\n\t\t\t\t\t\t[0, '#9BD'],\n\t\t\t\t\t\t[1, '#CDF']\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}, pressedState);\n\t\t\tpressedStyle = pressedState.style;\n\t\t\tdelete pressedState.style;\n\n\t\t\t// Disabled state\n\t\t\tdisabledState = merge(normalState, {\n\t\t\t\tstyle: {\n\t\t\t\t\tcolor: '#CCC'\n\t\t\t\t}\n\t\t\t}, disabledState);\n\t\t\tdisabledStyle = disabledState.style;\n\t\t\tdelete disabledState.style;\n\n\t\t\t// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n\t\t\taddEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {\n\t\t\t\tif (curState !== 3) {\n\t\t\t\t\tlabel.attr(hoverState)\n\t\t\t\t\t\t.css(hoverStyle);\n\t\t\t\t}\n\t\t\t});\n\t\t\taddEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {\n\t\t\t\tif (curState !== 3) {\n\t\t\t\t\tstateOptions = [normalState, hoverState, pressedState][curState];\n\t\t\t\t\tstateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n\t\t\t\t\tlabel.attr(stateOptions)\n\t\t\t\t\t\t.css(stateStyle);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlabel.setState = function (state) {\n\t\t\t\tlabel.state = curState = state;\n\t\t\t\tif (!state) {\n\t\t\t\t\tlabel.attr(normalState)\n\t\t\t\t\t\t.css(normalStyle);\n\t\t\t\t} else if (state === 2) {\n\t\t\t\t\tlabel.attr(pressedState)\n\t\t\t\t\t\t.css(pressedStyle);\n\t\t\t\t} else if (state === 3) {\n\t\t\t\t\tlabel.attr(disabledState)\n\t\t\t\t\t\t.css(disabledStyle);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn label\n\t\t\t\t.on('click', function () {\n\t\t\t\t\tif (curState !== 3) {\n\t\t\t\t\t\tcallback.call(label);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.attr(normalState)\n\t\t\t\t.css(extend({ cursor: 'default' }, normalStyle));\n\t\t},\n\n\t\t/**\n\t\t * Make a straight line crisper by not spilling out to neighbour pixels\n\t\t * @param {Array} points\n\t\t * @param {Number} width\n\t\t */\n\t\tcrispLine: function (points, width) {\n\t\t\t// points format: [M, 0, 0, L, 100, 0]\n\t\t\t// normalize to a crisp line\n\t\t\tif (points[1] === points[4]) {\n\t\t\t\t// Substract due to #1129. Now bottom and left axis gridlines behave the same.\n\t\t\t\tpoints[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);\n\t\t\t}\n\t\t\tif (points[2] === points[5]) {\n\t\t\t\tpoints[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n\t\t\t}\n\t\t\treturn points;\n\t\t},\n\n\n\t\t/**\n\t\t * Draw a path\n\t\t * @param {Array} path An SVG path in array form\n\t\t */\n\t\tpath: function (path) {\n\t\t\tvar attr = {\n\t\t\t\tfill: NONE\n\t\t\t};\n\t\t\tif (isArray(path)) {\n\t\t\t\tattr.d = path;\n\t\t\t} else if (isObject(path)) { // attributes\n\t\t\t\textend(attr, path);\n\t\t\t}\n\t\t\treturn this.createElement('path').attr(attr);\n\t\t},\n\n\t\t/**\n\t\t * Draw and return an SVG circle\n\t\t * @param {Number} x The x position\n\t\t * @param {Number} y The y position\n\t\t * @param {Number} r The radius\n\t\t */\n\t\tcircle: function (x, y, r) {\n\t\t\tvar attr = isObject(x) ?\n\t\t\t\tx :\n\t\t\t\t{\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\tr: r\n\t\t\t\t},\n\t\t\t\twrapper = this.createElement('circle');\n\n\t\t\twrapper.xSetter = function (value) {\n\t\t\t\tthis.element.setAttribute('cx', value);\n\t\t\t};\n\t\t\twrapper.ySetter = function (value) {\n\t\t\t\tthis.element.setAttribute('cy', value);\n\t\t\t};\n\t\t\treturn wrapper.attr(attr);\n\t\t},\n\n\t\t/**\n\t\t * Draw and return an arc\n\t\t * @param {Number} x X position\n\t\t * @param {Number} y Y position\n\t\t * @param {Number} r Radius\n\t\t * @param {Number} innerR Inner radius like used in donut charts\n\t\t * @param {Number} start Starting angle\n\t\t * @param {Number} end Ending angle\n\t\t */\n\t\tarc: function (x, y, r, innerR, start, end) {\n\t\t\tvar arc;\n\n\t\t\tif (isObject(x)) {\n\t\t\t\ty = x.y;\n\t\t\t\tr = x.r;\n\t\t\t\tinnerR = x.innerR;\n\t\t\t\tstart = x.start;\n\t\t\t\tend = x.end;\n\t\t\t\tx = x.x;\n\t\t\t}\n\n\t\t\t// Arcs are defined as symbols for the ability to set\n\t\t\t// attributes in attr and animate\n\t\t\tarc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n\t\t\t\tinnerR: innerR || 0,\n\t\t\t\tstart: start || 0,\n\t\t\t\tend: end || 0\n\t\t\t});\n\t\t\tarc.r = r; // #959\n\t\t\treturn arc;\n\t\t},\n\n\t\t/**\n\t\t * Draw and return a rectangle\n\t\t * @param {Number} x Left position\n\t\t * @param {Number} y Top position\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t * @param {Number} r Border corner radius\n\t\t * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n\t\t */\n\t\trect: function (x, y, width, height, r, strokeWidth) {\n\n\t\t\tr = isObject(x) ? x.r : r;\n\n\t\t\tvar wrapper = this.createElement('rect'),\n\t\t\t\tattribs = isObject(x) ? x : x === UNDEFINED ? {} : {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: mathMax(width, 0),\n\t\t\t\t\theight: mathMax(height, 0)\n\t\t\t\t};\n\n\t\t\tif (strokeWidth !== UNDEFINED) {\n\t\t\t\tattribs.strokeWidth = strokeWidth;\n\t\t\t\tattribs = wrapper.crisp(attribs);\n\t\t\t}\n\n\t\t\tif (r) {\n\t\t\t\tattribs.r = r;\n\t\t\t}\n\n\t\t\twrapper.rSetter = function (value) {\n\t\t\t\tattr(this.element, {\n\t\t\t\t\trx: value,\n\t\t\t\t\try: value\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\treturn wrapper.attr(attribs);\n\t\t},\n\n\t\t/**\n\t\t * Resize the box and re-align all aligned elements\n\t\t * @param {Object} width\n\t\t * @param {Object} height\n\t\t * @param {Boolean} animate\n\t\t *\n\t\t */\n\t\tsetSize: function (width, height, animate) {\n\t\t\tvar renderer = this,\n\t\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\t\ti = alignedObjects.length;\n\n\t\t\trenderer.width = width;\n\t\t\trenderer.height = height;\n\n\t\t\trenderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\n\t\t\twhile (i--) {\n\t\t\t\talignedObjects[i].align();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Create a group\n\t\t * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n\t\t *\t This can be used for styling and scripting.\n\t\t */\n\t\tg: function (name) {\n\t\t\tvar elem = this.createElement('g');\n\t\t\treturn defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n\t\t},\n\n\t\t/**\n\t\t * Display an image\n\t\t * @param {String} src\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\timage: function (src, x, y, width, height) {\n\t\t\tvar attribs = {\n\t\t\t\t\tpreserveAspectRatio: NONE\n\t\t\t\t},\n\t\t\t\telemWrapper;\n\n\t\t\t// optional properties\n\t\t\tif (arguments.length > 1) {\n\t\t\t\textend(attribs, {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t});\n\t\t\t}\n\n\t\t\telemWrapper = this.createElement('image').attr(attribs);\n\n\t\t\t// set the href in the xlink namespace\n\t\t\tif (elemWrapper.element.setAttributeNS) {\n\t\t\t\telemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n\t\t\t\t\t'href', src);\n\t\t\t} else {\n\t\t\t\t// could be exporting in IE\n\t\t\t\t// using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n\t\t\t\telemWrapper.element.setAttribute('hc-svg-href', src);\n\t\t\t}\n\t\t\treturn elemWrapper;\n\t\t},\n\n\t\t/**\n\t\t * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n\t\t *\n\t\t * @param {Object} symbol\n\t\t * @param {Object} x\n\t\t * @param {Object} y\n\t\t * @param {Object} radius\n\t\t * @param {Object} options\n\t\t */\n\t\tsymbol: function (symbol, x, y, width, height, options) {\n\n\t\t\tvar obj,\n\n\t\t\t\t// get the symbol definition function\n\t\t\t\tsymbolFn = this.symbols[symbol],\n\n\t\t\t\t// check if there's a path defined for this symbol\n\t\t\t\tpath = symbolFn && symbolFn(\n\t\t\t\t\tmathRound(x),\n\t\t\t\t\tmathRound(y),\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\toptions\n\t\t\t\t),\n\n\t\t\t\timageElement,\n\t\t\t\timageRegex = /^url\\((.*?)\\)$/,\n\t\t\t\timageSrc,\n\t\t\t\timageSize,\n\t\t\t\tcenterImage;\n\n\t\t\tif (path) {\n\n\t\t\t\tobj = this.path(path);\n\t\t\t\t// expando properties for use in animate and attr\n\t\t\t\textend(obj, {\n\t\t\t\t\tsymbolName: symbol,\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t});\n\t\t\t\tif (options) {\n\t\t\t\t\textend(obj, options);\n\t\t\t\t}\n\n\n\t\t\t// image symbols\n\t\t\t} else if (imageRegex.test(symbol)) {\n\n\t\t\t\t// On image load, set the size and position\n\t\t\t\tcenterImage = function (img, size) {\n\t\t\t\t\tif (img.element) { // it may be destroyed in the meantime (#1390)\n\t\t\t\t\t\timg.attr({\n\t\t\t\t\t\t\twidth: size[0],\n\t\t\t\t\t\t\theight: size[1]\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!img.alignByTranslate) { // #185\n\t\t\t\t\t\t\timg.translate(\n\t\t\t\t\t\t\t\tmathRound((width - size[0]) / 2), // #1378\n\t\t\t\t\t\t\t\tmathRound((height - size[1]) / 2)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\timageSrc = symbol.match(imageRegex)[1];\n\t\t\t\timageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);\n\n\t\t\t\t// Ireate the image synchronously, add attribs async\n\t\t\t\tobj = this.image(imageSrc)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tx: x,\n\t\t\t\t\t\ty: y\n\t\t\t\t\t});\n\t\t\t\tobj.isImg = true;\n\n\t\t\t\tif (imageSize) {\n\t\t\t\t\tcenterImage(obj, imageSize);\n\t\t\t\t} else {\n\t\t\t\t\t// Initialize image to be 0 size so export will still function if there's no cached sizes.\n\t\t\t\t\tobj.attr({ width: 0, height: 0 });\n\n\t\t\t\t\t// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n\t\t\t\t\t// the created element must be assigned to a variable in order to load (#292).\n\t\t\t\t\timageElement = createElement('img', {\n\t\t\t\t\t\tonload: function () {\n\t\t\t\t\t\t\tcenterImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsrc: imageSrc\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t/**\n\t\t * An extendable collection of functions for defining symbol paths.\n\t\t */\n\t\tsymbols: {\n\t\t\t'circle': function (x, y, w, h) {\n\t\t\t\tvar cpw = 0.166 * w;\n\t\t\t\treturn [\n\t\t\t\t\tM, x + w / 2, y,\n\t\t\t\t\t'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n\t\t\t\t\t'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n\t\t\t\t\t'Z'\n\t\t\t\t];\n\t\t\t},\n\n\t\t\t'square': function (x, y, w, h) {\n\t\t\t\treturn [\n\t\t\t\t\tM, x, y,\n\t\t\t\t\tL, x + w, y,\n\t\t\t\t\tx + w, y + h,\n\t\t\t\t\tx, y + h,\n\t\t\t\t\t'Z'\n\t\t\t\t];\n\t\t\t},\n\n\t\t\t'triangle': function (x, y, w, h) {\n\t\t\t\treturn [\n\t\t\t\t\tM, x + w / 2, y,\n\t\t\t\t\tL, x + w, y + h,\n\t\t\t\t\tx, y + h,\n\t\t\t\t\t'Z'\n\t\t\t\t];\n\t\t\t},\n\n\t\t\t'triangle-down': function (x, y, w, h) {\n\t\t\t\treturn [\n\t\t\t\t\tM, x, y,\n\t\t\t\t\tL, x + w, y,\n\t\t\t\t\tx + w / 2, y + h,\n\t\t\t\t\t'Z'\n\t\t\t\t];\n\t\t\t},\n\t\t\t'diamond': function (x, y, w, h) {\n\t\t\t\treturn [\n\t\t\t\t\tM, x + w / 2, y,\n\t\t\t\t\tL, x + w, y + h / 2,\n\t\t\t\t\tx + w / 2, y + h,\n\t\t\t\t\tx, y + h / 2,\n\t\t\t\t\t'Z'\n\t\t\t\t];\n\t\t\t},\n\t\t\t'arc': function (x, y, w, h, options) {\n\t\t\t\tvar start = options.start,\n\t\t\t\t\tradius = options.r || w || h,\n\t\t\t\t\tend = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n\t\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\t\topen = options.open,\n\t\t\t\t\tcosStart = mathCos(start),\n\t\t\t\t\tsinStart = mathSin(start),\n\t\t\t\t\tcosEnd = mathCos(end),\n\t\t\t\t\tsinEnd = mathSin(end),\n\t\t\t\t\tlongArc = options.end - start < mathPI ? 0 : 1;\n\n\t\t\t\treturn [\n\t\t\t\t\tM,\n\t\t\t\t\tx + radius * cosStart,\n\t\t\t\t\ty + radius * sinStart,\n\t\t\t\t\t'A', // arcTo\n\t\t\t\t\tradius, // x radius\n\t\t\t\t\tradius, // y radius\n\t\t\t\t\t0, // slanting\n\t\t\t\t\tlongArc, // long or short arc\n\t\t\t\t\t1, // clockwise\n\t\t\t\t\tx + radius * cosEnd,\n\t\t\t\t\ty + radius * sinEnd,\n\t\t\t\t\topen ? M : L,\n\t\t\t\t\tx + innerRadius * cosEnd,\n\t\t\t\t\ty + innerRadius * sinEnd,\n\t\t\t\t\t'A', // arcTo\n\t\t\t\t\tinnerRadius, // x radius\n\t\t\t\t\tinnerRadius, // y radius\n\t\t\t\t\t0, // slanting\n\t\t\t\t\tlongArc, // long or short arc\n\t\t\t\t\t0, // clockwise\n\t\t\t\t\tx + innerRadius * cosStart,\n\t\t\t\t\ty + innerRadius * sinStart,\n\n\t\t\t\t\topen ? '' : 'Z' // close\n\t\t\t\t];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Callout shape used for default tooltips, also used for rounded rectangles in VML\n\t\t\t */\n\t\t\tcallout: function (x, y, w, h, options) {\n\t\t\t\tvar arrowLength = 6,\n\t\t\t\t\thalfDistance = 6,\n\t\t\t\t\tr = mathMin((options && options.r) || 0, w, h),\n\t\t\t\t\tsafeDistance = r + halfDistance,\n\t\t\t\t\tanchorX = options && options.anchorX,\n\t\t\t\t\tanchorY = options && options.anchorY,\n\t\t\t\t\tpath,\n\t\t\t\t\tnormalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;\n\n\t\t\t\tx += normalizer;\n\t\t\t\ty += normalizer;\n\t\t\t\tpath = [\n\t\t\t\t\t'M', x + r, y, \n\t\t\t\t\t'L', x + w - r, y, // top side\n\t\t\t\t\t'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n\t\t\t\t\t'L', x + w, y + h - r, // right side\n\t\t\t\t\t'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n\t\t\t\t\t'L', x + r, y + h, // bottom side\n\t\t\t\t\t'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n\t\t\t\t\t'L', x, y + r, // left side\n\t\t\t\t\t'C', x, y, x, y, x + r, y // top-right corner\n\t\t\t\t];\n\t\t\t\t\n\t\t\t\tif (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n\t\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t\t'L', x + w, anchorY - halfDistance, \n\t\t\t\t\t\tx + w + arrowLength, anchorY,\n\t\t\t\t\t\tx + w, anchorY + halfDistance,\n\t\t\t\t\t\tx + w, y + h - r\n\t\t\t\t\t);\n\t\t\t\t} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n\t\t\t\t\tpath.splice(33, 3, \n\t\t\t\t\t\t'L', x, anchorY + halfDistance, \n\t\t\t\t\t\tx - arrowLength, anchorY,\n\t\t\t\t\t\tx, anchorY - halfDistance,\n\t\t\t\t\t\tx, y + r\n\t\t\t\t\t);\n\t\t\t\t} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n\t\t\t\t\tpath.splice(23, 3,\n\t\t\t\t\t\t'L', anchorX + halfDistance, y + h,\n\t\t\t\t\t\tanchorX, y + h + arrowLength,\n\t\t\t\t\t\tanchorX - halfDistance, y + h,\n\t\t\t\t\t\tx + r, y + h\n\t\t\t\t\t);\n\t\t\t\t} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n\t\t\t\t\tpath.splice(3, 3,\n\t\t\t\t\t\t'L', anchorX - halfDistance, y,\n\t\t\t\t\t\tanchorX, y - arrowLength,\n\t\t\t\t\t\tanchorX + halfDistance, y,\n\t\t\t\t\t\tw - r, y\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn path;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Define a clipping rectangle\n\t\t * @param {String} id\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\tclipRect: function (x, y, width, height) {\n\t\t\tvar wrapper,\n\t\t\t\tid = PREFIX + idCounter++,\n\n\t\t\t\tclipPath = this.createElement('clipPath').attr({\n\t\t\t\t\tid: id\n\t\t\t\t}).add(this.defs);\n\n\t\t\twrapper = this.rect(x, y, width, height, 0).add(clipPath);\n\t\t\twrapper.id = id;\n\t\t\twrapper.clipPath = clipPath;\n\t\t\twrapper.count = 0;\n\n\t\t\treturn wrapper;\n\t\t},\n\n\n\t\t\n\n\n\t\t/**\n\t\t * Add text to the SVG object\n\t\t * @param {String} str\n\t\t * @param {Number} x Left position\n\t\t * @param {Number} y Top position\n\t\t * @param {Boolean} useHTML Use HTML to render the text\n\t\t */\n\t\ttext: function (str, x, y, useHTML) {\n\n\t\t\t// declare variables\n\t\t\tvar renderer = this,\n\t\t\t\tfakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n\t\t\t\twrapper,\n\t\t\t\tattr = {};\n\n\t\t\tif (useHTML && !renderer.forExport) {\n\t\t\t\treturn renderer.html(str, x, y);\n\t\t\t}\n\n\t\t\tattr.x = Math.round(x || 0); // X is always needed for line-wrap logic\n\t\t\tif (y) {\n\t\t\t\tattr.y = Math.round(y);\n\t\t\t}\n\t\t\tif (str || str === 0) {\n\t\t\t\tattr.text = str;\n\t\t\t}\n\n\t\t\twrapper = renderer.createElement('text')\n\t\t\t\t.attr(attr);\n\n\t\t\t// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n\t\t\tif (fakeSVG) {\n\t\t\t\twrapper.css({\n\t\t\t\t\tposition: ABSOLUTE\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!useHTML) {\n\t\t\t\twrapper.xSetter = function (value, key, element) {\n\t\t\t\t\tvar tspans = element.getElementsByTagName('tspan'),\n\t\t\t\t\t\ttspan,\n\t\t\t\t\t\tparentVal = element.getAttribute(key),\n\t\t\t\t\t\ti;\n\t\t\t\t\tfor (i = 0; i < tspans.length; i++) {\n\t\t\t\t\t\ttspan = tspans[i];\n\t\t\t\t\t\t// If the x values are equal, the tspan represents a linebreak\n\t\t\t\t\t\tif (tspan.getAttribute(key) === parentVal) {\n\t\t\t\t\t\t\ttspan.setAttribute(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telement.setAttribute(key, value);\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * Utility to return the baseline offset and total line height from the font size\n\t\t */\n\t\tfontMetrics: function (fontSize, elem) {\n\t\t\tfontSize = fontSize || this.style.fontSize;\n\t\t\tif (elem && win.getComputedStyle) {\n\t\t\t\telem = elem.element || elem; // SVGElement\n\t\t\t\tfontSize = win.getComputedStyle(elem, \"\").fontSize;\n\t\t\t}\n\t\t\tfontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n\t\t\t// Empirical values found by comparing font size and bounding box height.\n\t\t\t// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n\t\t\tvar lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),\n\t\t\t\tbaseline = mathRound(lineHeight * 0.8);\n\n\t\t\treturn {\n\t\t\t\th: lineHeight,\n\t\t\t\tb: baseline,\n\t\t\t\tf: fontSize\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Correct X and Y positioning of a label for rotation (#1764)\n\t\t */\n\t\trotCorr: function (baseline, rotation, alterY) {\n\t\t\tvar y = baseline;\n\t\t\tif (rotation && alterY) {\n\t\t\t\ty = mathMax(y * mathCos(rotation * deg2rad), 4);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tx: (-baseline / 3) * mathSin(rotation * deg2rad),\n\t\t\t\ty: y\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Add a label, a text item that can hold a colored or gradient background\n\t\t * as well as a border and shadow.\n\t\t * @param {string} str\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {String} shape\n\t\t * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n\t\t *\tcoordinates it should be pinned to\n\t\t * @param {Number} anchorY\n\t\t * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n\t\t *\tlike renderer.text, or to the upper border of the rectangle.\n\t\t * @param {String} className Class name for the group\n\t\t */\n\t\tlabel: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n\t\t\tvar renderer = this,\n\t\t\t\twrapper = renderer.g(className),\n\t\t\t\ttext = renderer.text('', 0, 0, useHTML)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tzIndex: 1\n\t\t\t\t\t}),\n\t\t\t\t\t//.add(wrapper),\n\t\t\t\tbox,\n\t\t\t\tbBox,\n\t\t\t\talignFactor = 0,\n\t\t\t\tpadding = 3,\n\t\t\t\tpaddingLeft = 0,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\twrapperX,\n\t\t\t\twrapperY,\n\t\t\t\tcrispAdjust = 0,\n\t\t\t\tdeferredAttr = {},\n\t\t\t\tbaselineOffset,\n\t\t\t\tneedsBox;\n\n\t\t\t/**\n\t\t\t * This function runs after the label is added to the DOM (when the bounding box is\n\t\t\t * available), and after the text of the label is updated to detect the new bounding\n\t\t\t * box and reflect it in the border box.\n\t\t\t */\n\t\t\tfunction updateBoxSize() {\n\t\t\t\tvar boxX,\n\t\t\t\t\tboxY,\n\t\t\t\t\tstyle = text.element.style;\n\n\t\t\t\tbBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && \n\t\t\t\t\ttext.getBBox(); //#3295 && 3514 box failure when string equals 0\n\t\t\t\twrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n\t\t\t\twrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n\t\t\t\t// update the label-scoped y offset\n\t\t\t\tbaselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\t\t\t\t\n\t\t\t\tif (needsBox) {\n\n\t\t\t\t\t// create the border box if it is not already present\n\t\t\t\t\tif (!box) {\n\t\t\t\t\t\tboxX = mathRound(-alignFactor * padding);\n\t\t\t\t\t\tboxY = baseline ? -baselineOffset : 0;\n\n\t\t\t\t\t\twrapper.box = box = shape ?\n\t\t\t\t\t\t\trenderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :\n\t\t\t\t\t\t\trenderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n\t\t\t\t\t\tbox.attr('fill', NONE).add(wrapper);\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply the box attributes\n\t\t\t\t\tif (!box.isImg) { // #1630\n\t\t\t\t\t\tbox.attr(extend({\n\t\t\t\t\t\t\twidth: mathRound(wrapper.width),\n\t\t\t\t\t\t\theight: mathRound(wrapper.height)\n\t\t\t\t\t\t}, deferredAttr));\n\t\t\t\t\t}\n\t\t\t\t\tdeferredAttr = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * This function runs after setting text or padding, but only if padding is changed\n\t\t\t */\n\t\t\tfunction updateTextPadding() {\n\t\t\t\tvar styles = wrapper.styles,\n\t\t\t\t\ttextAlign = styles && styles.textAlign,\n\t\t\t\t\tx = paddingLeft + padding * (1 - alignFactor),\n\t\t\t\t\ty;\n\n\t\t\t\t// determin y based on the baseline\n\t\t\t\ty = baseline ? 0 : baselineOffset;\n\n\t\t\t\t// compensate for alignment\n\t\t\t\tif (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n\t\t\t\t\tx += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n\t\t\t\t}\n\n\t\t\t\t// update if anything changed\n\t\t\t\tif (x !== text.x || y !== text.y) {\n\t\t\t\t\ttext.attr('x', x);\n\t\t\t\t\tif (y !== UNDEFINED) {\n\t\t\t\t\t\t// As a workaround for #3649, use translation instead of y attribute. #3649\n\t\t\t\t\t\t// is a rendering bug in WebKit for Retina (Mac, iOS, PhantomJS) that \n\t\t\t\t\t\t// results in duplicated text when an y attribute is used in combination \n\t\t\t\t\t\t// with a CSS text-style.\n\t\t\t\t\t\ttext.attr(text.element.nodeName === 'SPAN' ? 'y' : 'translateY', y);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// record current values\n\t\t\t\ttext.x = x;\n\t\t\t\ttext.y = y;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Set a box attribute, or defer it if the box is not yet created\n\t\t\t * @param {Object} key\n\t\t\t * @param {Object} value\n\t\t\t */\n\t\t\tfunction boxAttr(key, value) {\n\t\t\t\tif (box) {\n\t\t\t\t\tbox.attr(key, value);\n\t\t\t\t} else {\n\t\t\t\t\tdeferredAttr[key] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * After the text element is added, get the desired size of the border box\n\t\t\t * and add it before the text in the DOM.\n\t\t\t */\n\t\t\twrapper.onAdd = function () {\n\t\t\t\ttext.add(wrapper);\n\t\t\t\twrapper.attr({\n\t\t\t\t\ttext: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t});\n\n\t\t\t\tif (box && defined(anchorX)) {\n\t\t\t\t\twrapper.attr({\n\t\t\t\t\t\tanchorX: anchorX,\n\t\t\t\t\t\tanchorY: anchorY\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * Add specific attribute setters.\n\t\t\t */\n\n\t\t\t// only change local variables\n\t\t\twrapper.widthSetter = function (value) {\n\t\t\t\twidth = value;\n\t\t\t};\n\t\t\twrapper.heightSetter = function (value) {\n\t\t\t\theight = value;\n\t\t\t};\n\t\t\twrapper.paddingSetter =  function (value) {\n\t\t\t\tif (defined(value) && value !== padding) {\n\t\t\t\t\tpadding = wrapper.padding = value;\n\t\t\t\t\tupdateTextPadding();\n\t\t\t\t}\n\t\t\t};\n\t\t\twrapper.paddingLeftSetter =  function (value) {\n\t\t\t\tif (defined(value) && value !== paddingLeft) {\n\t\t\t\t\tpaddingLeft = value;\n\t\t\t\t\tupdateTextPadding();\n\t\t\t\t}\n\t\t\t};\n\n\n\t\t\t// change local variable and prevent setting attribute on the group\n\t\t\twrapper.alignSetter = function (value) {\n\t\t\t\talignFactor = { left: 0, center: 0.5, right: 1 }[value];\n\t\t\t};\n\n\t\t\t// apply these to the box and the text alike\n\t\t\twrapper.textSetter = function (value) {\n\t\t\t\tif (value !== UNDEFINED) {\n\t\t\t\t\ttext.textSetter(value);\n\t\t\t\t}\n\t\t\t\tupdateBoxSize();\n\t\t\t\tupdateTextPadding();\n\t\t\t};\n\n\t\t\t// apply these to the box but not to the text\n\t\t\twrapper['stroke-widthSetter'] = function (value, key) {\n\t\t\t\tif (value) {\n\t\t\t\t\tneedsBox = true;\n\t\t\t\t}\n\t\t\t\tcrispAdjust = value % 2 / 2;\n\t\t\t\tboxAttr(key, value);\n\t\t\t};\n\t\t\twrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n\t\t\t\tif (key === 'fill' && value) {\n\t\t\t\t\tneedsBox = true;\n\t\t\t\t}\n\t\t\t\tboxAttr(key, value);\n\t\t\t};\n\t\t\twrapper.anchorXSetter = function (value, key) {\n\t\t\t\tanchorX = value;\n\t\t\t\tboxAttr(key, value + crispAdjust - wrapperX);\n\t\t\t};\n\t\t\twrapper.anchorYSetter = function (value, key) {\n\t\t\t\tanchorY = value;\n\t\t\t\tboxAttr(key, value - wrapperY);\n\t\t\t};\n\n\t\t\t// rename attributes\n\t\t\twrapper.xSetter = function (value) {\n\t\t\t\twrapper.x = value; // for animation getter\n\t\t\t\tif (alignFactor) {\n\t\t\t\t\tvalue -= alignFactor * ((width || bBox.width) + padding);\n\t\t\t\t}\n\t\t\t\twrapperX = mathRound(value);\n\t\t\t\twrapper.attr('translateX', wrapperX);\n\t\t\t};\n\t\t\twrapper.ySetter = function (value) {\n\t\t\t\twrapperY = wrapper.y = mathRound(value);\n\t\t\t\twrapper.attr('translateY', wrapperY);\n\t\t\t};\n\n\t\t\t// Redirect certain methods to either the box or the text\n\t\t\tvar baseCss = wrapper.css;\n\t\t\treturn extend(wrapper, {\n\t\t\t\t/**\n\t\t\t\t * Pick up some properties and apply them to the text instead of the wrapper\n\t\t\t\t */\n\t\t\t\tcss: function (styles) {\n\t\t\t\t\tif (styles) {\n\t\t\t\t\t\tvar textStyles = {};\n\t\t\t\t\t\tstyles = merge(styles); // create a copy to avoid altering the original object (#537)\n\t\t\t\t\t\teach(wrapper.textProps, function (prop) {\n\t\t\t\t\t\t\tif (styles[prop] !== UNDEFINED) {\n\t\t\t\t\t\t\t\ttextStyles[prop] = styles[prop];\n\t\t\t\t\t\t\t\tdelete styles[prop];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttext.css(textStyles);\n\t\t\t\t\t}\n\t\t\t\t\treturn baseCss.call(wrapper, styles);\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Return the bounding box of the box, not the group\n\t\t\t\t */\n\t\t\t\tgetBBox: function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: bBox.width + 2 * padding,\n\t\t\t\t\t\theight: bBox.height + 2 * padding,\n\t\t\t\t\t\tx: bBox.x - padding,\n\t\t\t\t\t\ty: bBox.y - padding\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Apply the shadow to the box\n\t\t\t\t */\n\t\t\t\tshadow: function (b) {\n\t\t\t\t\tif (box) {\n\t\t\t\t\t\tbox.shadow(b);\n\t\t\t\t\t}\n\t\t\t\t\treturn wrapper;\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Destroy and release memory.\n\t\t\t\t */\n\t\t\t\tdestroy: function () {\n\n\t\t\t\t\t// Added by button implementation\n\t\t\t\t\tremoveEvent(wrapper.element, 'mouseenter');\n\t\t\t\t\tremoveEvent(wrapper.element, 'mouseleave');\n\n\t\t\t\t\tif (text) {\n\t\t\t\t\t\ttext = text.destroy();\n\t\t\t\t\t}\n\t\t\t\t\tif (box) {\n\t\t\t\t\t\tbox = box.destroy();\n\t\t\t\t\t}\n\t\t\t\t\t// Call base implementation to destroy the rest\n\t\t\t\t\tSVGElement.prototype.destroy.call(wrapper);\n\n\t\t\t\t\t// Release local pointers (#1298)\n\t\t\t\t\twrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}; // end SVGRenderer\n\n\n\t// general renderer\n\tRenderer = SVGRenderer;\n\t// extend SvgElement for useHTML option\n\textend(SVGElement.prototype, {\n\t\t/**\n\t\t * Apply CSS to HTML elements. This is used in text within SVG rendering and\n\t\t * by the VML renderer\n\t\t */\n\t\thtmlCss: function (styles) {\n\t\t\tvar wrapper = this,\n\t\t\t\telement = wrapper.element,\n\t\t\t\ttextWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n\t\t\tif (textWidth) {\n\t\t\t\tdelete styles.width;\n\t\t\t\twrapper.textWidth = textWidth;\n\t\t\t\twrapper.updateTransform();\n\t\t\t}\n\t\t\tif (styles && styles.textOverflow === 'ellipsis') {\n\t\t\t\tstyles.whiteSpace = 'nowrap';\n\t\t\t\tstyles.overflow = 'hidden';\n\t\t\t}\n\t\t\twrapper.styles = extend(wrapper.styles, styles);\n\t\t\tcss(wrapper.element, styles);\n\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * VML and useHTML method for calculating the bounding box based on offsets\n\t\t * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n\t\t * use the cached value\n\t\t *\n\t\t * @return {Object} A hash containing values for x, y, width and height\n\t\t */\n\n\t\thtmlGetBBox: function () {\n\t\t\tvar wrapper = this,\n\t\t\t\telement = wrapper.element;\n\n\t\t\t// faking getBBox in exported SVG in legacy IE\n\t\t\t// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n\t\t\tif (element.nodeName === 'text') {\n\t\t\t\telement.style.position = ABSOLUTE;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: element.offsetLeft,\n\t\t\t\ty: element.offsetTop,\n\t\t\t\twidth: element.offsetWidth,\n\t\t\t\theight: element.offsetHeight\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * VML override private method to update elements based on internal\n\t\t * properties based on SVG transform\n\t\t */\n\t\thtmlUpdateTransform: function () {\n\t\t\t// aligning non added elements is expensive\n\t\t\tif (!this.added) {\n\t\t\t\tthis.alignOnAdd = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar wrapper = this,\n\t\t\t\trenderer = wrapper.renderer,\n\t\t\t\telem = wrapper.element,\n\t\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\t\tx = wrapper.x || 0,\n\t\t\t\ty = wrapper.y || 0,\n\t\t\t\talign = wrapper.textAlign || 'left',\n\t\t\t\talignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n\t\t\t\tshadows = wrapper.shadows,\n\t\t\t\tstyles = wrapper.styles;\n\n\t\t\t// apply translate\n\t\t\tcss(elem, {\n\t\t\t\tmarginLeft: translateX,\n\t\t\t\tmarginTop: translateY\n\t\t\t});\n\t\t\tif (shadows) { // used in labels/tooltip\n\t\t\t\teach(shadows, function (shadow) {\n\t\t\t\t\tcss(shadow, {\n\t\t\t\t\t\tmarginLeft: translateX + 1,\n\t\t\t\t\t\tmarginTop: translateY + 1\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// apply inversion\n\t\t\tif (wrapper.inverted) { // wrapper is a group\n\t\t\t\teach(elem.childNodes, function (child) {\n\t\t\t\t\trenderer.invertChild(child, elem);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (elem.tagName === 'SPAN') {\n\n\t\t\t\tvar width,\n\t\t\t\t\trotation = wrapper.rotation,\n\t\t\t\t\tbaseline,\n\t\t\t\t\ttextWidth = pInt(wrapper.textWidth),\n\t\t\t\t\tcurrentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');\n\n\t\t\t\tif (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n\t\t\t\t\tbaseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n\t\t\t\t\t// Renderer specific handling of span rotation\n\t\t\t\t\tif (defined(rotation)) {\n\t\t\t\t\t\twrapper.setSpanRotation(rotation, alignCorrection, baseline);\n\t\t\t\t\t}\n\n\t\t\t\t\twidth = pick(wrapper.elemWidth, elem.offsetWidth);\n\n\t\t\t\t\t// Update textWidth\n\t\t\t\t\tif (width > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n\t\t\t\t\t\tcss(elem, {\n\t\t\t\t\t\t\twidth: textWidth + PX,\n\t\t\t\t\t\t\tdisplay: 'block',\n\t\t\t\t\t\t\twhiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331\n\t\t\t\t\t\t});\n\t\t\t\t\t\twidth = textWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\twrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);\n\t\t\t\t}\n\n\t\t\t\t// apply position with correction\n\t\t\t\tcss(elem, {\n\t\t\t\t\tleft: (x + (wrapper.xCorr || 0)) + PX,\n\t\t\t\t\ttop: (y + (wrapper.yCorr || 0)) + PX\n\t\t\t\t});\n\n\t\t\t\t// force reflow in webkit to apply the left and top on useHTML element (#1249)\n\t\t\t\tif (isWebKit) {\n\t\t\t\t\tbaseline = elem.offsetHeight; // assigned to baseline for JSLint purpose\n\t\t\t\t}\n\n\t\t\t\t// record current text transform\n\t\t\t\twrapper.cTT = currentTextTransform;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the rotation of an individual HTML span\n\t\t */\n\t\tsetSpanRotation: function (rotation, alignCorrection, baseline) {\n\t\t\tvar rotationStyle = {},\n\t\t\t\tcssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n\n\t\t\trotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n\t\t\trotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n\t\t\tcss(this.element, rotationStyle);\n\t\t},\n\n\t\t/**\n\t\t * Get the correction in X and Y positioning as the element is rotated.\n\t\t */\n\t\tgetSpanCorrection: function (width, baseline, alignCorrection) {\n\t\t\tthis.xCorr = -width * alignCorrection;\n\t\t\tthis.yCorr = -baseline;\n\t\t}\n\t});\n\n\t// Extend SvgRenderer for useHTML option.\n\textend(SVGRenderer.prototype, {\n\t\t/**\n\t\t * Create HTML text node. This is used by the VML renderer as well as the SVG\n\t\t * renderer through the useHTML option.\n\t\t *\n\t\t * @param {String} str\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t */\n\t\thtml: function (str, x, y) {\n\t\t\tvar wrapper = this.createElement('span'),\n\t\t\t\telement = wrapper.element,\n\t\t\t\trenderer = wrapper.renderer;\n\n\t\t\t// Text setter\n\t\t\twrapper.textSetter = function (value) {\n\t\t\t\tif (value !== element.innerHTML) {\n\t\t\t\t\tdelete this.bBox;\n\t\t\t\t}\n\t\t\t\telement.innerHTML = this.textStr = value;\n\t\t\t};\n\n\t\t\t// Various setters which rely on update transform\n\t\t\twrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n\t\t\t\tif (key === 'align') {\n\t\t\t\t\tkey = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n\t\t\t\t}\n\t\t\t\twrapper[key] = value;\n\t\t\t\twrapper.htmlUpdateTransform();\n\t\t\t};\n\n\t\t\t// Set the default attributes\n\t\t\twrapper.attr({\n\t\t\t\t\ttext: str,\n\t\t\t\t\tx: mathRound(x),\n\t\t\t\t\ty: mathRound(y)\n\t\t\t\t})\n\t\t\t\t.css({\n\t\t\t\t\tposition: ABSOLUTE,\n\t\t\t\t\tfontFamily: this.style.fontFamily,\n\t\t\t\t\tfontSize: this.style.fontSize\n\t\t\t\t});\n\n\t\t\t// Keep the whiteSpace style outside the wrapper.styles collection\n\t\t\telement.style.whiteSpace = 'nowrap';\n\n\t\t\t// Use the HTML specific .css method\n\t\t\twrapper.css = wrapper.htmlCss;\n\n\t\t\t// This is specific for HTML within SVG\n\t\t\tif (renderer.isSVG) {\n\t\t\t\twrapper.add = function (svgGroupWrapper) {\n\n\t\t\t\t\tvar htmlGroup,\n\t\t\t\t\t\tcontainer = renderer.box.parentNode,\n\t\t\t\t\t\tparentGroup,\n\t\t\t\t\t\tparents = [];\n\n\t\t\t\t\tthis.parentGroup = svgGroupWrapper;\n\n\t\t\t\t\t// Create a mock group to hold the HTML elements\n\t\t\t\t\tif (svgGroupWrapper) {\n\t\t\t\t\t\thtmlGroup = svgGroupWrapper.div;\n\t\t\t\t\t\tif (!htmlGroup) {\n\n\t\t\t\t\t\t\t// Read the parent chain into an array and read from top down\n\t\t\t\t\t\t\tparentGroup = svgGroupWrapper;\n\t\t\t\t\t\t\twhile (parentGroup) {\n\n\t\t\t\t\t\t\t\tparents.push(parentGroup);\n\n\t\t\t\t\t\t\t\t// Move up to the next parent group\n\t\t\t\t\t\t\t\tparentGroup = parentGroup.parentGroup;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Ensure dynamically updating position when any parent is translated\n\t\t\t\t\t\t\teach(parents.reverse(), function (parentGroup) {\n\t\t\t\t\t\t\t\tvar htmlGroupStyle;\n\n\t\t\t\t\t\t\t\t// Create a HTML div and append it to the parent div to emulate\n\t\t\t\t\t\t\t\t// the SVG group structure\n\t\t\t\t\t\t\t\thtmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {\n\t\t\t\t\t\t\t\t\tclassName: attr(parentGroup.element, 'class')\n\t\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\t\tposition: ABSOLUTE,\n\t\t\t\t\t\t\t\t\tleft: (parentGroup.translateX || 0) + PX,\n\t\t\t\t\t\t\t\t\ttop: (parentGroup.translateY || 0) + PX\n\t\t\t\t\t\t\t\t}, htmlGroup || container); // the top group is appended to container\n\n\t\t\t\t\t\t\t\t// Shortcut\n\t\t\t\t\t\t\t\thtmlGroupStyle = htmlGroup.style;\n\n\t\t\t\t\t\t\t\t// Set listeners to update the HTML div's position whenever the SVG group\n\t\t\t\t\t\t\t\t// position is changed\n\t\t\t\t\t\t\t\textend(parentGroup, {\n\t\t\t\t\t\t\t\t\ttranslateXSetter: function (value, key) {\n\t\t\t\t\t\t\t\t\t\thtmlGroupStyle.left = value + PX;\n\t\t\t\t\t\t\t\t\t\tparentGroup[key] = value;\n\t\t\t\t\t\t\t\t\t\tparentGroup.doTransform = true;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttranslateYSetter: function (value, key) {\n\t\t\t\t\t\t\t\t\t\thtmlGroupStyle.top = value + PX;\n\t\t\t\t\t\t\t\t\t\tparentGroup[key] = value;\n\t\t\t\t\t\t\t\t\t\tparentGroup.doTransform = true;\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tvisibilitySetter: function (value, key) {\n\t\t\t\t\t\t\t\t\t\thtmlGroupStyle[key] = value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thtmlGroup = container;\n\t\t\t\t\t}\n\n\t\t\t\t\thtmlGroup.appendChild(element);\n\n\t\t\t\t\t// Shared with VML:\n\t\t\t\t\twrapper.added = true;\n\t\t\t\t\tif (wrapper.alignOnAdd) {\n\t\t\t\t\t\twrapper.htmlUpdateTransform();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn wrapper;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn wrapper;\n\t\t}\n\t});\n\n\t/* ****************************************************************************\n\t *                                                                            *\n\t * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n\t *                                                                            *\n\t * For applications and websites that don't need IE support, like platform    *\n\t * targeted mobile apps and web apps, this code can be removed.               *\n\t *                                                                            *\n\t *****************************************************************************/\n\n\t/**\n\t * @constructor\n\t */\n\tvar VMLRenderer, VMLElement;\n\tif (!hasSVG && !useCanVG) {\n\n\t/**\n\t * The VML element wrapper.\n\t */\n\tVMLElement = {\n\n\t\t/**\n\t\t * Initialize a new VML element wrapper. It builds the markup as a string\n\t\t * to minimize DOM traffic.\n\t\t * @param {Object} renderer\n\t\t * @param {Object} nodeName\n\t\t */\n\t\tinit: function (renderer, nodeName) {\n\t\t\tvar wrapper = this,\n\t\t\t\tmarkup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n\t\t\t\tstyle = ['position: ', ABSOLUTE, ';'],\n\t\t\t\tisDiv = nodeName === DIV;\n\n\t\t\t// divs and shapes need size\n\t\t\tif (nodeName === 'shape' || isDiv) {\n\t\t\t\tstyle.push('left:0;top:0;width:1px;height:1px;');\n\t\t\t}\n\t\t\tstyle.push('visibility: ', isDiv ? HIDDEN : VISIBLE);\n\n\t\t\tmarkup.push(' style=\"', style.join(''), '\"/>');\n\n\t\t\t// create element with default attributes and style\n\t\t\tif (nodeName) {\n\t\t\t\tmarkup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n\t\t\t\t\tmarkup.join('')\n\t\t\t\t\t: renderer.prepVML(markup);\n\t\t\t\twrapper.element = createElement(markup);\n\t\t\t}\n\n\t\t\twrapper.renderer = renderer;\n\t\t},\n\n\t\t/**\n\t\t * Add the node to the given parent\n\t\t * @param {Object} parent\n\t\t */\n\t\tadd: function (parent) {\n\t\t\tvar wrapper = this,\n\t\t\t\trenderer = wrapper.renderer,\n\t\t\t\telement = wrapper.element,\n\t\t\t\tbox = renderer.box,\n\t\t\t\tinverted = parent && parent.inverted,\n\n\t\t\t\t// get the parent node\n\t\t\t\tparentNode = parent ?\n\t\t\t\t\tparent.element || parent :\n\t\t\t\t\tbox;\n\n\n\t\t\t// if the parent group is inverted, apply inversion on all children\n\t\t\tif (inverted) { // only on groups\n\t\t\t\trenderer.invertChild(element, parentNode);\n\t\t\t}\n\n\t\t\t// append it\n\t\t\tparentNode.appendChild(element);\n\n\t\t\t// align text after adding to be able to read offset\n\t\t\twrapper.added = true;\n\t\t\tif (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n\t\t\t\twrapper.updateTransform();\n\t\t\t}\n\n\t\t\t// fire an event for internal hooks\n\t\t\tif (wrapper.onAdd) {\n\t\t\t\twrapper.onAdd();\n\t\t\t}\n\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * VML always uses htmlUpdateTransform\n\t\t */\n\t\tupdateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n\t\t/**\n\t\t * Set the rotation of a span with oldIE's filter\n\t\t */\n\t\tsetSpanRotation: function () {\n\t\t\t// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n\t\t\t// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n\t\t\t// has support for CSS3 transform. The getBBox method also needs to be updated\n\t\t\t// to compensate for the rotation, like it currently does for SVG.\n\t\t\t// Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n\t\t\tvar rotation = this.rotation,\n\t\t\t\tcostheta = mathCos(rotation * deg2rad),\n\t\t\t\tsintheta = mathSin(rotation * deg2rad);\n\t\t\t\t\t\t\n\t\t\tcss(this.element, {\n\t\t\t\tfilter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n\t\t\t\t\t', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n\t\t\t\t\t', sizingMethod=\\'auto expand\\')'].join('') : NONE\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Get the positioning correction for the span after rotating. \n\t\t */\n\t\tgetSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n\t\t\tvar costheta = rotation ? mathCos(rotation * deg2rad) : 1,\n\t\t\t\tsintheta = rotation ? mathSin(rotation * deg2rad) : 0,\n\t\t\t\theight = pick(this.elemHeight, this.element.offsetHeight),\n\t\t\t\tquad,\n\t\t\t\tnonLeft = align && align !== 'left';\n\n\t\t\t// correct x and y\n\t\t\tthis.xCorr = costheta < 0 && -width;\n\t\t\tthis.yCorr = sintheta < 0 && -height;\n\n\t\t\t// correct for baseline and corners spilling out after rotation\n\t\t\tquad = costheta * sintheta < 0;\n\t\t\tthis.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n\t\t\tthis.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n\t\t\t// correct for the length/height of the text\n\t\t\tif (nonLeft) {\n\t\t\t\tthis.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n\t\t\t\tif (rotation) {\n\t\t\t\t\tthis.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n\t\t\t\t}\n\t\t\t\tcss(this.element, {\n\t\t\t\t\ttextAlign: align\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n\t\t * as the parameter and returns a string.\n\t\t */\n\t\tpathToVML: function (value) {\n\t\t\t// convert paths\n\t\t\tvar i = value.length,\n\t\t\t\tpath = [];\n\n\t\t\twhile (i--) {\n\n\t\t\t\t// Multiply by 10 to allow subpixel precision.\n\t\t\t\t// Substracting half a pixel seems to make the coordinates\n\t\t\t\t// align with SVG, but this hasn't been tested thoroughly\n\t\t\t\tif (isNumber(value[i])) {\n\t\t\t\t\tpath[i] = mathRound(value[i] * 10) - 5;\n\t\t\t\t} else if (value[i] === 'Z') { // close the path\n\t\t\t\t\tpath[i] = 'x';\n\t\t\t\t} else {\n\t\t\t\t\tpath[i] = value[i];\n\n\t\t\t\t\t// When the start X and end X coordinates of an arc are too close,\n\t\t\t\t\t// they are rounded to the same value above. In this case, substract or \n\t\t\t\t\t// add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n\t\t\t\t\tif (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n\t\t\t\t\t\t// Start and end X\n\t\t\t\t\t\tif (path[i + 5] === path[i + 7]) {\n\t\t\t\t\t\t\tpath[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Start and end Y\n\t\t\t\t\t\tif (path[i + 6] === path[i + 8]) {\n\t\t\t\t\t\t\tpath[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\t// Loop up again to handle path shortcuts (#2132)\n\t\t\t/*while (i++ < path.length) {\n\t\t\t\tif (path[i] === 'H') { // horizontal line to\n\t\t\t\t\tpath[i] = 'L';\n\t\t\t\t\tpath.splice(i + 2, 0, path[i - 1]);\n\t\t\t\t} else if (path[i] === 'V') { // vertical line to\n\t\t\t\t\tpath[i] = 'L';\n\t\t\t\t\tpath.splice(i + 1, 0, path[i - 2]);\n\t\t\t\t}\n\t\t\t}*/\n\t\t\treturn path.join(' ') || 'x';\n\t\t},\n\n\t\t/**\n\t\t * Set the element's clipping to a predefined rectangle\n\t\t *\n\t\t * @param {String} id The id of the clip rectangle\n\t\t */\n\t\tclip: function (clipRect) {\n\t\t\tvar wrapper = this,\n\t\t\t\tclipMembers,\n\t\t\t\tcssRet;\n\n\t\t\tif (clipRect) {\n\t\t\t\tclipMembers = clipRect.members;\n\t\t\t\terase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n\t\t\t\tclipMembers.push(wrapper);\n\t\t\t\twrapper.destroyClip = function () {\n\t\t\t\t\terase(clipMembers, wrapper);\n\t\t\t\t};\n\t\t\t\tcssRet = clipRect.getCSS(wrapper);\n\n\t\t\t} else {\n\t\t\t\tif (wrapper.destroyClip) {\n\t\t\t\t\twrapper.destroyClip();\n\t\t\t\t}\n\t\t\t\tcssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n\t\t\t}\n\n\t\t\treturn wrapper.css(cssRet);\n\n\t\t},\n\n\t\t/**\n\t\t * Set styles for the element\n\t\t * @param {Object} styles\n\t\t */\n\t\tcss: SVGElement.prototype.htmlCss,\n\n\t\t/**\n\t\t * Removes a child either by removeChild or move to garbageBin.\n\t\t * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n\t\t */\n\t\tsafeRemoveChild: function (element) {\n\t\t\t// discardElement will detach the node from its parent before attaching it\n\t\t\t// to the garbage bin. Therefore it is important that the node is attached and have parent.\n\t\t\tif (element.parentNode) {\n\t\t\t\tdiscardElement(element);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extend element.destroy by removing it from the clip members array\n\t\t */\n\t\tdestroy: function () {\n\t\t\tif (this.destroyClip) {\n\t\t\t\tthis.destroyClip();\n\t\t\t}\n\n\t\t\treturn SVGElement.prototype.destroy.apply(this);\n\t\t},\n\n\t\t/**\n\t\t * Add an event listener. VML override for normalizing event parameters.\n\t\t * @param {String} eventType\n\t\t * @param {Function} handler\n\t\t */\n\t\ton: function (eventType, handler) {\n\t\t\t// simplest possible event model for internal use\n\t\t\tthis.element['on' + eventType] = function () {\n\t\t\t\tvar evt = win.event;\n\t\t\t\tevt.target = evt.srcElement;\n\t\t\t\thandler(evt);\n\t\t\t};\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * In stacked columns, cut off the shadows so that they don't overlap\n\t\t */\n\t\tcutOffPath: function (path, length) {\n\n\t\t\tvar len;\n\n\t\t\tpath = path.split(/[ ,]/);\n\t\t\tlen = path.length;\n\n\t\t\tif (len === 9 || len === 11) {\n\t\t\t\tpath[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n\t\t\t}\n\t\t\treturn path.join(' ');\n\t\t},\n\n\t\t/**\n\t\t * Apply a drop shadow by copying elements and giving them different strokes\n\t\t * @param {Boolean|Object} shadowOptions\n\t\t */\n\t\tshadow: function (shadowOptions, group, cutOff) {\n\t\t\tvar shadows = [],\n\t\t\t\ti,\n\t\t\t\telement = this.element,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tshadow,\n\t\t\t\telemStyle = element.style,\n\t\t\t\tmarkup,\n\t\t\t\tpath = element.path,\n\t\t\t\tstrokeWidth,\n\t\t\t\tmodifiedPath,\n\t\t\t\tshadowWidth,\n\t\t\t\tshadowElementOpacity;\n\n\t\t\t// some times empty paths are not strings\n\t\t\tif (path && typeof path.value !== 'string') {\n\t\t\t\tpath = 'x';\n\t\t\t}\n\t\t\tmodifiedPath = path;\n\n\t\t\tif (shadowOptions) {\n\t\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n\t\t\t\tfor (i = 1; i <= 3; i++) {\n\n\t\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n\t\t\t\t\t// Cut off shadows for stacked column items\n\t\t\t\t\tif (cutOff) {\n\t\t\t\t\t\tmodifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n\t\t\t\t\t}\n\n\t\t\t\t\tmarkup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n\t\t\t\t\t\t'\" filled=\"false\" path=\"', modifiedPath,\n\t\t\t\t\t\t'\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n\n\t\t\t\t\tshadow = createElement(renderer.prepVML(markup),\n\t\t\t\t\t\tnull, {\n\t\t\t\t\t\t\tleft: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n\t\t\t\t\t\t\ttop: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tif (cutOff) {\n\t\t\t\t\t\tshadow.cutOff = strokeWidth + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply the opacity\n\t\t\t\t\tmarkup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n\t\t\t\t\tcreateElement(renderer.prepVML(markup), null, null, shadow);\n\n\n\t\t\t\t\t// insert it\n\t\t\t\t\tif (group) {\n\t\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t\t}\n\n\t\t\t\t\t// record it\n\t\t\t\t\tshadows.push(shadow);\n\n\t\t\t\t}\n\n\t\t\t\tthis.shadows = shadows;\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tupdateShadows: noop, // Used in SVG only\n\n\t\tsetAttr: function (key, value) {\n\t\t\tif (docMode8) { // IE8 setAttribute bug\n\t\t\t\tthis.element[key] = value;\n\t\t\t} else {\n\t\t\t\tthis.element.setAttribute(key, value);\n\t\t\t}\n\t\t},\n\t\tclassSetter: function (value) {\n\t\t\t// IE8 Standards mode has problems retrieving the className unless set like this\n\t\t\tthis.element.className = value;\n\t\t},\n\t\tdashstyleSetter: function (value, key, element) {\n\t\t\tvar strokeElem = element.getElementsByTagName('stroke')[0] ||\n\t\t\t\tcreateElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n\t\t\tstrokeElem[key] = value || 'solid';\n\t\t\tthis[key] = value; /* because changing stroke-width will change the dash length\n\t\t\t\tand cause an epileptic effect */\n\t\t},\n\t\tdSetter: function (value, key, element) {\n\t\t\tvar i,\n\t\t\t\tshadows = this.shadows;\n\t\t\tvalue = value || [];\n\t\t\tthis.d = value.join && value.join(' '); // used in getter for animation\n\n\t\t\telement.path = value = this.pathToVML(value);\n\n\t\t\t// update shadows\n\t\t\tif (shadows) {\n\t\t\t\ti = shadows.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tshadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setAttr(key, value);\n\t\t},\n\t\tfillSetter: function (value, key, element) {\n\t\t\tvar nodeName = element.nodeName;\n\t\t\tif (nodeName === 'SPAN') { // text color\n\t\t\t\telement.style.color = value;\n\t\t\t} else if (nodeName !== 'IMG') { // #1336\n\t\t\t\telement.filled = value !== NONE;\n\t\t\t\tthis.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n\t\t\t}\n\t\t},\n\t\topacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n\t\trotationSetter: function (value, key, element) {\n\t\t\tvar style = element.style;\n\t\t\tthis[key] = style[key] = value; // style is for #1873\n\n\t\t\t// Correction for the 1x1 size of the shape container. Used in gauge needles.\n\t\t\tstyle.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n\t\t\tstyle.top = mathRound(mathCos(value * deg2rad)) + PX;\n\t\t},\n\t\tstrokeSetter: function (value, key, element) {\n\t\t\tthis.setAttr('strokecolor', this.renderer.color(value, element, key));\n\t\t},\n\t\t'stroke-widthSetter': function (value, key, element) {\n\t\t\telement.stroked = !!value; // VML \"stroked\" attribute\n\t\t\tthis[key] = value; // used in getter, issue #113\n\t\t\tif (isNumber(value)) {\n\t\t\t\tvalue += PX;\n\t\t\t}\n\t\t\tthis.setAttr('strokeweight', value);\n\t\t},\n\t\ttitleSetter: function (value, key) {\n\t\t\tthis.setAttr(key, value);\n\t\t},\n\t\tvisibilitySetter: function (value, key, element) {\n\n\t\t\t// Handle inherited visibility\n\t\t\tif (value === 'inherit') {\n\t\t\t\tvalue = VISIBLE;\n\t\t\t}\n\t\t\t\n\t\t\t// Let the shadow follow the main element\n\t\t\tif (this.shadows) {\n\t\t\t\teach(this.shadows, function (shadow) {\n\t\t\t\t\tshadow.style[key] = value;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Instead of toggling the visibility CSS property, move the div out of the viewport.\n\t\t\t// This works around #61 and #586\n\t\t\tif (element.nodeName === 'DIV') {\n\t\t\t\tvalue = value === HIDDEN ? '-999em' : 0;\n\n\t\t\t\t// In order to redraw, IE7 needs the div to be visible when tucked away\n\t\t\t\t// outside the viewport. So the visibility is actually opposite of\n\t\t\t\t// the expected value. This applies to the tooltip only.\n\t\t\t\tif (!docMode8) {\n\t\t\t\t\telement.style[key] = value ? VISIBLE : HIDDEN;\n\t\t\t\t}\n\t\t\t\tkey = 'top';\n\t\t\t}\n\t\t\telement.style[key] = value;\n\t\t},\n\t\txSetter: function (value, key, element) {\n\t\t\tthis[key] = value; // used in getter\n\n\t\t\tif (key === 'x') {\n\t\t\t\tkey = 'left';\n\t\t\t} else if (key === 'y') {\n\t\t\t\tkey = 'top';\n\t\t\t}/* else {\n\t\t\t\tvalue = mathMax(0, value); // don't set width or height below zero (#311)\n\t\t\t}*/\n\n\t\t\t// clipping rectangle special\n\t\t\tif (this.updateClipping) {\n\t\t\t\tthis[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n\t\t\t\tthis.updateClipping();\n\t\t\t} else {\n\t\t\t\t// normal\n\t\t\t\telement.style[key] = value;\n\t\t\t}\n\t\t},\n\t\tzIndexSetter: function (value, key, element) {\n\t\t\telement.style[key] = value;\n\t\t}\n\t};\n\tHighcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n\t// Some shared setters\n\tVMLElement.prototype.ySetter =\n\t\tVMLElement.prototype.widthSetter = \n\t\tVMLElement.prototype.heightSetter = \n\t\tVMLElement.prototype.xSetter;\n\n\n\t/**\n\t * The VML renderer\n\t */\n\tvar VMLRendererExtension = { // inherit SVGRenderer\n\n\t\tElement: VMLElement,\n\t\tisIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n\t\t/**\n\t\t * Initialize the VMLRenderer\n\t\t * @param {Object} container\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\tinit: function (container, width, height, style) {\n\t\t\tvar renderer = this,\n\t\t\t\tboxWrapper,\n\t\t\t\tbox,\n\t\t\t\tcss;\n\n\t\t\trenderer.alignedObjects = [];\n\n\t\t\tboxWrapper = renderer.createElement(DIV)\n\t\t\t\t.css(extend(this.getStyle(style), { position: RELATIVE}));\n\t\t\tbox = boxWrapper.element;\n\t\t\tcontainer.appendChild(boxWrapper.element);\n\n\n\t\t\t// generate the containing box\n\t\t\trenderer.isVML = true;\n\t\t\trenderer.box = box;\n\t\t\trenderer.boxWrapper = boxWrapper;\n\t\t\trenderer.cache = {};\n\n\n\t\t\trenderer.setSize(width, height, false);\n\n\t\t\t// The only way to make IE6 and IE7 print is to use a global namespace. However,\n\t\t\t// with IE8 the only way to make the dynamic shapes visible in screen and print mode\n\t\t\t// seems to be to add the xmlns attribute and the behaviour style inline.\n\t\t\tif (!doc.namespaces.hcv) {\n\n\t\t\t\tdoc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n\t\t\t\t// Setup default CSS (#2153, #2368, #2384)\n\t\t\t\tcss = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n\t\t\t\t\t'{ behavior:url(#default#VML); display: inline-block; } ';\n\t\t\t\ttry {\n\t\t\t\t\tdoc.createStyleSheet().cssText = css;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdoc.styleSheets[0].cssText += css;\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Detect whether the renderer is hidden. This happens when one of the parent elements\n\t\t * has display: none\n\t\t */\n\t\tisHidden: function () {\n\t\t\treturn !this.box.offsetWidth;\n\t\t},\n\n\t\t/**\n\t\t * Define a clipping rectangle. In VML it is accomplished by storing the values\n\t\t * for setting the CSS style to all associated members.\n\t\t *\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\tclipRect: function (x, y, width, height) {\n\n\t\t\t// create a dummy element\n\t\t\tvar clipRect = this.createElement(),\n\t\t\t\tisObj = isObject(x);\n\n\t\t\t// mimic a rectangle with its style object for automatic updating in attr\n\t\t\treturn extend(clipRect, {\n\t\t\t\tmembers: [],\n\t\t\t\tcount: 0,\n\t\t\t\tleft: (isObj ? x.x : x) + 1,\n\t\t\t\ttop: (isObj ? x.y : y) + 1,\n\t\t\t\twidth: (isObj ? x.width : width) - 1,\n\t\t\t\theight: (isObj ? x.height : height) - 1,\n\t\t\t\tgetCSS: function (wrapper) {\n\t\t\t\t\tvar element = wrapper.element,\n\t\t\t\t\t\tnodeName = element.nodeName,\n\t\t\t\t\t\tisShape = nodeName === 'shape',\n\t\t\t\t\t\tinverted = wrapper.inverted,\n\t\t\t\t\t\trect = this,\n\t\t\t\t\t\ttop = rect.top - (isShape ? element.offsetTop : 0),\n\t\t\t\t\t\tleft = rect.left,\n\t\t\t\t\t\tright = left + rect.width,\n\t\t\t\t\t\tbottom = top + rect.height,\n\t\t\t\t\t\tret = {\n\t\t\t\t\t\t\tclip: 'rect(' +\n\t\t\t\t\t\t\t\tmathRound(inverted ? left : top) + 'px,' +\n\t\t\t\t\t\t\t\tmathRound(inverted ? bottom : right) + 'px,' +\n\t\t\t\t\t\t\t\tmathRound(inverted ? right : bottom) + 'px,' +\n\t\t\t\t\t\t\t\tmathRound(inverted ? top : left) + 'px)'\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// issue 74 workaround\n\t\t\t\t\tif (!inverted && docMode8 && nodeName === 'DIV') {\n\t\t\t\t\t\textend(ret, {\n\t\t\t\t\t\t\twidth: right + PX,\n\t\t\t\t\t\t\theight: bottom + PX\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t},\n\n\t\t\t\t// used in attr and animation to update the clipping of all members\n\t\t\t\tupdateClipping: function () {\n\t\t\t\t\teach(clipRect.members, function (member) {\n\t\t\t\t\t\tif (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n\t\t\t\t\t\t\tmember.css(clipRect.getCSS(member));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t},\n\n\n\t\t/**\n\t\t * Take a color and return it if it's a string, make it a gradient if it's a\n\t\t * gradient configuration object, and apply opacity.\n\t\t *\n\t\t * @param {Object} color The color or config object\n\t\t */\n\t\tcolor: function (color, elem, prop, wrapper) {\n\t\t\tvar renderer = this,\n\t\t\t\tcolorObject,\n\t\t\t\tregexRgba = /^rgba/,\n\t\t\t\tmarkup,\n\t\t\t\tfillType,\n\t\t\t\tret = NONE;\n\n\t\t\t// Check for linear or radial gradient\n\t\t\tif (color && color.linearGradient) {\n\t\t\t\tfillType = 'gradient';\n\t\t\t} else if (color && color.radialGradient) {\n\t\t\t\tfillType = 'pattern';\n\t\t\t}\n\n\n\t\t\tif (fillType) {\n\n\t\t\t\tvar stopColor,\n\t\t\t\t\tstopOpacity,\n\t\t\t\t\tgradient = color.linearGradient || color.radialGradient,\n\t\t\t\t\tx1,\n\t\t\t\t\ty1,\n\t\t\t\t\tx2,\n\t\t\t\t\ty2,\n\t\t\t\t\topacity1,\n\t\t\t\t\topacity2,\n\t\t\t\t\tcolor1,\n\t\t\t\t\tcolor2,\n\t\t\t\t\tfillAttr = '',\n\t\t\t\t\tstops = color.stops,\n\t\t\t\t\tfirstStop,\n\t\t\t\t\tlastStop,\n\t\t\t\t\tcolors = [],\n\t\t\t\t\taddFillNode = function () {\n\t\t\t\t\t\t// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n\t\t\t\t\t\t// are reversed.\n\t\t\t\t\t\tmarkup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n\t\t\t\t\t\t\t'\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n\t\t\t\t\t\tcreateElement(renderer.prepVML(markup), null, null, elem);\n\t\t\t\t\t};\n\n\t\t\t\t// Extend from 0 to 1\n\t\t\t\tfirstStop = stops[0];\n\t\t\t\tlastStop = stops[stops.length - 1];\n\t\t\t\tif (firstStop[0] > 0) {\n\t\t\t\t\tstops.unshift([\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tfirstStop[1]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tif (lastStop[0] < 1) {\n\t\t\t\t\tstops.push([\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tlastStop[1]\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\t// Compute the stops\n\t\t\t\teach(stops, function (stop, i) {\n\t\t\t\t\tif (regexRgba.test(stop[1])) {\n\t\t\t\t\t\tcolorObject = Color(stop[1]);\n\t\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Build the color attribute\n\t\t\t\t\tcolors.push((stop[0] * 100) + '% ' + stopColor);\n\n\t\t\t\t\t// Only start and end opacities are allowed, so we use the first and the last\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\topacity1 = stopOpacity;\n\t\t\t\t\t\tcolor2 = stopColor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topacity2 = stopOpacity;\n\t\t\t\t\t\tcolor1 = stopColor;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Apply the gradient to fills only.\n\t\t\t\tif (prop === 'fill') {\n\n\t\t\t\t\t// Handle linear gradient angle\n\t\t\t\t\tif (fillType === 'gradient') {\n\t\t\t\t\t\tx1 = gradient.x1 || gradient[0] || 0;\n\t\t\t\t\t\ty1 = gradient.y1 || gradient[1] || 0;\n\t\t\t\t\t\tx2 = gradient.x2 || gradient[2] || 0;\n\t\t\t\t\t\ty2 = gradient.y2 || gradient[3] || 0;\n\t\t\t\t\t\tfillAttr = 'angle=\"' + (90  - math.atan(\n\t\t\t\t\t\t\t(y2 - y1) / // y vector\n\t\t\t\t\t\t\t(x2 - x1) // x vector\n\t\t\t\t\t\t\t) * 180 / mathPI) + '\"';\n\n\t\t\t\t\t\taddFillNode();\n\n\t\t\t\t\t// Radial (circular) gradient\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar r = gradient.r,\n\t\t\t\t\t\t\tsizex = r * 2,\n\t\t\t\t\t\t\tsizey = r * 2,\n\t\t\t\t\t\t\tcx = gradient.cx,\n\t\t\t\t\t\t\tcy = gradient.cy,\n\t\t\t\t\t\t\tradialReference = elem.radialReference,\n\t\t\t\t\t\t\tbBox,\n\t\t\t\t\t\t\tapplyRadialGradient = function () {\n\t\t\t\t\t\t\t\tif (radialReference) {\n\t\t\t\t\t\t\t\t\tbBox = wrapper.getBBox();\n\t\t\t\t\t\t\t\t\tcx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n\t\t\t\t\t\t\t\t\tcy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n\t\t\t\t\t\t\t\t\tsizex *= radialReference[2] / bBox.width;\n\t\t\t\t\t\t\t\t\tsizey *= radialReference[2] / bBox.height;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n\t\t\t\t\t\t\t\t\t'size=\"' + sizex + ',' + sizey + '\" ' +\n\t\t\t\t\t\t\t\t\t'origin=\"0.5,0.5\" ' +\n\t\t\t\t\t\t\t\t\t'position=\"' + cx + ',' + cy + '\" ' +\n\t\t\t\t\t\t\t\t\t'color2=\"' + color2 + '\" ';\n\n\t\t\t\t\t\t\t\taddFillNode();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Apply radial gradient\n\t\t\t\t\t\tif (wrapper.added) {\n\t\t\t\t\t\t\tapplyRadialGradient();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// We need to know the bounding box to get the size and position right\n\t\t\t\t\t\t\twrapper.onAdd = applyRadialGradient;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The fill element's color attribute is broken in IE8 standards mode, so we\n\t\t\t\t\t\t// need to set the parent shape's fillcolor attribute instead.\n\t\t\t\t\t\tret = color1;\n\t\t\t\t\t}\n\n\t\t\t\t// Gradients are not supported for VML stroke, return the first color. #722.\n\t\t\t\t} else {\n\t\t\t\t\tret = stopColor;\n\t\t\t\t}\n\n\t\t\t// if the color is an rgba color, split it and add a fill node\n\t\t\t// to hold the opacity component\n\t\t\t} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n\t\t\t\tcolorObject = Color(color);\n\n\t\t\t\tmarkup = ['<', prop, ' opacity=\"', colorObject.get('a'), '\"/>'];\n\t\t\t\tcreateElement(this.prepVML(markup), null, null, elem);\n\n\t\t\t\tret = colorObject.get('rgb');\n\n\n\t\t\t} else {\n\t\t\t\tvar propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n\t\t\t\tif (propNodes.length) {\n\t\t\t\t\tpropNodes[0].opacity = 1;\n\t\t\t\t\tpropNodes[0].type = 'solid';\n\t\t\t\t}\n\t\t\t\tret = color;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Take a VML string and prepare it for either IE8 or IE6/IE7.\n\t\t * @param {Array} markup A string array of the VML markup to prepare\n\t\t */\n\t\tprepVML: function (markup) {\n\t\t\tvar vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n\t\t\t\tisIE8 = this.isIE8;\n\n\t\t\tmarkup = markup.join('');\n\n\t\t\tif (isIE8) { // add xmlns and style inline\n\t\t\t\tmarkup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n\t\t\t\tif (markup.indexOf('style=\"') === -1) {\n\t\t\t\t\tmarkup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n\t\t\t\t} else {\n\t\t\t\t\tmarkup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n\t\t\t\t}\n\n\t\t\t} else { // add namespace\n\t\t\t\tmarkup = markup.replace('<', '<hcv:');\n\t\t\t}\n\n\t\t\treturn markup;\n\t\t},\n\n\t\t/**\n\t\t * Create rotated and aligned text\n\t\t * @param {String} str\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t */\n\t\ttext: SVGRenderer.prototype.html,\n\n\t\t/**\n\t\t * Create and return a path element\n\t\t * @param {Array} path\n\t\t */\n\t\tpath: function (path) {\n\t\t\tvar attr = {\n\t\t\t\t// subpixel precision down to 0.1 (width and height = 1px)\n\t\t\t\tcoordsize: '10 10'\n\t\t\t};\n\t\t\tif (isArray(path)) {\n\t\t\t\tattr.d = path;\n\t\t\t} else if (isObject(path)) { // attributes\n\t\t\t\textend(attr, path);\n\t\t\t}\n\t\t\t// create the shape\n\t\t\treturn this.createElement('shape').attr(attr);\n\t\t},\n\n\t\t/**\n\t\t * Create and return a circle element. In VML circles are implemented as\n\t\t * shapes, which is faster than v:oval\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} r\n\t\t */\n\t\tcircle: function (x, y, r) {\n\t\t\tvar circle = this.symbol('circle');\n\t\t\tif (isObject(x)) {\n\t\t\t\tr = x.r;\n\t\t\t\ty = x.y;\n\t\t\t\tx = x.x;\n\t\t\t}\n\t\t\tcircle.isCircle = true; // Causes x and y to mean center (#1682)\n\t\t\tcircle.r = r;\n\t\t\treturn circle.attr({ x: x, y: y });\n\t\t},\n\n\t\t/**\n\t\t * Create a group using an outer div and an inner v:group to allow rotating\n\t\t * and flipping. A simple v:group would have problems with positioning\n\t\t * child HTML elements and CSS clip.\n\t\t *\n\t\t * @param {String} name The name of the group\n\t\t */\n\t\tg: function (name) {\n\t\t\tvar wrapper,\n\t\t\t\tattribs;\n\n\t\t\t// set the class name\n\t\t\tif (name) {\n\t\t\t\tattribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n\t\t\t}\n\n\t\t\t// the div to hold HTML and clipping\n\t\t\twrapper = this.createElement(DIV).attr(attribs);\n\n\t\t\treturn wrapper;\n\t\t},\n\n\t\t/**\n\t\t * VML override to create a regular HTML image\n\t\t * @param {String} src\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t */\n\t\timage: function (src, x, y, width, height) {\n\t\t\tvar obj = this.createElement('img')\n\t\t\t\t.attr({ src: src });\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tobj.attr({\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\t/**\n\t\t * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n\t\t */\n\t\tcreateElement: function (nodeName) {\n\t\t\treturn nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\t\n\t\t},\n\n\t\t/**\n\t\t * In the VML renderer, each child of an inverted div (group) is inverted\n\t\t * @param {Object} element\n\t\t * @param {Object} parentNode\n\t\t */\n\t\tinvertChild: function (element, parentNode) {\n\t\t\tvar ren = this,\n\t\t\t\tparentStyle = parentNode.style,\n\t\t\t\timgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n\t\t\tcss(element, {\n\t\t\t\tflip: 'x',\n\t\t\t\tleft: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n\t\t\t\ttop: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n\t\t\t\trotation: -90\n\t\t\t});\n\n\t\t\t// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n\t\t\teach(element.childNodes, function (child) {\n\t\t\t\tren.invertChild(child, element);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Symbol definitions that override the parent SVG renderer's symbols\n\t\t *\n\t\t */\n\t\tsymbols: {\n\t\t\t// VML specific arc function\n\t\t\tarc: function (x, y, w, h, options) {\n\t\t\t\tvar start = options.start,\n\t\t\t\t\tend = options.end,\n\t\t\t\t\tradius = options.r || w || h,\n\t\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\t\tcosStart = mathCos(start),\n\t\t\t\t\tsinStart = mathSin(start),\n\t\t\t\t\tcosEnd = mathCos(end),\n\t\t\t\t\tsinEnd = mathSin(end),\n\t\t\t\t\tret;\n\n\t\t\t\tif (end - start === 0) { // no angle, don't show it.\n\t\t\t\t\treturn ['x'];\n\t\t\t\t}\n\n\t\t\t\tret = [\n\t\t\t\t\t'wa', // clockwise arc to\n\t\t\t\t\tx - radius, // left\n\t\t\t\t\ty - radius, // top\n\t\t\t\t\tx + radius, // right\n\t\t\t\t\ty + radius, // bottom\n\t\t\t\t\tx + radius * cosStart, // start x\n\t\t\t\t\ty + radius * sinStart, // start y\n\t\t\t\t\tx + radius * cosEnd, // end x\n\t\t\t\t\ty + radius * sinEnd  // end y\n\t\t\t\t];\n\n\t\t\t\tif (options.open && !innerRadius) {\n\t\t\t\t\tret.push(\n\t\t\t\t\t\t'e',\n\t\t\t\t\t\tM,\n\t\t\t\t\t\tx,// - innerRadius,\n\t\t\t\t\t\ty// - innerRadius\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tret.push(\n\t\t\t\t\t'at', // anti clockwise arc to\n\t\t\t\t\tx - innerRadius, // left\n\t\t\t\t\ty - innerRadius, // top\n\t\t\t\t\tx + innerRadius, // right\n\t\t\t\t\ty + innerRadius, // bottom\n\t\t\t\t\tx + innerRadius * cosEnd, // start x\n\t\t\t\t\ty + innerRadius * sinEnd, // start y\n\t\t\t\t\tx + innerRadius * cosStart, // end x\n\t\t\t\t\ty + innerRadius * sinStart, // end y\n\t\t\t\t\t'x', // finish path\n\t\t\t\t\t'e' // close\n\t\t\t\t);\n\n\t\t\t\tret.isArc = true;\n\t\t\t\treturn ret;\n\n\t\t\t},\n\t\t\t// Add circle symbol path. This performs significantly faster than v:oval.\n\t\t\tcircle: function (x, y, w, h, wrapper) {\n\n\t\t\t\tif (wrapper) {\n\t\t\t\t\tw = h = 2 * wrapper.r;\n\t\t\t\t}\n\n\t\t\t\t// Center correction, #1682\n\t\t\t\tif (wrapper && wrapper.isCircle) {\n\t\t\t\t\tx -= w / 2;\n\t\t\t\t\ty -= h / 2;\n\t\t\t\t}\n\n\t\t\t\t// Return the path\n\t\t\t\treturn [\n\t\t\t\t\t'wa', // clockwisearcto\n\t\t\t\t\tx, // left\n\t\t\t\t\ty, // top\n\t\t\t\t\tx + w, // right\n\t\t\t\t\ty + h, // bottom\n\t\t\t\t\tx + w, // start x\n\t\t\t\t\ty + h / 2,     // start y\n\t\t\t\t\tx + w, // end x\n\t\t\t\t\ty + h / 2,     // end y\n\t\t\t\t\t//'x', // finish path\n\t\t\t\t\t'e' // close\n\t\t\t\t];\n\t\t\t},\n\t\t\t/**\n\t\t\t * Add rectangle symbol path which eases rotation and omits arcsize problems\n\t\t\t * compared to the built-in VML roundrect shape. When borders are not rounded,\n\t\t\t * use the simpler square path, else use the callout path without the arrow.\n\t\t\t */\n\t\t\trect: function (x, y, w, h, options) {\n\t\t\t\treturn SVGRenderer.prototype.symbols[\n\t\t\t\t\t!defined(options) || !options.r ? 'square' : 'callout'\n\t\t\t\t].call(0, x, y, w, h, options);\n\t\t\t}\n\t\t}\n\t};\n\tHighcharts.VMLRenderer = VMLRenderer = function () {\n\t\tthis.init.apply(this, arguments);\n\t};\n\tVMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n\t\t// general renderer\n\t\tRenderer = VMLRenderer;\n\t}\n\n\t// This method is used with exporting in old IE, when emulating SVG (see #2314)\n\tSVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n\t\tvar measuringSpan = doc.createElement('span'),\n\t\t\toffsetWidth,\n\t\ttextNode = doc.createTextNode(text);\n\n\t\tmeasuringSpan.appendChild(textNode);\n\t\tcss(measuringSpan, styles);\n\t\tthis.box.appendChild(measuringSpan);\n\t\toffsetWidth = measuringSpan.offsetWidth;\n\t\tdiscardElement(measuringSpan); // #2463\n\t\treturn offsetWidth;\n\t};\n\n\n\t/* ****************************************************************************\n\t *                                                                            *\n\t * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n\t *                                                                            *\n\t *****************************************************************************/\n\t/* ****************************************************************************\n\t *                                                                            *\n\t * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n\t * TARGETING THAT SYSTEM.                                                     *\n\t *                                                                            *\n\t *****************************************************************************/\n\tvar CanVGRenderer,\n\t\tCanVGController;\n\n\tif (useCanVG) {\n\t\t/**\n\t\t * The CanVGRenderer is empty from start to keep the source footprint small.\n\t\t * When requested, the CanVGController downloads the rest of the source packaged\n\t\t * together with the canvg library.\n\t\t */\n\t\tHighcharts.CanVGRenderer = CanVGRenderer = function () {\n\t\t\t// Override the global SVG namespace to fake SVG/HTML that accepts CSS\n\t\t\tSVG_NS = 'http://www.w3.org/1999/xhtml';\n\t\t};\n\n\t\t/**\n\t\t * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but \n\t\t * the implementation from SvgRenderer will not be merged in until first render.\n\t\t */\n\t\tCanVGRenderer.prototype.symbols = {};\n\n\t\t/**\n\t\t * Handles on demand download of canvg rendering support.\n\t\t */\n\t\tCanVGController = (function () {\n\t\t\t// List of renderering calls\n\t\t\tvar deferredRenderCalls = [];\n\n\t\t\t/**\n\t\t\t * When downloaded, we are ready to draw deferred charts.\n\t\t\t */\n\t\t\tfunction drawDeferred() {\n\t\t\t\tvar callLength = deferredRenderCalls.length,\n\t\t\t\t\tcallIndex;\n\n\t\t\t\t// Draw all pending render calls\n\t\t\t\tfor (callIndex = 0; callIndex < callLength; callIndex++) {\n\t\t\t\t\tdeferredRenderCalls[callIndex]();\n\t\t\t\t}\n\t\t\t\t// Clear the list\n\t\t\t\tdeferredRenderCalls = [];\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpush: function (func, scriptLocation) {\n\t\t\t\t\t// Only get the script once\n\t\t\t\t\tif (deferredRenderCalls.length === 0) {\n\t\t\t\t\t\tgetScript(scriptLocation, drawDeferred);\n\t\t\t\t\t}\n\t\t\t\t\t// Register render call\n\t\t\t\t\tdeferredRenderCalls.push(func);\n\t\t\t\t}\n\t\t\t};\n\t\t}());\n\n\t\tRenderer = CanVGRenderer;\n\t} // end CanVGRenderer\n\n\t/* ****************************************************************************\n\t *                                                                            *\n\t * END OF ANDROID < 3 SPECIFIC CODE                                           *\n\t *                                                                            *\n\t *****************************************************************************/\n\n\t/**\n\t * The Tick class\n\t */\n\tfunction Tick(axis, pos, type, noLabel) {\n\t\tthis.axis = axis;\n\t\tthis.pos = pos;\n\t\tthis.type = type || '';\n\t\tthis.isNew = true;\n\n\t\tif (!type && !noLabel) {\n\t\t\tthis.addLabel();\n\t\t}\n\t}\n\n\tTick.prototype = {\n\t\t/**\n\t\t * Write the tick label\n\t\t */\n\t\taddLabel: function () {\n\t\t\tvar tick = this,\n\t\t\t\taxis = tick.axis,\n\t\t\t\toptions = axis.options,\n\t\t\t\tchart = axis.chart,\n\t\t\t\tcategories = axis.categories,\n\t\t\t\tnames = axis.names,\n\t\t\t\tpos = tick.pos,\n\t\t\t\tlabelOptions = options.labels,\n\t\t\t\tstr,\n\t\t\t\ttickPositions = axis.tickPositions,\n\t\t\t\tisFirst = pos === tickPositions[0],\n\t\t\t\tisLast = pos === tickPositions[tickPositions.length - 1],\n\t\t\t\tvalue = categories ?\n\t\t\t\t\tpick(categories[pos], names[pos], pos) :\n\t\t\t\t\tpos,\n\t\t\t\tlabel = tick.label,\n\t\t\t\ttickPositionInfo = tickPositions.info,\n\t\t\t\tdateTimeLabelFormat;\n\n\t\t\t// Set the datetime label format. If a higher rank is set for this position, use that. If not,\n\t\t\t// use the general format.\n\t\t\tif (axis.isDatetimeAxis && tickPositionInfo) {\n\t\t\t\tdateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n\t\t\t}\n\t\t\t// set properties for access in render method\n\t\t\ttick.isFirst = isFirst;\n\t\t\ttick.isLast = isLast;\n\n\t\t\t// get the string\n\t\t\tstr = axis.labelFormatter.call({\n\t\t\t\taxis: axis,\n\t\t\t\tchart: chart,\n\t\t\t\tisFirst: isFirst,\n\t\t\t\tisLast: isLast,\n\t\t\t\tdateTimeLabelFormat: dateTimeLabelFormat,\n\t\t\t\tvalue: axis.isLog ? correctFloat(lin2log(value)) : value\n\t\t\t});\n\n\t\t\t// prepare CSS\n\t\t\t//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n\t\t\t\n\t\t\t// first call\n\t\t\tif (!defined(label)) {\n\n\t\t\t\ttick.label = label =\n\t\t\t\t\tdefined(str) && labelOptions.enabled ?\n\t\t\t\t\t\tchart.renderer.text(\n\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tlabelOptions.useHTML\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t//.attr(attr)\n\t\t\t\t\t\t\t// without position absolute, IE export sometimes is wrong\n\t\t\t\t\t\t\t.css(merge(labelOptions.style))\n\t\t\t\t\t\t\t.add(axis.labelGroup) :\n\t\t\t\t\t\tnull;\n\t\t\t\ttick.labelLength = label && label.getBBox().width; // Un-rotated length\n\t\t\t\ttick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n\t\t\t// update\n\t\t\t} else if (label) {\n\t\t\t\tlabel.attr({ text: str });\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Get the offset height or width of the label\n\t\t */\n\t\tgetLabelSize: function () {\n\t\t\treturn this.label ?\n\t\t\t\tthis.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Handle the label overflow by adjusting the labels to the left and right edge, or\n\t\t * hide them if they collide into the neighbour label.\n\t\t */\n\t\thandleOverflow: function (xy) {\n\t\t\tvar axis = this.axis,\n\t\t\t\tpxPos = xy.x,\n\t\t\t\tchartWidth = axis.chart.chartWidth,\n\t\t\t\tspacing = axis.chart.spacing,\n\t\t\t\tleftBound = pick(axis.labelLeft, spacing[3]),\n\t\t\t\trightBound = pick(axis.labelRight, chartWidth - spacing[1]),\n\t\t\t\tlabel = this.label,\n\t\t\t\trotation = this.rotation,\n\t\t\t\tfactor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n\t\t\t\tlabelWidth = label.getBBox().width,\n\t\t\t\tslotWidth = axis.slotWidth,\n\t\t\t\tleftPos,\n\t\t\t\trightPos,\n\t\t\t\ttextWidth;\n\n\t\t\t// Check if the label overshoots the chart spacing box. If it does, move it.\n\t\t\t// If it now overshoots the slotWidth, add ellipsis.\n\t\t\tif (!rotation) {\n\t\t\t\tleftPos = pxPos - factor * labelWidth;\n\t\t\t\trightPos = pxPos + factor * labelWidth;\n\n\t\t\t\tif (leftPos < leftBound) {\n\t\t\t\t\tslotWidth -= leftBound - leftPos;\n\t\t\t\t\txy.x = leftBound;\n\t\t\t\t\tlabel.attr({ align: 'left' });\t\t\t\t\n\t\t\t\t} else if (rightPos > rightBound) {\n\t\t\t\t\tslotWidth -= rightPos - rightBound;\n\t\t\t\t\txy.x = rightBound;\n\t\t\t\t\tlabel.attr({ align: 'right' });\n\t\t\t\t}\n\n\t\t\t\tif (labelWidth > slotWidth) {\n\t\t\t\t\ttextWidth = slotWidth;\n\t\t\t\t}\n\t\t\t\n\n\t\t\t// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n\t\t\t} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n\t\t\t\ttextWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);\n\t\t\t} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n\t\t\t\ttextWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));\n\t\t\t}\n\n\t\t\tif (textWidth) {\n\t\t\t\tlabel.css({\n\t\t\t\t\twidth: textWidth,\n\t\t\t\t\ttextOverflow: 'ellipsis'\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Get the x and y position for ticks and labels\n\t\t */\n\t\tgetPosition: function (horiz, pos, tickmarkOffset, old) {\n\t\t\tvar axis = this.axis,\n\t\t\t\tchart = axis.chart,\n\t\t\t\tcHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n\t\t\treturn {\n\t\t\t\tx: horiz ?\n\t\t\t\t\taxis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n\t\t\t\t\taxis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n\t\t\t\ty: horiz ?\n\t\t\t\t\tcHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n\t\t\t\t\tcHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n\t\t\t};\n\n\t\t},\n\n\t\t/**\n\t\t * Get the x, y position of the tick label\n\t\t */\n\t\tgetLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n\t\t\tvar axis = this.axis,\n\t\t\t\ttransA = axis.transA,\n\t\t\t\treversed = axis.reversed,\n\t\t\t\tstaggerLines = axis.staggerLines,\n\t\t\t\trotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n\t\t\t\tyOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),\n\t\t\t\tline;\n\n\t\t\tx = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n\t\t\t\ttickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n\t\t\ty = y + yOffset - (tickmarkOffset && !horiz ?\n\t\t\t\ttickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n\t\t\t// Correct for staggered labels\n\t\t\tif (staggerLines) {\n\t\t\t\tline = (index / (step || 1) % staggerLines);\n\t\t\t\ty += line * (axis.labelOffset / staggerLines);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: mathRound(y)\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Extendible method to return the path of the marker\n\t\t */\n\t\tgetMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n\t\t\treturn renderer.crispLine([\n\t\t\t\t\tM,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\tL,\n\t\t\t\t\tx + (horiz ? 0 : -tickLength),\n\t\t\t\t\ty + (horiz ? tickLength : 0)\n\t\t\t\t], tickWidth);\n\t\t},\n\n\t\t/**\n\t\t * Put everything in place\n\t\t *\n\t\t * @param index {Number}\n\t\t * @param old {Boolean} Use old coordinates to prepare an animation into new position\n\t\t */\n\t\trender: function (index, old, opacity) {\n\t\t\tvar tick = this,\n\t\t\t\taxis = tick.axis,\n\t\t\t\toptions = axis.options,\n\t\t\t\tchart = axis.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\thoriz = axis.horiz,\n\t\t\t\ttype = tick.type,\n\t\t\t\tlabel = tick.label,\n\t\t\t\tpos = tick.pos,\n\t\t\t\tlabelOptions = options.labels,\n\t\t\t\tgridLine = tick.gridLine,\n\t\t\t\tgridPrefix = type ? type + 'Grid' : 'grid',\n\t\t\t\ttickPrefix = type ? type + 'Tick' : 'tick',\n\t\t\t\tgridLineWidth = options[gridPrefix + 'LineWidth'],\n\t\t\t\tgridLineColor = options[gridPrefix + 'LineColor'],\n\t\t\t\tdashStyle = options[gridPrefix + 'LineDashStyle'],\n\t\t\t\ttickLength = options[tickPrefix + 'Length'],\n\t\t\t\ttickWidth = options[tickPrefix + 'Width'] || 0,\n\t\t\t\ttickColor = options[tickPrefix + 'Color'],\n\t\t\t\ttickPosition = options[tickPrefix + 'Position'],\n\t\t\t\tgridLinePath,\n\t\t\t\tmark = tick.mark,\n\t\t\t\tmarkPath,\n\t\t\t\tstep = /*axis.labelStep || */labelOptions.step,\n\t\t\t\tattribs,\n\t\t\t\tshow = true,\n\t\t\t\ttickmarkOffset = axis.tickmarkOffset,\n\t\t\t\txy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n\t\t\t\tx = xy.x,\n\t\t\t\ty = xy.y,\n\t\t\t\treverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n\t\t\topacity = pick(opacity, 1);\n\t\t\tthis.isActive = true;\n\n\t\t\t// create the grid line\n\t\t\tif (gridLineWidth) {\n\t\t\t\tgridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n\t\t\t\tif (gridLine === UNDEFINED) {\n\t\t\t\t\tattribs = {\n\t\t\t\t\t\tstroke: gridLineColor,\n\t\t\t\t\t\t'stroke-width': gridLineWidth\n\t\t\t\t\t};\n\t\t\t\t\tif (dashStyle) {\n\t\t\t\t\t\tattribs.dashstyle = dashStyle;\n\t\t\t\t\t}\n\t\t\t\t\tif (!type) {\n\t\t\t\t\t\tattribs.zIndex = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (old) {\n\t\t\t\t\t\tattribs.opacity = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttick.gridLine = gridLine =\n\t\t\t\t\t\tgridLineWidth ?\n\t\t\t\t\t\t\trenderer.path(gridLinePath)\n\t\t\t\t\t\t\t\t.attr(attribs).add(axis.gridGroup) :\n\t\t\t\t\t\t\tnull;\n\t\t\t\t}\n\n\t\t\t\t// If the parameter 'old' is set, the current call will be followed\n\t\t\t\t// by another call, therefore do not do any animations this time\n\t\t\t\tif (!old && gridLine && gridLinePath) {\n\t\t\t\t\tgridLine[tick.isNew ? 'attr' : 'animate']({\n\t\t\t\t\t\td: gridLinePath,\n\t\t\t\t\t\topacity: opacity\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create the tick mark\n\t\t\tif (tickWidth && tickLength) {\n\n\t\t\t\t// negate the length\n\t\t\t\tif (tickPosition === 'inside') {\n\t\t\t\t\ttickLength = -tickLength;\n\t\t\t\t}\n\t\t\t\tif (axis.opposite) {\n\t\t\t\t\ttickLength = -tickLength;\n\t\t\t\t}\n\n\t\t\t\tmarkPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);\n\t\t\t\tif (mark) { // updating\n\t\t\t\t\tmark.animate({\n\t\t\t\t\t\td: markPath,\n\t\t\t\t\t\topacity: opacity\n\t\t\t\t\t});\n\t\t\t\t} else { // first time\n\t\t\t\t\ttick.mark = renderer.path(\n\t\t\t\t\t\tmarkPath\n\t\t\t\t\t).attr({\n\t\t\t\t\t\tstroke: tickColor,\n\t\t\t\t\t\t'stroke-width': tickWidth,\n\t\t\t\t\t\topacity: opacity\n\t\t\t\t\t}).add(axis.axisGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the label is created on init - now move it into place\n\t\t\tif (label && !isNaN(x)) {\n\t\t\t\tlabel.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n\t\t\t\t// Apply show first and show last. If the tick is both first and last, it is\n\t\t\t\t// a single centered tick, in which case we show the label anyway (#2100).\n\t\t\t\tif ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n\t\t\t\t\t\t(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n\t\t\t\t\tshow = false;\n\n\t\t\t\t// Handle label overflow and show or hide accordingly\n\t\t\t\t} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n\t\t\t\t\ttick.handleOverflow(xy);\n\t\t\t\t}\n\n\t\t\t\t// apply step\n\t\t\t\tif (step && index % step) {\n\t\t\t\t\t// show those indices dividable by step\n\t\t\t\t\tshow = false;\n\t\t\t\t}\n\n\t\t\t\t// Set the new position, and show or hide\n\t\t\t\tif (show && !isNaN(xy.y)) {\n\t\t\t\t\txy.opacity = opacity;\n\t\t\t\t\tlabel[tick.isNew ? 'attr' : 'animate'](xy);\n\t\t\t\t\ttick.isNew = false;\n\t\t\t\t} else {\n\t\t\t\t\tlabel.attr('y', -9999); // #1338\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Destructor for the tick prototype\n\t\t */\n\t\tdestroy: function () {\n\t\t\tdestroyObjectProperties(this, this.axis);\n\t\t}\n\t};\n\n\t/**\n\t * The object wrapper for plot lines and plot bands\n\t * @param {Object} options\n\t */\n\tHighcharts.PlotLineOrBand = function (axis, options) {\n\t\tthis.axis = axis;\n\n\t\tif (options) {\n\t\t\tthis.options = options;\n\t\t\tthis.id = options.id;\n\t\t}\n\t};\n\n\tHighcharts.PlotLineOrBand.prototype = {\n\t\t\n\t\t/**\n\t\t * Render the plot line or plot band. If it is already existing,\n\t\t * move it.\n\t\t */\n\t\trender: function () {\n\t\t\tvar plotLine = this,\n\t\t\t\taxis = plotLine.axis,\n\t\t\t\thoriz = axis.horiz,\n\t\t\t\toptions = plotLine.options,\n\t\t\t\toptionsLabel = options.label,\n\t\t\t\tlabel = plotLine.label,\n\t\t\t\twidth = options.width,\n\t\t\t\tto = options.to,\n\t\t\t\tfrom = options.from,\n\t\t\t\tisBand = defined(from) && defined(to),\n\t\t\t\tvalue = options.value,\n\t\t\t\tdashStyle = options.dashStyle,\n\t\t\t\tsvgElem = plotLine.svgElem,\n\t\t\t\tpath = [],\n\t\t\t\taddEvent,\n\t\t\t\teventType,\n\t\t\t\txs,\n\t\t\t\tys,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tcolor = options.color,\n\t\t\t\tzIndex = options.zIndex,\n\t\t\t\tevents = options.events,\n\t\t\t\tattribs = {},\n\t\t\t\trenderer = axis.chart.renderer;\n\n\t\t\t// logarithmic conversion\n\t\t\tif (axis.isLog) {\n\t\t\t\tfrom = log2lin(from);\n\t\t\t\tto = log2lin(to);\n\t\t\t\tvalue = log2lin(value);\n\t\t\t}\n\n\t\t\t// plot line\n\t\t\tif (width) {\n\t\t\t\tpath = axis.getPlotLinePath(value, width);\n\t\t\t\tattribs = {\n\t\t\t\t\tstroke: color,\n\t\t\t\t\t'stroke-width': width\n\t\t\t\t};\n\t\t\t\tif (dashStyle) {\n\t\t\t\t\tattribs.dashstyle = dashStyle;\n\t\t\t\t}\n\t\t\t} else if (isBand) { // plot band\n\n\t\t\t\tpath = axis.getPlotBandPath(from, to, options);\n\t\t\t\tif (color) {\n\t\t\t\t\tattribs.fill = color;\n\t\t\t\t}\n\t\t\t\tif (options.borderWidth) {\n\t\t\t\t\tattribs.stroke = options.borderColor;\n\t\t\t\t\tattribs['stroke-width'] = options.borderWidth;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// zIndex\n\t\t\tif (defined(zIndex)) {\n\t\t\t\tattribs.zIndex = zIndex;\n\t\t\t}\n\n\t\t\t// common for lines and bands\n\t\t\tif (svgElem) {\n\t\t\t\tif (path) {\n\t\t\t\t\tsvgElem.animate({\n\t\t\t\t\t\td: path\n\t\t\t\t\t}, null, svgElem.onGetPath);\n\t\t\t\t} else {\n\t\t\t\t\tsvgElem.hide();\n\t\t\t\t\tsvgElem.onGetPath = function () {\n\t\t\t\t\t\tsvgElem.show();\n\t\t\t\t\t};\n\t\t\t\t\tif (label) {\n\t\t\t\t\t\tplotLine.label = label = label.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (path && path.length) {\n\t\t\t\tplotLine.svgElem = svgElem = renderer.path(path)\n\t\t\t\t\t.attr(attribs).add();\n\n\t\t\t\t// events\n\t\t\t\tif (events) {\n\t\t\t\t\taddEvent = function (eventType) {\n\t\t\t\t\t\tsvgElem.on(eventType, function (e) {\n\t\t\t\t\t\t\tevents[eventType].apply(plotLine, [e]);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tfor (eventType in events) {\n\t\t\t\t\t\taddEvent(eventType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the plot band/line label\n\t\t\tif (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {\n\t\t\t\t// apply defaults\n\t\t\t\toptionsLabel = merge({\n\t\t\t\t\talign: horiz && isBand && 'center',\n\t\t\t\t\tx: horiz ? !isBand && 4 : 10,\n\t\t\t\t\tverticalAlign : !horiz && isBand && 'middle',\n\t\t\t\t\ty: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n\t\t\t\t\trotation: horiz && !isBand && 90\n\t\t\t\t}, optionsLabel);\n\n\t\t\t\t// add the SVG element\n\t\t\t\tif (!label) {\n\t\t\t\t\tattribs = {\n\t\t\t\t\t\talign: optionsLabel.textAlign || optionsLabel.align,\n\t\t\t\t\t\trotation: optionsLabel.rotation\n\t\t\t\t\t};\n\t\t\t\t\tif (defined(zIndex)) {\n\t\t\t\t\t\tattribs.zIndex = zIndex;\n\t\t\t\t\t}\n\t\t\t\t\tplotLine.label = label = renderer.text(\n\t\t\t\t\t\t\toptionsLabel.text,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\toptionsLabel.useHTML\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr(attribs)\n\t\t\t\t\t\t.css(optionsLabel.style)\n\t\t\t\t\t\t.add();\n\t\t\t\t}\n\n\t\t\t\t// get the bounding box and align the label\n\t\t\t\t// #3000 changed to better handle choice between plotband or plotline\n\t\t\t\txs = [path[1], path[4], (isBand ? path[6] : path[1])];\n\t\t\t\tys = [path[2], path[5], (isBand ? path[7] : path[2])];\n\t\t\t\tx = arrayMin(xs);\n\t\t\t\ty = arrayMin(ys);\n\n\t\t\t\tlabel.align(optionsLabel, false, {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: arrayMax(xs) - x,\n\t\t\t\t\theight: arrayMax(ys) - y\n\t\t\t\t});\n\t\t\t\tlabel.show();\n\n\t\t\t} else if (label) { // move out of sight\n\t\t\t\tlabel.hide();\n\t\t\t}\n\n\t\t\t// chainable\n\t\t\treturn plotLine;\n\t\t},\n\n\t\t/**\n\t\t * Remove the plot line or band\n\t\t */\n\t\tdestroy: function () {\n\t\t\t// remove it from the lookup\n\t\t\terase(this.axis.plotLinesAndBands, this);\n\t\t\t\n\t\t\tdelete this.axis;\n\t\t\tdestroyObjectProperties(this);\n\t\t}\n\t};\n\n\t/**\n\t * Object with members for extending the Axis prototype\n\t */\n\n\tAxisPlotLineOrBandExtension = {\n\n\t\t/**\n\t\t * Create the path for a plot band\n\t\t */ \n\t\tgetPlotBandPath: function (from, to) {\n\t\t\tvar toPath = this.getPlotLinePath(to, null, null, true),\n\t\t\t\tpath = this.getPlotLinePath(from, null, null, true);\n\n\t\t\tif (path && toPath && path.toString() !== toPath.toString()) { // #3836\n\t\t\t\tpath.push(\n\t\t\t\t\ttoPath[4],\n\t\t\t\t\ttoPath[5],\n\t\t\t\t\ttoPath[1],\n\t\t\t\t\ttoPath[2]\n\t\t\t\t);\n\t\t\t} else { // outside the axis area\n\t\t\t\tpath = null;\n\t\t\t}\n\t\t\t\n\t\t\treturn path;\n\t\t},\n\n\t\taddPlotBand: function (options) {\n\t\t\treturn this.addPlotBandOrLine(options, 'plotBands');\n\t\t},\n\t\t\n\t\taddPlotLine: function (options) {\n\t\t\treturn this.addPlotBandOrLine(options, 'plotLines');\n\t\t},\n\n\t\t/**\n\t\t * Add a plot band or plot line after render time\n\t\t *\n\t\t * @param options {Object} The plotBand or plotLine configuration object\n\t\t */\n\t\taddPlotBandOrLine: function (options, coll) {\n\t\t\tvar obj = new Highcharts.PlotLineOrBand(this, options).render(),\n\t\t\t\tuserOptions = this.userOptions;\n\n\t\t\tif (obj) { // #2189\n\t\t\t\t// Add it to the user options for exporting and Axis.update\n\t\t\t\tif (coll) {\n\t\t\t\t\tuserOptions[coll] = userOptions[coll] || [];\n\t\t\t\t\tuserOptions[coll].push(options); \n\t\t\t\t}\n\t\t\t\tthis.plotLinesAndBands.push(obj); \n\t\t\t}\n\t\t\t\n\t\t\treturn obj;\n\t\t},\n\n\t\t/**\n\t\t * Remove a plot band or plot line from the chart by id\n\t\t * @param {Object} id\n\t\t */\n\t\tremovePlotBandOrLine: function (id) {\n\t\t\tvar plotLinesAndBands = this.plotLinesAndBands,\n\t\t\t\toptions = this.options,\n\t\t\t\tuserOptions = this.userOptions,\n\t\t\t\ti = plotLinesAndBands.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (plotLinesAndBands[i].id === id) {\n\t\t\t\t\tplotLinesAndBands[i].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\teach([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (arr[i].id === id) {\n\t\t\t\t\t\terase(arr, arr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Create a new axis object\n\t * @param {Object} chart\n\t * @param {Object} options\n\t */\n\tvar Axis = Highcharts.Axis = function () {\n\t\tthis.init.apply(this, arguments);\n\t};\n\n\tAxis.prototype = {\n\n\t\t/**\n\t\t * Default options for the X axis - the Y axis has extended defaults\n\t\t */\n\t\tdefaultOptions: {\n\t\t\t// allowDecimals: null,\n\t\t\t// alternateGridColor: null,\n\t\t\t// categories: [],\n\t\t\tdateTimeLabelFormats: {\n\t\t\t\tmillisecond: '%H:%M:%S.%L',\n\t\t\t\tsecond: '%H:%M:%S',\n\t\t\t\tminute: '%H:%M',\n\t\t\t\thour: '%H:%M',\n\t\t\t\tday: '%e. %b',\n\t\t\t\tweek: '%e. %b',\n\t\t\t\tmonth: '%b \\'%y',\n\t\t\t\tyear: '%Y'\n\t\t\t},\n\t\t\tendOnTick: false,\n\t\t\tgridLineColor: '#D8D8D8',\n\t\t\t// gridLineDashStyle: 'solid',\n\t\t\t// gridLineWidth: 0,\n\t\t\t// reversed: false,\n\n\t\t\tlabels: {\n\t\t\t\tenabled: true,\n\t\t\t\t// rotation: 0,\n\t\t\t\t// align: 'center',\n\t\t\t\t// step: null,\n\t\t\t\tstyle: {\n\t\t\t\t\tcolor: '#606060',\n\t\t\t\t\tcursor: 'default',\n\t\t\t\t\tfontSize: '11px'\n\t\t\t\t},\n\t\t\t\tx: 0,\n\t\t\t\ty: 15\n\t\t\t\t/*formatter: function () {\n\t\t\t\t\treturn this.value;\n\t\t\t\t},*/\n\t\t\t},\n\t\t\tlineColor: '#C0D0E0',\n\t\t\tlineWidth: 1,\n\t\t\t//linkedTo: null,\n\t\t\t//max: undefined,\n\t\t\t//min: undefined,\n\t\t\tminPadding: 0.01,\n\t\t\tmaxPadding: 0.01,\n\t\t\t//minRange: null,\n\t\t\tminorGridLineColor: '#E0E0E0',\n\t\t\t// minorGridLineDashStyle: null,\n\t\t\tminorGridLineWidth: 1,\n\t\t\tminorTickColor: '#A0A0A0',\n\t\t\t//minorTickInterval: null,\n\t\t\tminorTickLength: 2,\n\t\t\tminorTickPosition: 'outside', // inside or outside\n\t\t\t//minorTickWidth: 0,\n\t\t\t//opposite: false,\n\t\t\t//offset: 0,\n\t\t\t//plotBands: [{\n\t\t\t//\tevents: {},\n\t\t\t//\tzIndex: 1,\n\t\t\t//\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n\t\t\t//}],\n\t\t\t//plotLines: [{\n\t\t\t//\tevents: {}\n\t\t\t//  dashStyle: {}\n\t\t\t//\tzIndex:\n\t\t\t//\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n\t\t\t//}],\n\t\t\t//reversed: false,\n\t\t\t// showFirstLabel: true,\n\t\t\t// showLastLabel: true,\n\t\t\tstartOfWeek: 1,\n\t\t\tstartOnTick: false,\n\t\t\ttickColor: '#C0D0E0',\n\t\t\t//tickInterval: null,\n\t\t\ttickLength: 10,\n\t\t\ttickmarkPlacement: 'between', // on or between\n\t\t\ttickPixelInterval: 100,\n\t\t\ttickPosition: 'outside',\n\t\t\ttickWidth: 1,\n\t\t\ttitle: {\n\t\t\t\t//text: null,\n\t\t\t\talign: 'middle', // low, middle or high\n\t\t\t\t//margin: 0 for horizontal, 10 for vertical axes,\n\t\t\t\t//rotation: 0,\n\t\t\t\t//side: 'outside',\n\t\t\t\tstyle: {\n\t\t\t\t\tcolor: '#707070'\n\t\t\t\t}\n\t\t\t\t//x: 0,\n\t\t\t\t//y: 0\n\t\t\t},\n\t\t\ttype: 'linear' // linear, logarithmic or datetime\n\t\t},\n\n\t\t/**\n\t\t * This options set extends the defaultOptions for Y axes\n\t\t */\n\t\tdefaultYAxisOptions: {\n\t\t\tendOnTick: true,\n\t\t\tgridLineWidth: 1,\n\t\t\ttickPixelInterval: 72,\n\t\t\tshowLastLabel: true,\n\t\t\tlabels: {\n\t\t\t\tx: -8,\n\t\t\t\ty: 3\n\t\t\t},\n\t\t\tlineWidth: 0,\n\t\t\tmaxPadding: 0.05,\n\t\t\tminPadding: 0.05,\n\t\t\tstartOnTick: true,\n\t\t\ttickWidth: 0,\n\t\t\ttitle: {\n\t\t\t\trotation: 270,\n\t\t\t\ttext: 'Values'\n\t\t\t},\n\t\t\tstackLabels: {\n\t\t\t\tenabled: false,\n\t\t\t\t//align: dynamic,\n\t\t\t\t//y: dynamic,\n\t\t\t\t//x: dynamic,\n\t\t\t\t//verticalAlign: dynamic,\n\t\t\t\t//textAlign: dynamic,\n\t\t\t\t//rotation: 0,\n\t\t\t\tformatter: function () {\n\t\t\t\t\treturn Highcharts.numberFormat(this.total, -1);\n\t\t\t\t},\n\t\t\t\tstyle: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * These options extend the defaultOptions for left axes\n\t\t */\n\t\tdefaultLeftAxisOptions: {\n\t\t\tlabels: {\n\t\t\t\tx: -15,\n\t\t\t\ty: null\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\trotation: 270\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * These options extend the defaultOptions for right axes\n\t\t */\n\t\tdefaultRightAxisOptions: {\n\t\t\tlabels: {\n\t\t\t\tx: 15,\n\t\t\t\ty: null\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\trotation: 90\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * These options extend the defaultOptions for bottom axes\n\t\t */\n\t\tdefaultBottomAxisOptions: {\n\t\t\tlabels: {\n\t\t\t\tautoRotation: [-45],\n\t\t\t\tx: 0,\n\t\t\t\ty: null // based on font size\n\t\t\t\t// overflow: undefined,\n\t\t\t\t// staggerLines: null\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\trotation: 0\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * These options extend the defaultOptions for top axes\n\t\t */\n\t\tdefaultTopAxisOptions: {\n\t\t\tlabels: {\n\t\t\t\tautoRotation: [-45],\n\t\t\t\tx: 0,\n\t\t\t\ty: -15\n\t\t\t\t// overflow: undefined\n\t\t\t\t// staggerLines: null\n\t\t\t},\n\t\t\ttitle: {\n\t\t\t\trotation: 0\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Initialize the axis\n\t\t */\n\t\tinit: function (chart, userOptions) {\n\n\n\t\t\tvar isXAxis = userOptions.isX,\n\t\t\t\taxis = this;\n\n\t\t\t// Flag, is the axis horizontal\n\t\t\taxis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n\t\t\t// Flag, isXAxis\n\t\t\taxis.isXAxis = isXAxis;\n\t\t\taxis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n\t\t\taxis.opposite = userOptions.opposite; // needed in setOptions\n\t\t\taxis.side = userOptions.side || (axis.horiz ?\n\t\t\t\t\t(axis.opposite ? 0 : 2) : // top : bottom\n\t\t\t\t\t(axis.opposite ? 1 : 3));  // right : left\n\n\t\t\taxis.setOptions(userOptions);\n\n\n\t\t\tvar options = this.options,\n\t\t\t\ttype = options.type,\n\t\t\t\tisDatetimeAxis = type === 'datetime';\n\n\t\t\taxis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n\t\t\t// Flag, stagger lines or not\n\t\t\taxis.userOptions = userOptions;\n\n\t\t\t//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n\t\t\taxis.minPixelPadding = 0;\n\t\t\t//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series\n\t\t\t//axis.ignoreMaxPadding = UNDEFINED;\n\n\t\t\taxis.chart = chart;\n\t\t\taxis.reversed = options.reversed;\n\t\t\taxis.zoomEnabled = options.zoomEnabled !== false;\n\n\t\t\t// Initial categories\n\t\t\taxis.categories = options.categories || type === 'category';\n\t\t\taxis.names = axis.names || []; // Preserve on update (#3830)\n\n\t\t\t// Elements\n\t\t\t//axis.axisGroup = UNDEFINED;\n\t\t\t//axis.gridGroup = UNDEFINED;\n\t\t\t//axis.axisTitle = UNDEFINED;\n\t\t\t//axis.axisLine = UNDEFINED;\n\n\t\t\t// Shorthand types\n\t\t\taxis.isLog = type === 'logarithmic';\n\t\t\taxis.isDatetimeAxis = isDatetimeAxis;\n\n\t\t\t// Flag, if axis is linked to another axis\n\t\t\taxis.isLinked = defined(options.linkedTo);\n\t\t\t// Linked axis.\n\t\t\t//axis.linkedParent = UNDEFINED;\n\n\t\t\t// Tick positions\n\t\t\t//axis.tickPositions = UNDEFINED; // array containing predefined positions\n\t\t\t// Tick intervals\n\t\t\t//axis.tickInterval = UNDEFINED;\n\t\t\t//axis.minorTickInterval = UNDEFINED;\n\n\t\t\t\n\t\t\t// Major ticks\n\t\t\taxis.ticks = {};\n\t\t\taxis.labelEdge = [];\n\t\t\t// Minor ticks\n\t\t\taxis.minorTicks = {};\n\n\t\t\t// List of plotLines/Bands\n\t\t\taxis.plotLinesAndBands = [];\n\n\t\t\t// Alternate bands\n\t\t\taxis.alternateBands = {};\n\n\t\t\t// Axis metrics\n\t\t\t//axis.left = UNDEFINED;\n\t\t\t//axis.top = UNDEFINED;\n\t\t\t//axis.width = UNDEFINED;\n\t\t\t//axis.height = UNDEFINED;\n\t\t\t//axis.bottom = UNDEFINED;\n\t\t\t//axis.right = UNDEFINED;\n\t\t\t//axis.transA = UNDEFINED;\n\t\t\t//axis.transB = UNDEFINED;\n\t\t\t//axis.oldTransA = UNDEFINED;\n\t\t\taxis.len = 0;\n\t\t\t//axis.oldMin = UNDEFINED;\n\t\t\t//axis.oldMax = UNDEFINED;\n\t\t\t//axis.oldUserMin = UNDEFINED;\n\t\t\t//axis.oldUserMax = UNDEFINED;\n\t\t\t//axis.oldAxisLength = UNDEFINED;\n\t\t\taxis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n\t\t\taxis.range = options.range;\n\t\t\taxis.offset = options.offset || 0;\n\n\n\t\t\t// Dictionary for stacks\n\t\t\taxis.stacks = {};\n\t\t\taxis.oldStacks = {};\n\t\t\t\n\t\t\t// Min and max in the data\n\t\t\t//axis.dataMin = UNDEFINED,\n\t\t\t//axis.dataMax = UNDEFINED,\n\n\t\t\t// The axis range\n\t\t\taxis.max = null;\n\t\t\taxis.min = null;\n\n\t\t\t// User set min and max\n\t\t\t//axis.userMin = UNDEFINED,\n\t\t\t//axis.userMax = UNDEFINED,\n\n\t\t\t// Crosshair options\n\t\t\taxis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n\t\t\t// Run Axis\n\n\t\t\tvar eventType,\n\t\t\t\tevents = axis.options.events;\n\n\t\t\t// Register\n\t\t\tif (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n\t\t\t\tif (isXAxis && !this.isColorAxis) { // #2713\n\t\t\t\t\tchart.axes.splice(chart.xAxis.length, 0, axis);\n\t\t\t\t} else {\n\t\t\t\t\tchart.axes.push(axis);\n\t\t\t\t}\n\n\t\t\t\tchart[axis.coll].push(axis);\n\t\t\t}\n\n\t\t\taxis.series = axis.series || []; // populated by Series\n\n\t\t\t// inverted charts have reversed xAxes as default\n\t\t\tif (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n\t\t\t\taxis.reversed = true;\n\t\t\t}\n\n\t\t\taxis.removePlotBand = axis.removePlotBandOrLine;\n\t\t\taxis.removePlotLine = axis.removePlotBandOrLine;\n\n\n\t\t\t// register event listeners\n\t\t\tfor (eventType in events) {\n\t\t\t\taddEvent(axis, eventType, events[eventType]);\n\t\t\t}\n\n\t\t\t// extend logarithmic axis\n\t\t\tif (axis.isLog) {\n\t\t\t\taxis.val2lin = log2lin;\n\t\t\t\taxis.lin2val = lin2log;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Merge and set options\n\t\t */\n\t\tsetOptions: function (userOptions) {\n\t\t\tthis.options = merge(\n\t\t\t\tthis.defaultOptions,\n\t\t\t\tthis.isXAxis ? {} : this.defaultYAxisOptions,\n\t\t\t\t[this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n\t\t\t\t\tthis.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n\t\t\t\tmerge(\n\t\t\t\t\tdefaultOptions[this.coll], // if set in setOptions (#1053)\n\t\t\t\t\tuserOptions\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\n\t\t/**\n\t\t * The default label formatter. The context is a special config object for the label.\n\t\t */\n\t\tdefaultLabelFormatter: function () {\n\t\t\tvar axis = this.axis,\n\t\t\t\tvalue = this.value,\n\t\t\t\tcategories = axis.categories,\n\t\t\t\tdateTimeLabelFormat = this.dateTimeLabelFormat,\n\t\t\t\tnumericSymbols = defaultOptions.lang.numericSymbols,\n\t\t\t\ti = numericSymbols && numericSymbols.length,\n\t\t\t\tmulti,\n\t\t\t\tret,\n\t\t\t\tformatOption = axis.options.labels.format,\n\n\t\t\t\t// make sure the same symbol is added for all labels on a linear axis\n\t\t\t\tnumericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n\t\t\tif (formatOption) {\n\t\t\t\tret = format(formatOption, this);\n\n\t\t\t} else if (categories) {\n\t\t\t\tret = value;\n\n\t\t\t} else if (dateTimeLabelFormat) { // datetime axis\n\t\t\t\tret = dateFormat(dateTimeLabelFormat, value);\n\n\t\t\t} else if (i && numericSymbolDetector >= 1000) {\n\t\t\t\t// Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n\t\t\t\t// If we are to enable this in tooltip or other places as well, we can move this\n\t\t\t\t// logic to the numberFormatter and enable it by a parameter.\n\t\t\t\twhile (i-- && ret === UNDEFINED) {\n\t\t\t\t\tmulti = Math.pow(1000, i + 1);\n\t\t\t\t\tif (numericSymbolDetector >= multi && numericSymbols[i] !== null) {\n\t\t\t\t\t\tret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret === UNDEFINED) {\n\t\t\t\tif (mathAbs(value) >= 10000) { // add thousands separators\n\t\t\t\t\tret = Highcharts.numberFormat(value, 0);\n\n\t\t\t\t} else { // small numbers\n\t\t\t\t\tret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Get the minimum and maximum for the series of each axis\n\t\t */\n\t\tgetSeriesExtremes: function () {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart;\n\n\t\t\taxis.hasVisibleSeries = false;\n\n\t\t\t// Reset properties in case we're redrawing (#3353)\n\t\t\taxis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;\n\t\t\t\n\t\t\tif (axis.buildStacks) {\n\t\t\t\taxis.buildStacks();\n\t\t\t}\n\n\t\t\t// loop through this axis' series\n\t\t\teach(axis.series, function (series) {\n\n\t\t\t\tif (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n\t\t\t\t\tvar seriesOptions = series.options,\n\t\t\t\t\t\txData,\n\t\t\t\t\t\tthreshold = seriesOptions.threshold,\n\t\t\t\t\t\tseriesDataMin,\n\t\t\t\t\t\tseriesDataMax;\n\n\t\t\t\t\taxis.hasVisibleSeries = true;\n\n\t\t\t\t\t// Validate threshold in logarithmic axes\n\t\t\t\t\tif (axis.isLog && threshold <= 0) {\n\t\t\t\t\t\tthreshold = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get dataMin and dataMax for X axes\n\t\t\t\t\tif (axis.isXAxis) {\n\t\t\t\t\t\txData = series.xData;\n\t\t\t\t\t\tif (xData.length) {\n\t\t\t\t\t\t\taxis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));\n\t\t\t\t\t\t\taxis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Get this particular series extremes\n\t\t\t\t\t\tseries.getExtremes();\n\t\t\t\t\t\tseriesDataMax = series.dataMax;\n\t\t\t\t\t\tseriesDataMin = series.dataMin;\n\n\t\t\t\t\t\t// Get the dataMin and dataMax so far. If percentage is used, the min and max are\n\t\t\t\t\t\t// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n\t\t\t\t\t\t// doesn't have active y data, we continue with nulls\n\t\t\t\t\t\tif (defined(seriesDataMin) && defined(seriesDataMax)) {\n\t\t\t\t\t\t\taxis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n\t\t\t\t\t\t\taxis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Adjust to threshold\n\t\t\t\t\t\tif (defined(threshold)) {\n\t\t\t\t\t\t\tif (axis.dataMin >= threshold) {\n\t\t\t\t\t\t\t\taxis.dataMin = threshold;\n\t\t\t\t\t\t\t\taxis.ignoreMinPadding = true;\n\t\t\t\t\t\t\t} else if (axis.dataMax < threshold) {\n\t\t\t\t\t\t\t\taxis.dataMax = threshold;\n\t\t\t\t\t\t\t\taxis.ignoreMaxPadding = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Translate from axis value to pixel position on the chart, or back\n\t\t *\n\t\t */\n\t\ttranslate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n\t\t\tvar axis = this,\n\t\t\t\tsign = 1,\n\t\t\t\tcvsOffset = 0,\n\t\t\t\tlocalA = old ? axis.oldTransA : axis.transA,\n\t\t\t\tlocalMin = old ? axis.oldMin : axis.min,\n\t\t\t\treturnValue,\n\t\t\t\tminPixelPadding = axis.minPixelPadding,\n\t\t\t\tdoPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;\n\n\t\t\tif (!localA) {\n\t\t\t\tlocalA = axis.transA;\n\t\t\t}\n\n\t\t\t// In vertical axes, the canvas coordinates start from 0 at the top like in\n\t\t\t// SVG.\n\t\t\tif (cvsCoord) {\n\t\t\t\tsign *= -1; // canvas coordinates inverts the value\n\t\t\t\tcvsOffset = axis.len;\n\t\t\t}\n\n\t\t\t// Handle reversed axis\n\t\t\tif (axis.reversed) {\n\t\t\t\tsign *= -1;\n\t\t\t\tcvsOffset -= sign * (axis.sector || axis.len);\n\t\t\t}\n\n\t\t\t// From pixels to value\n\t\t\tif (backwards) { // reverse translation\n\n\t\t\t\tval = val * sign + cvsOffset;\n\t\t\t\tval -= minPixelPadding;\n\t\t\t\treturnValue = val / localA + localMin; // from chart pixel to value\n\t\t\t\tif (doPostTranslate) { // log and ordinal axes\n\t\t\t\t\treturnValue = axis.lin2val(returnValue);\n\t\t\t\t}\n\n\t\t\t// From value to pixels\n\t\t\t} else {\n\t\t\t\tif (doPostTranslate) { // log and ordinal axes\n\t\t\t\t\tval = axis.val2lin(val);\n\t\t\t\t}\n\t\t\t\tif (pointPlacement === 'between') {\n\t\t\t\t\tpointPlacement = 0.5;\n\t\t\t\t}\n\t\t\t\treturnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n\t\t\t\t\t(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t},\n\n\t\t/**\n\t\t * Utility method to translate an axis value to pixel position.\n\t\t * @param {Number} value A value in terms of axis units\n\t\t * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n\t\t *        or just the axis/pane itself.\n\t\t */\n\t\ttoPixels: function (value, paneCoordinates) {\n\t\t\treturn this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n\t\t},\n\n\t\t/*\n\t\t * Utility method to translate a pixel position in to an axis value\n\t\t * @param {Number} pixel The pixel value coordinate\n\t\t * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n\t\t *        axis/pane itself.\n\t\t */\n\t\ttoValue: function (pixel, paneCoordinates) {\n\t\t\treturn this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n\t\t},\n\n\t\t/**\n\t\t * Create the path for a plot line that goes from the given value on\n\t\t * this axis, across the plot to the opposite side\n\t\t * @param {Number} value\n\t\t * @param {Number} lineWidth Used for calculation crisp line\n\t\t * @param {Number] old Use old coordinates (for resizing and rescaling)\n\t\t */\n\t\tgetPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart,\n\t\t\t\taxisLeft = axis.left,\n\t\t\t\taxisTop = axis.top,\n\t\t\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2,\n\t\t\t\tcHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n\t\t\t\tcWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n\t\t\t\tskip,\n\t\t\t\ttransB = axis.transB,\n\t\t\t\t/**\n\t\t\t\t * Check if x is between a and b. If not, either move to a/b or skip, \n\t\t\t\t * depending on the force parameter.\n\t\t\t\t */\n\t\t\t\tbetween = function (x, a, b) {\n\t\t\t\t\tif (x < a || x > b) {\n\t\t\t\t\t\tif (force) {\n\t\t\t\t\t\t\tx = mathMin(mathMax(a, x), b);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tskip = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn x;\n\t\t\t\t};\n\n\t\t\ttranslatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n\t\t\tx1 = x2 = mathRound(translatedValue + transB);\n\t\t\ty1 = y2 = mathRound(cHeight - translatedValue - transB);\n\n\t\t\tif (isNaN(translatedValue)) { // no min or max\n\t\t\t\tskip = true;\n\n\t\t\t} else if (axis.horiz) {\n\t\t\t\ty1 = axisTop;\n\t\t\t\ty2 = cHeight - axis.bottom;\n\t\t\t\tx1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n\t\t\t} else {\n\t\t\t\tx1 = axisLeft;\n\t\t\t\tx2 = cWidth - axis.right;\n\t\t\t\ty1 = y2 = between(y1, axisTop, axisTop + axis.height);\n\t\t\t}\n\t\t\treturn skip && !force ?\n\t\t\t\tnull :\n\t\t\t\tchart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);\n\t\t},\n\n\t\t/**\n\t\t * Set the tick positions of a linear axis to round values like whole tens or every five.\n\t\t */\n\t\tgetLinearTickPositions: function (tickInterval, min, max) {\n\t\t\tvar pos,\n\t\t\t\tlastPos,\n\t\t\t\troundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n\t\t\t\troundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n\t\t\t\ttickPositions = [];\n\n\t\t\t// For single points, add a tick regardless of the relative position (#2662)\n\t\t\tif (min === max && isNumber(min)) {\n\t\t\t\treturn [min];\n\t\t\t}\n\n\t\t\t// Populate the intermediate values\n\t\t\tpos = roundedMin;\n\t\t\twhile (pos <= roundedMax) {\n\n\t\t\t\t// Place the tick on the rounded value\n\t\t\t\ttickPositions.push(pos);\n\n\t\t\t\t// Always add the raw tickInterval, not the corrected one.\n\t\t\t\tpos = correctFloat(pos + tickInterval);\n\n\t\t\t\t// If the interval is not big enough in the current min - max range to actually increase\n\t\t\t\t// the loop variable, we need to break out to prevent endless loop. Issue #619\n\t\t\t\tif (pos === lastPos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Record the last value\n\t\t\t\tlastPos = pos;\n\t\t\t}\n\t\t\treturn tickPositions;\n\t\t},\n\n\t\t/**\n\t\t * Return the minor tick positions. For logarithmic axes, reuse the same logic\n\t\t * as for major ticks.\n\t\t */\n\t\tgetMinorTickPositions: function () {\n\t\t\tvar axis = this,\n\t\t\t\toptions = axis.options,\n\t\t\t\ttickPositions = axis.tickPositions,\n\t\t\t\tminorTickInterval = axis.minorTickInterval,\n\t\t\t\tminorTickPositions = [],\n\t\t\t\tpos,\n\t\t\t\ti,\n\t\t\t\tmin = axis.min,\n\t\t\t\tmax = axis.max,\n\t\t\t\trange = max - min,\n\t\t\t\tlen;\n\n\t\t\t// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n\t\t\tif (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n\t\t\t\tif (axis.isLog) {\n\t\t\t\t\tlen = tickPositions.length;\n\t\t\t\t\tfor (i = 1; i < len; i++) {\n\t\t\t\t\t\tminorTickPositions = minorTickPositions.concat(\n\t\t\t\t\t\t\taxis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n\t\t\t\t\tminorTickPositions = minorTickPositions.concat(\n\t\t\t\t\t\taxis.getTimeTicks(\n\t\t\t\t\t\t\taxis.normalizeTimeTickInterval(minorTickInterval),\n\t\t\t\t\t\t\tmin,\n\t\t\t\t\t\t\tmax,\n\t\t\t\t\t\t\toptions.startOfWeek\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n\t\t\t\t\t\tminorTickPositions.push(pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taxis.trimTicks(minorTickPositions); // #3652 #3743\n\t\t\treturn minorTickPositions;\n\t\t},\n\n\t\t/**\n\t\t * Adjust the min and max for the minimum range. Keep in mind that the series data is\n\t\t * not yet processed, so we don't have information on data cropping and grouping, or\n\t\t * updated axis.pointRange or series.pointRange. The data can't be processed until\n\t\t * we have finally established min and max.\n\t\t */\n\t\tadjustForMinRange: function () {\n\t\t\tvar axis = this,\n\t\t\t\toptions = axis.options,\n\t\t\t\tmin = axis.min,\n\t\t\t\tmax = axis.max,\n\t\t\t\tzoomOffset,\n\t\t\t\tspaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n\t\t\t\tclosestDataRange,\n\t\t\t\ti,\n\t\t\t\tdistance,\n\t\t\t\txData,\n\t\t\t\tloopLength,\n\t\t\t\tminArgs,\n\t\t\t\tmaxArgs;\n\n\t\t\t// Set the automatic minimum range based on the closest point distance\n\t\t\tif (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n\t\t\t\tif (defined(options.min) || defined(options.max)) {\n\t\t\t\t\taxis.minRange = null; // don't do this again\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Find the closest distance between raw data points, as opposed to\n\t\t\t\t\t// closestPointRange that applies to processed points (cropped and grouped)\n\t\t\t\t\teach(axis.series, function (series) {\n\t\t\t\t\t\txData = series.xData;\n\t\t\t\t\t\tloopLength = series.xIncrement ? 1 : xData.length - 1;\n\t\t\t\t\t\tfor (i = loopLength; i > 0; i--) {\n\t\t\t\t\t\t\tdistance = xData[i] - xData[i - 1];\n\t\t\t\t\t\t\tif (closestDataRange === UNDEFINED || distance < closestDataRange) {\n\t\t\t\t\t\t\t\tclosestDataRange = distance;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\taxis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if minRange is exceeded, adjust\n\t\t\tif (max - min < axis.minRange) {\n\t\t\t\tvar minRange = axis.minRange;\n\t\t\t\tzoomOffset = (minRange - max + min) / 2;\n\n\t\t\t\t// if min and max options have been set, don't go beyond it\n\t\t\t\tminArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n\t\t\t\tif (spaceAvailable) { // if space is available, stay within the data range\n\t\t\t\t\tminArgs[2] = axis.dataMin;\n\t\t\t\t}\n\t\t\t\tmin = arrayMax(minArgs);\n\n\t\t\t\tmaxArgs = [min + minRange, pick(options.max, min + minRange)];\n\t\t\t\tif (spaceAvailable) { // if space is availabe, stay within the data range\n\t\t\t\t\tmaxArgs[2] = axis.dataMax;\n\t\t\t\t}\n\n\t\t\t\tmax = arrayMin(maxArgs);\n\n\t\t\t\t// now if the max is adjusted, adjust the min back\n\t\t\t\tif (max - min < minRange) {\n\t\t\t\t\tminArgs[0] = max - minRange;\n\t\t\t\t\tminArgs[1] = pick(options.min, max - minRange);\n\t\t\t\t\tmin = arrayMax(minArgs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Record modified extremes\n\t\t\taxis.min = min;\n\t\t\taxis.max = max;\n\t\t},\n\n\t\t/**\n\t\t * Update translation information\n\t\t */\n\t\tsetAxisTranslation: function (saveOld) {\n\t\t\tvar axis = this,\n\t\t\t\trange = axis.max - axis.min,\n\t\t\t\tpointRange = axis.axisPointRange || 0,\n\t\t\t\tclosestPointRange,\n\t\t\t\tminPointOffset = 0,\n\t\t\t\tpointRangePadding = 0,\n\t\t\t\tlinkedParent = axis.linkedParent,\n\t\t\t\tordinalCorrection,\n\t\t\t\thasCategories = !!axis.categories,\n\t\t\t\ttransA = axis.transA,\n\t\t\t\tisXAxis = axis.isXAxis;\n\n\t\t\t// Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n\t\t\tif (isXAxis || hasCategories || pointRange) {\n\t\t\t\tif (linkedParent) {\n\t\t\t\t\tminPointOffset = linkedParent.minPointOffset;\n\t\t\t\t\tpointRangePadding = linkedParent.pointRangePadding;\n\n\t\t\t\t} else {\n\t\t\t\t\teach(axis.series, function (series) {\n\t\t\t\t\t\tvar seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806\n\t\t\t\t\t\t\tpointPlacement = series.options.pointPlacement,\n\t\t\t\t\t\t\tseriesClosestPointRange = series.closestPointRange;\n\n\t\t\t\t\t\tif (seriesPointRange > range) { // #1446\n\t\t\t\t\t\t\tseriesPointRange = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointRange = mathMax(pointRange, seriesPointRange);\n\n\t\t\t\t\t\tif (!axis.single) {\n\t\t\t\t\t\t\t// minPointOffset is the value padding to the left of the axis in order to make\n\t\t\t\t\t\t\t// room for points with a pointRange, typically columns. When the pointPlacement option\n\t\t\t\t\t\t\t// is 'between' or 'on', this padding does not apply.\n\t\t\t\t\t\t\tminPointOffset = mathMax(\n\t\t\t\t\t\t\t\tminPointOffset,\n\t\t\t\t\t\t\t\tisString(pointPlacement) ? 0 : seriesPointRange / 2\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Determine the total padding needed to the length of the axis to make room for the\n\t\t\t\t\t\t\t// pointRange. If the series' pointPlacement is 'on', no padding is added.\n\t\t\t\t\t\t\tpointRangePadding = mathMax(\n\t\t\t\t\t\t\t\tpointRangePadding,\n\t\t\t\t\t\t\t\tpointPlacement === 'on' ? 0 : seriesPointRange\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set the closestPointRange\n\t\t\t\t\t\tif (!series.noSharedTooltip && defined(seriesClosestPointRange)) {\n\t\t\t\t\t\t\tclosestPointRange = defined(closestPointRange) ?\n\t\t\t\t\t\t\t\tmathMin(closestPointRange, seriesClosestPointRange) :\n\t\t\t\t\t\t\t\tseriesClosestPointRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Record minPointOffset and pointRangePadding\n\t\t\t\tordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n\t\t\t\taxis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n\t\t\t\taxis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n\t\t\t\t// pointRange means the width reserved for each point, like in a column chart\n\t\t\t\taxis.pointRange = mathMin(pointRange, range);\n\n\t\t\t\t// closestPointRange means the closest distance between points. In columns\n\t\t\t\t// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n\t\t\t\t// is some other value\n\t\t\t\tif (isXAxis) {\n\t\t\t\t\taxis.closestPointRange = closestPointRange;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Secondary values\n\t\t\tif (saveOld) {\n\t\t\t\taxis.oldTransA = transA;\n\t\t\t}\n\t\t\taxis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n\t\t\taxis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n\t\t\taxis.minPixelPadding = transA * minPointOffset;\n\t\t},\n\n\t\t/**\n\t\t * Set the tick positions to round values and optionally extend the extremes\n\t\t * to the nearest tick\n\t\t */\n\t\tsetTickInterval: function (secondPass) {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart,\n\t\t\t\toptions = axis.options,\n\t\t\t\tisLog = axis.isLog,\n\t\t\t\tisDatetimeAxis = axis.isDatetimeAxis,\n\t\t\t\tisXAxis = axis.isXAxis,\n\t\t\t\tisLinked = axis.isLinked,\n\t\t\t\tmaxPadding = options.maxPadding,\n\t\t\t\tminPadding = options.minPadding,\n\t\t\t\tlength,\n\t\t\t\tlinkedParentExtremes,\n\t\t\t\ttickIntervalOption = options.tickInterval,\n\t\t\t\tminTickInterval,\n\t\t\t\ttickPixelIntervalOption = options.tickPixelInterval,\n\t\t\t\tcategories = axis.categories;\n\n\t\t\tif (!isDatetimeAxis && !categories && !isLinked) {\n\t\t\t\tthis.getTickAmount();\n\t\t\t}\n\n\t\t\t// linked axis gets the extremes from the parent axis\n\t\t\tif (isLinked) {\n\t\t\t\taxis.linkedParent = chart[axis.coll][options.linkedTo];\n\t\t\t\tlinkedParentExtremes = axis.linkedParent.getExtremes();\n\t\t\t\taxis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n\t\t\t\taxis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n\t\t\t\tif (options.type !== axis.linkedParent.options.type) {\n\t\t\t\t\terror(11, 1); // Can't link axes of different type\n\t\t\t\t}\n\t\t\t} else { // initial min and max from the extreme data values\n\t\t\t\taxis.min = pick(axis.userMin, options.min, axis.dataMin);\n\t\t\t\taxis.max = pick(axis.userMax, options.max, axis.dataMax);\n\t\t\t}\n\n\t\t\tif (isLog) {\n\t\t\t\tif (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n\t\t\t\t\terror(10, 1); // Can't plot negative values on log axis\n\t\t\t\t}\n\t\t\t\taxis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934\n\t\t\t\taxis.max = correctFloat(log2lin(axis.max));\n\t\t\t}\n\n\t\t\t// handle zoomed range\n\t\t\tif (axis.range && defined(axis.max)) {\n\t\t\t\taxis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618\n\t\t\t\taxis.userMax = axis.max;\n\n\t\t\t\taxis.range = null;  // don't use it when running setExtremes\n\t\t\t}\n\n\t\t\t// Hook for adjusting this.min and this.max. Used by bubble series.\n\t\t\tif (axis.beforePadding) {\n\t\t\t\taxis.beforePadding();\n\t\t\t}\n\n\t\t\t// adjust min and max for the minimum range\n\t\t\taxis.adjustForMinRange();\n\n\t\t\t// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n\t\t\t// into account, we do this after computing tick interval (#1337).\n\t\t\tif (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n\t\t\t\tlength = axis.max - axis.min;\n\t\t\t\tif (length) {\n\t\t\t\t\tif (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {\n\t\t\t\t\t\taxis.min -= length * minPadding;\n\t\t\t\t\t}\n\t\t\t\t\tif (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {\n\t\t\t\t\t\taxis.max += length * maxPadding;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Stay within floor and ceiling\n\t\t\tif (isNumber(options.floor)) {\n\t\t\t\taxis.min = mathMax(axis.min, options.floor);\n\t\t\t}\n\t\t\tif (isNumber(options.ceiling)) {\n\t\t\t\taxis.max = mathMin(axis.max, options.ceiling);\n\t\t\t}\n\n\t\t\t// get tickInterval\n\t\t\tif (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n\t\t\t\taxis.tickInterval = 1;\n\t\t\t} else if (isLinked && !tickIntervalOption &&\n\t\t\t\t\ttickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n\t\t\t\taxis.tickInterval = axis.linkedParent.tickInterval;\n\t\t\t} else {\n\t\t\t\taxis.tickInterval = pick(\n\t\t\t\t\ttickIntervalOption,\n\t\t\t\t\tthis.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,\n\t\t\t\t\tcategories ? // for categoried axis, 1 is default, for linear axis use tickPix\n\t\t\t\t\t\t1 :\n\t\t\t\t\t\t// don't let it be more than the data range\n\t\t\t\t\t\t(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Now we're finished detecting min and max, crop and group series data. This\n\t\t\t// is in turn needed in order to find tick positions in ordinal axes.\n\t\t\tif (isXAxis && !secondPass) {\n\t\t\t\teach(axis.series, function (series) {\n\t\t\t\t\tseries.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// set the translation factor used in translate function\n\t\t\taxis.setAxisTranslation(true);\n\n\t\t\t// hook for ordinal axes and radial axes\n\t\t\tif (axis.beforeSetTickPositions) {\n\t\t\t\taxis.beforeSetTickPositions();\n\t\t\t}\n\n\t\t\t// hook for extensions, used in Highstock ordinal axes\n\t\t\tif (axis.postProcessTickInterval) {\n\t\t\t\taxis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n\t\t\t}\n\n\t\t\t// In column-like charts, don't cramp in more ticks than there are points (#1943)\n\t\t\tif (axis.pointRange) {\n\t\t\t\taxis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);\n\t\t\t}\n\n\t\t\t// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n\t\t\tminTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n\t\t\tif (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n\t\t\t\taxis.tickInterval = minTickInterval;\n\t\t\t}\n\n\t\t\t// for linear axes, get magnitude and normalize the interval\n\t\t\tif (!isDatetimeAxis && !isLog) { // linear\n\t\t\t\tif (!tickIntervalOption) {\n\t\t\t\t\taxis.tickInterval = normalizeTickInterval(\n\t\t\t\t\t\taxis.tickInterval, \n\t\t\t\t\t\tnull, \n\t\t\t\t\t\tgetMagnitude(axis.tickInterval), \n\t\t\t\t\t\t// If the tick interval is between 0.5 and 5 and the axis max is in the order of\n\t\t\t\t\t\t// thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n\t\t\t\t\t\tpick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n\t\t\t\t\t\t!!this.tickAmount\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prevent ticks from getting so close that we can't draw the labels\n\t\t\tif (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n\t\t\t\taxis.tickInterval = axis.unsquish();\n\t\t\t}\n\n\t\t\tthis.setTickPositions();\n\t\t},\n\n\t\t/**\n\t\t * Now we have computed the normalized tickInterval, get the tick positions\n\t\t */\n\t\tsetTickPositions: function () {\n\n\t\t\tvar options = this.options,\n\t\t\t\ttickPositions,\n\t\t\t\ttickPositionsOption = options.tickPositions,\n\t\t\t\ttickPositioner = options.tickPositioner,\n\t\t\t\tstartOnTick = options.startOnTick,\n\t\t\t\tendOnTick = options.endOnTick,\n\t\t\t\tsingle;\n\n\t\t\t// Set the tickmarkOffset\n\t\t\tthis.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && \n\t\t\t\tthis.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n\t\t\t// get minorTickInterval\n\t\t\tthis.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n\t\t\t\tthis.tickInterval / 5 : options.minorTickInterval;\n\n\t\t\t// Find the tick positions\n\t\t\tthis.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)\n\t\t\tif (!tickPositions) {\n\n\t\t\t\tif (this.isDatetimeAxis) {\n\t\t\t\t\ttickPositions = this.getTimeTicks(\n\t\t\t\t\t\tthis.normalizeTimeTickInterval(this.tickInterval, options.units),\n\t\t\t\t\t\tthis.min,\n\t\t\t\t\t\tthis.max,\n\t\t\t\t\t\toptions.startOfWeek,\n\t\t\t\t\t\tthis.ordinalPositions,\n\t\t\t\t\t\tthis.closestPointRange,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t} else if (this.isLog) {\n\t\t\t\t\ttickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n\t\t\t\t} else {\n\t\t\t\t\ttickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n\t\t\t\t}\n\n\t\t\t\tthis.tickPositions = tickPositions;\n\n\t\t\t\t// Run the tick positioner callback, that allows modifying auto tick positions.\n\t\t\t\tif (tickPositioner) {\n\t\t\t\t\ttickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n\t\t\t\t\tif (tickPositioner) {\n\t\t\t\t\t\tthis.tickPositions = tickPositions = tickPositioner;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!this.isLinked) {\n\n\t\t\t\t// reset min/max or remove extremes based on start/end on tick\n\t\t\t\tthis.trimTicks(tickPositions, startOnTick, endOnTick);\n\n\t\t\t\t// When there is only one point, or all points have the same value on this axis, then min\n\t\t\t\t// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n\t\t\t\t// in order to center the point, but leave it with one tick. #1337.\n\t\t\t\tif (this.min === this.max && defined(this.min) && !this.tickAmount) {\n\t\t\t\t\t// Substract half a unit (#2619, #2846, #2515, #3390)\n\t\t\t\t\tsingle = true;\n\t\t\t\t\tthis.min -= 0.5;\n\t\t\t\t\tthis.max += 0.5;\n\t\t\t\t}\n\t\t\t\tthis.single = single;\n\n\t\t\t\tif (!tickPositionsOption && !tickPositioner) {\n\t\t\t\t\tthis.adjustTickAmount();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n\t\t */\n\t\ttrimTicks: function (tickPositions, startOnTick, endOnTick) {\n\t\t\tvar roundedMin = tickPositions[0],\n\t\t\t\troundedMax = tickPositions[tickPositions.length - 1],\n\t\t\t\tminPointOffset = this.minPointOffset || 0;\n\t\t\t\t\n\t\t\tif (startOnTick) {\n\t\t\t\tthis.min = roundedMin;\n\t\t\t} else if (this.min - minPointOffset > roundedMin) {\n\t\t\t\ttickPositions.shift();\n\t\t\t}\n\n\t\t\tif (endOnTick) {\n\t\t\t\tthis.max = roundedMax;\n\t\t\t} else if (this.max + minPointOffset < roundedMax) {\n\t\t\t\ttickPositions.pop();\n\t\t\t}\n\n\t\t\t// If no tick are left, set one tick in the middle (#3195) \n\t\t\tif (tickPositions.length === 0 && defined(roundedMin)) {\n\t\t\t\ttickPositions.push((roundedMax + roundedMin) / 2);\n\t\t\t}\t\t\n\t\t},\n\n\t\t/**\n\t\t * Set the max ticks of either the x and y axis collection\n\t\t */\n\t\tgetTickAmount: function () {\n\t\t\tvar others = {}, // Whether there is another axis to pair with this one\n\t\t\t\thasOther,\n\t\t\t\toptions = this.options,\n\t\t\t\ttickAmount = options.tickAmount,\n\t\t\t\ttickPixelInterval = options.tickPixelInterval;\n\n\t\t\tif (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n\t\t\t\t\t!this.isLog && options.startOnTick && options.endOnTick) {\n\t\t\t\ttickAmount = 2;\n\t\t\t}\n\n\t\t\tif (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n\t\t\t\t// Check if there are multiple axes in the same pane\n\t\t\t\teach(this.chart[this.coll], function (axis) {\n\t\t\t\t\tvar options = axis.options,\n\t\t\t\t\t\thoriz = axis.horiz,\n\t\t\t\t\t\tkey = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');\n\t\t\t\t\t\n\t\t\t\t\tif (others[key]) {\n\t\t\t\t\t\thasOther = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tothers[key] = 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (hasOther) {\n\t\t\t\t\t// Add 1 because 4 tick intervals require 5 ticks (including first and last)\n\t\t\t\t\ttickAmount = mathCeil(this.len / tickPixelInterval) + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n\t\t\t// prevents the axis from adding ticks that are too far away from the data extremes.\n\t\t\tif (tickAmount < 4) {\n\t\t\t\tthis.finalTickAmt = tickAmount;\n\t\t\t\ttickAmount = 5;\n\t\t\t}\n\t\t\t\n\t\t\tthis.tickAmount = tickAmount;\n\t\t},\n\n\t\t/**\n\t\t * When using multiple axes, adjust the number of ticks to match the highest\n\t\t * number of ticks in that group\n\t\t */\n\t\tadjustTickAmount: function () {\n\t\t\tvar tickInterval = this.tickInterval,\n\t\t\t\ttickPositions = this.tickPositions,\n\t\t\t\ttickAmount = this.tickAmount,\n\t\t\t\tfinalTickAmt = this.finalTickAmt,\n\t\t\t\tcurrentTickAmount = tickPositions && tickPositions.length,\n\t\t\t\ti,\n\t\t\t\tlen;\n\n\t\t\tif (currentTickAmount < tickAmount) { // TODO: Check #3411\n\t\t\t\twhile (tickPositions.length < tickAmount) {\n\t\t\t\t\ttickPositions.push(correctFloat(\n\t\t\t\t\t\ttickPositions[tickPositions.length - 1] + tickInterval\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\tthis.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n\t\t\t\tthis.max = tickPositions[tickPositions.length - 1];\n\n\t\t\t// We have too many ticks, run second pass to try to reduce ticks\n\t\t\t} else if (currentTickAmount > tickAmount) {\n\t\t\t\tthis.tickInterval *= 2;\n\t\t\t\tthis.setTickPositions();\n\t\t\t}\n\n\t\t\t// The finalTickAmt property is set in getTickAmount\n\t\t\tif (defined(finalTickAmt)) {\n\t\t\t\ti = len = tickPositions.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n\t\t\t\t\t\t(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n\t\t\t\t\t) {\n\t\t\t\t\t\ttickPositions.splice(i, 1);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\tthis.finalTickAmt = UNDEFINED;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the scale based on data min and max, user set min and max or options\n\t\t *\n\t\t */\n\t\tsetScale: function () {\n\t\t\tvar axis = this,\n\t\t\t\tstacks = axis.stacks,\n\t\t\t\ttype,\n\t\t\t\ti,\n\t\t\t\tisDirtyData,\n\t\t\t\tisDirtyAxisLength;\n\n\t\t\taxis.oldMin = axis.min;\n\t\t\taxis.oldMax = axis.max;\n\t\t\taxis.oldAxisLength = axis.len;\n\n\t\t\t// set the new axisLength\n\t\t\taxis.setAxisSize();\n\t\t\t//axisLength = horiz ? axisWidth : axisHeight;\n\t\t\tisDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n\t\t\t// is there new data?\n\t\t\teach(axis.series, function (series) {\n\t\t\t\tif (series.isDirtyData || series.isDirty ||\n\t\t\t\t\t\tseries.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n\t\t\t\t\tisDirtyData = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// do we really need to go through all this?\n\t\t\tif (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n\t\t\t\taxis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {\n\n\t\t\t\t// reset stacks\n\t\t\t\tif (!axis.isXAxis) {\n\t\t\t\t\tfor (type in stacks) {\n\t\t\t\t\t\tfor (i in stacks[type]) {\n\t\t\t\t\t\t\tstacks[type][i].total = null;\n\t\t\t\t\t\t\tstacks[type][i].cum = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\taxis.forceRedraw = false;\n\n\t\t\t\t// get data extremes if needed\n\t\t\t\taxis.getSeriesExtremes();\n\n\t\t\t\t// get fixed positions based on tickInterval\n\t\t\t\taxis.setTickInterval();\n\n\t\t\t\t// record old values to decide whether a rescale is necessary later on (#540)\n\t\t\t\taxis.oldUserMin = axis.userMin;\n\t\t\t\taxis.oldUserMax = axis.userMax;\n\n\t\t\t\t// Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n\t\t\t\tif (!axis.isDirty) {\n\t\t\t\t\taxis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n\t\t\t\t}\n\t\t\t} else if (!axis.isXAxis) {\n\t\t\t\tif (axis.oldStacks) {\n\t\t\t\t\tstacks = axis.stacks = axis.oldStacks;\n\t\t\t\t}\n\n\t\t\t\t// reset stacks\n\t\t\t\tfor (type in stacks) {\n\t\t\t\t\tfor (i in stacks[type]) {\n\t\t\t\t\t\tstacks[type][i].cum = stacks[type][i].total;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the extremes and optionally redraw\n\t\t * @param {Number} newMin\n\t\t * @param {Number} newMax\n\t\t * @param {Boolean} redraw\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t * @param {Object} eventArguments\n\t\t *\n\t\t */\n\t\tsetExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart;\n\n\t\t\tredraw = pick(redraw, true); // defaults to true\n\n\t\t\teach(axis.series, function (serie) {\n\t\t\t\tdelete serie.kdTree;\n\t\t\t});\n\n\t\t\t// Extend the arguments with min and max\n\t\t\teventArguments = extend(eventArguments, {\n\t\t\t\tmin: newMin,\n\t\t\t\tmax: newMax\n\t\t\t});\n\n\t\t\t// Fire the event\n\t\t\tfireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n\t\t\t\taxis.userMin = newMin;\n\t\t\t\taxis.userMax = newMax;\n\t\t\t\taxis.eventArgs = eventArguments;\n\n\t\t\t\t// Mark for running afterSetExtremes\n\t\t\t\taxis.isDirtyExtremes = true;\n\n\t\t\t\t// redraw\n\t\t\t\tif (redraw) {\n\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n\t\t * in stock charts.\n\t\t */\n\t\tzoom: function (newMin, newMax) {\n\t\t\tvar dataMin = this.dataMin,\n\t\t\t\tdataMax = this.dataMax,\n\t\t\t\toptions = this.options;\n\n\t\t\t// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n\t\t\tif (!this.allowZoomOutside) {\n\t\t\t\tif (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {\n\t\t\t\t\tnewMin = UNDEFINED;\n\t\t\t\t}\n\t\t\t\tif (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {\n\t\t\t\t\tnewMax = UNDEFINED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In full view, displaying the reset zoom button is not required\n\t\t\tthis.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;\n\n\t\t\t// Do it\n\t\t\tthis.setExtremes(\n\t\t\t\tnewMin,\n\t\t\t\tnewMax,\n\t\t\t\tfalse,\n\t\t\t\tUNDEFINED,\n\t\t\t\t{ trigger: 'zoom' }\n\t\t\t);\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Update the axis metrics\n\t\t */\n\t\tsetAxisSize: function () {\n\t\t\tvar chart = this.chart,\n\t\t\t\toptions = this.options,\n\t\t\t\toffsetLeft = options.offsetLeft || 0,\n\t\t\t\toffsetRight = options.offsetRight || 0,\n\t\t\t\thoriz = this.horiz,\n\t\t\t\twidth = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n\t\t\t\theight = pick(options.height, chart.plotHeight),\n\t\t\t\ttop = pick(options.top, chart.plotTop),\n\t\t\t\tleft = pick(options.left, chart.plotLeft + offsetLeft),\n\t\t\t\tpercentRegex = /%$/;\n\n\t\t\t// Check for percentage based input values\n\t\t\tif (percentRegex.test(height)) {\n\t\t\t\theight = parseFloat(height) / 100 * chart.plotHeight;\n\t\t\t}\n\t\t\tif (percentRegex.test(top)) {\n\t\t\t\ttop = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;\n\t\t\t}\n\n\t\t\t// Expose basic values to use in Series object and navigator\n\t\t\tthis.left = left;\n\t\t\tthis.top = top;\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.bottom = chart.chartHeight - height - top;\n\t\t\tthis.right = chart.chartWidth - width - left;\n\n\t\t\t// Direction agnostic properties\n\t\t\tthis.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905\n\t\t\tthis.pos = horiz ? left : top; // distance from SVG origin\n\t\t},\n\n\t\t/**\n\t\t * Get the actual axis extremes\n\t\t */\n\t\tgetExtremes: function () {\n\t\t\tvar axis = this,\n\t\t\t\tisLog = axis.isLog;\n\n\t\t\treturn {\n\t\t\t\tmin: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n\t\t\t\tmax: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n\t\t\t\tdataMin: axis.dataMin,\n\t\t\t\tdataMax: axis.dataMax,\n\t\t\t\tuserMin: axis.userMin,\n\t\t\t\tuserMax: axis.userMax\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Get the zero plane either based on zero or on the min or max value.\n\t\t * Used in bar and area plots\n\t\t */\n\t\tgetThreshold: function (threshold) {\n\t\t\tvar axis = this,\n\t\t\t\tisLog = axis.isLog;\n\n\t\t\tvar realMin = isLog ? lin2log(axis.min) : axis.min,\n\t\t\t\trealMax = isLog ? lin2log(axis.max) : axis.max;\n\n\t\t\tif (realMin > threshold || threshold === null) {\n\t\t\t\tthreshold = realMin;\n\t\t\t} else if (realMax < threshold) {\n\t\t\t\tthreshold = realMax;\n\t\t\t}\n\n\t\t\treturn axis.translate(threshold, 0, 1, 0, 1);\n\t\t},\n\n\t\t/**\n\t\t * Compute auto alignment for the axis label based on which side the axis is on\n\t\t * and the given rotation for the label\n\t\t */\n\t\tautoLabelAlign: function (rotation) {\n\t\t\tvar ret,\n\t\t\t\tangle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n\t\t\tif (angle > 15 && angle < 165) {\n\t\t\t\tret = 'right';\n\t\t\t} else if (angle > 195 && angle < 345) {\n\t\t\t\tret = 'left';\n\t\t\t} else {\n\t\t\t\tret = 'center';\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n\t\t * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. \n\t\t * On a vertical axis remove ticks and add ellipsis.\n\t\t */\n\t\tunsquish: function () {\n\t\t\tvar chart = this.chart,\n\t\t\t\tticks = this.ticks,\n\t\t\t\tlabelOptions = this.options.labels,\n\t\t\t\thoriz = this.horiz,\n\t\t\t\ttickInterval = this.tickInterval,\n\t\t\t\tnewTickInterval = tickInterval,\n\t\t\t\tslotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n\t\t\t\trotation,\n\t\t\t\trotationOption = labelOptions.rotation,\n\t\t\t\tlabelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n\t\t\t\tstep,\n\t\t\t\tbestScore = Number.MAX_VALUE,\n\t\t\t\tautoRotation,\n\t\t\t\t// Return the multiple of tickInterval that is needed to avoid collision\n\t\t\t\tgetStep = function (spaceNeeded) {\n\t\t\t\t\tvar step = spaceNeeded / (slotSize || 1);\n\t\t\t\t\tstep = step > 1 ? mathCeil(step) : 1;\n\t\t\t\t\treturn step * tickInterval;\n\t\t\t\t};\n\t\t\t\n\t\t\tif (horiz) {\n\t\t\t\tautoRotation = defined(rotationOption) ? \n\t\t\t\t\t[rotationOption] :\n\t\t\t\t\tslotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;\n\n\t\t\t\tif (autoRotation) {\n\n\t\t\t\t\t// Loop over the given autoRotation options, and determine which gives the best score. The \n\t\t\t\t\t// best score is that with the lowest number of steps and a rotation closest to horizontal.\n\t\t\t\t\teach(autoRotation, function (rot) {\n\t\t\t\t\t\tvar score;\n\n\t\t\t\t\t\tif (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tstep = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));\n\n\t\t\t\t\t\t\tscore = step + mathAbs(rot / 360);\n\n\t\t\t\t\t\t\tif (score < bestScore) {\n\t\t\t\t\t\t\t\tbestScore = score;\n\t\t\t\t\t\t\t\trotation = rot;\n\t\t\t\t\t\t\t\tnewTickInterval = step;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tnewTickInterval = getStep(labelMetrics.h);\n\t\t\t}\n\n\t\t\tthis.autoRotation = autoRotation;\n\t\t\tthis.labelRotation = rotation;\n\n\t\t\treturn newTickInterval;\n\t\t},\n\n\t\trenderUnsquish: function () {\n\t\t\tvar chart = this.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\ttickPositions = this.tickPositions,\n\t\t\t\tticks = this.ticks,\n\t\t\t\tlabelOptions = this.options.labels,\n\t\t\t\thoriz = this.horiz,\n\t\t\t\tmargin = chart.margin,\n\t\t\t\tslotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&\n\t\t\t\t\t((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||\n\t\t\t\t\t(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,\n\t\t\t\tinnerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),\n\t\t\t\tattr = {},\n\t\t\t\tlabelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n\t\t\t\tcss,\n\t\t\t\tlabelLength = 0,\n\t\t\t\tlabel,\n\t\t\t\ti,\n\t\t\t\tpos;\n\n\t\t\t// Set rotation option unless it is \"auto\", like in gauges\n\t\t\tif (!isString(labelOptions.rotation)) {\n\t\t\t\tattr.rotation = labelOptions.rotation;\n\t\t\t}\n\t\t\t\n\t\t\t// Handle auto rotation on horizontal axis\n\t\t\tif (this.autoRotation) {\n\n\t\t\t\t// Get the longest label length\n\t\t\t\teach(tickPositions, function (tick) {\n\t\t\t\t\ttick = ticks[tick];\n\t\t\t\t\tif (tick && tick.labelLength > labelLength) {\n\t\t\t\t\t\tlabelLength = tick.labelLength;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Apply rotation only if the label is too wide for the slot, and\n\t\t\t\t// the label is wider than its height.\n\t\t\t\tif (labelLength > innerWidth && labelLength > labelMetrics.h) {\n\t\t\t\t\tattr.rotation = this.labelRotation;\n\t\t\t\t} else {\n\t\t\t\t\tthis.labelRotation = 0;\n\t\t\t\t}\n\n\t\t\t// Handle word-wrap or ellipsis on vertical axis\n\t\t\t} else if (slotWidth) {\n\t\t\t\t// For word-wrap or ellipsis\n\t\t\t\tcss = { width: innerWidth + PX, textOverflow: 'clip' };\n\n\t\t\t\t// On vertical axis, only allow word wrap if there is room for more lines.\n\t\t\t\ti = tickPositions.length;\n\t\t\t\twhile (!horiz && i--) {\n\t\t\t\t\tpos = tickPositions[i];\n\t\t\t\t\tlabel = ticks[pos].label;\n\t\t\t\t\tif (label) {\n\t\t\t\t\t\tif (this.len / tickPositions.length - 4 < label.getBBox().height) {\n\t\t\t\t\t\t\tlabel.specCss = { textOverflow: 'ellipsis' };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Add ellipsis if the label length is significantly longer than ideal\n\t\t\tif (attr.rotation) {\n\t\t\t\tcss = { \n\t\t\t\t\twidth: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,\n\t\t\t\t\ttextOverflow: 'ellipsis'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Set the explicit or automatic label alignment\n\t\t\tthis.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n\t\t\t// Apply general and specific CSS\n\t\t\teach(tickPositions, function (pos) {\n\t\t\t\tvar tick = ticks[pos],\n\t\t\t\t\tlabel = tick && tick.label;\n\t\t\t\tif (label) {\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tlabel.css(merge(css, label.specCss));\n\t\t\t\t\t}\n\t\t\t\t\tdelete label.specCss;\n\t\t\t\t\tlabel.attr(attr);\n\t\t\t\t\ttick.rotation = attr.rotation;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// TODO: Why not part of getLabelPosition?\n\t\t\tthis.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);\n\t\t},\n\n\t\t/**\n\t\t * Render the tick labels to a preliminary position to get their sizes\n\t\t */\n\t\tgetOffset: function () {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\toptions = axis.options,\n\t\t\t\ttickPositions = axis.tickPositions,\n\t\t\t\tticks = axis.ticks,\n\t\t\t\thoriz = axis.horiz,\n\t\t\t\tside = axis.side,\n\t\t\t\tinvertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n\t\t\t\thasData,\n\t\t\t\tshowAxis,\n\t\t\t\ttitleOffset = 0,\n\t\t\t\ttitleOffsetOption,\n\t\t\t\ttitleMargin = 0,\n\t\t\t\taxisTitleOptions = options.title,\n\t\t\t\tlabelOptions = options.labels,\n\t\t\t\tlabelOffset = 0, // reset\n\t\t\t\tlabelOffsetPadded,\n\t\t\t\taxisOffset = chart.axisOffset,\n\t\t\t\tclipOffset = chart.clipOffset,\n\t\t\t\tdirectionFactor = [-1, 1, 1, -1][side],\n\t\t\t\tn,\n\t\t\t\tlineHeightCorrection;\n\n\t\t\t// For reuse in Axis.render\n\t\t\taxis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));\n\t\t\taxis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n\t\t\t// Set/reset staggerLines\n\t\t\taxis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n\t\t\t// Create the axisGroup and gridGroup elements on first iteration\n\t\t\tif (!axis.axisGroup) {\n\t\t\t\taxis.gridGroup = renderer.g('grid')\n\t\t\t\t\t.attr({ zIndex: options.gridZIndex || 1 })\n\t\t\t\t\t.add();\n\t\t\t\taxis.axisGroup = renderer.g('axis')\n\t\t\t\t\t.attr({ zIndex: options.zIndex || 2 })\n\t\t\t\t\t.add();\n\t\t\t\taxis.labelGroup = renderer.g('axis-labels')\n\t\t\t\t\t.attr({ zIndex: labelOptions.zIndex || 7 })\n\t\t\t\t\t.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')\n\t\t\t\t\t.add();\n\t\t\t}\n\n\t\t\tif (hasData || axis.isLinked) {\n\t\t\t\t\n\t\t\t\t// Generate ticks\n\t\t\t\teach(tickPositions, function (pos) {\n\t\t\t\t\tif (!ticks[pos]) {\n\t\t\t\t\t\tticks[pos] = new Tick(axis, pos);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tticks[pos].addLabel(); // update labels depending on tick interval\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\taxis.renderUnsquish();\n\n\t\t\t\teach(tickPositions, function (pos) {\n\t\t\t\t\t// left side must be align: right and right side must have align: left for labels\n\t\t\t\t\tif (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {\n\n\t\t\t\t\t\t// get the highest offset\n\t\t\t\t\t\tlabelOffset = mathMax(\n\t\t\t\t\t\t\tticks[pos].getLabelSize(),\n\t\t\t\t\t\t\tlabelOffset\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (axis.staggerLines) {\n\t\t\t\t\tlabelOffset *= axis.staggerLines;\n\t\t\t\t\taxis.labelOffset = labelOffset;\n\t\t\t\t}\n\n\n\t\t\t} else { // doesn't have data\n\t\t\t\tfor (n in ticks) {\n\t\t\t\t\tticks[n].destroy();\n\t\t\t\t\tdelete ticks[n];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n\t\t\t\tif (!axis.axisTitle) {\n\t\t\t\t\taxis.axisTitle = renderer.text(\n\t\t\t\t\t\taxisTitleOptions.text,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\taxisTitleOptions.useHTML\n\t\t\t\t\t)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tzIndex: 7,\n\t\t\t\t\t\trotation: axisTitleOptions.rotation || 0,\n\t\t\t\t\t\talign:\n\t\t\t\t\t\t\taxisTitleOptions.textAlign ||\n\t\t\t\t\t\t\t{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]\n\t\t\t\t\t})\n\t\t\t\t\t.addClass(PREFIX + this.coll.toLowerCase() + '-title')\n\t\t\t\t\t.css(axisTitleOptions.style)\n\t\t\t\t\t.add(axis.axisGroup);\n\t\t\t\t\taxis.axisTitle.isNew = true;\n\t\t\t\t}\n\n\t\t\t\tif (showAxis) {\n\t\t\t\t\ttitleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n\t\t\t\t\ttitleOffsetOption = axisTitleOptions.offset;\n\t\t\t\t\ttitleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n\t\t\t\t}\n\n\t\t\t\t// hide or show the title depending on whether showEmpty is set\n\t\t\t\taxis.axisTitle[showAxis ? 'show' : 'hide']();\n\t\t\t}\n\n\t\t\t// handle automatic or user set offset\n\t\t\taxis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n\t\t\taxis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n\t\t\tlineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;\n\t\t\tlabelOffsetPadded = labelOffset + titleMargin +\n\t\t\t\t(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));\n\t\t\taxis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n\t\t\taxisOffset[side] = mathMax(\n\t\t\t\taxisOffset[side],\n\t\t\t\taxis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n\t\t\t\tlabelOffsetPadded // #3027\n\t\t\t);\n\t\t\tclipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);\n\t\t},\n\n\t\t/**\n\t\t * Get the path for the axis line\n\t\t */\n\t\tgetLinePath: function (lineWidth) {\n\t\t\tvar chart = this.chart,\n\t\t\t\topposite = this.opposite,\n\t\t\t\toffset = this.offset,\n\t\t\t\thoriz = this.horiz,\n\t\t\t\tlineLeft = this.left + (opposite ? this.width : 0) + offset,\n\t\t\t\tlineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n\t\t\tif (opposite) {\n\t\t\t\tlineWidth *= -1; // crispify the other way - #1480, #1687\n\t\t\t}\n\n\t\t\treturn chart.renderer.crispLine([\n\t\t\t\t\tM,\n\t\t\t\t\thoriz ?\n\t\t\t\t\t\tthis.left :\n\t\t\t\t\t\tlineLeft,\n\t\t\t\t\thoriz ?\n\t\t\t\t\t\tlineTop :\n\t\t\t\t\t\tthis.top,\n\t\t\t\t\tL,\n\t\t\t\t\thoriz ?\n\t\t\t\t\t\tchart.chartWidth - this.right :\n\t\t\t\t\t\tlineLeft,\n\t\t\t\t\thoriz ?\n\t\t\t\t\t\tlineTop :\n\t\t\t\t\t\tchart.chartHeight - this.bottom\n\t\t\t\t], lineWidth);\n\t\t},\n\n\t\t/**\n\t\t * Position the title\n\t\t */\n\t\tgetTitlePosition: function () {\n\t\t\t// compute anchor points for each of the title align options\n\t\t\tvar horiz = this.horiz,\n\t\t\t\taxisLeft = this.left,\n\t\t\t\taxisTop = this.top,\n\t\t\t\taxisLength = this.len,\n\t\t\t\taxisTitleOptions = this.options.title,\n\t\t\t\tmargin = horiz ? axisLeft : axisTop,\n\t\t\t\topposite = this.opposite,\n\t\t\t\toffset = this.offset,\n\t\t\t\tfontSize = pInt(axisTitleOptions.style.fontSize || 12),\n\n\t\t\t\t// the position in the length direction of the axis\n\t\t\t\talongAxis = {\n\t\t\t\t\tlow: margin + (horiz ? 0 : axisLength),\n\t\t\t\t\tmiddle: margin + axisLength / 2,\n\t\t\t\t\thigh: margin + (horiz ? axisLength : 0)\n\t\t\t\t}[axisTitleOptions.align],\n\n\t\t\t\t// the position in the perpendicular direction of the axis\n\t\t\t\toffAxis = (horiz ? axisTop + this.height : axisLeft) +\n\t\t\t\t\t(horiz ? 1 : -1) * // horizontal axis reverses the margin\n\t\t\t\t\t(opposite ? -1 : 1) * // so does opposite axes\n\t\t\t\t\tthis.axisTitleMargin +\n\t\t\t\t\t(this.side === 2 ? fontSize : 0);\n\n\t\t\treturn {\n\t\t\t\tx: horiz ?\n\t\t\t\t\talongAxis :\n\t\t\t\t\toffAxis + (opposite ? this.width : 0) + offset +\n\t\t\t\t\t\t(axisTitleOptions.x || 0), // x\n\t\t\t\ty: horiz ?\n\t\t\t\t\toffAxis - (opposite ? this.height : 0) + offset :\n\t\t\t\t\talongAxis + (axisTitleOptions.y || 0) // y\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Render the axis\n\t\t */\n\t\trender: function () {\n\t\t\tvar axis = this,\n\t\t\t\tchart = axis.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\toptions = axis.options,\n\t\t\t\tisLog = axis.isLog,\n\t\t\t\tisLinked = axis.isLinked,\n\t\t\t\ttickPositions = axis.tickPositions,\n\t\t\t\taxisTitle = axis.axisTitle,\t\t\t\n\t\t\t\tticks = axis.ticks,\n\t\t\t\tminorTicks = axis.minorTicks,\n\t\t\t\talternateBands = axis.alternateBands,\n\t\t\t\tstackLabelOptions = options.stackLabels,\n\t\t\t\talternateGridColor = options.alternateGridColor,\n\t\t\t\ttickmarkOffset = axis.tickmarkOffset,\n\t\t\t\tlineWidth = options.lineWidth,\n\t\t\t\tlinePath,\n\t\t\t\thasRendered = chart.hasRendered,\n\t\t\t\tslideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n\t\t\t\thasData = axis.hasData,\n\t\t\t\tshowAxis = axis.showAxis,\n\t\t\t\tfrom,\n\t\t\t\tto;\n\n\t\t\t// Reset\n\t\t\taxis.labelEdge.length = 0;\n\t\t\t//axis.justifyToPlot = overflow === 'justify';\n\t\t\taxis.overlap = false;\n\n\t\t\t// Mark all elements inActive before we go over and mark the active ones\n\t\t\teach([ticks, minorTicks, alternateBands], function (coll) {\n\t\t\t\tvar pos;\n\t\t\t\tfor (pos in coll) {\n\t\t\t\t\tcoll[pos].isActive = false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If the series has data draw the ticks. Else only the line and title\n\t\t\tif (hasData || isLinked) {\n\n\t\t\t\t// minor ticks\n\t\t\t\tif (axis.minorTickInterval && !axis.categories) {\n\t\t\t\t\teach(axis.getMinorTickPositions(), function (pos) {\n\t\t\t\t\t\tif (!minorTicks[pos]) {\n\t\t\t\t\t\t\tminorTicks[pos] = new Tick(axis, pos, 'minor');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// render new ticks in old position\n\t\t\t\t\t\tif (slideInTicks && minorTicks[pos].isNew) {\n\t\t\t\t\t\t\tminorTicks[pos].render(null, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminorTicks[pos].render(null, false, 1);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Major ticks. Pull out the first item and render it last so that\n\t\t\t\t// we can get the position of the neighbour label. #808.\n\t\t\t\tif (tickPositions.length) { // #1300\n\t\t\t\t\teach(tickPositions, function (pos, i) {\n\n\t\t\t\t\t\t// linked axes need an extra check to find out if\n\t\t\t\t\t\tif (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n\t\t\t\t\t\t\tif (!ticks[pos]) {\n\t\t\t\t\t\t\t\tticks[pos] = new Tick(axis, pos);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// render new ticks in old position\n\t\t\t\t\t\t\tif (slideInTicks && ticks[pos].isNew) {\n\t\t\t\t\t\t\t\tticks[pos].render(i, true, 0.1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tticks[pos].render(i);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t\t// In a categorized axis, the tick marks are displayed between labels. So\n\t\t\t\t\t// we need to add a tick mark and grid line at the left edge of the X axis.\n\t\t\t\t\tif (tickmarkOffset && (axis.min === 0 || axis.single)) {\n\t\t\t\t\t\tif (!ticks[-1]) {\n\t\t\t\t\t\t\tticks[-1] = new Tick(axis, -1, null, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tticks[-1].render(-1);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// alternate grid color\n\t\t\t\tif (alternateGridColor) {\n\t\t\t\t\teach(tickPositions, function (pos, i) {\n\t\t\t\t\t\tif (i % 2 === 0 && pos < axis.max) {\n\t\t\t\t\t\t\tif (!alternateBands[pos]) {\n\t\t\t\t\t\t\t\talternateBands[pos] = new Highcharts.PlotLineOrBand(axis);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfrom = pos + tickmarkOffset; // #949\n\t\t\t\t\t\t\tto = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;\n\t\t\t\t\t\t\talternateBands[pos].options = {\n\t\t\t\t\t\t\t\tfrom: isLog ? lin2log(from) : from,\n\t\t\t\t\t\t\t\tto: isLog ? lin2log(to) : to,\n\t\t\t\t\t\t\t\tcolor: alternateGridColor\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\talternateBands[pos].render();\n\t\t\t\t\t\t\talternateBands[pos].isActive = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// custom plot lines and bands\n\t\t\t\tif (!axis._addedPlotLB) { // only first time\n\t\t\t\t\teach((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n\t\t\t\t\t\taxis.addPlotBandOrLine(plotLineOptions);\n\t\t\t\t\t});\n\t\t\t\t\taxis._addedPlotLB = true;\n\t\t\t\t}\n\n\t\t\t} // end if hasData\n\n\t\t\t// Remove inactive ticks\n\t\t\teach([ticks, minorTicks, alternateBands], function (coll) {\n\t\t\t\tvar pos,\n\t\t\t\t\ti,\n\t\t\t\t\tforDestruction = [],\n\t\t\t\t\tdelay = globalAnimation ? globalAnimation.duration || 500 : 0,\n\t\t\t\t\tdestroyInactiveItems = function () {\n\t\t\t\t\t\ti = forDestruction.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t// When resizing rapidly, the same items may be destroyed in different timeouts,\n\t\t\t\t\t\t\t// or the may be reactivated\n\t\t\t\t\t\t\tif (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n\t\t\t\t\t\t\t\tcoll[forDestruction[i]].destroy();\n\t\t\t\t\t\t\t\tdelete coll[forDestruction[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\tfor (pos in coll) {\n\n\t\t\t\t\tif (!coll[pos].isActive) {\n\t\t\t\t\t\t// Render to zero opacity\n\t\t\t\t\t\tcoll[pos].render(pos, false, 0);\n\t\t\t\t\t\tcoll[pos].isActive = false;\n\t\t\t\t\t\tforDestruction.push(pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// When the objects are finished fading out, destroy them\n\t\t\t\tif (coll === alternateBands || !chart.hasRendered || !delay) {\n\t\t\t\t\tdestroyInactiveItems();\n\t\t\t\t} else if (delay) {\n\t\t\t\t\tsetTimeout(destroyInactiveItems, delay);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Static items. As the axis group is cleared on subsequent calls\n\t\t\t// to render, these items are added outside the group.\n\t\t\t// axis line\n\t\t\tif (lineWidth) {\n\t\t\t\tlinePath = axis.getLinePath(lineWidth);\n\t\t\t\tif (!axis.axisLine) {\n\t\t\t\t\taxis.axisLine = renderer.path(linePath)\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\tstroke: options.lineColor,\n\t\t\t\t\t\t\t'stroke-width': lineWidth,\n\t\t\t\t\t\t\tzIndex: 7\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add(axis.axisGroup);\n\t\t\t\t} else {\n\t\t\t\t\taxis.axisLine.animate({ d: linePath });\n\t\t\t\t}\n\n\t\t\t\t// show or hide the line depending on options.showEmpty\n\t\t\t\taxis.axisLine[showAxis ? 'show' : 'hide']();\n\t\t\t}\n\n\t\t\tif (axisTitle && showAxis) {\n\n\t\t\t\taxisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n\t\t\t\t\taxis.getTitlePosition()\n\t\t\t\t);\n\t\t\t\taxisTitle.isNew = false;\n\t\t\t}\n\n\t\t\t// Stacked totals:\n\t\t\tif (stackLabelOptions && stackLabelOptions.enabled) {\n\t\t\t\taxis.renderStackTotals();\n\t\t\t}\n\t\t\t// End stacked totals\n\n\t\t\taxis.isDirty = false;\n\t\t},\n\n\t\t/**\n\t\t * Redraw the axis to reflect changes in the data or axis extremes\n\t\t */\n\t\tredraw: function () {\n\t\t\t\n\t\t\t// render the axis\n\t\t\tthis.render();\n\n\t\t\t// move plot lines and bands\n\t\t\teach(this.plotLinesAndBands, function (plotLine) {\n\t\t\t\tplotLine.render();\n\t\t\t});\n\n\t\t\t// mark associated series as dirty and ready for redraw\n\t\t\teach(this.series, function (series) {\n\t\t\t\tseries.isDirty = true;\n\t\t\t});\n\n\t\t},\n\n\t\t/**\n\t\t * Destroys an Axis instance.\n\t\t */\n\t\tdestroy: function (keepEvents) {\n\t\t\tvar axis = this,\n\t\t\t\tstacks = axis.stacks,\n\t\t\t\tstackKey,\n\t\t\t\tplotLinesAndBands = axis.plotLinesAndBands,\n\t\t\t\ti;\n\n\t\t\t// Remove the events\n\t\t\tif (!keepEvents) {\n\t\t\t\tremoveEvent(axis);\n\t\t\t}\n\n\t\t\t// Destroy each stack total\n\t\t\tfor (stackKey in stacks) {\n\t\t\t\tdestroyObjectProperties(stacks[stackKey]);\n\n\t\t\t\tstacks[stackKey] = null;\n\t\t\t}\n\n\t\t\t// Destroy collections\n\t\t\teach([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n\t\t\t\tdestroyObjectProperties(coll);\n\t\t\t});\n\t\t\ti = plotLinesAndBands.length;\n\t\t\twhile (i--) { // #1975\n\t\t\t\tplotLinesAndBands[i].destroy();\n\t\t\t}\n\n\t\t\t// Destroy local variables\n\t\t\teach(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n\t\t\t\tif (axis[prop]) {\n\t\t\t\t\taxis[prop] = axis[prop].destroy();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Destroy crosshair\n\t\t\tif (this.cross) {\n\t\t\t\tthis.cross.destroy();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Draw the crosshair\n\t\t */\n\t\tdrawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.\n\n\t\t\tvar path,\n\t\t\t\toptions = this.crosshair,\n\t\t\t\tanimation = options.animation,\n\t\t\t\tpos,\n\t\t\t\tattribs,\n\t\t\t\tcategorized;\n\t\t\t\n\t\t\tif (\n\t\t\t\t// Disabled in options\n\t\t\t\t!this.crosshair || \n\t\t\t\t// Snap\n\t\t\t\t((defined(point) || !pick(this.crosshair.snap, true)) === false)\n\t\t\t) {\n\t\t\t\tthis.hideCrosshair();\n\t\t\t\n\t\t\t} else {\t\t\t\n\n\t\t\t\t// Get the path\n\t\t\t\tif (!pick(options.snap, true)) {\n\t\t\t\t\tpos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n\t\t\t\t} else if (defined(point)) {\n\t\t\t\t\t/*jslint eqeq: true*/\n\t\t\t\t\tpos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n\t\t\t\t\t/*jslint eqeq: false*/\n\t\t\t\t}\n\n\t\t\t\tif (this.isRadial) {\n\t\t\t\t\tpath = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n\t\t\t\t} else {\n\t\t\t\t\tpath = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n\t\t\t\t}\n\n\t\t\t\tif (path === null) {\n\t\t\t\t\tthis.hideCrosshair();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Draw the cross\n\t\t\t\tif (this.cross) {\n\t\t\t\t\tthis.cross\n\t\t\t\t\t\t.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);\n\t\t\t\t} else {\n\t\t\t\t\tcategorized = this.categories && !this.isRadial;\n\t\t\t\t\tattribs = {\n\t\t\t\t\t\t'stroke-width': options.width || (categorized ? this.transA : 1),\n\t\t\t\t\t\tstroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n\t\t\t\t\t\tzIndex: options.zIndex || 2\n\t\t\t\t\t};\n\t\t\t\t\tif (options.dashStyle) {\n\t\t\t\t\t\tattribs.dashstyle = options.dashStyle;\n\t\t\t\t\t}\n\t\t\t\t\tthis.cross = this.chart.renderer.path(path).attr(attribs).add();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t *\tHide the crosshair.\n\t\t */\n\t\thideCrosshair: function () {\n\t\t\tif (this.cross) {\n\t\t\t\tthis.cross.hide();\n\t\t\t}\n\t\t}\n\t}; // end Axis\n\n\textend(Axis.prototype, AxisPlotLineOrBandExtension);\n\n\t/**\n\t * Set the tick positions to a time unit that makes sense, for example\n\t * on the first of each month or on every Monday. Return an array\n\t * with the time positions. Used in datetime axes as well as for grouping\n\t * data on a datetime axis.\n\t *\n\t * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n\t * @param {Number} min The minimum in axis values\n\t * @param {Number} max The maximum in axis values\n\t * @param {Number} startOfWeek\n\t */\n\tAxis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n\t\tvar tickPositions = [],\n\t\t\ti,\n\t\t\thigherRanks = {},\n\t\t\tuseUTC = defaultOptions.global.useUTC,\n\t\t\tminYear, // used in months and years as a basis for Date.UTC()\n\t\t\tminDate = new Date(min - getTZOffset(min)),\n\t\t\tinterval = normalizedInterval.unitRange,\n\t\t\tcount = normalizedInterval.count;\n\n\t\tif (defined(min)) { // #1300\n\t\t\tminDate.setMilliseconds(interval >= timeUnits.second ? 0 :\n\t\t\t\tcount * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n\t\t\tif (interval >= timeUnits.second) { // second\n\t\t\t\tminDate.setSeconds(interval >= timeUnits.minute ? 0 :\n\t\t\t\t\tcount * mathFloor(minDate.getSeconds() / count));\n\t\t\t}\n\t\t\n\t\t\tif (interval >= timeUnits.minute) { // minute\n\t\t\t\tminDate[setMinutes](interval >= timeUnits.hour ? 0 :\n\t\t\t\t\tcount * mathFloor(minDate[getMinutes]() / count));\n\t\t\t}\n\t\t\n\t\t\tif (interval >= timeUnits.hour) { // hour\n\t\t\t\tminDate[setHours](interval >= timeUnits.day ? 0 :\n\t\t\t\t\tcount * mathFloor(minDate[getHours]() / count));\n\t\t\t}\n\t\t\n\t\t\tif (interval >= timeUnits.day) { // day\n\t\t\t\tminDate[setDate](interval >= timeUnits.month ? 1 :\n\t\t\t\t\tcount * mathFloor(minDate[getDate]() / count));\n\t\t\t}\n\t\t\n\t\t\tif (interval >= timeUnits.month) { // month\n\t\t\t\tminDate[setMonth](interval >= timeUnits.year ? 0 :\n\t\t\t\t\tcount * mathFloor(minDate[getMonth]() / count));\n\t\t\t\tminYear = minDate[getFullYear]();\n\t\t\t}\n\t\t\n\t\t\tif (interval >= timeUnits.year) { // year\n\t\t\t\tminYear -= minYear % count;\n\t\t\t\tminDate[setFullYear](minYear);\n\t\t\t}\n\t\t\n\t\t\t// week is a special case that runs outside the hierarchy\n\t\t\tif (interval === timeUnits.week) {\n\t\t\t\t// get start of current week, independent of count\n\t\t\t\tminDate[setDate](minDate[getDate]() - minDate[getDay]() +\n\t\t\t\t\tpick(startOfWeek, 1));\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// get tick positions\n\t\t\ti = 1;\n\t\t\tif (timezoneOffset || getTimezoneOffset) {\n\t\t\t\tminDate = minDate.getTime();\n\t\t\t\tminDate = new Date(minDate + getTZOffset(minDate));\n\t\t\t}\n\t\t\tminYear = minDate[getFullYear]();\n\t\t\tvar time = minDate.getTime(),\n\t\t\t\tminMonth = minDate[getMonth](),\n\t\t\t\tminDateDate = minDate[getDate](),\n\t\t\t\tlocalTimezoneOffset = (timeUnits.day + \n\t\t\t\t\t\t(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n\t\t\t\t\t) % timeUnits.day; // #950, #3359\n\t\t\n\t\t\t// iterate and add tick positions at appropriate values\n\t\t\twhile (time < max) {\n\t\t\t\ttickPositions.push(time);\n\t\t\n\t\t\t\t// if the interval is years, use Date.UTC to increase years\n\t\t\t\tif (interval === timeUnits.year) {\n\t\t\t\t\ttime = makeTime(minYear + i * count, 0);\n\t\t\n\t\t\t\t// if the interval is months, use Date.UTC to increase months\n\t\t\t\t} else if (interval === timeUnits.month) {\n\t\t\t\t\ttime = makeTime(minYear, minMonth + i * count);\n\t\t\n\t\t\t\t// if we're using global time, the interval is not fixed as it jumps\n\t\t\t\t// one hour at the DST crossover\n\t\t\t\t} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {\n\t\t\t\t\ttime = makeTime(minYear, minMonth, minDateDate +\n\t\t\t\t\t\ti * count * (interval === timeUnits.day ? 1 : 7));\n\t\t\n\t\t\t\t// else, the interval is fixed and we use simple addition\n\t\t\t\t} else {\n\t\t\t\t\ttime += interval * count;\n\t\t\t\t}\n\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\n\t\t\t// push the last time\n\t\t\ttickPositions.push(time);\n\n\n\t\t\t// mark new days if the time is dividible by day (#1649, #1760)\n\t\t\teach(grep(tickPositions, function (time) {\n\t\t\t\treturn interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n\t\t\t}), function (time) {\n\t\t\t\thigherRanks[time] = 'day';\n\t\t\t});\n\t\t}\n\n\n\t\t// record information on the chosen unit - for dynamic label formatter\n\t\ttickPositions.info = extend(normalizedInterval, {\n\t\t\thigherRanks: higherRanks,\n\t\t\ttotalRange: interval * count\n\t\t});\n\n\t\treturn tickPositions;\n\t};\n\n\t/**\n\t * Get a normalized tick interval for dates. Returns a configuration object with\n\t * unit range (interval), count and name. Used to prepare data for getTimeTicks. \n\t * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n\t * of segments in stock charts, the normalizing logic was extracted in order to \n\t * prevent it for running over again for each segment having the same interval. \n\t * #662, #697.\n\t */\n\tAxis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n\t\tvar units = unitsOption || [[\n\t\t\t\t\t'millisecond', // unit name\n\t\t\t\t\t[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n\t\t\t\t], [\n\t\t\t\t\t'second',\n\t\t\t\t\t[1, 2, 5, 10, 15, 30]\n\t\t\t\t], [\n\t\t\t\t\t'minute',\n\t\t\t\t\t[1, 2, 5, 10, 15, 30]\n\t\t\t\t], [\n\t\t\t\t\t'hour',\n\t\t\t\t\t[1, 2, 3, 4, 6, 8, 12]\n\t\t\t\t], [\n\t\t\t\t\t'day',\n\t\t\t\t\t[1, 2]\n\t\t\t\t], [\n\t\t\t\t\t'week',\n\t\t\t\t\t[1, 2]\n\t\t\t\t], [\n\t\t\t\t\t'month',\n\t\t\t\t\t[1, 2, 3, 4, 6]\n\t\t\t\t], [\n\t\t\t\t\t'year',\n\t\t\t\t\tnull\n\t\t\t\t]],\n\t\t\tunit = units[units.length - 1], // default unit is years\n\t\t\tinterval = timeUnits[unit[0]],\n\t\t\tmultiples = unit[1],\n\t\t\tcount,\n\t\t\ti;\n\t\t\t\n\t\t// loop through the units to find the one that best fits the tickInterval\n\t\tfor (i = 0; i < units.length; i++) {\n\t\t\tunit = units[i];\n\t\t\tinterval = timeUnits[unit[0]];\n\t\t\tmultiples = unit[1];\n\n\n\t\t\tif (units[i + 1]) {\n\t\t\t\t// lessThan is in the middle between the highest multiple and the next unit.\n\t\t\t\tvar lessThan = (interval * multiples[multiples.length - 1] +\n\t\t\t\t\t\t\ttimeUnits[units[i + 1][0]]) / 2;\n\n\t\t\t\t// break and keep the current unit\n\t\t\t\tif (tickInterval <= lessThan) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// prevent 2.5 years intervals, though 25, 250 etc. are allowed\n\t\tif (interval === timeUnits.year && tickInterval < 5 * interval) {\n\t\t\tmultiples = [1, 2, 5];\n\t\t}\n\n\t\t// get the count\n\t\tcount = normalizeTickInterval(\n\t\t\ttickInterval / interval, \n\t\t\tmultiples,\n\t\t\tunit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n\t\t);\n\t\t\n\t\treturn {\n\t\t\tunitRange: interval,\n\t\t\tcount: count,\n\t\t\tunitName: unit[0]\n\t\t};\n\t};/**\n\t * Methods defined on the Axis prototype\n\t */\n\n\t/**\n\t * Set the tick positions of a logarithmic axis\n\t */\n\tAxis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n\t\tvar axis = this,\n\t\t\toptions = axis.options,\n\t\t\taxisLength = axis.len,\n\t\t\t// Since we use this method for both major and minor ticks,\n\t\t\t// use a local variable and return the result\n\t\t\tpositions = []; \n\t\t\n\t\t// Reset\n\t\tif (!minor) {\n\t\t\taxis._minorAutoInterval = null;\n\t\t}\n\t\t\n\t\t// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n\t\tif (interval >= 0.5) {\n\t\t\tinterval = mathRound(interval);\n\t\t\tpositions = axis.getLinearTickPositions(interval, min, max);\n\t\t\t\n\t\t// Second case: We need intermediary ticks. For example \n\t\t// 1, 2, 4, 6, 8, 10, 20, 40 etc. \n\t\t} else if (interval >= 0.08) {\n\t\t\tvar roundedMin = mathFloor(min),\n\t\t\t\tintermediate,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tlen,\n\t\t\t\tpos,\n\t\t\t\tlastPos,\n\t\t\t\tbreak2;\n\t\t\t\t\n\t\t\tif (interval > 0.3) {\n\t\t\t\tintermediate = [1, 2, 4];\n\t\t\t} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n\t\t\t\tintermediate = [1, 2, 4, 6, 8];\n\t\t\t} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n\t\t\t\tintermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\t\t\t}\n\t\t\t\n\t\t\tfor (i = roundedMin; i < max + 1 && !break2; i++) {\n\t\t\t\tlen = intermediate.length;\n\t\t\t\tfor (j = 0; j < len && !break2; j++) {\n\t\t\t\t\tpos = log2lin(lin2log(i) * intermediate[j]);\n\t\t\t\t\tif (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113\n\t\t\t\t\t\tpositions.push(lastPos);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (lastPos > max) {\n\t\t\t\t\t\tbreak2 = true;\n\t\t\t\t\t}\n\t\t\t\t\tlastPos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t// Third case: We are so deep in between whole logarithmic values that\n\t\t// we might as well handle the tick positions like a linear axis. For\n\t\t// example 1.01, 1.02, 1.03, 1.04.\n\t\t} else {\n\t\t\tvar realMin = lin2log(min),\n\t\t\t\trealMax = lin2log(max),\n\t\t\t\ttickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n\t\t\t\tfilteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n\t\t\t\ttickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n\t\t\t\ttotalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\t\t\t\n\t\t\tinterval = pick(\n\t\t\t\tfilteredTickIntervalOption,\n\t\t\t\taxis._minorAutoInterval,\n\t\t\t\t(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n\t\t\t);\n\t\t\t\n\t\t\tinterval = normalizeTickInterval(\n\t\t\t\tinterval, \n\t\t\t\tnull, \n\t\t\t\tgetMagnitude(interval)\n\t\t\t);\n\t\t\t\n\t\t\tpositions = map(axis.getLinearTickPositions(\n\t\t\t\tinterval, \n\t\t\t\trealMin,\n\t\t\t\trealMax\t\n\t\t\t), log2lin);\n\t\t\t\n\t\t\tif (!minor) {\n\t\t\t\taxis._minorAutoInterval = interval / 5;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Set the axis-level tickInterval variable \n\t\tif (!minor) {\n\t\t\taxis.tickInterval = interval;\n\t\t}\n\t\treturn positions;\n\t};/**\n\t * The tooltip object\n\t * @param {Object} chart The chart instance\n\t * @param {Object} options Tooltip options\n\t */\n\tvar Tooltip = Highcharts.Tooltip = function () {\n\t\tthis.init.apply(this, arguments);\n\t};\n\n\tTooltip.prototype = {\n\n\t\tinit: function (chart, options) {\n\n\t\t\tvar borderWidth = options.borderWidth,\n\t\t\t\tstyle = options.style,\n\t\t\t\tpadding = pInt(style.padding);\n\n\t\t\t// Save the chart and options\n\t\t\tthis.chart = chart;\n\t\t\tthis.options = options;\n\n\t\t\t// Keep track of the current series\n\t\t\t//this.currentSeries = UNDEFINED;\n\n\t\t\t// List of crosshairs\n\t\t\tthis.crosshairs = [];\n\n\t\t\t// Current values of x and y when animating\n\t\t\tthis.now = { x: 0, y: 0 };\n\n\t\t\t// The tooltip is initially hidden\n\t\t\tthis.isHidden = true;\n\n\n\t\t\t// create the label\t\t\n\t\t\tthis.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n\t\t\t\t.attr({\n\t\t\t\t\tpadding: padding,\n\t\t\t\t\tfill: options.backgroundColor,\n\t\t\t\t\t'stroke-width': borderWidth,\n\t\t\t\t\tr: options.borderRadius,\n\t\t\t\t\tzIndex: 8\n\t\t\t\t})\n\t\t\t\t.css(style)\n\t\t\t\t.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n\t\t\t\t.add()\n\t\t\t\t.attr({ y: -9999 }); // #2301, #2657\n\n\t\t\t// When using canVG the shadow shows up as a gray circle\n\t\t\t// even if the tooltip is hidden.\n\t\t\tif (!useCanVG) {\n\t\t\t\tthis.label.shadow(options.shadow);\n\t\t\t}\n\n\t\t\t// Public property for getting the shared state.\n\t\t\tthis.shared = options.shared;\n\t\t},\n\n\t\t/**\n\t\t * Destroy the tooltip and its elements.\n\t\t */\n\t\tdestroy: function () {\n\t\t\t// Destroy and clear local variables\n\t\t\tif (this.label) {\n\t\t\t\tthis.label = this.label.destroy();\n\t\t\t}\n\t\t\tclearTimeout(this.hideTimer);\n\t\t\tclearTimeout(this.tooltipTimeout);\n\t\t},\n\n\t\t/**\n\t\t * Provide a soft movement for the tooltip\n\t\t *\n\t\t * @param {Number} x\n\t\t * @param {Number} y\n\t\t * @private\n\t\t */\n\t\tmove: function (x, y, anchorX, anchorY) {\n\t\t\tvar tooltip = this,\n\t\t\t\tnow = tooltip.now,\n\t\t\t\tanimate = tooltip.options.animation !== false && !tooltip.isHidden && \n\t\t\t\t\t// When we get close to the target position, abort animation and land on the right place (#3056)\n\t\t\t\t\t(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),\n\t\t\t\tskipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n\t\t\t// Get intermediate values for animation\n\t\t\textend(now, {\n\t\t\t\tx: animate ? (2 * now.x + x) / 3 : x,\n\t\t\t\ty: animate ? (now.y + y) / 2 : y,\n\t\t\t\tanchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n\t\t\t\tanchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY\n\t\t\t});\n\n\t\t\t// Move to the intermediate value\n\t\t\ttooltip.label.attr(now);\n\n\t\t\t\n\t\t\t// Run on next tick of the mouse tracker\n\t\t\tif (animate) {\n\t\t\t\n\t\t\t\t// Never allow two timeouts\n\t\t\t\tclearTimeout(this.tooltipTimeout);\n\t\t\t\t\n\t\t\t\t// Set the fixed interval ticking for the smooth tooltip\n\t\t\t\tthis.tooltipTimeout = setTimeout(function () {\n\t\t\t\t\t// The interval function may still be running during destroy, so check that the chart is really there before calling.\n\t\t\t\t\tif (tooltip) {\n\t\t\t\t\t\ttooltip.move(x, y, anchorX, anchorY);\n\t\t\t\t\t}\n\t\t\t\t}, 32);\n\t\t\t\t\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Hide the tooltip\n\t\t */\n\t\thide: function (delay) {\n\t\t\tvar tooltip = this,\n\t\t\t\thoverPoints;\n\t\t\t\n\t\t\tclearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n\t\t\tif (!this.isHidden) {\n\t\t\t\thoverPoints = this.chart.hoverPoints;\n\n\t\t\t\tthis.hideTimer = setTimeout(function () {\n\t\t\t\t\ttooltip.label.fadeOut();\n\t\t\t\t\ttooltip.isHidden = true;\n\t\t\t\t}, pick(delay, this.options.hideDelay, 500));\n\n\t\t\t\t// hide previous hoverPoints and set new\n\t\t\t\tif (hoverPoints) {\n\t\t\t\t\teach(hoverPoints, function (point) {\n\t\t\t\t\t\tpoint.setState();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.chart.hoverPoints = null;\n\t\t\t\tthis.chart.hoverSeries = null;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/** \n\t\t * Extendable method to get the anchor position of the tooltip\n\t\t * from a point or set of points\n\t\t */\n\t\tgetAnchor: function (points, mouseEvent) {\n\t\t\tvar ret,\n\t\t\t\tchart = this.chart,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\tplotTop = chart.plotTop,\n\t\t\t\tplotLeft = chart.plotLeft,\n\t\t\t\tplotX = 0,\n\t\t\t\tplotY = 0,\n\t\t\t\tyAxis,\n\t\t\t\txAxis;\n\t\t\t\n\t\t\tpoints = splat(points);\n\t\t\t\n\t\t\t// Pie uses a special tooltipPos\n\t\t\tret = points[0].tooltipPos;\n\t\t\t\n\t\t\t// When tooltip follows mouse, relate the position to the mouse\n\t\t\tif (this.followPointer && mouseEvent) {\n\t\t\t\tif (mouseEvent.chartX === UNDEFINED) {\n\t\t\t\t\tmouseEvent = chart.pointer.normalize(mouseEvent);\n\t\t\t\t}\n\t\t\t\tret = [\n\t\t\t\t\tmouseEvent.chartX - chart.plotLeft,\n\t\t\t\t\tmouseEvent.chartY - plotTop\n\t\t\t\t];\n\t\t\t}\n\t\t\t// When shared, use the average position\n\t\t\tif (!ret) {\n\t\t\t\teach(points, function (point) {\n\t\t\t\t\tyAxis = point.series.yAxis;\n\t\t\t\t\txAxis = point.series.xAxis;\n\t\t\t\t\tplotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); \n\t\t\t\t\tplotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n\t\t\t\t\t\t(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tplotX /= points.length;\n\t\t\t\tplotY /= points.length;\n\t\t\t\t\n\t\t\t\tret = [\n\t\t\t\t\tinverted ? chart.plotWidth - plotY : plotX,\n\t\t\t\t\tthis.shared && !inverted && points.length > 1 && mouseEvent ? \n\t\t\t\t\t\tmouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n\t\t\t\t\t\tinverted ? chart.plotHeight - plotX : plotY\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn map(ret, mathRound);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Place the tooltip in a chart without spilling over\n\t\t * and not covering the point it self.\n\t\t */\n\t\tgetPosition: function (boxWidth, boxHeight, point) {\n\t\t\t\n\t\t\tvar chart = this.chart,\n\t\t\t\tdistance = this.distance,\n\t\t\t\tret = {},\n\t\t\t\tswapped,\n\t\t\t\tfirst = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],\n\t\t\t\tsecond = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],\n\t\t\t\t// The far side is right or bottom\n\t\t\t\tpreferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),\n\t\t\t\t/**\n\t\t\t\t * Handle the preferred dimension. When the preferred dimension is tooltip\n\t\t\t\t * on top or bottom of the point, it will look for space there.\n\t\t\t\t */\n\t\t\t\tfirstDimension = function (dim, outerSize, innerSize, point) {\n\t\t\t\t\tvar roomLeft = innerSize < point - distance,\n\t\t\t\t\t\troomRight = point + distance + innerSize < outerSize,\n\t\t\t\t\t\talignedLeft = point - distance - innerSize,\n\t\t\t\t\t\talignedRight = point + distance;\n\n\t\t\t\t\tif (preferFarSide && roomRight) {\n\t\t\t\t\t\tret[dim] = alignedRight;\n\t\t\t\t\t} else if (!preferFarSide && roomLeft) {\n\t\t\t\t\t\tret[dim] = alignedLeft;\n\t\t\t\t\t} else if (roomLeft) {\n\t\t\t\t\t\tret[dim] = alignedLeft;\n\t\t\t\t\t} else if (roomRight) {\n\t\t\t\t\t\tret[dim] = alignedRight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Handle the secondary dimension. If the preferred dimension is tooltip\n\t\t\t\t * on top or bottom of the point, the second dimension is to align the tooltip\n\t\t\t\t * above the point, trying to align center but allowing left or right\n\t\t\t\t * align within the chart box.\n\t\t\t\t */\n\t\t\t\tsecondDimension = function (dim, outerSize, innerSize, point) {\n\t\t\t\t\t// Too close to the edge, return false and swap dimensions\n\t\t\t\t\tif (point < distance || point > outerSize - distance) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t\t// Align left/top\n\t\t\t\t\t} else if (point < innerSize / 2) {\n\t\t\t\t\t\tret[dim] = 1;\n\t\t\t\t\t// Align right/bottom\n\t\t\t\t\t} else if (point > outerSize - innerSize / 2) {\n\t\t\t\t\t\tret[dim] = outerSize - innerSize - 2;\n\t\t\t\t\t// Align center\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret[dim] = point - innerSize / 2;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Swap the dimensions \n\t\t\t\t */\n\t\t\t\tswap = function (count) {\n\t\t\t\t\tvar temp = first;\n\t\t\t\t\tfirst = second;\n\t\t\t\t\tsecond = temp;\n\t\t\t\t\tswapped = count;\n\t\t\t\t},\n\t\t\t\trun = function () {\n\t\t\t\t\tif (firstDimension.apply(0, first) !== false) {\n\t\t\t\t\t\tif (secondDimension.apply(0, second) === false && !swapped) {\n\t\t\t\t\t\t\tswap(true);\n\t\t\t\t\t\t\trun();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!swapped) {\n\t\t\t\t\t\tswap(true);\n\t\t\t\t\t\trun();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret.x = ret.y = 0;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// Under these conditions, prefer the tooltip on the side of the point\n\t\t\tif (chart.inverted || this.len > 1) {\n\t\t\t\tswap();\n\t\t\t}\n\t\t\trun();\n\n\t\t\treturn ret;\n\t\t\n\t\t},\n\n\t\t/**\n\t\t * In case no user defined formatter is given, this will be used. Note that the context\n\t\t * here is an object holding point, series, x, y etc.\n\t\t */\n\t\tdefaultFormatter: function (tooltip) {\n\t\t\tvar items = this.points || splat(this),\n\t\t\t\ts;\n\n\t\t\t// build the header\n\t\t\ts = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n\t\t\t// build the values\n\t\t\ts = s.concat(tooltip.bodyFormatter(items));\n\n\t\t\t// footer\n\t\t\ts.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n\t\t\treturn s.join('');\n\t\t},\n\n\t\t/**\n\t\t * Refresh the tooltip's text and position.\n\t\t * @param {Object} point\n\t\t */\n\t\trefresh: function (point, mouseEvent) {\n\t\t\tvar tooltip = this,\n\t\t\t\tchart = tooltip.chart,\n\t\t\t\tlabel = tooltip.label,\n\t\t\t\toptions = tooltip.options,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tanchor,\n\t\t\t\ttextConfig = {},\n\t\t\t\ttext,\n\t\t\t\tpointConfig = [],\n\t\t\t\tformatter = options.formatter || tooltip.defaultFormatter,\n\t\t\t\thoverPoints = chart.hoverPoints,\n\t\t\t\tborderColor,\n\t\t\t\tshared = tooltip.shared,\n\t\t\t\tcurrentSeries;\n\t\t\t\t\n\t\t\tclearTimeout(this.hideTimer);\n\t\t\t\n\t\t\t// get the reference point coordinates (pie charts use tooltipPos)\n\t\t\ttooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n\t\t\tanchor = tooltip.getAnchor(point, mouseEvent);\n\t\t\tx = anchor[0];\n\t\t\ty = anchor[1];\n\n\t\t\t// shared tooltip, array is sent over\n\t\t\tif (shared && !(point.series && point.series.noSharedTooltip)) {\n\t\t\t\t\n\t\t\t\t// hide previous hoverPoints and set new\n\t\t\t\t\n\t\t\t\tchart.hoverPoints = point;\n\t\t\t\tif (hoverPoints) {\n\t\t\t\t\teach(hoverPoints, function (point) {\n\t\t\t\t\t\tpoint.setState();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\teach(point, function (item) {\n\t\t\t\t\titem.setState(HOVER_STATE);\n\n\t\t\t\t\tpointConfig.push(item.getLabelConfig());\n\t\t\t\t});\n\n\t\t\t\ttextConfig = {\n\t\t\t\t\tx: point[0].category,\n\t\t\t\t\ty: point[0].y\n\t\t\t\t};\n\t\t\t\ttextConfig.points = pointConfig;\n\t\t\t\tthis.len = pointConfig.length;\n\t\t\t\tpoint = point[0];\n\n\t\t\t// single point tooltip\n\t\t\t} else {\n\t\t\t\ttextConfig = point.getLabelConfig();\n\t\t\t}\n\t\t\ttext = formatter.call(textConfig, tooltip);\n\n\t\t\t// register the current series\n\t\t\tcurrentSeries = point.series;\n\t\t\tthis.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n\t\t\t// update the inner HTML\n\t\t\tif (text === false) {\n\t\t\t\tthis.hide();\n\t\t\t} else {\n\n\t\t\t\t// show it\n\t\t\t\tif (tooltip.isHidden) {\n\t\t\t\t\tstop(label);\n\t\t\t\t\tlabel.attr('opacity', 1).show();\n\t\t\t\t}\n\n\t\t\t\t// update text\n\t\t\t\tlabel.attr({\n\t\t\t\t\ttext: text\n\t\t\t\t});\n\n\t\t\t\t// set the stroke color of the box\n\t\t\t\tborderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n\t\t\t\tlabel.attr({\n\t\t\t\t\tstroke: borderColor\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttooltip.updatePosition({ plotX: x, plotY: y, negative: point.negative, ttBelow: point.ttBelow });\n\t\t\t\n\t\t\t\tthis.isHidden = false;\n\t\t\t}\n\t\t\tfireEvent(chart, 'tooltipRefresh', {\n\t\t\t\t\ttext: text,\n\t\t\t\t\tx: x + chart.plotLeft,\n\t\t\t\t\ty: y + chart.plotTop,\n\t\t\t\t\tborderColor: borderColor\n\t\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find the new position and perform the move\n\t\t */\n\t\tupdatePosition: function (point) {\n\t\t\tvar chart = this.chart,\n\t\t\t\tlabel = this.label, \n\t\t\t\tpos = (this.options.positioner || this.getPosition).call(\n\t\t\t\t\tthis,\n\t\t\t\t\tlabel.width,\n\t\t\t\t\tlabel.height,\n\t\t\t\t\tpoint\n\t\t\t\t);\n\n\t\t\t// do the move\n\t\t\tthis.move(\n\t\t\t\tmathRound(pos.x), \n\t\t\t\tmathRound(pos.y), \n\t\t\t\tpoint.plotX + chart.plotLeft, \n\t\t\t\tpoint.plotY + chart.plotTop\n\t\t\t);\n\t\t},\n\n\t\t/** \n\t\t * Get the best X date format based on the closest point range on the axis.\n\t\t */\n\t\tgetXDateFormat: function (point, options, xAxis) {\n\t\t\tvar xDateFormat,\n\t\t\t\tdateTimeLabelFormats = options.dateTimeLabelFormats,\n\t\t\t\tclosestPointRange = xAxis && xAxis.closestPointRange,\n\t\t\t\tn,\n\t\t\t\tblank = '01-01 00:00:00.000',\n\t\t\t\tstrpos = {\n\t\t\t\t\tmillisecond: 15,\n\t\t\t\t\tsecond: 12,\n\t\t\t\t\tminute: 9,\n\t\t\t\t\thour: 6,\n\t\t\t\t\tday: 3\n\t\t\t\t},\n\t\t\t\tdate,\n\t\t\t\tlastN;\n\n\t\t\tif (closestPointRange) {\n\t\t\t\tdate = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n\t\t\t\tfor (n in timeUnits) {\n\n\t\t\t\t\t// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n\t\t\t\t\tif (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && \n\t\t\t\t\t\t\tdate.substr(6) === blank.substr(6)) {\n\t\t\t\t\t\tn = 'week';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// The first format that is too great for the range\n\t\t\t\t\t} else if (timeUnits[n] > closestPointRange) {\n\t\t\t\t\t\tn = lastN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t// If the point is placed every day at 23:59, we need to show\n\t\t\t\t\t// the minutes as well. #2637.\n\t\t\t\t\t} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n\t\t\t\t\tif (n !== 'week') {\n\t\t\t\t\t\tlastN = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (n) {\n\t\t\t\t\txDateFormat = dateTimeLabelFormats[n];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txDateFormat = dateTimeLabelFormats.day;\n\t\t\t}\n\n\t\t\treturn xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n\t\t},\n\n\t\t/**\n\t\t * Format the footer/header of the tooltip\n\t\t * #3397: abstraction to enable formatting of footer and header\n\t\t */\n\t\ttooltipFooterHeaderFormatter: function (point, isFooter) {\n\t\t\tvar footOrHead = isFooter ? 'footer' : 'header',\n\t\t\t\tseries = point.series,\n\t\t\t\ttooltipOptions = series.tooltipOptions,\n\t\t\t\txDateFormat = tooltipOptions.xDateFormat,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tisDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n\t\t\t\tformatString = tooltipOptions[footOrHead+'Format'];\n\n\t\t\t// Guess the best date format based on the closest point distance (#568, #3418)\n\t\t\tif (isDateTime && !xDateFormat) {\n\t\t\t\txDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n\t\t\t}\n\n\t\t\t// Insert the footer date format if any\n\t\t\tif (isDateTime && xDateFormat) {\n\t\t\t\tformatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n\t\t\t}\n\n\t\t\treturn format(formatString, {\n\t\t\t\tpoint: point,\n\t\t\t\tseries: series\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n\t     * abstracting this functionality allows to easily overwrite and extend it. \n\t\t */\n\t\tbodyFormatter: function (items) {\n\t        return map(items, function (item) {\n\t            var tooltipOptions = item.series.tooltipOptions;\n\t            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n\t        });\n\t    }\n\t    \n\t};\n\n\tvar hoverChartIndex;\n\n\t// Global flag for touch support\n\thasTouch = doc.documentElement.ontouchstart !== UNDEFINED;\n\n\t/**\n\t * The mouse tracker object. All methods starting with \"on\" are primary DOM event handlers. \n\t * Subsequent methods should be named differently from what they are doing.\n\t * @param {Object} chart The Chart instance\n\t * @param {Object} options The root options object\n\t */\n\tvar Pointer = Highcharts.Pointer = function (chart, options) {\n\t\tthis.init(chart, options);\n\t};\n\n\tPointer.prototype = {\n\t\t/**\n\t\t * Initialize Pointer\n\t\t */\n\t\tinit: function (chart, options) {\n\t\t\t\n\t\t\tvar chartOptions = options.chart,\n\t\t\t\tchartEvents = chartOptions.events,\n\t\t\t\tzoomType = useCanVG ? '' : chartOptions.zoomType,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\tzoomX,\n\t\t\t\tzoomY;\n\n\t\t\t// Store references\n\t\t\tthis.options = options;\n\t\t\tthis.chart = chart;\n\t\t\t\n\t\t\t// Zoom status\n\t\t\tthis.zoomX = zoomX = /x/.test(zoomType);\n\t\t\tthis.zoomY = zoomY = /y/.test(zoomType);\n\t\t\tthis.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n\t\t\tthis.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n\t\t\tthis.hasZoom = zoomX || zoomY;\n\n\t\t\t// Do we need to handle click on a touch device?\n\t\t\tthis.runChartClick = chartEvents && !!chartEvents.click;\n\n\t\t\tthis.pinchDown = [];\n\t\t\tthis.lastValidTouch = {};\n\n\t\t\tif (Highcharts.Tooltip && options.tooltip.enabled) {\n\t\t\t\tchart.tooltip = new Tooltip(chart, options.tooltip);\n\t\t\t\tthis.followTouchMove = pick(options.tooltip.followTouchMove, true);\n\t\t\t}\n\n\t\t\tthis.setDOMEvents();\n\t\t}, \n\n\t\t/**\n\t\t * Add crossbrowser support for chartX and chartY\n\t\t * @param {Object} e The event object in standard browsers\n\t\t */\n\t\tnormalize: function (e, chartPosition) {\n\t\t\tvar chartX,\n\t\t\t\tchartY,\n\t\t\t\tePos;\n\n\t\t\t// common IE normalizing\n\t\t\te = e || window.event;\n\n\t\t\t// Framework specific normalizing (#1165)\n\t\t\te = washMouseEvent(e);\n\n\t\t\t// More IE normalizing, needs to go after washMouseEvent\n\t\t\tif (!e.target) {\n\t\t\t\te.target = e.srcElement;\n\t\t\t}\n\t\t\t\n\t\t\t// iOS (#2757)\n\t\t\tePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n\t\t\t// Get mouse position\n\t\t\tif (!chartPosition) {\n\t\t\t\tthis.chartPosition = chartPosition = offset(this.chart.container);\n\t\t\t}\n\n\t\t\t// chartX and chartY\n\t\t\tif (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n\t\t\t\tchartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n\t\t\t\t\t// for IE10 quirks mode within framesets\n\t\t\t\tchartY = e.y;\n\t\t\t} else {\n\t\t\t\tchartX = ePos.pageX - chartPosition.left;\n\t\t\t\tchartY = ePos.pageY - chartPosition.top;\n\t\t\t}\n\n\t\t\treturn extend(e, {\n\t\t\t\tchartX: mathRound(chartX),\n\t\t\t\tchartY: mathRound(chartY)\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Get the click position in terms of axis values.\n\t\t *\n\t\t * @param {Object} e A pointer event\n\t\t */\n\t\tgetCoordinates: function (e) {\n\t\t\tvar coordinates = {\n\t\t\t\t\txAxis: [],\n\t\t\t\t\tyAxis: []\n\t\t\t\t};\n\n\t\t\teach(this.chart.axes, function (axis) {\n\t\t\t\tcoordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n\t\t\t\t\taxis: axis,\n\t\t\t\t\tvalue: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn coordinates;\n\t\t},\n\t\t\n\t\t/**\n\t\t * With line type charts with a single tracker, get the point closest to the mouse.\n\t\t * Run Point.onMouseOver and display tooltip for the point or points.\n\t\t */\n\t\trunPointActions: function (e) {\n\n\t\t\tvar pointer = this,\n\t\t\t\tchart = pointer.chart,\n\t\t\t\tseries = chart.series,\n\t\t\t\ttooltip = chart.tooltip,\n\t\t\t\tshared = tooltip ? tooltip.shared : false,\n\t\t\t\tfollowPointer,\n\t\t\t\t//point,\n\t\t\t\t//points,\n\t\t\t\thoverPoint = chart.hoverPoint,\n\t\t\t\thoverSeries = chart.hoverSeries,\n\t\t\t\ti,\n\t\t\t\ttrueXkd,\n\t\t\t\ttrueX,\n\t\t\t\t//j,\n\t\t\t\tdistance = chart.chartWidth,\n\t\t\t\trdistance = chart.chartWidth,\n\t\t\t\tanchor,\n\t\t\t\tnoSharedTooltip,\n\t\t\t\tkdpoints = [],\n\t\t\t\tkdpoint,\n\t\t\t\tkdpointT;\n\n\t\t\t// For hovering over the empty parts of the plot area (hoverSeries is undefined). \n\t\t\t// If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n\t\t\tif (!shared && !hoverSeries) {\n\t\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\t\tif (series[i].directTouch || !series[i].options.stickyTracking) {\n\t\t\t\t\t\tseries = [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle shared tooltip or cases where a series is not yet hovered\n\t\t\tif (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 \n\t\t\t\t// Find nearest points on all series\n\t\t\t\teach(series, function (s) {\n\t\t\t\t\t// Skip hidden series\n\t\t\t\t\tnoSharedTooltip = s.noSharedTooltip && shared;\n\t\t\t\t\tif (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821\n\t\t\t\t\t\tkdpointT = s.searchPoint(e); // #3828\n\t\t\t\t\t\tif (kdpointT) {\n\t\t\t\t\t\t\tkdpoints.push(kdpointT);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Find absolute nearest point\n\t\t\t\teach(kdpoints, function (p) {\n\t\t\t\t\tif (p && defined(p.plotX) && defined(p.plotY)) {\n\t\t\t\t\t\tif ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {\n\t\t\t\t\t\t\tdistance = p.dist.distX;\n\t\t\t\t\t\t\trdistance = p.dist.distR;\n\t\t\t\t\t\t\tkdpoint = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\t\n\n\t\t\t// Handle non-shared tooltips\n\t\t\t} else {\n\t\t\t\t// If it has a hoverPoint and that series requires direct touch (like columns), use the hoverPoint (#3899).\n\t\t\t\t// Otherwise, search the k-d tree (like scatter).\n\t\t\t\tkdpoint = (hoverSeries.directTouch && hoverPoint) || (hoverSeries && hoverSeries.searchPoint(e));\n\t\t\t}\n\n\t\t\t// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926\n\t\t\tif (kdpoint && (kdpoint !== hoverPoint || (tooltip && tooltip.isHidden))) {\n\t\t\t\t// Draw tooltip if necessary\n\t\t\t\tif (shared && !kdpoint.series.noSharedTooltip) {\n\t\t\t\t\ti = kdpoints.length;\n\t\t\t\t\ttrueXkd = kdpoint.clientX;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\ttrueX = kdpoints[i].clientX;\n\t\t\t\t\t\tif (kdpoints[i].x !== kdpoint.x || trueX !== trueXkd || (kdpoints[i].series.noSharedTooltip || false)) {\n\t\t\t\t\t\t\tkdpoints.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (kdpoints.length && tooltip) {\n\t\t\t\t\t\ttooltip.refresh(kdpoints, e);\n\t\t\t\t\t}\n\n\t\t\t\t\t// do mouseover on all points except the closest\n\t\t\t\t\teach(kdpoints, function (point) {\n\t\t\t\t\t\tif (point !== kdpoint) { \n\t\t\t\t\t\t\tpoint.onMouseOver(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\t\t\t\t\n\t\t\t\t\tkdpoint.onMouseOver(e); // #3919 do mouseover on the closest point last to ensure it is the hoverpoint\n\t\t\t\t} else {\n\t\t\t\t\tif (tooltip) { \n\t\t\t\t\t\ttooltip.refresh(kdpoint, e);\n\t\t\t\t\t}\n\t\t\t\t\tkdpoint.onMouseOver(e); \n\t\t\t\t}\n\t\t\t\n\t\t\t// Update positions (regardless of kdpoint or hoverPoint)\n\t\t\t} else {\n\t\t\t\tfollowPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n\t\t\t\tif (tooltip && followPointer && !tooltip.isHidden) {\n\t\t\t\t\tanchor = tooltip.getAnchor([{}], e);\n\t\t\t\t\ttooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the event listener to pick up the tooltip \n\t\t\tif (tooltip && !pointer._onDocumentMouseMove) {\n\t\t\t\tpointer._onDocumentMouseMove = function (e) {\n\t\t\t\t\tif (charts[hoverChartIndex]) {\n\t\t\t\t\t\tcharts[hoverChartIndex].pointer.onDocumentMouseMove(e);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n\t\t\t}\n\t\t\t\n\t\t\t// Crosshair\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\taxis.drawCrosshair(e, pick(kdpoint, hoverPoint));\n\t\t\t});\t\n\t\t\t\t\t\n\t\t},\n\n\n\n\t\t/**\n\t\t * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n\t\t * \n\t\t * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n\t\t */\n\t\treset: function (allowMove, delay) {\n\t\t\tvar pointer = this,\n\t\t\t\tchart = pointer.chart,\n\t\t\t\thoverSeries = chart.hoverSeries,\n\t\t\t\thoverPoint = chart.hoverPoint,\n\t\t\t\ttooltip = chart.tooltip,\n\t\t\t\ttooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;\n\t\t\t\t\n\t\t\t// Narrow in allowMove\n\t\t\tallowMove = allowMove && tooltip && tooltipPoints;\n\t\t\t\t\n\t\t\t// Check if the points have moved outside the plot area, #1003\t\t\n\t\t\tif (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {\n\t\t\t\tallowMove = false;\n\t\t\t}\t\n\t\t\t// Just move the tooltip, #349\n\t\t\tif (allowMove) {\n\t\t\t\ttooltip.refresh(tooltipPoints);\n\t\t\t\tif (hoverPoint) { // #2500\n\t\t\t\t\thoverPoint.setState(hoverPoint.state, true);\n\t\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\t\tif (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {\n\t\t\t\t\t\t\taxis.drawCrosshair(null, allowMove);\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\taxis.hideCrosshair();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t// Full reset\n\t\t\t} else {\n\n\t\t\t\tif (hoverPoint) {\n\t\t\t\t\thoverPoint.onMouseOut();\n\t\t\t\t}\n\n\t\t\t\tif (hoverSeries) {\n\t\t\t\t\thoverSeries.onMouseOut();\n\t\t\t\t}\n\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.hide(delay);\n\t\t\t\t}\n\n\t\t\t\tif (pointer._onDocumentMouseMove) {\n\t\t\t\t\tremoveEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n\t\t\t\t\tpointer._onDocumentMouseMove = null;\n\t\t\t\t}\n\n\t\t\t\t// Remove crosshairs\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\taxis.hideCrosshair();\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tpointer.hoverX = null;\n\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Scale series groups to a certain scale and translation\n\t\t */\n\t\tscaleGroups: function (attribs, clip) {\n\n\t\t\tvar chart = this.chart,\n\t\t\t\tseriesAttribs;\n\n\t\t\t// Scale each series\n\t\t\teach(chart.series, function (series) {\n\t\t\t\tseriesAttribs = attribs || series.getPlotBox(); // #1701\n\t\t\t\tif (series.xAxis && series.xAxis.zoomEnabled) {\n\t\t\t\t\tseries.group.attr(seriesAttribs);\n\t\t\t\t\tif (series.markerGroup) {\n\t\t\t\t\t\tseries.markerGroup.attr(seriesAttribs);\n\t\t\t\t\t\tseries.markerGroup.clip(clip ? chart.clipRect : null);\n\t\t\t\t\t}\n\t\t\t\t\tif (series.dataLabelsGroup) {\n\t\t\t\t\t\tseries.dataLabelsGroup.attr(seriesAttribs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Clip\n\t\t\tchart.clipRect.attr(clip || chart.clipBox);\n\t\t},\n\n\t\t/**\n\t\t * Start a drag operation\n\t\t */\n\t\tdragStart: function (e) {\n\t\t\tvar chart = this.chart;\n\n\t\t\t// Record the start position\n\t\t\tchart.mouseIsDown = e.type;\n\t\t\tchart.cancelClick = false;\n\t\t\tchart.mouseDownX = this.mouseDownX = e.chartX;\n\t\t\tchart.mouseDownY = this.mouseDownY = e.chartY;\n\t\t},\n\n\t\t/**\n\t\t * Perform a drag operation in response to a mousemove event while the mouse is down\n\t\t */\n\t\tdrag: function (e) {\n\n\t\t\tvar chart = this.chart,\n\t\t\t\tchartOptions = chart.options.chart,\n\t\t\t\tchartX = e.chartX,\n\t\t\t\tchartY = e.chartY,\n\t\t\t\tzoomHor = this.zoomHor,\n\t\t\t\tzoomVert = this.zoomVert,\n\t\t\t\tplotLeft = chart.plotLeft,\n\t\t\t\tplotTop = chart.plotTop,\n\t\t\t\tplotWidth = chart.plotWidth,\n\t\t\t\tplotHeight = chart.plotHeight,\n\t\t\t\tclickedInside,\n\t\t\t\tsize,\n\t\t\t\tmouseDownX = this.mouseDownX,\n\t\t\t\tmouseDownY = this.mouseDownY,\n\t\t\t\tpanKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n\t\t\t// If the mouse is outside the plot area, adjust to cooordinates\n\t\t\t// inside to prevent the selection marker from going outside\n\t\t\tif (chartX < plotLeft) {\n\t\t\t\tchartX = plotLeft;\n\t\t\t} else if (chartX > plotLeft + plotWidth) {\n\t\t\t\tchartX = plotLeft + plotWidth;\n\t\t\t}\n\n\t\t\tif (chartY < plotTop) {\n\t\t\t\tchartY = plotTop;\n\t\t\t} else if (chartY > plotTop + plotHeight) {\n\t\t\t\tchartY = plotTop + plotHeight;\n\t\t\t}\n\t\t\t\n\t\t\t// determine if the mouse has moved more than 10px\n\t\t\tthis.hasDragged = Math.sqrt(\n\t\t\t\tMath.pow(mouseDownX - chartX, 2) +\n\t\t\t\tMath.pow(mouseDownY - chartY, 2)\n\t\t\t);\n\t\t\t\n\t\t\tif (this.hasDragged > 10) {\n\t\t\t\tclickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n\t\t\t\t// make a selection\n\t\t\t\tif (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n\t\t\t\t\tif (!this.selectionMarker) {\n\t\t\t\t\t\tthis.selectionMarker = chart.renderer.rect(\n\t\t\t\t\t\t\tplotLeft,\n\t\t\t\t\t\t\tplotTop,\n\t\t\t\t\t\t\tzoomHor ? 1 : plotWidth,\n\t\t\t\t\t\t\tzoomVert ? 1 : plotHeight,\n\t\t\t\t\t\t\t0\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\tfill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n\t\t\t\t\t\t\tzIndex: 7\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// adjust the width of the selection marker\n\t\t\t\tif (this.selectionMarker && zoomHor) {\n\t\t\t\t\tsize = chartX - mouseDownX;\n\t\t\t\t\tthis.selectionMarker.attr({\n\t\t\t\t\t\twidth: mathAbs(size),\n\t\t\t\t\t\tx: (size > 0 ? 0 : size) + mouseDownX\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// adjust the height of the selection marker\n\t\t\t\tif (this.selectionMarker && zoomVert) {\n\t\t\t\t\tsize = chartY - mouseDownY;\n\t\t\t\t\tthis.selectionMarker.attr({\n\t\t\t\t\t\theight: mathAbs(size),\n\t\t\t\t\t\ty: (size > 0 ? 0 : size) + mouseDownY\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// panning\n\t\t\t\tif (clickedInside && !this.selectionMarker && chartOptions.panning) {\n\t\t\t\t\tchart.pan(e, chartOptions.panning);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * On mouse up or touch end across the entire document, drop the selection.\n\t\t */\n\t\tdrop: function (e) {\n\t\t\tvar pointer = this,\n\t\t\t\tchart = this.chart,\n\t\t\t\thasPinched = this.hasPinched;\n\n\t\t\tif (this.selectionMarker) {\n\t\t\t\tvar selectionData = {\n\t\t\t\t\t\txAxis: [],\n\t\t\t\t\t\tyAxis: [],\n\t\t\t\t\t\toriginalEvent: e.originalEvent || e\n\t\t\t\t\t},\n\t\t\t\t\tselectionBox = this.selectionMarker,\n\t\t\t\t\tselectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n\t\t\t\t\tselectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n\t\t\t\t\tselectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n\t\t\t\t\tselectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n\t\t\t\t\trunZoom;\n\n\t\t\t\t// a selection has been made\n\t\t\t\tif (this.hasDragged || hasPinched) {\n\n\t\t\t\t\t// record each axis' min and max\n\t\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\t\tif (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n\t\t\t\t\t\t\tvar horiz = axis.horiz,\n\t\t\t\t\t\t\t\tminPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075\n\t\t\t\t\t\t\t\tselectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n\t\t\t\t\t\t\t\tselectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n\t\t\t\t\t\t\tselectionData[axis.coll].push({\n\t\t\t\t\t\t\t\taxis: axis,\n\t\t\t\t\t\t\t\tmin: mathMin(selectionMin, selectionMax), // for reversed axes\n\t\t\t\t\t\t\t\tmax: mathMax(selectionMin, selectionMax)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\trunZoom = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (runZoom) {\n\t\t\t\t\t\tfireEvent(chart, 'selection', selectionData, function (args) { \n\t\t\t\t\t\t\tchart.zoom(extend(args, hasPinched ? { animation: false } : null)); \n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tthis.selectionMarker = this.selectionMarker.destroy();\n\n\t\t\t\t// Reset scaling preview\n\t\t\t\tif (hasPinched) {\n\t\t\t\t\tthis.scaleGroups();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reset all\n\t\t\tif (chart) { // it may be destroyed on mouse up - #877\n\t\t\t\tcss(chart.container, { cursor: chart._cursor });\n\t\t\t\tchart.cancelClick = this.hasDragged > 10; // #370\n\t\t\t\tchart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n\t\t\t\tthis.pinchDown = [];\n\t\t\t}\n\t\t},\n\n\t\tonContainerMouseDown: function (e) {\n\n\t\t\te = this.normalize(e);\n\n\t\t\t// issue #295, dragging not always working in Firefox\n\t\t\tif (e.preventDefault) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\t\n\t\t\tthis.dragStart(e);\n\t\t},\n\n\t\t\n\n\t\tonDocumentMouseUp: function (e) {\n\t\t\tif (charts[hoverChartIndex]) {\n\t\t\t\tcharts[hoverChartIndex].pointer.drop(e);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n\t\t * Issue #149 workaround. The mouseleave event does not always fire. \n\t\t */\n\t\tonDocumentMouseMove: function (e) {\n\t\t\tvar chart = this.chart,\n\t\t\t\tchartPosition = this.chartPosition;\n\n\t\t\te = this.normalize(e, chartPosition);\n\n\t\t\t// If we're outside, hide the tooltip\n\t\t\tif (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n\t\t\t\t\t!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * When mouse leaves the container, hide the tooltip.\n\t\t */\n\t\tonContainerMouseLeave: function () {\n\t\t\tvar chart = charts[hoverChartIndex];\n\t\t\tif (chart) {\n\t\t\t\tchart.pointer.reset();\n\t\t\t\tchart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n\t\t\t}\n\t\t},\n\n\t\t// The mousemove, touchmove and touchstart event handler\n\t\tonContainerMouseMove: function (e) {\n\n\t\t\tvar chart = this.chart;\n\n\t\t\thoverChartIndex = chart.index;\n\n\t\t\te = this.normalize(e);\t\t\n\t\t\te.returnValue = false; // #2251, #3224\n\t\t\t\n\t\t\tif (chart.mouseIsDown === 'mousedown') {\n\t\t\t\tthis.drag(e);\n\t\t\t} \n\t\t\t\n\t\t\t// Show the tooltip and run mouse over events (#977)\n\t\t\tif ((this.inClass(e.target, 'highcharts-tracker') || \n\t\t\t\t\tchart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n\t\t\t\tthis.runPointActions(e);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Utility to detect whether an element has, or has a parent with, a specific\n\t\t * class name. Used on detection of tracker objects and on deciding whether\n\t\t * hovering the tooltip should cause the active series to mouse out.\n\t\t */\n\t\tinClass: function (element, className) {\n\t\t\tvar elemClassName;\n\t\t\twhile (element) {\n\t\t\t\telemClassName = attr(element, 'class');\n\t\t\t\tif (elemClassName) {\n\t\t\t\t\tif (elemClassName.indexOf(className) !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telement = element.parentNode;\n\t\t\t}\t\t\n\t\t},\n\n\t\tonTrackerMouseOut: function (e) {\n\t\t\tvar series = this.chart.hoverSeries,\n\t\t\t\trelatedTarget = e.relatedTarget || e.toElement,\n\t\t\t\trelatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499\n\t\t\t\n\t\t\tif (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&\n\t\t\t\t\trelatedSeries !== series) {\n\t\t\t\tseries.onMouseOut();\n\t\t\t}\n\t\t},\n\n\t\tonContainerClick: function (e) {\n\t\t\tvar chart = this.chart,\n\t\t\t\thoverPoint = chart.hoverPoint, \n\t\t\t\tplotLeft = chart.plotLeft,\n\t\t\t\tplotTop = chart.plotTop;\n\t\t\t\n\t\t\te = this.normalize(e);\n\t\t\te.originalEvent = e; // #3913\n\t\t\te.cancelBubble = true; // IE specific\n\n\t\t\tif (!chart.cancelClick) {\n\t\t\t\t\n\t\t\t\t// On tracker click, fire the series and point events. #783, #1583\n\t\t\t\tif (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {\n\n\t\t\t\t\t// the series click event\n\t\t\t\t\tfireEvent(hoverPoint.series, 'click', extend(e, {\n\t\t\t\t\t\tpoint: hoverPoint\n\t\t\t\t\t}));\n\n\t\t\t\t\t// the point click event\n\t\t\t\t\tif (chart.hoverPoint) { // it may be destroyed (#1844)\n\t\t\t\t\t\thoverPoint.firePointEvent('click', e);\n\t\t\t\t\t}\n\n\t\t\t\t// When clicking outside a tracker, fire a chart event\n\t\t\t\t} else {\n\t\t\t\t\textend(e, this.getCoordinates(e));\n\n\t\t\t\t\t// fire a click event in the chart\n\t\t\t\t\tif (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n\t\t\t\t\t\tfireEvent(chart, 'click', e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the JS DOM events on the container and document. This method should contain\n\t\t * a one-to-one assignment between methods and their handlers. Any advanced logic should\n\t\t * be moved to the handler reflecting the event's name.\n\t\t */\n\t\tsetDOMEvents: function () {\n\n\t\t\tvar pointer = this,\n\t\t\t\tcontainer = pointer.chart.container;\n\n\t\t\tcontainer.onmousedown = function (e) {\n\t\t\t\tpointer.onContainerMouseDown(e);\n\t\t\t};\n\t\t\tcontainer.onmousemove = function (e) {\n\t\t\t\tpointer.onContainerMouseMove(e);\n\t\t\t};\n\t\t\tcontainer.onclick = function (e) {\n\t\t\t\tpointer.onContainerClick(e);\n\t\t\t};\n\t\t\taddEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n\t\t\tif (chartCount === 1) {\n\t\t\t\taddEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n\t\t\t}\n\t\t\tif (hasTouch) {\n\t\t\t\tcontainer.ontouchstart = function (e) {\n\t\t\t\t\tpointer.onContainerTouchStart(e);\n\t\t\t\t};\n\t\t\t\tcontainer.ontouchmove = function (e) {\n\t\t\t\t\tpointer.onContainerTouchMove(e);\n\t\t\t\t};\n\t\t\t\tif (chartCount === 1) {\n\t\t\t\t\taddEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Destroys the Pointer object and disconnects DOM events.\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar prop;\n\n\t\t\tremoveEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n\t\t\tif (!chartCount) {\n\t\t\t\tremoveEvent(doc, 'mouseup', this.onDocumentMouseUp);\n\t\t\t\tremoveEvent(doc, 'touchend', this.onDocumentTouchEnd);\n\t\t\t}\n\n\t\t\t// memory and CPU leak\n\t\t\tclearInterval(this.tooltipTimeout);\n\n\t\t\tfor (prop in this) {\n\t\t\t\tthis[prop] = null;\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/* Support for touch devices */\n\textend(Highcharts.Pointer.prototype, {\n\n\t\t/**\n\t\t * Run translation operations\n\t\t */\n\t\tpinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n\t\t\tif (this.zoomHor || this.pinchHor) {\n\t\t\t\tthis.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\t\t\t}\n\t\t\tif (this.zoomVert || this.pinchVert) {\n\t\t\t\tthis.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Run translation operations for each direction (horizontal and vertical) independently\n\t\t */\n\t\tpinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n\t\t\tvar chart = this.chart,\n\t\t\t\txy = horiz ? 'x' : 'y',\n\t\t\t\tXY = horiz ? 'X' : 'Y',\n\t\t\t\tsChartXY = 'chart' + XY,\n\t\t\t\twh = horiz ? 'width' : 'height',\n\t\t\t\tplotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n\t\t\t\tselectionWH,\n\t\t\t\tselectionXY,\n\t\t\t\tclipXY,\n\t\t\t\tscale = forcedScale || 1,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\tbounds = chart.bounds[horiz ? 'h' : 'v'],\n\t\t\t\tsingleTouch = pinchDown.length === 1,\n\t\t\t\ttouch0Start = pinchDown[0][sChartXY],\n\t\t\t\ttouch0Now = touches[0][sChartXY],\n\t\t\t\ttouch1Start = !singleTouch && pinchDown[1][sChartXY],\n\t\t\t\ttouch1Now = !singleTouch && touches[1][sChartXY],\n\t\t\t\toutOfBounds,\n\t\t\t\ttransformScale,\n\t\t\t\tscaleKey,\n\t\t\t\tsetScale = function () {\n\t\t\t\t\tif (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n\t\t\t\t\t\tscale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); \n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n\t\t\t\t\tselectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n\t\t\t\t};\n\n\t\t\t// Set the scale, first pass\n\t\t\tsetScale();\n\n\t\t\tselectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n\t\t\t// Out of bounds\n\t\t\tif (selectionXY < bounds.min) {\n\t\t\t\tselectionXY = bounds.min;\n\t\t\t\toutOfBounds = true;\n\t\t\t} else if (selectionXY + selectionWH > bounds.max) {\n\t\t\t\tselectionXY = bounds.max - selectionWH;\n\t\t\t\toutOfBounds = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Is the chart dragged off its bounds, determined by dataMin and dataMax?\n\t\t\tif (outOfBounds) {\n\n\t\t\t\t// Modify the touchNow position in order to create an elastic drag movement. This indicates\n\t\t\t\t// to the user that the chart is responsive but can't be dragged further.\n\t\t\t\ttouch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n\t\t\t\tif (!singleTouch) {\n\t\t\t\t\ttouch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n\t\t\t\t}\n\n\t\t\t\t// Set the scale, second pass to adapt to the modified touchNow positions\n\t\t\t\tsetScale();\n\n\t\t\t} else {\n\t\t\t\tlastValidTouch[xy] = [touch0Now, touch1Now];\n\t\t\t}\n\n\t\t\t// Set geometry for clipping, selection and transformation\n\t\t\tif (!inverted) { // TODO: implement clipping for inverted charts\n\t\t\t\tclip[xy] = clipXY - plotLeftTop;\n\t\t\t\tclip[wh] = selectionWH;\n\t\t\t}\n\t\t\tscaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n\t\t\ttransformScale = inverted ? 1 / scale : scale;\n\n\t\t\tselectionMarker[wh] = selectionWH;\n\t\t\tselectionMarker[xy] = selectionXY;\n\t\t\ttransform[scaleKey] = scale;\n\t\t\ttransform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Handle touch events with two touches\n\t\t */\n\t\tpinch: function (e) {\n\n\t\t\tvar self = this,\n\t\t\t\tchart = self.chart,\n\t\t\t\tpinchDown = self.pinchDown,\n\t\t\t\ttouches = e.touches,\n\t\t\t\ttouchesLength = touches.length,\n\t\t\t\tlastValidTouch = self.lastValidTouch,\n\t\t\t\thasZoom = self.hasZoom,\n\t\t\t\tselectionMarker = self.selectionMarker,\n\t\t\t\ttransform = {},\n\t\t\t\tfireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && \n\t\t\t\t\tchart.runTrackerClick) || self.runChartClick),\n\t\t\t\tclip = {};\n\n\t\t\t// On touch devices, only proceed to trigger click if a handler is defined\n\t\t\tif (hasZoom && !fireClickEvent) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\t\n\t\t\t// Normalize each touch\n\t\t\tmap(touches, function (e) {\n\t\t\t\treturn self.normalize(e);\n\t\t\t});\n\t\t\t\n\t\t\t// Register the touch start position\n\t\t\tif (e.type === 'touchstart') {\n\t\t\t\teach(touches, function (e, i) {\n\t\t\t\t\tpinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n\t\t\t\t});\n\t\t\t\tlastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n\t\t\t\tlastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n\t\t\t\t// Identify the data bounds in pixels\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\tif (axis.zoomEnabled) {\n\t\t\t\t\t\tvar bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n\t\t\t\t\t\t\tminPixelPadding = axis.minPixelPadding,\n\t\t\t\t\t\t\tmin = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n\t\t\t\t\t\t\tmax = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n\t\t\t\t\t\t\tabsMin = mathMin(min, max),\n\t\t\t\t\t\t\tabsMax = mathMax(min, max);\n\n\t\t\t\t\t\t// Store the bounds for use in the touchmove handler\n\t\t\t\t\t\tbounds.min = mathMin(axis.pos, absMin - minPixelPadding);\n\t\t\t\t\t\tbounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tself.res = true; // reset on next move\n\t\t\t\n\t\t\t// Event type is touchmove, handle panning and pinching\n\t\t\t} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\t\t\t\t\n\n\t\t\t\t// Set the marker\n\t\t\t\tif (!selectionMarker) {\n\t\t\t\t\tself.selectionMarker = selectionMarker = extend({\n\t\t\t\t\t\tdestroy: noop\n\t\t\t\t\t}, chart.plotBox);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tself.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n\t\t\t\tself.hasPinched = hasZoom;\n\n\t\t\t\t// Scale and translate the groups to provide visual feedback during pinching\n\t\t\t\tself.scaleGroups(transform, clip);\n\t\t\t\t\n\t\t\t\t// Optionally move the tooltip on touchmove\n\t\t\t\tif (!hasZoom && self.followTouchMove && touchesLength === 1) {\n\t\t\t\t\tthis.runPointActions(self.normalize(e));\n\t\t\t\t} else if (self.res) {\n\t\t\t\t\tself.res = false;\n\t\t\t\t\tthis.reset(false, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tonContainerTouchStart: function (e) {\n\t\t\tvar chart = this.chart;\n\n\t\t\thoverChartIndex = chart.index;\n\n\t\t\tif (e.touches.length === 1) {\n\n\t\t\t\te = this.normalize(e);\n\n\t\t\t\tif (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n\t\t\t\t\t// Run mouse events and display tooltip etc\n\t\t\t\t\tthis.runPointActions(e);\n\n\t\t\t\t\tthis.pinch(e);\n\n\t\t\t\t} else {\n\t\t\t\t\t// Hide the tooltip on touching outside the plot area (#1203)\n\t\t\t\t\tthis.reset();\n\t\t\t\t}\n\n\t\t\t} else if (e.touches.length === 2) {\n\t\t\t\tthis.pinch(e);\n\t\t\t}   \n\t\t},\n\n\t\tonContainerTouchMove: function (e) {\n\t\t\tif (e.touches.length === 1 || e.touches.length === 2) {\n\t\t\t\tthis.pinch(e);\n\t\t\t}\n\t\t},\n\n\t\tonDocumentTouchEnd: function (e) {\n\t\t\tif (charts[hoverChartIndex]) {\n\t\t\t\tcharts[hoverChartIndex].pointer.drop(e);\n\t\t\t}\n\t\t}\n\n\t});\n\tif (win.PointerEvent || win.MSPointerEvent) {\n\t\t\n\t\t// The touches object keeps track of the points being touched at all times\n\t\tvar touches = {},\n\t\t\thasPointerEvent = !!win.PointerEvent,\n\t\t\tgetWebkitTouches = function () {\n\t\t\t\tvar key, fake = [];\n\t\t\t\tfake.item = function (i) { return this[i]; };\n\t\t\t\tfor (key in touches) {\n\t\t\t\t\tif (touches.hasOwnProperty(key)) {\n\t\t\t\t\t\tfake.push({\n\t\t\t\t\t\t\tpageX: touches[key].pageX,\n\t\t\t\t\t\t\tpageY: touches[key].pageY,\n\t\t\t\t\t\t\ttarget: touches[key].target\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fake;\n\t\t\t},\n\t\t\ttranslateMSPointer = function (e, method, wktype, callback) {\n\t\t\t\tvar p;\n\t\t\t\te = e.originalEvent || e;\n\t\t\t\tif ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t\tp = charts[hoverChartIndex].pointer;\n\t\t\t\t\tp[method]({\n\t\t\t\t\t\ttype: wktype,\n\t\t\t\t\t\ttarget: e.currentTarget,\n\t\t\t\t\t\tpreventDefault: noop,\n\t\t\t\t\t\ttouches: getWebkitTouches()\n\t\t\t\t\t});\t\t\t\t\n\t\t\t\t}\n\t\t\t};\n\n\t\t/**\n\t\t * Extend the Pointer prototype with methods for each event handler and more\n\t\t */\n\t\textend(Pointer.prototype, {\n\t\t\tonContainerPointerDown: function (e) {\n\t\t\t\ttranslateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n\t\t\t\t\ttouches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n\t\t\t\t});\n\t\t\t},\n\t\t\tonContainerPointerMove: function (e) {\n\t\t\t\ttranslateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n\t\t\t\t\ttouches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n\t\t\t\t\tif (!touches[e.pointerId].target) {\n\t\t\t\t\t\ttouches[e.pointerId].target = e.currentTarget;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonDocumentPointerUp: function (e) {\n\t\t\t\ttranslateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {\n\t\t\t\t\tdelete touches[e.pointerId];\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Add or remove the MS Pointer specific events\n\t\t\t */\n\t\t\tbatchMSEvents: function (fn) {\n\t\t\t\tfn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n\t\t\t\tfn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n\t\t\t\tfn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n\t\t\t}\n\t\t});\n\n\t\t// Disable default IE actions for pinch and such on chart element\n\t\twrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\t\t\tproceed.call(this, chart, options);\n\t\t\tif (this.hasZoom || this.followTouchMove) {\n\t\t\t\tcss(chart.container, {\n\t\t\t\t\t'-ms-touch-action': NONE,\n\t\t\t\t\t'touch-action': NONE\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// Add IE specific touch events to chart\n\t\twrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n\t\t\tproceed.apply(this);\n\t\t\tif (this.hasZoom || this.followTouchMove) {\n\t\t\t\tthis.batchMSEvents(addEvent);\n\t\t\t}\n\t\t});\n\t\t// Destroy MS events also\n\t\twrap(Pointer.prototype, 'destroy', function (proceed) {\n\t\t\tthis.batchMSEvents(removeEvent);\n\t\t\tproceed.call(this);\n\t\t});\n\t}\n\t/**\n\t * The overview of the chart's series\n\t */\n\tvar Legend = Highcharts.Legend = function (chart, options) {\n\t\tthis.init(chart, options);\n\t};\n\n\tLegend.prototype = {\n\t\t\n\t\t/**\n\t\t * Initialize the legend\n\t\t */\n\t\tinit: function (chart, options) {\n\t\t\t\n\t\t\tvar legend = this,\n\t\t\t\titemStyle = options.itemStyle,\n\t\t\t\tpadding,\n\t\t\t\titemMarginTop = options.itemMarginTop || 0;\n\t\t\n\t\t\tthis.options = options;\n\n\t\t\tif (!options.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tlegend.itemStyle = itemStyle;\n\t\t\tlegend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n\t\t\tlegend.itemMarginTop = itemMarginTop;\n\t\t\tlegend.padding = padding = pick(options.padding, 8);\n\t\t\tlegend.initialItemX = padding;\n\t\t\tlegend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n\t\t\tlegend.maxItemWidth = 0;\n\t\t\tlegend.chart = chart;\n\t\t\tlegend.itemHeight = 0;\n\t\t\tlegend.symbolWidth = pick(options.symbolWidth, 16);\n\t\t\tlegend.pages = [];\n\n\n\t\t\t// Render it\n\t\t\tlegend.render();\n\n\t\t\t// move checkboxes\n\t\t\taddEvent(legend.chart, 'endResize', function () { \n\t\t\t\tlegend.positionCheckboxes();\n\t\t\t});\n\n\t\t},\n\n\t\t/**\n\t\t * Set the colors for the legend item\n\t\t * @param {Object} item A Series or Point instance\n\t\t * @param {Object} visible Dimmed or colored\n\t\t */\n\t\tcolorizeItem: function (item, visible) {\n\t\t\tvar legend = this,\n\t\t\t\toptions = legend.options,\n\t\t\t\tlegendItem = item.legendItem,\n\t\t\t\tlegendLine = item.legendLine,\n\t\t\t\tlegendSymbol = item.legendSymbol,\n\t\t\t\thiddenColor = legend.itemHiddenStyle.color,\n\t\t\t\ttextColor = visible ? options.itemStyle.color : hiddenColor,\n\t\t\t\tsymbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n\t\t\t\tmarkerOptions = item.options && item.options.marker,\n\t\t\t\tsymbolAttr = { fill: symbolColor },\n\t\t\t\tkey,\n\t\t\t\tval;\n\t\t\t\n\t\t\tif (legendItem) {\n\t\t\t\tlegendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n\t\t\t}\n\t\t\tif (legendLine) {\n\t\t\t\tlegendLine.attr({ stroke: symbolColor });\n\t\t\t}\n\t\t\t\n\t\t\tif (legendSymbol) {\n\t\t\t\t\n\t\t\t\t// Apply marker options\n\t\t\t\tif (markerOptions && legendSymbol.isMarker) { // #585\n\t\t\t\t\tsymbolAttr.stroke = symbolColor;\n\t\t\t\t\tmarkerOptions = item.convertAttribs(markerOptions);\n\t\t\t\t\tfor (key in markerOptions) {\n\t\t\t\t\t\tval = markerOptions[key];\n\t\t\t\t\t\tif (val !== UNDEFINED) {\n\t\t\t\t\t\t\tsymbolAttr[key] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlegendSymbol.attr(symbolAttr);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Position the legend item\n\t\t * @param {Object} item A Series or Point instance\n\t\t */\n\t\tpositionItem: function (item) {\n\t\t\tvar legend = this,\n\t\t\t\toptions = legend.options,\n\t\t\t\tsymbolPadding = options.symbolPadding,\n\t\t\t\tltr = !options.rtl,\n\t\t\t\tlegendItemPos = item._legendItemPos,\n\t\t\t\titemX = legendItemPos[0],\n\t\t\t\titemY = legendItemPos[1],\n\t\t\t\tcheckbox = item.checkbox;\n\n\t\t\tif (item.legendGroup) {\n\t\t\t\titem.legendGroup.translate(\n\t\t\t\t\tltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n\t\t\t\t\titemY\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (checkbox) {\n\t\t\t\tcheckbox.x = itemX;\n\t\t\t\tcheckbox.y = itemY;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Destroy a single legend item\n\t\t * @param {Object} item The series or point\n\t\t */\n\t\tdestroyItem: function (item) {\n\t\t\tvar checkbox = item.checkbox;\n\n\t\t\t// destroy SVG elements\n\t\t\teach(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n\t\t\t\tif (item[key]) {\n\t\t\t\t\titem[key] = item[key].destroy();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (checkbox) {\n\t\t\t\tdiscardElement(item.checkbox);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Destroy all items.\n\t\t */\n\t\tclearItems: function () {\n\t\t\tvar legend = this;\n\t\t\teach(legend.getAllItems(), function (item) {\n\t\t\t\tlegend.destroyItem(item); \n\t\t\t});\t\t\n\t\t},\n\n\t\t/**\n\t\t * Destroys the legend.\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar legend = this,\n\t\t\t\tlegendGroup = legend.group,\n\t\t\t\tbox = legend.box;\n\n\t\t\tif (box) {\n\t\t\t\tlegend.box = box.destroy();\n\t\t\t}\n\n\t\t\tif (legendGroup) {\n\t\t\t\tlegend.group = legendGroup.destroy();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Position the checkboxes after the width is determined\n\t\t */\n\t\tpositionCheckboxes: function (scrollOffset) {\n\t\t\tvar alignAttr = this.group.alignAttr,\n\t\t\t\ttranslateY,\n\t\t\t\tclipHeight = this.clipHeight || this.legendHeight;\n\n\t\t\tif (alignAttr) {\n\t\t\t\ttranslateY = alignAttr.translateY;\n\t\t\t\teach(this.allItems, function (item) {\n\t\t\t\t\tvar checkbox = item.checkbox,\n\t\t\t\t\t\ttop;\n\t\t\t\t\t\n\t\t\t\t\tif (checkbox) {\n\t\t\t\t\t\ttop = (translateY + checkbox.y + (scrollOffset || 0) + 3);\n\t\t\t\t\t\tcss(checkbox, {\n\t\t\t\t\t\t\tleft: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,\n\t\t\t\t\t\t\ttop: top + PX,\n\t\t\t\t\t\t\tdisplay: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Render the legend title on top of the legend\n\t\t */\n\t\trenderTitle: function () {\n\t\t\tvar options = this.options,\n\t\t\t\tpadding = this.padding,\n\t\t\t\ttitleOptions = options.title,\n\t\t\t\ttitleHeight = 0,\n\t\t\t\tbBox;\n\t\t\t\n\t\t\tif (titleOptions.text) {\n\t\t\t\tif (!this.title) {\n\t\t\t\t\tthis.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n\t\t\t\t\t\t.attr({ zIndex: 1 })\n\t\t\t\t\t\t.css(titleOptions.style)\n\t\t\t\t\t\t.add(this.group);\n\t\t\t\t}\n\t\t\t\tbBox = this.title.getBBox();\n\t\t\t\ttitleHeight = bBox.height;\n\t\t\t\tthis.offsetWidth = bBox.width; // #1717\n\t\t\t\tthis.contentGroup.attr({ translateY: titleHeight });\n\t\t\t}\n\t\t\tthis.titleHeight = titleHeight;\n\t\t},\n\n\t\t/**\n\t\t * Render a single specific legend item\n\t\t * @param {Object} item A series or point\n\t\t */\n\t\trenderItem: function (item) {\n\t\t\tvar legend = this,\n\t\t\t\tchart = legend.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\toptions = legend.options,\n\t\t\t\thorizontal = options.layout === 'horizontal',\n\t\t\t\tsymbolWidth = legend.symbolWidth,\n\t\t\t\tsymbolPadding = options.symbolPadding,\n\t\t\t\titemStyle = legend.itemStyle,\n\t\t\t\titemHiddenStyle = legend.itemHiddenStyle,\n\t\t\t\tpadding = legend.padding,\n\t\t\t\titemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n\t\t\t\tltr = !options.rtl,\n\t\t\t\titemHeight,\n\t\t\t\twidthOption = options.width,\n\t\t\t\titemMarginBottom = options.itemMarginBottom || 0,\n\t\t\t\titemMarginTop = legend.itemMarginTop,\n\t\t\t\tinitialItemX = legend.initialItemX,\n\t\t\t\tbBox,\n\t\t\t\titemWidth,\n\t\t\t\tli = item.legendItem,\n\t\t\t\tseries = item.series && item.series.drawLegendSymbol ? item.series : item,\n\t\t\t\tseriesOptions = series.options,\n\t\t\t\tshowCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n\t\t\t\tuseHTML = options.useHTML;\n\n\t\t\tif (!li) { // generate it once, later move it\n\n\t\t\t\t// Generate the group box\n\t\t\t\t// A group to hold the symbol and text. Text is to be appended in Legend class.\n\t\t\t\titem.legendGroup = renderer.g('legend-item')\n\t\t\t\t\t.attr({ zIndex: 1 })\n\t\t\t\t\t.add(legend.scrollGroup);\n\n\t\t\t\t// Generate the list item text and add it to the group\n\t\t\t\titem.legendItem = li = renderer.text(\n\t\t\t\t\t\toptions.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),\n\t\t\t\t\t\tltr ? symbolWidth + symbolPadding : -symbolPadding,\n\t\t\t\t\t\tlegend.baseline || 0,\n\t\t\t\t\t\tuseHTML\n\t\t\t\t\t)\n\t\t\t\t\t.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\talign: ltr ? 'left' : 'right',\n\t\t\t\t\t\tzIndex: 2\n\t\t\t\t\t})\n\t\t\t\t\t.add(item.legendGroup);\n\n\t\t\t\t// Get the baseline for the first item - the font size is equal for all\n\t\t\t\tif (!legend.baseline) {\n\t\t\t\t\tlegend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;\n\t\t\t\t\tli.attr('y', legend.baseline);\n\t\t\t\t}\n\n\t\t\t\t// Draw the legend symbol inside the group box\n\t\t\t\tseries.drawLegendSymbol(legend, item);\n\n\t\t\t\tif (legend.setItemEvents) {\n\t\t\t\t\tlegend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);\n\t\t\t\t}\t\t\t\n\n\t\t\t\t// Colorize the items\n\t\t\t\tlegend.colorizeItem(item, item.visible);\n\n\t\t\t\t// add the HTML checkbox on top\n\t\t\t\tif (showCheckbox) {\n\t\t\t\t\tlegend.createCheckboxForItem(item);\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// calculate the positions for the next line\n\t\t\tbBox = li.getBBox();\n\n\t\t\titemWidth = item.checkboxOffset = \n\t\t\t\toptions.itemWidth || \n\t\t\t\titem.legendItemWidth || \n\t\t\t\tsymbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n\t\t\tlegend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);\n\n\t\t\t// if the item exceeds the width, start a new line\n\t\t\tif (horizontal && legend.itemX - initialItemX + itemWidth >\n\t\t\t\t\t(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n\t\t\t\tlegend.itemX = initialItemX;\n\t\t\t\tlegend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n\t\t\t}\n\n\t\t\t// If the item exceeds the height, start a new column\n\t\t\t/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n\t\t\t\tlegend.itemY = legend.initialItemY;\n\t\t\t\tlegend.itemX += legend.maxItemWidth;\n\t\t\t\tlegend.maxItemWidth = 0;\n\t\t\t}*/\n\n\t\t\t// Set the edge positions\n\t\t\tlegend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n\t\t\tlegend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n\t\t\tlegend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n\t\t\t// cache the position of the newly generated or reordered items\n\t\t\titem._legendItemPos = [legend.itemX, legend.itemY];\n\n\t\t\t// advance\n\t\t\tif (horizontal) {\n\t\t\t\tlegend.itemX += itemWidth;\n\n\t\t\t} else {\n\t\t\t\tlegend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n\t\t\t\tlegend.lastLineHeight = itemHeight;\n\t\t\t}\n\n\t\t\t// the width of the widest item\n\t\t\tlegend.offsetWidth = widthOption || mathMax(\n\t\t\t\t(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n\t\t\t\tlegend.offsetWidth\n\t\t\t);\n\t\t},\n\n\t\t/**\n\t\t * Get all items, which is one item per series for normal series and one item per point\n\t\t * for pie series.\n\t\t */\n\t\tgetAllItems: function () {\n\t\t\tvar allItems = [];\n\t\t\teach(this.chart.series, function (series) {\n\t\t\t\tvar seriesOptions = series.options;\n\n\t\t\t\t// Handle showInLegend. If the series is linked to another series, defaults to false.\n\t\t\t\tif (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// use points or series for the legend item depending on legendType\n\t\t\t\tallItems = allItems.concat(\n\t\t\t\t\t\tseries.legendItems ||\n\t\t\t\t\t\t(seriesOptions.legendType === 'point' ?\n\t\t\t\t\t\t\t\tseries.data :\n\t\t\t\t\t\t\t\tseries)\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn allItems;\n\t\t},\n\n\t\t/**\n\t\t * Adjust the chart margins by reserving space for the legend on only one side\n\t\t * of the chart. If the position is set to a corner, top or bottom is reserved\n\t\t * for horizontal legends and left or right for vertical ones.\n\t\t */\n\t\tadjustMargins: function (margin, spacing) {\n\t\t\tvar chart = this.chart, \n\t\t\t\toptions = this.options,\n\t\t\t\t// Use the first letter of each alignment option in order to detect the side \n\t\t\t\talignment = options.align[0] + options.verticalAlign[0] + options.layout[0];\n\t\t\t\t\n\t\t\tif (this.display && !options.floating) {\n\n\t\t\t\teach([\n\t\t\t\t\t/(lth|ct|rth)/,\n\t\t\t\t\t/(rtv|rm|rbv)/,\n\t\t\t\t\t/(rbh|cb|lbh)/,\n\t\t\t\t\t/(lbv|lm|ltv)/\n\t\t\t\t], function (alignments, side) {\n\t\t\t\t\tif (alignments.test(alignment) && !defined(margin[side])) {\n\t\t\t\t\t\t// Now we have detected on which side of the chart we should reserve space for the legend\n\t\t\t\t\t\tchart[marginNames[side]] = mathMax(\n\t\t\t\t\t\t\tchart[marginNames[side]],\n\t\t\t\t\t\t\tchart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + \n\t\t\t\t\t\t\t\t[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + \n\t\t\t\t\t\t\t\tpick(options.margin, 12) +\n\t\t\t\t\t\t\t\tspacing[side]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Render the legend. This method can be called both before and after\n\t\t * chart.render. If called after, it will only rearrange items instead\n\t\t * of creating new ones.\n\t\t */\n\t\trender: function () {\n\t\t\tvar legend = this,\n\t\t\t\tchart = legend.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tlegendGroup = legend.group,\n\t\t\t\tallItems,\n\t\t\t\tdisplay,\n\t\t\t\tlegendWidth,\n\t\t\t\tlegendHeight,\n\t\t\t\tbox = legend.box,\n\t\t\t\toptions = legend.options,\n\t\t\t\tpadding = legend.padding,\n\t\t\t\tlegendBorderWidth = options.borderWidth,\n\t\t\t\tlegendBackgroundColor = options.backgroundColor;\n\n\t\t\tlegend.itemX = legend.initialItemX;\n\t\t\tlegend.itemY = legend.initialItemY;\n\t\t\tlegend.offsetWidth = 0;\n\t\t\tlegend.lastItemY = 0;\n\n\t\t\tif (!legendGroup) {\n\t\t\t\tlegend.group = legendGroup = renderer.g('legend')\n\t\t\t\t\t.attr({ zIndex: 7 }) \n\t\t\t\t\t.add();\n\t\t\t\tlegend.contentGroup = renderer.g()\n\t\t\t\t\t.attr({ zIndex: 1 }) // above background\n\t\t\t\t\t.add(legendGroup);\n\t\t\t\tlegend.scrollGroup = renderer.g()\n\t\t\t\t\t.add(legend.contentGroup);\n\t\t\t}\n\t\t\t\n\t\t\tlegend.renderTitle();\n\n\t\t\t// add each series or point\n\t\t\tallItems = legend.getAllItems();\n\n\t\t\t// sort by legendIndex\n\t\t\tstableSort(allItems, function (a, b) {\n\t\t\t\treturn ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n\t\t\t});\n\n\t\t\t// reversed legend\n\t\t\tif (options.reversed) {\n\t\t\t\tallItems.reverse();\n\t\t\t}\n\n\t\t\tlegend.allItems = allItems;\n\t\t\tlegend.display = display = !!allItems.length;\n\n\t\t\t// render the items\n\t\t\tlegend.lastLineHeight = 0;\n\t\t\teach(allItems, function (item) {\n\t\t\t\tlegend.renderItem(item); \n\t\t\t});\n\n\t\t\t// Get the box\n\t\t\tlegendWidth = (options.width || legend.offsetWidth) + padding;\n\t\t\tlegendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n\t\t\tlegendHeight = legend.handleOverflow(legendHeight);\n\t\t\tlegendHeight += padding;\n\n\t\t\t// Draw the border and/or background\n\t\t\tif (legendBorderWidth || legendBackgroundColor) {\n\n\t\t\t\tif (!box) {\n\t\t\t\t\tlegend.box = box = renderer.rect(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tlegendWidth,\n\t\t\t\t\t\tlegendHeight,\n\t\t\t\t\t\toptions.borderRadius,\n\t\t\t\t\t\tlegendBorderWidth || 0\n\t\t\t\t\t).attr({\n\t\t\t\t\t\tstroke: options.borderColor,\n\t\t\t\t\t\t'stroke-width': legendBorderWidth || 0,\n\t\t\t\t\t\tfill: legendBackgroundColor || NONE\n\t\t\t\t\t})\n\t\t\t\t\t.add(legendGroup)\n\t\t\t\t\t.shadow(options.shadow);\n\t\t\t\t\tbox.isNew = true;\n\n\t\t\t\t} else if (legendWidth > 0 && legendHeight > 0) {\n\t\t\t\t\tbox[box.isNew ? 'attr' : 'animate'](\n\t\t\t\t\t\tbox.crisp({ width: legendWidth, height: legendHeight })\n\t\t\t\t\t);\n\t\t\t\t\tbox.isNew = false;\n\t\t\t\t}\n\n\t\t\t\t// hide the border if no items\n\t\t\t\tbox[display ? 'show' : 'hide']();\n\t\t\t}\n\t\t\t\n\t\t\tlegend.legendWidth = legendWidth;\n\t\t\tlegend.legendHeight = legendHeight;\n\n\t\t\t// Now that the legend width and height are established, put the items in the \n\t\t\t// final position\n\t\t\teach(allItems, function (item) {\n\t\t\t\tlegend.positionItem(item);\n\t\t\t});\n\n\t\t\t// 1.x compatibility: positioning based on style\n\t\t\t/*var props = ['left', 'right', 'top', 'bottom'],\n\t\t\t\tprop,\n\t\t\t\ti = 4;\n\t\t\twhile (i--) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (options.style[prop] && options.style[prop] !== 'auto') {\n\t\t\t\t\toptions[i < 2 ? 'align' : 'verticalAlign'] = prop;\n\t\t\t\t\toptions[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n\t\t\t\t}\n\t\t\t}*/\n\n\t\t\tif (display) {\n\t\t\t\tlegendGroup.align(extend({\n\t\t\t\t\twidth: legendWidth,\n\t\t\t\t\theight: legendHeight\n\t\t\t\t}, options), true, 'spacingBox');\n\t\t\t}\n\n\t\t\tif (!chart.isResizing) {\n\t\t\t\tthis.positionCheckboxes();\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Set up the overflow handling by adding navigation with up and down arrows below the\n\t\t * legend.\n\t\t */\n\t\thandleOverflow: function (legendHeight) {\n\t\t\tvar legend = this,\n\t\t\t\tchart = this.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\toptions = this.options,\n\t\t\t\toptionsY = options.y,\n\t\t\t\talignTop = options.verticalAlign === 'top',\n\t\t\t\tspaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n\t\t\t\tmaxHeight = options.maxHeight,\n\t\t\t\tclipHeight,\n\t\t\t\tclipRect = this.clipRect,\n\t\t\t\tnavOptions = options.navigation,\n\t\t\t\tanimation = pick(navOptions.animation, true),\n\t\t\t\tarrowSize = navOptions.arrowSize || 12,\n\t\t\t\tnav = this.nav,\n\t\t\t\tpages = this.pages,\n\t\t\t\tlastY,\n\t\t\t\tallItems = this.allItems;\n\t\t\t\t\n\t\t\t// Adjust the height\n\t\t\tif (options.layout === 'horizontal') {\n\t\t\t\tspaceHeight /= 2;\n\t\t\t}\n\t\t\tif (maxHeight) {\n\t\t\t\tspaceHeight = mathMin(spaceHeight, maxHeight);\n\t\t\t}\n\t\t\t\n\t\t\t// Reset the legend height and adjust the clipping rectangle\n\t\t\tpages.length = 0;\n\t\t\tif (legendHeight > spaceHeight && !options.useHTML) {\n\n\t\t\t\tthis.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);\n\t\t\t\tthis.currentPage = pick(this.currentPage, 1);\n\t\t\t\tthis.fullHeight = legendHeight;\n\t\t\t\t\n\t\t\t\t// Fill pages with Y positions so that the top of each a legend item defines\n\t\t\t\t// the scroll top for each page (#2098)\n\t\t\t\teach(allItems, function (item, i) {\n\t\t\t\t\tvar y = item._legendItemPos[1],\n\t\t\t\t\t\th = mathRound(item.legendItem.getBBox().height),\n\t\t\t\t\t\tlen = pages.length;\n\t\t\t\t\t\n\t\t\t\t\tif (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n\t\t\t\t\t\tpages.push(lastY || y);\n\t\t\t\t\t\tlen++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n\t\t\t\t\t\tpages.push(y);\n\t\t\t\t\t}\n\t\t\t\t\tif (y !== lastY) {\n\t\t\t\t\t\tlastY = y;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n\t\t\t\tif (!clipRect) {\n\t\t\t\t\tclipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);\n\t\t\t\t\tlegend.contentGroup.clip(clipRect);\n\t\t\t\t}\n\t\t\t\tclipRect.attr({\n\t\t\t\t\theight: clipHeight\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Add navigation elements\n\t\t\t\tif (!nav) {\n\t\t\t\t\tthis.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n\t\t\t\t\tthis.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n\t\t\t\t\t\t.on('click', function () {\n\t\t\t\t\t\t\tlegend.scroll(-1, animation);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add(nav);\n\t\t\t\t\tthis.pager = renderer.text('', 15, 10)\n\t\t\t\t\t\t.css(navOptions.style)\n\t\t\t\t\t\t.add(nav);\n\t\t\t\t\tthis.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n\t\t\t\t\t\t.on('click', function () {\n\t\t\t\t\t\t\tlegend.scroll(1, animation);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add(nav);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Set initial position\n\t\t\t\tlegend.scroll(0);\n\t\t\t\t\n\t\t\t\tlegendHeight = spaceHeight;\n\t\t\t\t\n\t\t\t} else if (nav) {\n\t\t\t\tclipRect.attr({\n\t\t\t\t\theight: chart.chartHeight\n\t\t\t\t});\n\t\t\t\tnav.hide();\n\t\t\t\tthis.scrollGroup.attr({\n\t\t\t\t\ttranslateY: 1\n\t\t\t\t});\n\t\t\t\tthis.clipHeight = 0; // #1379\n\t\t\t}\n\t\t\t\n\t\t\treturn legendHeight;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Scroll the legend by a number of pages\n\t\t * @param {Object} scrollBy\n\t\t * @param {Object} animation\n\t\t */\n\t\tscroll: function (scrollBy, animation) {\n\t\t\tvar pages = this.pages,\n\t\t\t\tpageCount = pages.length,\n\t\t\t\tcurrentPage = this.currentPage + scrollBy,\n\t\t\t\tclipHeight = this.clipHeight,\n\t\t\t\tnavOptions = this.options.navigation,\n\t\t\t\tactiveColor = navOptions.activeColor,\n\t\t\t\tinactiveColor = navOptions.inactiveColor,\n\t\t\t\tpager = this.pager,\n\t\t\t\tpadding = this.padding,\n\t\t\t\tscrollOffset;\n\t\t\t\n\t\t\t// When resizing while looking at the last page\n\t\t\tif (currentPage > pageCount) {\n\t\t\t\tcurrentPage = pageCount;\n\t\t\t}\n\t\t\t\n\t\t\tif (currentPage > 0) {\n\t\t\t\t\n\t\t\t\tif (animation !== UNDEFINED) {\n\t\t\t\t\tsetAnimation(animation, this.chart);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.nav.attr({\n\t\t\t\t\ttranslateX: padding,\n\t\t\t\t\ttranslateY: clipHeight + this.padding + 7 + this.titleHeight,\n\t\t\t\t\tvisibility: VISIBLE\n\t\t\t\t});\n\t\t\t\tthis.up.attr({\n\t\t\t\t\t\tfill: currentPage === 1 ? inactiveColor : activeColor\n\t\t\t\t\t})\n\t\t\t\t\t.css({\n\t\t\t\t\t\tcursor: currentPage === 1 ? 'default' : 'pointer'\n\t\t\t\t\t});\n\t\t\t\tpager.attr({\n\t\t\t\t\ttext: currentPage + '/' + pageCount\n\t\t\t\t});\n\t\t\t\tthis.down.attr({\n\t\t\t\t\t\tx: 18 + this.pager.getBBox().width, // adjust to text width\n\t\t\t\t\t\tfill: currentPage === pageCount ? inactiveColor : activeColor\n\t\t\t\t\t})\n\t\t\t\t\t.css({\n\t\t\t\t\t\tcursor: currentPage === pageCount ? 'default' : 'pointer'\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\tscrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n\t\t\t\tthis.scrollGroup.animate({\n\t\t\t\t\ttranslateY: scrollOffset\n\t\t\t\t});\t\t\t\n\t\t\t\t\n\t\t\t\tthis.currentPage = currentPage;\n\t\t\t\tthis.positionCheckboxes(scrollOffset);\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t/*\n\t * LegendSymbolMixin\n\t */ \n\n\tvar LegendSymbolMixin = Highcharts.LegendSymbolMixin = {\n\n\t\t/**\n\t\t * Get the series' symbol in the legend\n\t\t * \n\t\t * @param {Object} legend The legend object\n\t\t * @param {Object} item The series (this) or point\n\t\t */\n\t\tdrawRectangle: function (legend, item) {\n\t\t\tvar symbolHeight = legend.options.symbolHeight || 12;\n\t\t\t\n\t\t\titem.legendSymbol = this.chart.renderer.rect(\n\t\t\t\t0,\n\t\t\t\tlegend.baseline - 5 - (symbolHeight / 2),\n\t\t\t\tlegend.symbolWidth,\n\t\t\t\tsymbolHeight,\n\t\t\t\tlegend.options.symbolRadius || 0\n\t\t\t).attr({\n\t\t\t\tzIndex: 3\n\t\t\t}).add(item.legendGroup);\t\t\n\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Get the series' symbol in the legend. This method should be overridable to create custom \n\t\t * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n\t\t * \n\t\t * @param {Object} legend The legend object\n\t\t */\n\t\tdrawLineMarker: function (legend) {\n\n\t\t\tvar options = this.options,\n\t\t\t\tmarkerOptions = options.marker,\n\t\t\t\tradius,\n\t\t\t\tlegendOptions = legend.options,\n\t\t\t\tlegendSymbol,\n\t\t\t\tsymbolWidth = legend.symbolWidth,\n\t\t\t\trenderer = this.chart.renderer,\n\t\t\t\tlegendItemGroup = this.legendGroup,\n\t\t\t\tverticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),\n\t\t\t\tattr;\n\n\t\t\t// Draw the line\n\t\t\tif (options.lineWidth) {\n\t\t\t\tattr = {\n\t\t\t\t\t'stroke-width': options.lineWidth\n\t\t\t\t};\n\t\t\t\tif (options.dashStyle) {\n\t\t\t\t\tattr.dashstyle = options.dashStyle;\n\t\t\t\t}\n\t\t\t\tthis.legendLine = renderer.path([\n\t\t\t\t\tM,\n\t\t\t\t\t0,\n\t\t\t\t\tverticalCenter,\n\t\t\t\t\tL,\n\t\t\t\t\tsymbolWidth,\n\t\t\t\t\tverticalCenter\n\t\t\t\t])\n\t\t\t\t.attr(attr)\n\t\t\t\t.add(legendItemGroup);\n\t\t\t}\n\t\t\t\n\t\t\t// Draw the marker\n\t\t\tif (markerOptions && markerOptions.enabled !== false) {\n\t\t\t\tradius = markerOptions.radius;\n\t\t\t\tthis.legendSymbol = legendSymbol = renderer.symbol(\n\t\t\t\t\tthis.symbol,\n\t\t\t\t\t(symbolWidth / 2) - radius,\n\t\t\t\t\tverticalCenter - radius,\n\t\t\t\t\t2 * radius,\n\t\t\t\t\t2 * radius\n\t\t\t\t)\n\t\t\t\t.add(legendItemGroup);\n\t\t\t\tlegendSymbol.isMarker = true;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n\t// and for #2580, a similar drawing flaw in Firefox 26.\n\t// TODO: Explore if there's a general cause for this. The problem may be related \n\t// to nested group elements, as the legend item texts are within 4 group elements.\n\tif (/Trident\\/7\\.0/.test(userAgent) || isFirefox) {\n\t\twrap(Legend.prototype, 'positionItem', function (proceed, item) {\n\t\t\tvar legend = this,\n\t\t\t\trunPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n\t\t\t\t\tif (item._legendItemPos) {\n\t\t\t\t\t\tproceed.call(legend, item);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// Do it now, for export and to get checkbox placement\n\t\t\trunPositionItem();\n\t\t\t\n\t\t\t// Do it after to work around the core issue\n\t\t\tsetTimeout(runPositionItem);\n\t\t});\n\t}\n\t/**\n\t * The chart class\n\t * @param {Object} options\n\t * @param {Function} callback Function to run when the chart has loaded\n\t */\n\tvar Chart = Highcharts.Chart = function () {\n\t\tthis.init.apply(this, arguments);\n\t};\n\n\tChart.prototype = {\n\n\t\t/**\n\t\t * Hook for modules\n\t\t */\n\t\tcallbacks: [],\n\n\t\t/**\n\t\t * Initialize the chart\n\t\t */\n\t\tinit: function (userOptions, callback) {\n\n\t\t\t// Handle regular options\n\t\t\tvar options,\n\t\t\t\tseriesOptions = userOptions.series; // skip merging data points to increase performance\n\n\t\t\tuserOptions.series = null;\n\t\t\toptions = merge(defaultOptions, userOptions); // do the merge\n\t\t\toptions.series = userOptions.series = seriesOptions; // set back the series data\n\t\t\tthis.userOptions = userOptions;\n\n\t\t\tvar optionsChart = options.chart;\n\t\t\t\n\t\t\t// Create margin & spacing array\n\t\t\tthis.margin = this.splashArray('margin', optionsChart);\n\t\t\tthis.spacing = this.splashArray('spacing', optionsChart);\n\n\t\t\tvar chartEvents = optionsChart.events;\n\n\t\t\t//this.runChartClick = chartEvents && !!chartEvents.click;\n\t\t\tthis.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n\t\t\tthis.callback = callback;\n\t\t\tthis.isResizing = 0;\n\t\t\tthis.options = options;\n\t\t\t//chartTitleOptions = UNDEFINED;\n\t\t\t//chartSubtitleOptions = UNDEFINED;\n\n\t\t\tthis.axes = [];\n\t\t\tthis.series = [];\n\t\t\tthis.hasCartesianSeries = optionsChart.showAxes;\n\t\t\t//this.axisOffset = UNDEFINED;\n\t\t\t//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n\t\t\t//this.inverted = UNDEFINED;\n\t\t\t//this.loadingShown = UNDEFINED;\n\t\t\t//this.container = UNDEFINED;\n\t\t\t//this.chartWidth = UNDEFINED;\n\t\t\t//this.chartHeight = UNDEFINED;\n\t\t\t//this.marginRight = UNDEFINED;\n\t\t\t//this.marginBottom = UNDEFINED;\n\t\t\t//this.containerWidth = UNDEFINED;\n\t\t\t//this.containerHeight = UNDEFINED;\n\t\t\t//this.oldChartWidth = UNDEFINED;\n\t\t\t//this.oldChartHeight = UNDEFINED;\n\n\t\t\t//this.renderTo = UNDEFINED;\n\t\t\t//this.renderToClone = UNDEFINED;\n\n\t\t\t//this.spacingBox = UNDEFINED\n\n\t\t\t//this.legend = UNDEFINED;\n\n\t\t\t// Elements\n\t\t\t//this.chartBackground = UNDEFINED;\n\t\t\t//this.plotBackground = UNDEFINED;\n\t\t\t//this.plotBGImage = UNDEFINED;\n\t\t\t//this.plotBorder = UNDEFINED;\n\t\t\t//this.loadingDiv = UNDEFINED;\n\t\t\t//this.loadingSpan = UNDEFINED;\n\n\t\t\tvar chart = this,\n\t\t\t\teventType;\n\n\t\t\t// Add the chart to the global lookup\n\t\t\tchart.index = charts.length;\n\t\t\tcharts.push(chart);\n\t\t\tchartCount++;\n\n\t\t\t// Set up auto resize\n\t\t\tif (optionsChart.reflow !== false) {\n\t\t\t\taddEvent(chart, 'load', function () {\n\t\t\t\t\tchart.initReflow();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Chart event handlers\n\t\t\tif (chartEvents) {\n\t\t\t\tfor (eventType in chartEvents) {\n\t\t\t\t\taddEvent(chart, eventType, chartEvents[eventType]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.xAxis = [];\n\t\t\tchart.yAxis = [];\n\n\t\t\t// Expose methods and variables\n\t\t\tchart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n\t\t\tchart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n\t\t\tchart.firstRender();\n\t\t},\n\n\t\t/**\n\t\t * Initialize an individual series, called internally before render time\n\t\t */\n\t\tinitSeries: function (options) {\n\t\t\tvar chart = this,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\ttype = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n\t\t\t\tseries,\n\t\t\t\tconstr = seriesTypes[type];\n\n\t\t\t// No such series type\n\t\t\tif (!constr) {\n\t\t\t\terror(17, true);\n\t\t\t}\n\n\t\t\tseries = new constr();\n\t\t\tseries.init(this, options);\n\t\t\treturn series;\n\t\t},\n\n\t\t/**\n\t\t * Check whether a given point is within the plot area\n\t\t *\n\t\t * @param {Number} plotX Pixel x relative to the plot area\n\t\t * @param {Number} plotY Pixel y relative to the plot area\n\t\t * @param {Boolean} inverted Whether the chart is inverted\n\t\t */\n\t\tisInsidePlot: function (plotX, plotY, inverted) {\n\t\t\tvar x = inverted ? plotY : plotX,\n\t\t\t\ty = inverted ? plotX : plotY;\n\t\t\t\t\n\t\t\treturn x >= 0 &&\n\t\t\t\tx <= this.plotWidth &&\n\t\t\t\ty >= 0 &&\n\t\t\t\ty <= this.plotHeight;\n\t\t},\n\n\t\t/**\n\t\t * Redraw legend, axes or series based on updated data\n\t\t *\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t */\n\t\tredraw: function (animation) {\n\t\t\tvar chart = this,\n\t\t\t\taxes = chart.axes,\n\t\t\t\tseries = chart.series,\n\t\t\t\tpointer = chart.pointer,\n\t\t\t\tlegend = chart.legend,\n\t\t\t\tredrawLegend = chart.isDirtyLegend,\n\t\t\t\thasStackedSeries,\n\t\t\t\thasDirtyStacks,\n\t\t\t\thasCartesianSeries = chart.hasCartesianSeries,\n\t\t\t\tisDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?\n\t\t\t\tseriesLength = series.length,\n\t\t\t\ti = seriesLength,\n\t\t\t\tserie,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tisHiddenChart = renderer.isHidden(),\n\t\t\t\tafterRedraw = [];\n\t\t\t\t\n\t\t\tsetAnimation(animation, chart);\n\t\t\t\n\t\t\tif (isHiddenChart) {\n\t\t\t\tchart.cloneRenderTo();\n\t\t\t}\n\n\t\t\t// Adjust title layout (reflow multiline text)\n\t\t\tchart.layOutTitles();\n\n\t\t\t// link stacked series\n\t\t\twhile (i--) {\n\t\t\t\tserie = series[i];\n\n\t\t\t\tif (serie.options.stacking) {\n\t\t\t\t\thasStackedSeries = true;\n\t\t\t\t\t\n\t\t\t\t\tif (serie.isDirty) {\n\t\t\t\t\t\thasDirtyStacks = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasDirtyStacks) { // mark others as dirty\n\t\t\t\ti = seriesLength;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tserie = series[i];\n\t\t\t\t\tif (serie.options.stacking) {\n\t\t\t\t\t\tserie.isDirty = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handle updated data in the series\n\t\t\teach(series, function (serie) {\n\t\t\t\tif (serie.isDirty) { // prepare the data so axis can read it\n\t\t\t\t\tif (serie.options.legendType === 'point') {\n\t\t\t\t\t\tredrawLegend = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// handle added or removed series\n\t\t\tif (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n\t\t\t\t// draw legend graphics\n\t\t\t\tlegend.render();\n\n\t\t\t\tchart.isDirtyLegend = false;\n\t\t\t}\n\n\t\t\t// reset stacks\n\t\t\tif (hasStackedSeries) {\n\t\t\t\tchart.getStacks();\n\t\t\t}\n\n\n\t\t\tif (hasCartesianSeries) {\n\t\t\t\tif (!chart.isResizing) {\n\n\t\t\t\t\t// reset maxTicks\n\t\t\t\t\tchart.maxTicks = null;\n\n\t\t\t\t\t// set axes scales\n\t\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\t\taxis.setScale();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.getMargins(); // #3098\n\n\t\t\tif (hasCartesianSeries) {\n\t\t\t\t// If one axis is dirty, all axes must be redrawn (#792, #2169)\n\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\tif (axis.isDirty) {\n\t\t\t\t\t\tisDirtyBox = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// redraw axes\n\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\t\n\t\t\t\t\t// Fire 'afterSetExtremes' only if extremes are set\n\t\t\t\t\tif (axis.isDirtyExtremes) { // #821\n\t\t\t\t\t\taxis.isDirtyExtremes = false;\n\t\t\t\t\t\tafterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n\t\t\t\t\t\t\tfireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n\t\t\t\t\t\t\tdelete axis.eventArgs;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (isDirtyBox || hasStackedSeries) {\n\t\t\t\t\t\taxis.redraw();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// the plot areas size has changed\n\t\t\tif (isDirtyBox) {\n\t\t\t\tchart.drawChartBox();\n\t\t\t}\n\n\n\t\t\t// redraw affected series\n\t\t\teach(series, function (serie) {\n\t\t\t\tif (serie.isDirty && serie.visible &&\n\t\t\t\t\t\t(!serie.isCartesian || serie.xAxis)) { // issue #153\n\t\t\t\t\tserie.redraw();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// move tooltip or reset\n\t\t\tif (pointer) {\n\t\t\t\tpointer.reset(true);\n\t\t\t}\n\n\t\t\t// redraw if canvas\n\t\t\trenderer.draw();\n\n\t\t\t// fire the event\n\t\t\tfireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw\n\t\t\t\n\t\t\tif (isHiddenChart) {\n\t\t\t\tchart.cloneRenderTo(true);\n\t\t\t}\n\t\t\t\n\t\t\t// Fire callbacks that are put on hold until after the redraw\n\t\t\teach(afterRedraw, function (callback) {\n\t\t\t\tcallback.call();\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Get an axis, series or point object by id.\n\t\t * @param id {String} The id as given in the configuration options\n\t\t */\n\t\tget: function (id) {\n\t\t\tvar chart = this,\n\t\t\t\taxes = chart.axes,\n\t\t\t\tseries = chart.series;\n\n\t\t\tvar i,\n\t\t\t\tj,\n\t\t\t\tpoints;\n\n\t\t\t// search axes\n\t\t\tfor (i = 0; i < axes.length; i++) {\n\t\t\t\tif (axes[i].options.id === id) {\n\t\t\t\t\treturn axes[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// search series\n\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\tif (series[i].options.id === id) {\n\t\t\t\t\treturn series[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// search points\n\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\tpoints = series[i].points || [];\n\t\t\t\tfor (j = 0; j < points.length; j++) {\n\t\t\t\t\tif (points[j].id === id) {\n\t\t\t\t\t\treturn points[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n\t\t * Create the Axis instances based on the config options\n\t\t */\n\t\tgetAxes: function () {\n\t\t\tvar chart = this,\n\t\t\t\toptions = this.options,\n\t\t\t\txAxisOptions = options.xAxis = splat(options.xAxis || {}),\n\t\t\t\tyAxisOptions = options.yAxis = splat(options.yAxis || {}),\n\t\t\t\toptionsArray,\n\t\t\t\taxis;\n\n\t\t\t// make sure the options are arrays and add some members\n\t\t\teach(xAxisOptions, function (axis, i) {\n\t\t\t\taxis.index = i;\n\t\t\t\taxis.isX = true;\n\t\t\t});\n\n\t\t\teach(yAxisOptions, function (axis, i) {\n\t\t\t\taxis.index = i;\n\t\t\t});\n\n\t\t\t// concatenate all axis options into one array\n\t\t\toptionsArray = xAxisOptions.concat(yAxisOptions);\n\n\t\t\teach(optionsArray, function (axisOptions) {\n\t\t\t\taxis = new Axis(chart, axisOptions);\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * Get the currently selected points from all series\n\t\t */\n\t\tgetSelectedPoints: function () {\n\t\t\tvar points = [];\n\t\t\teach(this.series, function (serie) {\n\t\t\t\tpoints = points.concat(grep(serie.points || [], function (point) {\n\t\t\t\t\treturn point.selected;\n\t\t\t\t}));\n\t\t\t});\n\t\t\treturn points;\n\t\t},\n\n\t\t/**\n\t\t * Get the currently selected series\n\t\t */\n\t\tgetSelectedSeries: function () {\n\t\t\treturn grep(this.series, function (serie) {\n\t\t\t\treturn serie.selected;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Generate stacks for each series and calculate stacks total values\n\t\t */\n\t\tgetStacks: function () {\n\t\t\tvar chart = this;\n\n\t\t\t// reset stacks for each yAxis\n\t\t\teach(chart.yAxis, function (axis) {\n\t\t\t\tif (axis.stacks && axis.hasVisibleSeries) {\n\t\t\t\t\taxis.oldStacks = axis.stacks;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\teach(chart.series, function (series) {\n\t\t\t\tif (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n\t\t\t\t\tseries.stackKey = series.type + pick(series.options.stack, '');\n\t\t\t\t}\n\t\t\t});\n\t\t},\t\n\n\t\t/**\n\t\t * Show the title and subtitle of the chart\n\t\t *\n\t\t * @param titleOptions {Object} New title options\n\t\t * @param subtitleOptions {Object} New subtitle options\n\t\t *\n\t\t */\n\t\tsetTitle: function (titleOptions, subtitleOptions, redraw) {\n\t\t\tvar chart = this,\n\t\t\t\toptions = chart.options,\n\t\t\t\tchartTitleOptions,\n\t\t\t\tchartSubtitleOptions;\n\n\t\t\tchartTitleOptions = options.title = merge(options.title, titleOptions);\n\t\t\tchartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n\t\t\t// add title and subtitle\n\t\t\teach([\n\t\t\t\t['title', titleOptions, chartTitleOptions],\n\t\t\t\t['subtitle', subtitleOptions, chartSubtitleOptions]\n\t\t\t], function (arr) {\n\t\t\t\tvar name = arr[0],\n\t\t\t\t\ttitle = chart[name],\n\t\t\t\t\ttitleOptions = arr[1],\n\t\t\t\t\tchartTitleOptions = arr[2];\n\n\t\t\t\tif (title && titleOptions) {\n\t\t\t\t\tchart[name] = title = title.destroy(); // remove old\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (chartTitleOptions && chartTitleOptions.text && !title) {\n\t\t\t\t\tchart[name] = chart.renderer.text(\n\t\t\t\t\t\tchartTitleOptions.text,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tchartTitleOptions.useHTML\n\t\t\t\t\t)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\talign: chartTitleOptions.align,\n\t\t\t\t\t\t'class': PREFIX + name,\n\t\t\t\t\t\tzIndex: chartTitleOptions.zIndex || 4\n\t\t\t\t\t})\n\t\t\t\t\t.css(chartTitleOptions.style)\n\t\t\t\t\t.add();\n\t\t\t\t}\t\n\t\t\t});\n\t\t\tchart.layOutTitles(redraw);\n\t\t},\n\n\t\t/**\n\t\t * Lay out the chart titles and cache the full offset height for use in getMargins\n\t\t */\n\t\tlayOutTitles: function (redraw) {\n\t\t\tvar titleOffset = 0,\n\t\t\t\ttitle = this.title,\n\t\t\t\tsubtitle = this.subtitle,\n\t\t\t\toptions = this.options,\n\t\t\t\ttitleOptions = options.title,\n\t\t\t\tsubtitleOptions = options.subtitle,\n\t\t\t\trequiresDirtyBox,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tautoWidth = this.spacingBox.width - 44; // 44 makes room for default context button\n\n\t\t\tif (title) {\n\t\t\t\ttitle\n\t\t\t\t\t.css({ width: (titleOptions.width || autoWidth) + PX })\n\t\t\t\t\t.align(extend({ \n\t\t\t\t\t\ty: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3\n\t\t\t\t\t}, titleOptions), false, 'spacingBox');\n\t\t\t\t\n\t\t\t\tif (!titleOptions.floating && !titleOptions.verticalAlign) {\n\t\t\t\t\ttitleOffset = title.getBBox().height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (subtitle) {\n\t\t\t\tsubtitle\n\t\t\t\t\t.css({ width: (subtitleOptions.width || autoWidth) + PX })\n\t\t\t\t\t.align(extend({ \n\t\t\t\t\t\ty: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b \n\t\t\t\t\t}, subtitleOptions), false, 'spacingBox');\n\t\t\t\t\n\t\t\t\tif (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n\t\t\t\t\ttitleOffset = mathCeil(titleOffset + subtitle.getBBox().height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequiresDirtyBox = this.titleOffset !== titleOffset;\t\t\t\t\n\t\t\tthis.titleOffset = titleOffset; // used in getMargins\n\n\t\t\tif (!this.isDirtyBox && requiresDirtyBox) {\n\t\t\t\tthis.isDirtyBox = requiresDirtyBox;\n\t\t\t\t// Redraw if necessary (#2719, #2744)\t\t\n\t\t\t\tif (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Get chart width and height according to options and container size\n\t\t */\n\t\tgetChartSize: function () {\n\t\t\tvar chart = this,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\twidthOption = optionsChart.width,\n\t\t\t\theightOption = optionsChart.height,\n\t\t\t\trenderTo = chart.renderToClone || chart.renderTo;\n\n\t\t\t// get inner width and height from jQuery (#824)\n\t\t\tif (!defined(widthOption)) {\n\t\t\t\tchart.containerWidth = adapterRun(renderTo, 'width');\n\t\t\t}\n\t\t\tif (!defined(heightOption)) {\n\t\t\t\tchart.containerHeight = adapterRun(renderTo, 'height');\n\t\t\t}\n\t\t\t\n\t\t\tchart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n\t\t\tchart.chartHeight = mathMax(0, pick(heightOption,\n\t\t\t\t// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n\t\t\t\tchart.containerHeight > 19 ? chart.containerHeight : 400));\n\t\t},\n\n\t\t/**\n\t\t * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n\t\t * size computation on chart.render and chart.redraw\n\t\t */\n\t\tcloneRenderTo: function (revert) {\n\t\t\tvar clone = this.renderToClone,\n\t\t\t\tcontainer = this.container;\n\t\t\t\n\t\t\t// Destroy the clone and bring the container back to the real renderTo div\n\t\t\tif (revert) {\n\t\t\t\tif (clone) {\n\t\t\t\t\tthis.renderTo.appendChild(container);\n\t\t\t\t\tdiscardElement(clone);\n\t\t\t\t\tdelete this.renderToClone;\n\t\t\t\t}\n\t\t\t\n\t\t\t// Set up the clone\n\t\t\t} else {\n\t\t\t\tif (container && container.parentNode === this.renderTo) {\n\t\t\t\t\tthis.renderTo.removeChild(container); // do not clone this\n\t\t\t\t}\n\t\t\t\tthis.renderToClone = clone = this.renderTo.cloneNode(0);\n\t\t\t\tcss(clone, {\n\t\t\t\t\tposition: ABSOLUTE,\n\t\t\t\t\ttop: '-9999px',\n\t\t\t\t\tdisplay: 'block' // #833\n\t\t\t\t});\n\t\t\t\tif (clone.style.setProperty) { // #2631\n\t\t\t\t\tclone.style.setProperty('display', 'block', 'important');\n\t\t\t\t}\n\t\t\t\tdoc.body.appendChild(clone);\n\t\t\t\tif (container) {\n\t\t\t\t\tclone.appendChild(container);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Get the containing element, determine the size and create the inner container\n\t\t * div to hold the chart\n\t\t */\n\t\tgetContainer: function () {\n\t\t\tvar chart = this,\n\t\t\t\tcontainer,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\tchartWidth,\n\t\t\t\tchartHeight,\n\t\t\t\trenderTo,\n\t\t\t\tindexAttrName = 'data-highcharts-chart',\n\t\t\t\toldChartIndex,\n\t\t\t\tcontainerId;\n\n\t\t\tchart.renderTo = renderTo = optionsChart.renderTo;\n\t\t\tcontainerId = PREFIX + idCounter++;\n\n\t\t\tif (isString(renderTo)) {\n\t\t\t\tchart.renderTo = renderTo = doc.getElementById(renderTo);\n\t\t\t}\n\t\t\t\n\t\t\t// Display an error if the renderTo is wrong\n\t\t\tif (!renderTo) {\n\t\t\t\terror(13, true);\n\t\t\t}\n\t\t\t\n\t\t\t// If the container already holds a chart, destroy it. The check for hasRendered is there\n\t\t\t// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n\t\t\t// attribute and the SVG contents, but not an interactive chart. So in this case,\n\t\t\t// charts[oldChartIndex] will point to the wrong chart if any (#2609).\n\t\t\toldChartIndex = pInt(attr(renderTo, indexAttrName));\n\t\t\tif (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n\t\t\t\tcharts[oldChartIndex].destroy();\n\t\t\t}\t\t\n\t\t\t\n\t\t\t// Make a reference to the chart from the div\n\t\t\tattr(renderTo, indexAttrName, chart.index);\n\n\t\t\t// remove previous chart\n\t\t\trenderTo.innerHTML = '';\n\n\t\t\t// If the container doesn't have an offsetWidth, it has or is a child of a node\n\t\t\t// that has display:none. We need to temporarily move it out to a visible\n\t\t\t// state to determine the size, else the legend and tooltips won't render\n\t\t\t// properly. The allowClone option is used in sparklines as a micro optimization,\n\t\t\t// saving about 1-2 ms each chart.\n\t\t\tif (!optionsChart.skipClone && !renderTo.offsetWidth) {\n\t\t\t\tchart.cloneRenderTo();\n\t\t\t}\n\n\t\t\t// get the width and height\n\t\t\tchart.getChartSize();\n\t\t\tchartWidth = chart.chartWidth;\n\t\t\tchartHeight = chart.chartHeight;\n\n\t\t\t// create the inner container\n\t\t\tchart.container = container = createElement(DIV, {\n\t\t\t\t\tclassName: PREFIX + 'container' +\n\t\t\t\t\t\t(optionsChart.className ? ' ' + optionsChart.className : ''),\n\t\t\t\t\tid: containerId\n\t\t\t\t}, extend({\n\t\t\t\t\tposition: RELATIVE,\n\t\t\t\t\toverflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n\t\t\t\t\t\t// content overflow in IE\n\t\t\t\t\twidth: chartWidth + PX,\n\t\t\t\t\theight: chartHeight + PX,\n\t\t\t\t\ttextAlign: 'left',\n\t\t\t\t\tlineHeight: 'normal', // #427\n\t\t\t\t\tzIndex: 0, // #1072\n\t\t\t\t\t'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n\t\t\t\t}, optionsChart.style),\n\t\t\t\tchart.renderToClone || renderTo\n\t\t\t);\n\n\t\t\t// cache the cursor (#1650)\n\t\t\tchart._cursor = container.style.cursor;\n\n\t\t\t// Initialize the renderer\n\t\t\tchart.renderer =\n\t\t\t\toptionsChart.forExport ? // force SVG, used for SVG export\n\t\t\t\t\tnew SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :\n\t\t\t\t\tnew Renderer(container, chartWidth, chartHeight, optionsChart.style);\n\n\t\t\tif (useCanVG) {\n\t\t\t\t// If we need canvg library, extend and configure the renderer\n\t\t\t\t// to get the tracker for translating mouse events\n\t\t\t\tchart.renderer.create(chart, container, chartWidth, chartHeight);\n\t\t\t}\n\t\t\t// Add a reference to the charts index\n\t\t\tchart.renderer.chartIndex = chart.index;\n\t\t},\n\n\t\t/**\n\t\t * Calculate margins by rendering axis labels in a preliminary position. Title,\n\t\t * subtitle and legend have already been rendered at this stage, but will be\n\t\t * moved into their final positions\n\t\t */\n\t\tgetMargins: function (skipAxes) {\n\t\t\tvar chart = this,\n\t\t\t\tspacing = chart.spacing,\n\t\t\t\tmargin = chart.margin,\n\t\t\t\ttitleOffset = chart.titleOffset;\n\n\t\t\tchart.resetMargins();\n\n\t\t\t// Adjust for title and subtitle\n\t\t\tif (titleOffset && !defined(margin[0])) {\n\t\t\t\tchart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n\t\t\t}\n\t\t\t\n\t\t\t// Adjust for legend\n\t\t\tchart.legend.adjustMargins(margin, spacing);\n\n\t\t\t// adjust for scroller\n\t\t\tif (chart.extraBottomMargin) {\n\t\t\t\tchart.marginBottom += chart.extraBottomMargin;\n\t\t\t}\n\t\t\tif (chart.extraTopMargin) {\n\t\t\t\tchart.plotTop += chart.extraTopMargin;\n\t\t\t}\n\t\t\tif (!skipAxes) {\n\t\t\t\tthis.getAxisMargins();\n\t\t\t}\n\t\t},\n\n\t\tgetAxisMargins: function () {\n\n\t\t\tvar chart = this,\n\t\t\t\taxisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n\t\t\t\tmargin = chart.margin;\n\t\t\t\n\t\t\t// pre-render axes to get labels offset width\n\t\t\tif (chart.hasCartesianSeries) {\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\taxis.getOffset();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Add the axis offsets\n\t\t\teach(marginNames, function (m, side) {\n\t\t\t\tif (!defined(margin[side])) {\n\t\t\t\t\tchart[m] += axisOffset[side];\n\t\t\t\t}\t\t\n\t\t\t});\n\n\t\t\tchart.setChartSize();\n\n\t\t},\n\n\t\t/**\n\t\t * Resize the chart to its container if size is not explicitly set\n\t\t */\n\t\treflow: function (e) {\n\t\t\tvar chart = this,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\trenderTo = chart.renderTo,\n\t\t\t\twidth = optionsChart.width || adapterRun(renderTo, 'width'),\n\t\t\t\theight = optionsChart.height || adapterRun(renderTo, 'height'),\n\t\t\t\ttarget = e ? e.target : win, // #805 - MooTools doesn't supply e\n\t\t\t\tdoReflow = function () {\n\t\t\t\t\tif (chart.container) { // It may have been destroyed in the meantime (#1257)\n\t\t\t\t\t\tchart.setSize(width, height, false);\n\t\t\t\t\t\tchart.hasUserSize = null;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t\n\t\t\t// Width and height checks for display:none. Target is doc in IE8 and Opera,\n\t\t\t// win in Firefox, Chrome and IE9.\n\t\t\tif (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n\t\t\t\tif (width !== chart.containerWidth || height !== chart.containerHeight) {\n\t\t\t\t\tclearTimeout(chart.reflowTimeout);\n\t\t\t\t\tif (e) { // Called from window.resize\n\t\t\t\t\t\tchart.reflowTimeout = setTimeout(doReflow, 100);\n\t\t\t\t\t} else { // Called directly (#2224)\n\t\t\t\t\t\tdoReflow();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchart.containerWidth = width;\n\t\t\t\tchart.containerHeight = height;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Add the event handlers necessary for auto resizing\n\t\t */\n\t\tinitReflow: function () {\n\t\t\tvar chart = this,\n\t\t\t\treflow = function (e) {\n\t\t\t\t\tchart.reflow(e);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\n\t\t\taddEvent(win, 'resize', reflow);\n\t\t\taddEvent(chart, 'destroy', function () {\n\t\t\t\tremoveEvent(win, 'resize', reflow);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Resize the chart to a given width and height\n\t\t * @param {Number} width\n\t\t * @param {Number} height\n\t\t * @param {Object|Boolean} animation\n\t\t */\n\t\tsetSize: function (width, height, animation) {\n\t\t\tvar chart = this,\n\t\t\t\tchartWidth,\n\t\t\t\tchartHeight,\n\t\t\t\tfireEndResize;\n\n\t\t\t// Handle the isResizing counter\n\t\t\tchart.isResizing += 1;\n\t\t\tfireEndResize = function () {\n\t\t\t\tif (chart) {\n\t\t\t\t\tfireEvent(chart, 'endResize', null, function () {\n\t\t\t\t\t\tchart.isResizing -= 1;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// set the animation for the current process\n\t\t\tsetAnimation(animation, chart);\n\n\t\t\tchart.oldChartHeight = chart.chartHeight;\n\t\t\tchart.oldChartWidth = chart.chartWidth;\n\t\t\tif (defined(width)) {\n\t\t\t\tchart.chartWidth = chartWidth = mathMax(0, mathRound(width));\n\t\t\t\tchart.hasUserSize = !!chartWidth;\n\t\t\t}\n\t\t\tif (defined(height)) {\n\t\t\t\tchart.chartHeight = chartHeight = mathMax(0, mathRound(height));\n\t\t\t}\n\n\t\t\t// Resize the container with the global animation applied if enabled (#2503)\n\t\t\t(globalAnimation ? animate : css)(chart.container, {\n\t\t\t\twidth: chartWidth + PX,\n\t\t\t\theight: chartHeight + PX\n\t\t\t}, globalAnimation);\n\n\t\t\tchart.setChartSize(true);\n\t\t\tchart.renderer.setSize(chartWidth, chartHeight, animation);\n\n\t\t\t// handle axes\n\t\t\tchart.maxTicks = null;\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\taxis.isDirty = true;\n\t\t\t\taxis.setScale();\n\t\t\t});\n\n\t\t\t// make sure non-cartesian series are also handled\n\t\t\teach(chart.series, function (serie) {\n\t\t\t\tserie.isDirty = true;\n\t\t\t});\n\n\t\t\tchart.isDirtyLegend = true; // force legend redraw\n\t\t\tchart.isDirtyBox = true; // force redraw of plot and chart border\n\n\t\t\tchart.layOutTitles(); // #2857\n\t\t\tchart.getMargins();\n\n\t\t\tchart.redraw(animation);\n\n\n\t\t\tchart.oldChartHeight = null;\n\t\t\tfireEvent(chart, 'resize');\n\n\t\t\t// fire endResize and set isResizing back\n\t\t\t// If animation is disabled, fire without delay\n\t\t\tif (globalAnimation === false) {\n\t\t\t\tfireEndResize();\n\t\t\t} else { // else set a timeout with the animation duration\n\t\t\t\tsetTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the public chart properties. This is done before and after the pre-render\n\t\t * to determine margin sizes\n\t\t */\n\t\tsetChartSize: function (skipAxes) {\n\t\t\tvar chart = this,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tchartWidth = chart.chartWidth,\n\t\t\t\tchartHeight = chart.chartHeight,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\tspacing = chart.spacing,\n\t\t\t\tclipOffset = chart.clipOffset,\n\t\t\t\tclipX,\n\t\t\t\tclipY,\n\t\t\t\tplotLeft,\n\t\t\t\tplotTop,\n\t\t\t\tplotWidth,\n\t\t\t\tplotHeight,\n\t\t\t\tplotBorderWidth;\n\n\t\t\tchart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n\t\t\tchart.plotTop = plotTop = mathRound(chart.plotTop);\n\t\t\tchart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n\t\t\tchart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n\t\t\tchart.plotSizeX = inverted ? plotHeight : plotWidth;\n\t\t\tchart.plotSizeY = inverted ? plotWidth : plotHeight;\n\t\t\t\n\t\t\tchart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n\t\t\t// Set boxes used for alignment\n\t\t\tchart.spacingBox = renderer.spacingBox = {\n\t\t\t\tx: spacing[3],\n\t\t\t\ty: spacing[0],\n\t\t\t\twidth: chartWidth - spacing[3] - spacing[1],\n\t\t\t\theight: chartHeight - spacing[0] - spacing[2]\n\t\t\t};\n\t\t\tchart.plotBox = renderer.plotBox = {\n\t\t\t\tx: plotLeft,\n\t\t\t\ty: plotTop,\n\t\t\t\twidth: plotWidth,\n\t\t\t\theight: plotHeight\n\t\t\t};\n\n\t\t\tplotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);\n\t\t\tclipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);\n\t\t\tclipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);\n\t\t\tchart.clipBox = {\n\t\t\t\tx: clipX, \n\t\t\t\ty: clipY, \n\t\t\t\twidth: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), \n\t\t\t\theight: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n\t\t\t};\n\n\t\t\tif (!skipAxes) {\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\taxis.setAxisSize();\n\t\t\t\t\taxis.setAxisTranslation();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Initial margins before auto size margins are applied\n\t\t */\n\t\tresetMargins: function () {\n\t\t\tvar chart = this;\n\n\t\t\teach(marginNames, function (m, side) {\n\t\t\t\tchart[m] = pick(chart.margin[side], chart.spacing[side]);\n\t\t\t});\n\t\t\tchart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n\t\t\tchart.clipOffset = [0, 0, 0, 0];\n\t\t},\n\n\t\t/**\n\t\t * Draw the borders and backgrounds for chart and plot area\n\t\t */\n\t\tdrawChartBox: function () {\n\t\t\tvar chart = this,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tchartWidth = chart.chartWidth,\n\t\t\t\tchartHeight = chart.chartHeight,\n\t\t\t\tchartBackground = chart.chartBackground,\n\t\t\t\tplotBackground = chart.plotBackground,\n\t\t\t\tplotBorder = chart.plotBorder,\n\t\t\t\tplotBGImage = chart.plotBGImage,\n\t\t\t\tchartBorderWidth = optionsChart.borderWidth || 0,\n\t\t\t\tchartBackgroundColor = optionsChart.backgroundColor,\n\t\t\t\tplotBackgroundColor = optionsChart.plotBackgroundColor,\n\t\t\t\tplotBackgroundImage = optionsChart.plotBackgroundImage,\n\t\t\t\tplotBorderWidth = optionsChart.plotBorderWidth || 0,\n\t\t\t\tmgn,\n\t\t\t\tbgAttr,\n\t\t\t\tplotLeft = chart.plotLeft,\n\t\t\t\tplotTop = chart.plotTop,\n\t\t\t\tplotWidth = chart.plotWidth,\n\t\t\t\tplotHeight = chart.plotHeight,\n\t\t\t\tplotBox = chart.plotBox,\n\t\t\t\tclipRect = chart.clipRect,\n\t\t\t\tclipBox = chart.clipBox;\n\n\t\t\t// Chart area\n\t\t\tmgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n\t\t\tif (chartBorderWidth || chartBackgroundColor) {\n\t\t\t\tif (!chartBackground) {\n\t\t\t\t\t\n\t\t\t\t\tbgAttr = {\n\t\t\t\t\t\tfill: chartBackgroundColor || NONE\n\t\t\t\t\t};\n\t\t\t\t\tif (chartBorderWidth) { // #980\n\t\t\t\t\t\tbgAttr.stroke = optionsChart.borderColor;\n\t\t\t\t\t\tbgAttr['stroke-width'] = chartBorderWidth;\n\t\t\t\t\t}\n\t\t\t\t\tchart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n\t\t\t\t\t\t\toptionsChart.borderRadius, chartBorderWidth)\n\t\t\t\t\t\t.attr(bgAttr)\n\t\t\t\t\t\t.addClass(PREFIX + 'background')\n\t\t\t\t\t\t.add()\n\t\t\t\t\t\t.shadow(optionsChart.shadow);\n\n\t\t\t\t} else { // resize\n\t\t\t\t\tchartBackground.animate(\n\t\t\t\t\t\tchartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Plot background\n\t\t\tif (plotBackgroundColor) {\n\t\t\t\tif (!plotBackground) {\n\t\t\t\t\tchart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\tfill: plotBackgroundColor\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add()\n\t\t\t\t\t\t.shadow(optionsChart.plotShadow);\n\t\t\t\t} else {\n\t\t\t\t\tplotBackground.animate(plotBox);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (plotBackgroundImage) {\n\t\t\t\tif (!plotBGImage) {\n\t\t\t\t\tchart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n\t\t\t\t\t\t.add();\n\t\t\t\t} else {\n\t\t\t\t\tplotBGImage.animate(plotBox);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Plot clip\n\t\t\tif (!clipRect) {\n\t\t\t\tchart.clipRect = renderer.clipRect(clipBox);\n\t\t\t} else {\n\t\t\t\tclipRect.animate({\n\t\t\t\t\twidth: clipBox.width,\n\t\t\t\t\theight: clipBox.height\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Plot area border\n\t\t\tif (plotBorderWidth) {\n\t\t\t\tif (!plotBorder) {\n\t\t\t\t\tchart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\tstroke: optionsChart.plotBorderColor,\n\t\t\t\t\t\t\t'stroke-width': plotBorderWidth,\n\t\t\t\t\t\t\tfill: NONE,\n\t\t\t\t\t\t\tzIndex: 1\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.add();\n\t\t\t\t} else {\n\t\t\t\t\tplotBorder.animate(\n\t\t\t\t\t\tplotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset\n\t\t\tchart.isDirtyBox = false;\n\t\t},\n\n\t\t/**\n\t\t * Detect whether a certain chart property is needed based on inspecting its options\n\t\t * and series. This mainly applies to the chart.invert property, and in extensions to \n\t\t * the chart.angular and chart.polar properties.\n\t\t */\n\t\tpropFromSeries: function () {\n\t\t\tvar chart = this,\n\t\t\t\toptionsChart = chart.options.chart,\n\t\t\t\tklass,\n\t\t\t\tseriesOptions = chart.options.series,\n\t\t\t\ti,\n\t\t\t\tvalue;\n\t\t\t\t\n\t\t\t\t\n\t\t\teach(['inverted', 'angular', 'polar'], function (key) {\n\t\t\t\t\n\t\t\t\t// The default series type's class\n\t\t\t\tklass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\t\t\t\t\n\t\t\t\t// Get the value from available chart-wide properties\n\t\t\t\tvalue = (\n\t\t\t\t\tchart[key] || // 1. it is set before\n\t\t\t\t\toptionsChart[key] || // 2. it is set in the options\n\t\t\t\t\t(klass && klass.prototype[key]) // 3. it's default series class requires it\n\t\t\t\t);\n\t\t\n\t\t\t\t// 4. Check if any the chart's series require it\n\t\t\t\ti = seriesOptions && seriesOptions.length;\n\t\t\t\twhile (!value && i--) {\n\t\t\t\t\tklass = seriesTypes[seriesOptions[i].type];\n\t\t\t\t\tif (klass && klass.prototype[key]) {\n\t\t\t\t\t\tvalue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\t// Set the chart property\n\t\t\t\tchart[key] = value;\t\n\t\t\t});\n\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Link two or more series together. This is done initially from Chart.render,\n\t\t * and after Chart.addSeries and Series.remove.\n\t\t */\n\t\tlinkSeries: function () {\n\t\t\tvar chart = this,\n\t\t\t\tchartSeries = chart.series;\n\n\t\t\t// Reset links\n\t\t\teach(chartSeries, function (series) {\n\t\t\t\tseries.linkedSeries.length = 0;\n\t\t\t});\n\n\t\t\t// Apply new links\n\t\t\teach(chartSeries, function (series) {\n\t\t\t\tvar linkedTo = series.options.linkedTo;\n\t\t\t\tif (isString(linkedTo)) {\n\t\t\t\t\tif (linkedTo === ':previous') {\n\t\t\t\t\t\tlinkedTo = chart.series[series.index - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlinkedTo = chart.get(linkedTo);\n\t\t\t\t\t}\n\t\t\t\t\tif (linkedTo) {\n\t\t\t\t\t\tlinkedTo.linkedSeries.push(series);\n\t\t\t\t\t\tseries.linkedParent = linkedTo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Render series for the chart\n\t\t */\n\t\trenderSeries: function () {\n\t\t\teach(this.series, function (serie) {\n\t\t\t\tserie.translate();\n\t\t\t\tserie.render();\n\t\t\t});\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Render labels for the chart\n\t\t */\n\t\trenderLabels: function () {\n\t\t\tvar chart = this,\n\t\t\t\tlabels = chart.options.labels;\n\t\t\tif (labels.items) {\n\t\t\t\teach(labels.items, function (label) {\n\t\t\t\t\tvar style = extend(labels.style, label.style),\n\t\t\t\t\t\tx = pInt(style.left) + chart.plotLeft,\n\t\t\t\t\t\ty = pInt(style.top) + chart.plotTop + 12;\n\n\t\t\t\t\t// delete to prevent rewriting in IE\n\t\t\t\t\tdelete style.left;\n\t\t\t\t\tdelete style.top;\n\n\t\t\t\t\tchart.renderer.text(\n\t\t\t\t\t\tlabel.html,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty\n\t\t\t\t\t)\n\t\t\t\t\t.attr({ zIndex: 2 })\n\t\t\t\t\t.css(style)\n\t\t\t\t\t.add();\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Render all graphics for the chart\n\t\t */\n\t\trender: function () {\n\t\t\tvar chart = this,\n\t\t\t\taxes = chart.axes,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\toptions = chart.options,\n\t\t\t\ttempWidth,\n\t\t\t\ttempHeight,\n\t\t\t\tredoHorizontal,\n\t\t\t\tredoVertical;\n\n\t\t\t// Title\n\t\t\tchart.setTitle();\n\n\n\t\t\t// Legend\n\t\t\tchart.legend = new Legend(chart, options.legend);\n\n\t\t\tchart.getStacks(); // render stacks\n\n\t\t\t// Get chart margins\n\t\t\tchart.getMargins(true);\n\t\t\tchart.setChartSize();\n\n\t\t\t// Record preliminary dimensions for later comparison\n\t\t\ttempWidth = chart.plotWidth;\n\t\t\ttempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels\n\n\t\t\t// Get margins by pre-rendering axes\n\t\t\teach(axes, function (axis) {\n\t\t\t\taxis.setScale();\n\t\t\t});\n\t\t\tchart.getAxisMargins();\n\n\t\t\t// If the plot area size has changed significantly, calculate tick positions again\n\t\t\tredoHorizontal = tempWidth / chart.plotWidth > 1.2;\n\t\t\tredoVertical = tempHeight / chart.plotHeight > 1.1;\n\n\t\t\tif (redoHorizontal || redoVertical) {\n\n\t\t\t\tchart.maxTicks = null; // reset for second pass\n\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\tif ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n\t\t\t\t\t\taxis.setTickInterval(true); // update to reflect the new margins\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchart.getMargins(); // second pass to check for new labels\n\t\t\t}\n\n\t\t\t// Draw the borders and backgrounds\n\t\t\tchart.drawChartBox();\t\t\n\n\n\t\t\t// Axes\n\t\t\tif (chart.hasCartesianSeries) {\n\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\taxis.render();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// The series\n\t\t\tif (!chart.seriesGroup) {\n\t\t\t\tchart.seriesGroup = renderer.g('series-group')\n\t\t\t\t\t.attr({ zIndex: 3 })\n\t\t\t\t\t.add();\n\t\t\t}\n\t\t\tchart.renderSeries();\n\n\t\t\t// Labels\n\t\t\tchart.renderLabels();\n\n\t\t\t// Credits\n\t\t\tchart.showCredits(options.credits);\n\n\t\t\t// Set flag\n\t\t\tchart.hasRendered = true;\n\n\t\t},\n\n\t\t/**\n\t\t * Show chart credits based on config options\n\t\t */\n\t\tshowCredits: function (credits) {\n\t\t\tif (credits.enabled && !this.credits) {\n\t\t\t\tthis.credits = this.renderer.text(\n\t\t\t\t\tcredits.text,\n\t\t\t\t\t0,\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t\t.on('click', function () {\n\t\t\t\t\tif (credits.href) {\n\t\t\t\t\t\tlocation.href = credits.href;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.attr({\n\t\t\t\t\talign: credits.position.align,\n\t\t\t\t\tzIndex: 8\n\t\t\t\t})\n\t\t\t\t.css(credits.style)\n\t\t\t\t.add()\n\t\t\t\t.align(credits.position);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Clean up memory usage\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar chart = this,\n\t\t\t\taxes = chart.axes,\n\t\t\t\tseries = chart.series,\n\t\t\t\tcontainer = chart.container,\n\t\t\t\ti,\n\t\t\t\tparentNode = container && container.parentNode;\n\t\t\t\t\n\t\t\t// fire the chart.destoy event\n\t\t\tfireEvent(chart, 'destroy');\n\t\t\t\n\t\t\t// Delete the chart from charts lookup array\n\t\t\tcharts[chart.index] = UNDEFINED;\n\t\t\tchartCount--;\n\t\t\tchart.renderTo.removeAttribute('data-highcharts-chart');\n\n\t\t\t// remove events\n\t\t\tremoveEvent(chart);\n\n\t\t\t// ==== Destroy collections:\n\t\t\t// Destroy axes\n\t\t\ti = axes.length;\n\t\t\twhile (i--) {\n\t\t\t\taxes[i] = axes[i].destroy();\n\t\t\t}\n\n\t\t\t// Destroy each series\n\t\t\ti = series.length;\n\t\t\twhile (i--) {\n\t\t\t\tseries[i] = series[i].destroy();\n\t\t\t}\n\n\t\t\t// ==== Destroy chart properties:\n\t\t\teach(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', \n\t\t\t\t\t'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', \n\t\t\t\t\t'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n\t\t\t\tvar prop = chart[name];\n\n\t\t\t\tif (prop && prop.destroy) {\n\t\t\t\t\tchart[name] = prop.destroy();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// remove container and all SVG\n\t\t\tif (container) { // can break in IE when destroyed before finished loading\n\t\t\t\tcontainer.innerHTML = '';\n\t\t\t\tremoveEvent(container);\n\t\t\t\tif (parentNode) {\n\t\t\t\t\tdiscardElement(container);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clean it all up\n\t\t\tfor (i in chart) {\n\t\t\t\tdelete chart[i];\n\t\t\t}\n\n\t\t},\n\n\n\t\t/**\n\t\t * VML namespaces can't be added until after complete. Listening\n\t\t * for Perini's doScroll hack is not enough.\n\t\t */\n\t\tisReadyToRender: function () {\n\t\t\tvar chart = this;\n\n\t\t\t// Note: in spite of JSLint's complaints, win == win.top is required\n\t\t\t/*jslint eqeq: true*/\n\t\t\tif ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {\n\t\t\t/*jslint eqeq: false*/\n\t\t\t\tif (useCanVG) {\n\t\t\t\t\t// Delay rendering until canvg library is downloaded and ready\n\t\t\t\t\tCanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);\n\t\t\t\t} else {\n\t\t\t\t\tdoc.attachEvent('onreadystatechange', function () {\n\t\t\t\t\t\tdoc.detachEvent('onreadystatechange', chart.firstRender);\n\t\t\t\t\t\tif (doc.readyState === 'complete') {\n\t\t\t\t\t\t\tchart.firstRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t/**\n\t\t * Prepare for first rendering after all data are loaded\n\t\t */\n\t\tfirstRender: function () {\n\t\t\tvar chart = this,\n\t\t\t\toptions = chart.options,\n\t\t\t\tcallback = chart.callback;\n\n\t\t\t// Check whether the chart is ready to render\n\t\t\tif (!chart.isReadyToRender()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create the container\n\t\t\tchart.getContainer();\n\n\t\t\t// Run an early event after the container and renderer are established\n\t\t\tfireEvent(chart, 'init');\n\n\t\t\t\n\t\t\tchart.resetMargins();\n\t\t\tchart.setChartSize();\n\n\t\t\t// Set the common chart properties (mainly invert) from the given series\n\t\t\tchart.propFromSeries();\n\n\t\t\t// get axes\n\t\t\tchart.getAxes();\n\n\t\t\t// Initialize the series\n\t\t\teach(options.series || [], function (serieOptions) {\n\t\t\t\tchart.initSeries(serieOptions);\n\t\t\t});\n\n\t\t\tchart.linkSeries();\n\n\t\t\t// Run an event after axes and series are initialized, but before render. At this stage,\n\t\t\t// the series data is indexed and cached in the xData and yData arrays, so we can access\n\t\t\t// those before rendering. Used in Highstock. \n\t\t\tfireEvent(chart, 'beforeRender'); \n\n\t\t\t// depends on inverted and on margins being set\n\t\t\tif (Highcharts.Pointer) {\n\t\t\t\tchart.pointer = new Pointer(chart, options);\n\t\t\t}\n\n\t\t\tchart.render();\n\n\t\t\t// add canvas\n\t\t\tchart.renderer.draw();\n\t\t\t// run callbacks\n\t\t\tif (callback) {\n\t\t\t\tcallback.apply(chart, [chart]);\n\t\t\t}\n\t\t\teach(chart.callbacks, function (fn) {\n\t\t\t\tif (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)\n\t\t\t\t\tfn.apply(chart, [chart]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Fire the load event\n\t\t\tfireEvent(chart, 'load');\t\t\n\t\t\t\n\t\t\t// If the chart was rendered outside the top container, put it back in (#3679)\n\t\t\tchart.cloneRenderTo(true);\n\n\t\t},\n\n\t\t/**\n\t\t* Creates arrays for spacing and margin from given options.\n\t\t*/\n\t\tsplashArray: function (target, options) {\n\t\t\tvar oVar = options[target],\n\t\t\t\ttArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n\t\t\treturn [pick(options[target + 'Top'], tArray[0]),\n\t\t\t\t\tpick(options[target + 'Right'], tArray[1]),\n\t\t\t\t\tpick(options[target + 'Bottom'], tArray[2]),\n\t\t\t\t\tpick(options[target + 'Left'], tArray[3])];\n\t\t}\n\t}; // end Chart\n\n\tvar CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {\n\t\t/**\n\t\t * Get the center of the pie based on the size and center options relative to the  \n\t\t * plot area. Borrowed by the polar and gauge series types.\n\t\t */\n\t\tgetCenter: function () {\n\t\t\t\n\t\t\tvar options = this.options,\n\t\t\t\tchart = this.chart,\n\t\t\t\tslicingRoom = 2 * (options.slicedOffset || 0),\n\t\t\t\thandleSlicingRoom,\n\t\t\t\tplotWidth = chart.plotWidth - 2 * slicingRoom,\n\t\t\t\tplotHeight = chart.plotHeight - 2 * slicingRoom,\n\t\t\t\tcenterOption = options.center,\n\t\t\t\tpositions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n\t\t\t\tsmallestSize = mathMin(plotWidth, plotHeight),\n\t\t\t\tisPercent,\n\t\t\t\ti,\n\t\t\t\tvalue;\n\n\t\t\tfor (i = 0; i < 4; ++i) {\n\t\t\t\tvalue = positions[i];\n\t\t\t\tisPercent = /%$/.test(value);\n\t\t\t\thandleSlicingRoom = i < 2 || (i === 2 && isPercent);\n\t\t\t\tpositions[i] = (isPercent ?\n\t\t\t\t\t// i == 0: centerX, relative to width\n\t\t\t\t\t// i == 1: centerY, relative to height\n\t\t\t\t\t// i == 2: size, relative to smallestSize\n\t\t\t\t\t// i == 3: innerSize, relative to size\n\t\t\t\t\t[plotWidth, plotHeight, smallestSize, positions[2]][i] *\n\t\t\t\t\t\tpInt(value) / 100 :\n\t\t\t\t\tpInt(value)) + (handleSlicingRoom ? slicingRoom : 0);\n\t\t\t}\n\t\t\treturn positions;\n\t\t}\n\t};\n\n\t/**\n\t * The Point object and prototype. Inheritable and used as base for PiePoint\n\t */\n\tvar Point = function () {};\n\tPoint.prototype = {\n\n\t\t/**\n\t\t * Initialize the point\n\t\t * @param {Object} series The series object containing this point\n\t\t * @param {Object} options The data in either number, array or object format\n\t\t */\n\t\tinit: function (series, options, x) {\n\n\t\t\tvar point = this,\n\t\t\t\tcolors;\n\t\t\tpoint.series = series;\n\t\t\tpoint.color = series.color; // #3445\n\t\t\tpoint.applyOptions(options, x);\n\t\t\tpoint.pointAttr = {};\n\n\t\t\tif (series.options.colorByPoint) {\n\t\t\t\tcolors = series.options.colors || series.chart.options.colors;\n\t\t\t\tpoint.color = point.color || colors[series.colorCounter++];\n\t\t\t\t// loop back to zero\n\t\t\t\tif (series.colorCounter === colors.length) {\n\t\t\t\t\tseries.colorCounter = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseries.chart.pointCount++;\n\t\t\treturn point;\n\t\t},\n\t\t/**\n\t\t * Apply the options containing the x and y data and possible some extra properties.\n\t\t * This is called on point init or from point.update.\n\t\t *\n\t\t * @param {Object} options\n\t\t */\n\t\tapplyOptions: function (options, x) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tpointValKey = series.options.pointValKey || series.pointValKey;\n\n\t\t\toptions = Point.prototype.optionsToObject.call(this, options);\n\n\t\t\t// copy options directly to point\n\t\t\textend(point, options);\n\t\t\tpoint.options = point.options ? extend(point.options, options) : options;\n\n\t\t\t// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n\t\t\tif (pointValKey) {\n\t\t\t\tpoint.y = point[pointValKey];\n\t\t\t}\n\n\t\t\t// If no x is set by now, get auto incremented value. All points must have an\n\t\t\t// x value, however the y value can be null to create a gap in the series\n\t\t\tif (point.x === UNDEFINED && series) {\n\t\t\t\tpoint.x = x === UNDEFINED ? series.autoIncrement() : x;\n\t\t\t}\n\n\t\t\treturn point;\n\t\t},\n\n\t\t/**\n\t\t * Transform number or array configs into objects\n\t\t */\n\t\toptionsToObject: function (options) {\n\t\t\tvar ret = {},\n\t\t\t\tseries = this.series,\n\t\t\t\tpointArrayMap = series.pointArrayMap || ['y'],\n\t\t\t\tvalueCount = pointArrayMap.length,\n\t\t\t\tfirstItemType,\n\t\t\t\ti = 0,\n\t\t\t\tj = 0;\n\n\t\t\tif (typeof options === 'number' || options === null) {\n\t\t\t\tret[pointArrayMap[0]] = options;\n\n\t\t\t} else if (isArray(options)) {\n\t\t\t\t// with leading x value\n\t\t\t\tif (options.length > valueCount) {\n\t\t\t\t\tfirstItemType = typeof options[0];\n\t\t\t\t\tif (firstItemType === 'string') {\n\t\t\t\t\t\tret.name = options[0];\n\t\t\t\t\t} else if (firstItemType === 'number') {\n\t\t\t\t\t\tret.x = options[0];\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (j < valueCount) {\n\t\t\t\t\tret[pointArrayMap[j++]] = options[i++];\n\t\t\t\t}\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\tret = options;\n\n\t\t\t\t// This is the fastest way to detect if there are individual point dataLabels that need\n\t\t\t\t// to be considered in drawDataLabels. These can only occur in object configs.\n\t\t\t\tif (options.dataLabels) {\n\t\t\t\t\tseries._hasPointLabels = true;\n\t\t\t\t}\n\n\t\t\t\t// Same approach as above for markers\n\t\t\t\tif (options.marker) {\n\t\t\t\t\tseries._hasPointMarkers = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Destroy a point to clear memory. Its reference still stays in series.data.\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tchart = series.chart,\n\t\t\t\thoverPoints = chart.hoverPoints,\n\t\t\t\tprop;\n\n\t\t\tchart.pointCount--;\n\n\t\t\tif (hoverPoints) {\n\t\t\t\tpoint.setState();\n\t\t\t\terase(hoverPoints, point);\n\t\t\t\tif (!hoverPoints.length) {\n\t\t\t\t\tchart.hoverPoints = null;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (point === chart.hoverPoint) {\n\t\t\t\tpoint.onMouseOut();\n\t\t\t}\n\n\t\t\t// remove all events\n\t\t\tif (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n\t\t\t\tremoveEvent(point);\n\t\t\t\tpoint.destroyElements();\n\t\t\t}\n\n\t\t\tif (point.legendItem) { // pies have legend items\n\t\t\t\tchart.legend.destroyItem(point);\n\t\t\t}\n\n\t\t\tfor (prop in point) {\n\t\t\t\tpoint[prop] = null;\n\t\t\t}\n\n\n\t\t},\n\n\t\t/**\n\t\t * Destroy SVG elements associated with the point\n\t\t */\n\t\tdestroyElements: function () {\n\t\t\tvar point = this,\n\t\t\t\tprops = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],\n\t\t\t\tprop,\n\t\t\t\ti = 6;\n\t\t\twhile (i--) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (point[prop]) {\n\t\t\t\t\tpoint[prop] = point[prop].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Return the configuration hash needed for the data label and tooltip formatters\n\t\t */\n\t\tgetLabelConfig: function () {\n\t\t\tvar point = this;\n\t\t\treturn {\n\t\t\t\tx: point.category,\n\t\t\t\ty: point.y,\n\t\t\t\tkey: point.name || point.category,\n\t\t\t\tseries: point.series,\n\t\t\t\tpoint: point,\n\t\t\t\tpercentage: point.percentage,\n\t\t\t\ttotal: point.total || point.stackTotal\n\t\t\t};\n\t\t},\t\n\n\t\t/**\n\t\t * Extendable method for formatting each point's tooltip line\n\t\t *\n\t\t * @return {String} A string to be concatenated in to the common tooltip text\n\t\t */\n\t\ttooltipFormatter: function (pointFormat) {\n\n\t\t\t// Insert options for valueDecimals, valuePrefix, and valueSuffix\n\t\t\tvar series = this.series,\n\t\t\t\tseriesTooltipOptions = series.tooltipOptions,\n\t\t\t\tvalueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n\t\t\t\tvaluePrefix = seriesTooltipOptions.valuePrefix || '',\n\t\t\t\tvalueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n\t\t\t// Loop over the point array map and replace unformatted values with sprintf formatting markup\n\t\t\teach(series.pointArrayMap || ['y'], function (key) {\n\t\t\t\tkey = '{point.' + key; // without the closing bracket\n\t\t\t\tif (valuePrefix || valueSuffix) {\n\t\t\t\t\tpointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n\t\t\t\t}\n\t\t\t\tpointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n\t\t\t});\n\n\t\t\treturn format(pointFormat, {\n\t\t\t\tpoint: this,\n\t\t\t\tseries: this.series\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Fire an event on the Point object. Must not be renamed to fireEvent, as this\n\t\t * causes a name clash in MooTools\n\t\t * @param {String} eventType\n\t\t * @param {Object} eventArgs Additional event arguments\n\t\t * @param {Function} defaultFunction Default event handler\n\t\t */\n\t\tfirePointEvent: function (eventType, eventArgs, defaultFunction) {\n\t\t\tvar point = this,\n\t\t\t\tseries = this.series,\n\t\t\t\tseriesOptions = series.options;\n\n\t\t\t// load event handlers on demand to save time on mouseover/out\n\t\t\tif (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n\t\t\t\tthis.importEvents();\n\t\t\t}\n\n\t\t\t// add default handler if in selection mode\n\t\t\tif (eventType === 'click' && seriesOptions.allowPointSelect) {\n\t\t\t\tdefaultFunction = function (event) {\n\t\t\t\t\t// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n\t\t\t\t\tpoint.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfireEvent(this, eventType, eventArgs, defaultFunction);\n\t\t}\n\t};/**\n\t * @classDescription The base function which all other series types inherit from. The data in the series is stored\n\t * in various arrays.\n\t *\n\t * - First, series.options.data contains all the original config options for\n\t * each point whether added by options or methods like series.addPoint.\n\t * - Next, series.data contains those values converted to points, but in case the series data length\n\t * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n\t * only contains the points that have been created on demand.\n\t * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n\t * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n\t * compared to series.data and series.options.data. If however the series data is grouped, these can't\n\t * be correlated one to one.\n\t * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n\t * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n\t *\n\t * @param {Object} chart\n\t * @param {Object} options\n\t */\n\tvar Series = Highcharts.Series = function () {};\n\n\tSeries.prototype = {\n\n\t\tisCartesian: true,\n\t\ttype: 'line',\n\t\tpointClass: Point,\n\t\tsorted: true, // requires the data to be sorted\n\t\trequireSorting: true,\n\t\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\t\tstroke: 'lineColor',\n\t\t\t'stroke-width': 'lineWidth',\n\t\t\tfill: 'fillColor',\n\t\t\tr: 'radius'\n\t\t},\n\t\taxisTypes: ['xAxis', 'yAxis'],\n\t\tcolorCounter: 0,\n\t\tparallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n\t\tinit: function (chart, options) {\n\t\t\tvar series = this,\n\t\t\t\teventType,\n\t\t\t\tevents,\n\t\t\t\tchartSeries = chart.series,\n\t\t\t\tsortByIndex = function (a, b) {\n\t\t\t\t\treturn pick(a.options.index, a._i) - pick(b.options.index, b._i);\n\t\t\t\t};\n\n\t\t\tseries.chart = chart;\n\t\t\tseries.options = options = series.setOptions(options); // merge with plotOptions\n\t\t\tseries.linkedSeries = [];\n\n\t\t\t// bind the axes\n\t\t\tseries.bindAxes();\n\n\t\t\t// set some variables\n\t\t\textend(series, {\n\t\t\t\tname: options.name,\n\t\t\t\tstate: NORMAL_STATE,\n\t\t\t\tpointAttr: {},\n\t\t\t\tvisible: options.visible !== false, // true by default\n\t\t\t\tselected: options.selected === true // false by default\n\t\t\t});\n\n\t\t\t// special\n\t\t\tif (useCanVG) {\n\t\t\t\toptions.animation = false;\n\t\t\t}\n\n\t\t\t// register event listeners\n\t\t\tevents = options.events;\n\t\t\tfor (eventType in events) {\n\t\t\t\taddEvent(series, eventType, events[eventType]);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t(events && events.click) ||\n\t\t\t\t(options.point && options.point.events && options.point.events.click) ||\n\t\t\t\toptions.allowPointSelect\n\t\t\t) {\n\t\t\t\tchart.runTrackerClick = true;\n\t\t\t}\n\n\t\t\tseries.getColor();\n\t\t\tseries.getSymbol();\n\n\t\t\t// Set the data\n\t\t\teach(series.parallelArrays, function (key) {\n\t\t\t\tseries[key + 'Data'] = [];\n\t\t\t});\n\t\t\tseries.setData(options.data, false);\n\n\t\t\t// Mark cartesian\n\t\t\tif (series.isCartesian) {\n\t\t\t\tchart.hasCartesianSeries = true;\n\t\t\t}\n\n\t\t\t// Register it in the chart\n\t\t\tchartSeries.push(series);\n\t\t\tseries._i = chartSeries.length - 1;\n\n\t\t\t// Sort series according to index option (#248, #1123, #2456)\n\t\t\tstableSort(chartSeries, sortByIndex);\n\t\t\tif (this.yAxis) {\n\t\t\t\tstableSort(this.yAxis.series, sortByIndex);\n\t\t\t}\n\n\t\t\teach(chartSeries, function (series, i) {\n\t\t\t\tseries.index = i;\n\t\t\t\tseries.name = series.name || 'Series ' + (i + 1);\n\t\t\t});\n\n\t\t},\n\n\t\t/**\n\t\t * Set the xAxis and yAxis properties of cartesian series, and register the series\n\t\t * in the axis.series array\n\t\t */\n\t\tbindAxes: function () {\n\t\t\tvar series = this,\n\t\t\t\tseriesOptions = series.options,\n\t\t\t\tchart = series.chart,\n\t\t\t\taxisOptions;\n\n\t\t\teach(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n\t\t\t\teach(chart[AXIS], function (axis) { // loop through the chart's axis objects\n\t\t\t\t\taxisOptions = axis.options;\n\n\t\t\t\t\t// apply if the series xAxis or yAxis option mathches the number of the\n\t\t\t\t\t// axis, or if undefined, use the first axis\n\t\t\t\t\tif ((seriesOptions[AXIS] === axisOptions.index) ||\n\t\t\t\t\t\t\t(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n\t\t\t\t\t\t\t(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n\t\t\t\t\t\t// register this series in the axis.series lookup\n\t\t\t\t\t\taxis.series.push(series);\n\n\t\t\t\t\t\t// set this series.xAxis or series.yAxis reference\n\t\t\t\t\t\tseries[AXIS] = axis;\n\n\t\t\t\t\t\t// mark dirty for redraw\n\t\t\t\t\t\taxis.isDirty = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// The series needs an X and an Y axis\n\t\t\t\tif (!series[AXIS] && series.optionalAxis !== AXIS) {\n\t\t\t\t\terror(18, true);\n\t\t\t\t}\n\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * For simple series types like line and column, the data values are held in arrays like\n\t\t * xData and yData for quick lookup to find extremes and more. For multidimensional series\n\t\t * like bubble and map, this can be extended with arrays like zData and valueData by\n\t\t * adding to the series.parallelArrays array.\n\t\t */\n\t\tupdateParallelArrays: function (point, i) {\n\t\t\tvar series = point.series,\n\t\t\t\targs = arguments,\n\t\t\t\tfn = typeof i === 'number' ?\n\t\t\t\t\t // Insert the value in the given position\n\t\t\t\t\tfunction (key) {\n\t\t\t\t\t\tvar val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n\t\t\t\t\t\tseries[key + 'Data'][i] = val;\n\t\t\t\t\t} :\n\t\t\t\t\t// Apply the method specified in i with the following arguments as arguments\n\t\t\t\t\tfunction (key) {\n\t\t\t\t\t\tArray.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n\t\t\t\t\t};\n\n\t\t\teach(series.parallelArrays, fn);\n\t\t},\n\n\t\t/**\n\t\t * Return an auto incremented x value based on the pointStart and pointInterval options.\n\t\t * This is only used if an x value is not given for the point that calls autoIncrement.\n\t\t */\n\t\tautoIncrement: function () {\n\n\t\t\tvar options = this.options,\n\t\t\t\txIncrement = this.xIncrement,\n\t\t\t\tdate,\n\t\t\t\tpointInterval,\n\t\t\t\tpointIntervalUnit = options.pointIntervalUnit;\n\t\t\t\n\t\t\txIncrement = pick(xIncrement, options.pointStart, 0);\n\t\t\t\n\t\t\tthis.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\t\t\t\n\t\t\t// Added code for pointInterval strings\n\t\t\tif (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {\n\t\t\t\tdate = new Date(xIncrement);\n\t\t\t\tdate = (pointIntervalUnit === 'month') ?\n\t\t\t\t\t+date[setMonth](date[getMonth]() + pointInterval) :\n\t\t\t\t\t+date[setFullYear](date[getFullYear]() + pointInterval);\n\t\t\t\tpointInterval = date - xIncrement;\n\t\t\t}\n\t\t\t\n\t\t\tthis.xIncrement = xIncrement + pointInterval;\n\t\t\treturn xIncrement;\n\t\t},\n\n\t\t/**\n\t\t * Divide the series data into segments divided by null values.\n\t\t */\n\t\tgetSegments: function () {\n\t\t\tvar series = this,\n\t\t\t\tlastNull = -1,\n\t\t\t\tsegments = [],\n\t\t\t\ti,\n\t\t\t\tpoints = series.points,\n\t\t\t\tpointsLength = points.length;\n\n\t\t\tif (pointsLength) { // no action required for []\n\n\t\t\t\t// if connect nulls, just remove null points\n\t\t\t\tif (series.options.connectNulls) {\n\t\t\t\t\ti = pointsLength;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (points[i].y === null) {\n\t\t\t\t\t\t\tpoints.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (points.length) {\n\t\t\t\t\t\tsegments = [points];\n\t\t\t\t\t}\n\n\t\t\t\t// else, split on null points\n\t\t\t\t} else {\n\t\t\t\t\teach(points, function (point, i) {\n\t\t\t\t\t\tif (point.y === null) {\n\t\t\t\t\t\t\tif (i > lastNull + 1) {\n\t\t\t\t\t\t\t\tsegments.push(points.slice(lastNull + 1, i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastNull = i;\n\t\t\t\t\t\t} else if (i === pointsLength - 1) { // last value\n\t\t\t\t\t\t\tsegments.push(points.slice(lastNull + 1, i + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// register it\n\t\t\tseries.segments = segments;\n\t\t},\n\n\t\t/**\n\t\t * Set the series options by merging from the options tree\n\t\t * @param {Object} itemOptions\n\t\t */\n\t\tsetOptions: function (itemOptions) {\n\t\t\tvar chart = this.chart,\n\t\t\t\tchartOptions = chart.options,\n\t\t\t\tplotOptions = chartOptions.plotOptions,\n\t\t\t\tuserOptions = chart.userOptions || {},\n\t\t\t\tuserPlotOptions = userOptions.plotOptions || {},\n\t\t\t\ttypeOptions = plotOptions[this.type],\n\t\t\t\toptions,\n\t\t\t\tzones;\n\n\t\t\tthis.userOptions = itemOptions;\n\n\t\t\t// General series options take precedence over type options because otherwise, default\n\t\t\t// type options like column.animation would be overwritten by the general option.\n\t\t\t// But issues have been raised here (#3881), and the solution may be to distinguish \n\t\t\t// between default option and userOptions like in the tooltip below.\n\t\t\toptions = merge(\n\t\t\t\ttypeOptions,\n\t\t\t\tplotOptions.series,\n\t\t\t\titemOptions\n\t\t\t);\n\n\t\t\t// The tooltip options are merged between global and series specific options\n\t\t\tthis.tooltipOptions = merge(\n\t\t\t\tdefaultOptions.tooltip,\n\t\t\t\tdefaultOptions.plotOptions[this.type].tooltip,\n\t\t\t\tuserOptions.tooltip,\n\t\t\t\tuserPlotOptions.series && userPlotOptions.series.tooltip,\n\t\t\t\tuserPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n\t\t\t\titemOptions.tooltip\n\t\t\t);\n\n\t\t\t// Delete marker object if not allowed (#1125)\n\t\t\tif (typeOptions.marker === null) {\n\t\t\t\tdelete options.marker;\n\t\t\t}\n\n\t\t\t// Handle color zones\n\t\t\tthis.zoneAxis = options.zoneAxis;\n\t\t\tzones = this.zones = (options.zones || []).slice();\n\t\t\tif ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n\t\t\t\tzones.push({\n\t\t\t\t\tvalue: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n\t\t\t\t\tcolor: options.negativeColor,\n\t\t\t\t\tfillColor: options.negativeFillColor\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (zones.length) { // Push one extra zone for the rest\n\t\t\t\tif (defined(zones[zones.length - 1].value)) {\n\t\t\t\t\tzones.push({\n\t\t\t\t\t\tcolor: this.color,\n\t\t\t\t\t\tfillColor: this.fillColor\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options;\n\t\t},\n\n\t\tgetCyclic: function (prop, value, defaults) {\n\t\t\tvar i,\n\t\t\t\tuserOptions = this.userOptions,\n\t\t\t\tindexName = '_' + prop + 'Index',\n\t\t\t\tcounterName = prop + 'Counter';\n\n\t\t\tif (!value) {\n\t\t\t\tif (defined(userOptions[indexName])) { // after Series.update()\n\t\t\t\t\ti = userOptions[indexName];\n\t\t\t\t} else {\n\t\t\t\t\tuserOptions[indexName] = i = this.chart[counterName] % defaults.length;\n\t\t\t\t\tthis.chart[counterName] += 1;\n\t\t\t\t}\n\t\t\t\tvalue = defaults[i];\n\t\t\t}\n\t\t\tthis[prop] = value;\n\t\t},\n\n\t\t/**\n\t\t * Get the series' color\n\t\t */\n\t\tgetColor: function () {\n\t\t\tif (!this.options.colorByPoint) {\n\t\t\t\tthis.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Get the series' symbol\n\t\t */\n\t\tgetSymbol: function () {\n\t\t\tvar seriesMarkerOption = this.options.marker;\n\n\t\t\tthis.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n\t\t\t// don't substract radius in image symbols (#604)\n\t\t\tif (/^url/.test(this.symbol)) {\n\t\t\t\tseriesMarkerOption.radius = 0;\n\t\t\t}\n\t\t},\n\n\t\tdrawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n\t\t/**\n\t\t * Replace the series data with a new set of data\n\t\t * @param {Object} data\n\t\t * @param {Object} redraw\n\t\t */\n\t\tsetData: function (data, redraw, animation, updatePoints) {\n\t\t\tvar series = this,\n\t\t\t\toldData = series.points,\n\t\t\t\toldDataLength = (oldData && oldData.length) || 0,\n\t\t\t\tdataLength,\n\t\t\t\toptions = series.options,\n\t\t\t\tchart = series.chart,\n\t\t\t\tfirstPoint = null,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\thasCategories = xAxis && !!xAxis.categories,\n\t\t\t\ti,\n\t\t\t\tturboThreshold = options.turboThreshold,\n\t\t\t\tpt,\n\t\t\t\txData = this.xData,\n\t\t\t\tyData = this.yData,\n\t\t\t\tpointArrayMap = series.pointArrayMap,\n\t\t\t\tvalueCount = pointArrayMap && pointArrayMap.length;\n\n\t\t\tdata = data || [];\n\t\t\tdataLength = data.length;\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\t// If the point count is the same as is was, just run Point.update which is\n\t\t\t// cheaper, allows animation, and keeps references to points.\n\t\t\tif (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n\t\t\t\teach(data, function (point, i) {\n\t\t\t\t\toldData[i].update(point, false, null, false);\n\t\t\t\t});\n\n\t\t\t} else {\n\n\t\t\t\t// Reset properties\n\t\t\t\tseries.xIncrement = null;\n\t\t\t\tseries.pointRange = hasCategories ? 1 : options.pointRange;\n\n\t\t\t\tseries.colorCounter = 0; // for series with colorByPoint (#1547)\n\t\t\t\t\n\t\t\t\t// Update parallel arrays\n\t\t\t\teach(this.parallelArrays, function (key) {\n\t\t\t\t\tseries[key + 'Data'].length = 0;\n\t\t\t\t});\n\n\t\t\t\t// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n\t\t\t\t// first value is tested, and we assume that all the rest are defined the same\n\t\t\t\t// way. Although the 'for' loops are similar, they are repeated inside each\n\t\t\t\t// if-else conditional for max performance.\n\t\t\t\tif (turboThreshold && dataLength > turboThreshold) {\n\n\t\t\t\t\t// find the first non-null point\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (firstPoint === null && i < dataLength) {\n\t\t\t\t\t\tfirstPoint = data[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (isNumber(firstPoint)) { // assume all points are numbers\n\t\t\t\t\t\tvar x = pick(options.pointStart, 0),\n\t\t\t\t\t\t\tpointInterval = pick(options.pointInterval, 1);\n\n\t\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\t\txData[i] = x;\n\t\t\t\t\t\t\tyData[i] = data[i];\n\t\t\t\t\t\t\tx += pointInterval;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseries.xIncrement = x;\n\t\t\t\t\t} else if (isArray(firstPoint)) { // assume all points are arrays\n\t\t\t\t\t\tif (valueCount) { // [x, low, high] or [x, o, h, l, c]\n\t\t\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\t\t\tpt = data[i];\n\t\t\t\t\t\t\t\txData[i] = pt[0];\n\t\t\t\t\t\t\t\tyData[i] = pt.slice(1, valueCount + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else { // [x, y]\n\t\t\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\t\t\tpt = data[i];\n\t\t\t\t\t\t\t\txData[i] = pt[0];\n\t\t\t\t\t\t\t\tyData[i] = pt[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\tif (data[i] !== UNDEFINED) { // stray commas in oldIE\n\t\t\t\t\t\t\tpt = { series: series };\n\t\t\t\t\t\t\tseries.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n\t\t\t\t\t\t\tseries.updateParallelArrays(pt, i);\n\t\t\t\t\t\t\tif (hasCategories && pt.name) {\n\t\t\t\t\t\t\t\txAxis.names[pt.x] = pt.name; // #2046\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n\t\t\t\tif (isString(yData[0])) {\n\t\t\t\t\terror(14, true);\n\t\t\t\t}\n\n\t\t\t\tseries.data = [];\n\t\t\t\tseries.options.data = data;\n\t\t\t\t//series.zData = zData;\n\n\t\t\t\t// destroy old points\n\t\t\t\ti = oldDataLength;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (oldData[i] && oldData[i].destroy) {\n\t\t\t\t\t\toldData[i].destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reset minRange (#878)\n\t\t\t\tif (xAxis) {\n\t\t\t\t\txAxis.minRange = xAxis.userMinRange;\n\t\t\t\t}\n\n\t\t\t\t// redraw\n\t\t\t\tseries.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n\t\t\t\tanimation = false;\n\t\t\t}\n\n\t\t\tif (redraw) {\n\t\t\t\tchart.redraw(animation);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Process the data by cropping away unused data points if the series is longer\n\t\t * than the crop threshold. This saves computing time for lage series.\n\t\t */\n\t\tprocessData: function (force) {\n\t\t\tvar series = this,\n\t\t\t\tprocessedXData = series.xData, // copied during slice operation below\n\t\t\t\tprocessedYData = series.yData,\n\t\t\t\tdataLength = processedXData.length,\n\t\t\t\tcroppedData,\n\t\t\t\tcropStart = 0,\n\t\t\t\tcropped,\n\t\t\t\tdistance,\n\t\t\t\tclosestPointRange,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\ti, // loop variable\n\t\t\t\toptions = series.options,\n\t\t\t\tcropThreshold = options.cropThreshold,\n\t\t\t\tisCartesian = series.isCartesian,\n\t\t\t\txExtremes,\n\t\t\t\tmin,\n\t\t\t\tmax;\n\n\t\t\t// If the series data or axes haven't changed, don't go through this. Return false to pass\n\t\t\t// the message on to override methods like in data grouping.\n\t\t\tif (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (xAxis) {\n\t\t\t\txExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n\t\t\t\tmin = xExtremes.min;\n\t\t\t\tmax = xExtremes.max;\n\t\t\t}\n\n\t\t\t// optionally filter out points outside the plot area\n\t\t\tif (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\t\t\t\t\n\t\t\t\t// it's outside current extremes\n\t\t\t\tif (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n\t\t\t\t\tprocessedXData = [];\n\t\t\t\t\tprocessedYData = [];\n\n\t\t\t\t// only crop if it's actually spilling out\n\t\t\t\t} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n\t\t\t\t\tcroppedData = this.cropData(series.xData, series.yData, min, max);\n\t\t\t\t\tprocessedXData = croppedData.xData;\n\t\t\t\t\tprocessedYData = croppedData.yData;\n\t\t\t\t\tcropStart = croppedData.start;\n\t\t\t\t\tcropped = true;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// Find the closest distance between processed points\n\t\t\tfor (i = processedXData.length - 1; i >= 0; i--) {\n\t\t\t\tdistance = processedXData[i] - processedXData[i - 1];\n\t\t\t\t\n\t\t\t\tif (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n\t\t\t\t\tclosestPointRange = distance;\n\n\t\t\t\t// Unsorted data is not supported by the line tooltip, as well as data grouping and\n\t\t\t\t// navigation in Stock charts (#725) and width calculation of columns (#1900)\n\t\t\t\t} else if (distance < 0 && series.requireSorting) {\n\t\t\t\t\terror(15);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Record the properties\n\t\t\tseries.cropped = cropped; // undefined or true\n\t\t\tseries.cropStart = cropStart;\n\t\t\tseries.processedXData = processedXData;\n\t\t\tseries.processedYData = processedYData;\n\n\t\t\tif (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\n\t\t\t\tseries.pointRange = closestPointRange || 1;\n\t\t\t}\n\t\t\tseries.closestPointRange = closestPointRange;\n\n\t\t},\n\n\t\t/**\n\t\t * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n\t\t * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n\t\t */\n\t\tcropData: function (xData, yData, min, max) {\n\t\t\tvar dataLength = xData.length,\n\t\t\t\tcropStart = 0,\n\t\t\t\tcropEnd = dataLength,\n\t\t\t\tcropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n\t\t\t\ti;\n\n\t\t\t// iterate up to find slice start\n\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\tif (xData[i] >= min) {\n\t\t\t\t\tcropStart = mathMax(0, i - cropShoulder);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// proceed to find slice end\n\t\t\tfor (; i < dataLength; i++) {\n\t\t\t\tif (xData[i] > max) {\n\t\t\t\t\tcropEnd = i + cropShoulder;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\txData: xData.slice(cropStart, cropEnd),\n\t\t\t\tyData: yData.slice(cropStart, cropEnd),\n\t\t\t\tstart: cropStart,\n\t\t\t\tend: cropEnd\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * Generate the data point after the data has been processed by cropping away\n\t\t * unused points and optionally grouped in Highcharts Stock.\n\t\t */\n\t\tgeneratePoints: function () {\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\tdataOptions = options.data,\n\t\t\t\tdata = series.data,\n\t\t\t\tdataLength,\n\t\t\t\tprocessedXData = series.processedXData,\n\t\t\t\tprocessedYData = series.processedYData,\n\t\t\t\tpointClass = series.pointClass,\n\t\t\t\tprocessedDataLength = processedXData.length,\n\t\t\t\tcropStart = series.cropStart || 0,\n\t\t\t\tcursor,\n\t\t\t\thasGroupedData = series.hasGroupedData,\n\t\t\t\tpoint,\n\t\t\t\tpoints = [],\n\t\t\t\ti;\n\n\t\t\tif (!data && !hasGroupedData) {\n\t\t\t\tvar arr = [];\n\t\t\t\tarr.length = dataOptions.length;\n\t\t\t\tdata = series.data = arr;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < processedDataLength; i++) {\n\t\t\t\tcursor = cropStart + i;\n\t\t\t\tif (!hasGroupedData) {\n\t\t\t\t\tif (data[cursor]) {\n\t\t\t\t\t\tpoint = data[cursor];\n\t\t\t\t\t} else if (dataOptions[cursor] !== UNDEFINED) { // #970\n\t\t\t\t\t\tdata[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpoints[i] = point;\n\t\t\t\t} else {\n\t\t\t\t\t// splat the y data in case of ohlc data array\n\t\t\t\t\tpoints[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n\t\t\t\t}\n\t\t\t\tpoints[i].index = cursor; // For faster access in Point.update\n\t\t\t}\n\n\t\t\t// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n\t\t\t// swithching view from non-grouped data to grouped data (#637)\n\t\t\tif (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\tif (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n\t\t\t\t\t\ti += processedDataLength;\n\t\t\t\t\t}\n\t\t\t\t\tif (data[i]) {\n\t\t\t\t\t\tdata[i].destroyElements();\n\t\t\t\t\t\tdata[i].plotX = UNDEFINED; // #1003\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseries.data = data;\n\t\t\tseries.points = points;\n\t\t},\n\n\t\t/**\n\t\t * Calculate Y extremes for visible data\n\t\t */\n\t\tgetExtremes: function (yData) {\n\t\t\tvar xAxis = this.xAxis,\n\t\t\t\tyAxis = this.yAxis,\n\t\t\t\txData = this.processedXData,\n\t\t\t\tyDataLength,\n\t\t\t\tactiveYData = [],\n\t\t\t\tactiveCounter = 0,\n\t\t\t\txExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n\t\t\t\txMin = xExtremes.min,\n\t\t\t\txMax = xExtremes.max,\n\t\t\t\tvalidValue,\n\t\t\t\twithinRange,\n\t\t\t\tdataMin,\n\t\t\t\tdataMax,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\ti,\n\t\t\t\tj;\n\n\t\t\tyData = yData || this.stackedYData || this.processedYData;\n\t\t\tyDataLength = yData.length;\n\n\t\t\tfor (i = 0; i < yDataLength; i++) {\n\n\t\t\t\tx = xData[i];\n\t\t\t\ty = yData[i];\n\n\t\t\t\t// For points within the visible range, including the first point outside the\n\t\t\t\t// visible range, consider y extremes\n\t\t\t\tvalidValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));\n\t\t\t\twithinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&\n\t\t\t\t\t(xData[i - 1] || x) <= xMax);\n\n\t\t\t\tif (validValue && withinRange) {\n\n\t\t\t\t\tj = y.length;\n\t\t\t\t\tif (j) { // array, like ohlc or range data\n\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\tif (y[j] !== null) {\n\t\t\t\t\t\t\t\tactiveYData[activeCounter++] = y[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactiveYData[activeCounter++] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.dataMin = pick(dataMin, arrayMin(activeYData));\n\t\t\tthis.dataMax = pick(dataMax, arrayMax(activeYData));\n\t\t},\n\n\t\t/**\n\t\t * Translate data points from raw data values to chart specific positioning data\n\t\t * needed later in drawPoints, drawGraph and drawTracker.\n\t\t */\n\t\ttranslate: function () {\n\t\t\tif (!this.processedXData) { // hidden series\n\t\t\t\tthis.processData();\n\t\t\t}\n\t\t\tthis.generatePoints();\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\tstacking = options.stacking,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tcategories = xAxis.categories,\n\t\t\t\tyAxis = series.yAxis,\n\t\t\t\tpoints = series.points,\n\t\t\t\tdataLength = points.length,\n\t\t\t\thasModifyValue = !!series.modifyValue,\n\t\t\t\ti,\n\t\t\t\tpointPlacement = options.pointPlacement,\n\t\t\t\tdynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n\t\t\t\tthreshold = options.threshold,\n\t\t\t\tplotX,\n\t\t\t\tplotY,\n\t\t\t\tlastPlotX,\n\t\t\t\tclosestPointRangePx = Number.MAX_VALUE;\n\n\t\t\t// Translate each point\n\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\tvar point = points[i],\n\t\t\t\t\txValue = point.x,\n\t\t\t\t\tyValue = point.y,\n\t\t\t\t\tyBottom = point.low,\n\t\t\t\t\tstack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],\n\t\t\t\t\tpointStack,\n\t\t\t\t\tstackValues;\n\n\t\t\t\t// Discard disallowed y values for log axes (#3434)\n\t\t\t\tif (yAxis.isLog && yValue !== null && yValue <= 0) {\n\t\t\t\t\tpoint.y = yValue = null;\n\t\t\t\t\terror(10);\n\t\t\t\t}\n\n\t\t\t\t// Get the plotX translation\n\t\t\t\tpoint.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591\n\n\n\t\t\t\t// Calculate the bottom y value for stacked series\n\t\t\t\tif (stacking && series.visible && stack && stack[xValue]) {\n\n\t\t\t\t\tpointStack = stack[xValue];\n\t\t\t\t\tstackValues = pointStack.points[series.index + ',' + i];\n\t\t\t\t\tyBottom = stackValues[0];\n\t\t\t\t\tyValue = stackValues[1];\n\n\t\t\t\t\tif (yBottom === 0) {\n\t\t\t\t\t\tyBottom = pick(threshold, yAxis.min);\n\t\t\t\t\t}\n\t\t\t\t\tif (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n\t\t\t\t\t\tyBottom = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tpoint.total = point.stackTotal = pointStack.total;\n\t\t\t\t\tpoint.percentage = pointStack.total && (point.y / pointStack.total * 100);\n\t\t\t\t\tpoint.stackY = yValue;\n\n\t\t\t\t\t// Place the stack label\n\t\t\t\t\tpointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n\t\t\t\t}\n\n\t\t\t\t// Set translated yBottom or remove it\n\t\t\t\tpoint.yBottom = defined(yBottom) ?\n\t\t\t\t\tyAxis.translate(yBottom, 0, 1, 0, 1) :\n\t\t\t\t\tnull;\n\n\t\t\t\t// general hook, used for Highstock compare mode\n\t\t\t\tif (hasModifyValue) {\n\t\t\t\t\tyValue = series.modifyValue(yValue, point);\n\t\t\t\t}\n\n\t\t\t\t// Set the the plotY value, reset it for redraws\n\t\t\t\tpoint.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n\t\t\t\t\tmathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n\t\t\t\t\tUNDEFINED;\n\t\t\t\tpoint.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519\n\t\t\t\t\tplotX >= 0 && plotX <= xAxis.len;\n\n\n\t\t\t\t// Set client related positions for mouse tracking\n\t\t\t\tpoint.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n\t\t\t\tpoint.negative = point.y < (threshold || 0);\n\n\t\t\t\t// some API data\n\t\t\t\tpoint.category = categories && categories[point.x] !== UNDEFINED ?\n\t\t\t\t\tcategories[point.x] : point.x;\n\n\t\t\t\t// Determine auto enabling of markers (#3635)\n\t\t\t\tif (i) {\n\t\t\t\t\tclosestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));\n\t\t\t\t}\n\t\t\t\tlastPlotX = plotX;\n\n\t\t\t}\n\n\t\t\tseries.closestPointRangePx = closestPointRangePx;\n\n\t\t\t// now that we have the cropped data, build the segments\n\t\t\tseries.getSegments();\n\t\t},\n\n\t\t/**\n\t\t * Set the clipping for the series. For animated series it is called twice, first to initiate\n\t\t * animating the clip then the second time without the animation to set the final clip.\n\t\t */\n\t\tsetClip: function (animation) {\n\t\t\tvar chart = this.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\tseriesClipBox = this.clipBox,\n\t\t\t\tclipBox = seriesClipBox || chart.clipBox,\n\t\t\t\tsharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),\n\t\t\t\tclipRect = chart[sharedClipKey],\n\t\t\t\tmarkerClipRect = chart[sharedClipKey + 'm'];\n\n\t\t\t// If a clipping rectangle with the same properties is currently present in the chart, use that.\n\t\t\tif (!clipRect) {\n\n\t\t\t\t// When animation is set, prepare the initial positions\n\t\t\t\tif (animation) { \n\t\t\t\t\tclipBox.width = 0;\n\n\t\t\t\t\tchart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n\t\t\t\t\t\t-99, // include the width of the first marker\n\t\t\t\t\t\tinverted ? -chart.plotLeft : -chart.plotTop,\n\t\t\t\t\t\t99,\n\t\t\t\t\t\tinverted ? chart.chartWidth : chart.chartHeight\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tchart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n\t\t\t\t\n\t\t\t}\n\t\t\tif (animation) {\n\t\t\t\tclipRect.count += 1;\n\t\t\t}\n\n\t\t\tif (this.options.clip !== false) {\n\t\t\t\tthis.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n\t\t\t\tthis.markerGroup.clip(markerClipRect);\n\t\t\t\tthis.sharedClipKey = sharedClipKey;\n\t\t\t}\n\n\t\t\t// Remove the shared clipping rectancgle when all series are shown\n\t\t\tif (!animation) {\n\t\t\t\tclipRect.count -= 1;\n\t\t\t\tif (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n\t\t\t\t\tif (!seriesClipBox) {\n\t\t\t\t\t\tchart[sharedClipKey] = chart[sharedClipKey].destroy();\n\t\t\t\t\t}\n\t\t\t\t\tif (chart[sharedClipKey + 'm']) {\n\t\t\t\t\t\tchart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Animate in the series\n\t\t */\n\t\tanimate: function (init) {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\tclipRect,\n\t\t\t\tanimation = series.options.animation,\n\t\t\t\tsharedClipKey;\n\n\t\t\t// Animation option is set to true\n\t\t\tif (animation && !isObject(animation)) {\n\t\t\t\tanimation = defaultPlotOptions[series.type].animation;\n\t\t\t}\n\n\t\t\t// Initialize the animation. Set up the clipping rectangle.\n\t\t\tif (init) {\n\n\t\t\t\tseries.setClip(animation);\n\n\t\t\t// Run the animation\n\t\t\t} else {\n\t\t\t\tsharedClipKey = this.sharedClipKey;\n\t\t\t\tclipRect = chart[sharedClipKey];\n\t\t\t\tif (clipRect) {\n\t\t\t\t\tclipRect.animate({\n\t\t\t\t\t\twidth: chart.plotSizeX\n\t\t\t\t\t}, animation);\n\t\t\t\t}\n\t\t\t\tif (chart[sharedClipKey + 'm']) {\n\t\t\t\t\tchart[sharedClipKey + 'm'].animate({\n\t\t\t\t\t\twidth: chart.plotSizeX + 99\n\t\t\t\t\t}, animation);\n\t\t\t\t}\n\n\t\t\t\t// Delete this function to allow it only once\n\t\t\t\tseries.animate = null;\n\t \n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This runs after animation to land on the final plot clipping\n\t\t */\n\t\tafterAnimate: function () {\n\t\t\tthis.setClip();\n\t\t\tfireEvent(this, 'afterAnimate');\n\t\t},\n\n\t\t/**\n\t\t * Draw the markers\n\t\t */\n\t\tdrawPoints: function () {\n\t\t\tvar series = this,\n\t\t\t\tpointAttr,\n\t\t\t\tpoints = series.points,\n\t\t\t\tchart = series.chart,\n\t\t\t\tplotX,\n\t\t\t\tplotY,\n\t\t\t\ti,\n\t\t\t\tpoint,\n\t\t\t\tradius,\n\t\t\t\tsymbol,\n\t\t\t\tisImage,\n\t\t\t\tgraphic,\n\t\t\t\toptions = series.options,\n\t\t\t\tseriesMarkerOptions = options.marker,\n\t\t\t\tseriesPointAttr = series.pointAttr[''],\n\t\t\t\tpointMarkerOptions,\n\t\t\t\thasPointMarker,\n\t\t\t\tenabled,\n\t\t\t\tisInside,\n\t\t\t\tmarkerGroup = series.markerGroup,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tgloballyEnabled = pick(\n\t\t\t\t\tseriesMarkerOptions.enabled, \n\t\t\t\t\txAxis.isRadial,\n\t\t\t\t\tseries.closestPointRangePx > 2 * seriesMarkerOptions.radius\n\t\t\t\t);\n\n\t\t\tif (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n\t\t\t\ti = points.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tplotX = mathFloor(point.plotX); // #1843\n\t\t\t\t\tplotY = point.plotY;\n\t\t\t\t\tgraphic = point.graphic;\n\t\t\t\t\tpointMarkerOptions = point.marker || {};\n\t\t\t\t\thasPointMarker = !!point.marker;\n\t\t\t\t\tenabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n\t\t\t\t\tisInside = point.isInside;\n\n\t\t\t\t\t// only draw the point if y is defined\n\t\t\t\t\tif (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\n\t\t\t\t\t\t// shortcuts\n\t\t\t\t\t\tpointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;\n\t\t\t\t\t\tradius = pointAttr.r;\n\t\t\t\t\t\tsymbol = pick(pointMarkerOptions.symbol, series.symbol);\n\t\t\t\t\t\tisImage = symbol.indexOf('url') === 0;\n\n\t\t\t\t\t\tif (graphic) { // update\n\t\t\t\t\t\t\tgraphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n\t\t\t\t\t\t\t\t.animate(extend({\n\t\t\t\t\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\t\t\t\t\ty: plotY - radius\n\t\t\t\t\t\t\t\t}, graphic.symbolName ? { // don't apply to image symbols #507\n\t\t\t\t\t\t\t\t\twidth: 2 * radius,\n\t\t\t\t\t\t\t\t\theight: 2 * radius\n\t\t\t\t\t\t\t\t} : {}));\n\t\t\t\t\t\t} else if (isInside && (radius > 0 || isImage)) {\n\t\t\t\t\t\t\tpoint.graphic = graphic = chart.renderer.symbol(\n\t\t\t\t\t\t\t\tsymbol,\n\t\t\t\t\t\t\t\tplotX - radius,\n\t\t\t\t\t\t\t\tplotY - radius,\n\t\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\t\thasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t\t.add(markerGroup);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (graphic) {\n\t\t\t\t\t\tpoint.graphic = graphic.destroy(); // #1269\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Convert state properties from API naming conventions to SVG attributes\n\t\t *\n\t\t * @param {Object} options API options object\n\t\t * @param {Object} base1 SVG attribute object to inherit from\n\t\t * @param {Object} base2 Second level SVG attribute object to inherit from\n\t\t */\n\t\tconvertAttribs: function (options, base1, base2, base3) {\n\t\t\tvar conversion = this.pointAttrToOptions,\n\t\t\t\tattr,\n\t\t\t\toption,\n\t\t\t\tobj = {};\n\n\t\t\toptions = options || {};\n\t\t\tbase1 = base1 || {};\n\t\t\tbase2 = base2 || {};\n\t\t\tbase3 = base3 || {};\n\n\t\t\tfor (attr in conversion) {\n\t\t\t\toption = conversion[attr];\n\t\t\t\tobj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\n\t\t/**\n\t\t * Get the state attributes. Each series type has its own set of attributes\n\t\t * that are allowed to change on a point's state change. Series wide attributes are stored for\n\t\t * all series, and additionally point specific attributes are stored for all\n\t\t * points with individual marker options. If such options are not defined for the point,\n\t\t * a reference to the series wide attributes is stored in point.pointAttr.\n\t\t */\n\t\tgetAttribs: function () {\n\t\t\tvar series = this,\n\t\t\t\tseriesOptions = series.options,\n\t\t\t\tnormalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,\n\t\t\t\tstateOptions = normalOptions.states,\n\t\t\t\tstateOptionsHover = stateOptions[HOVER_STATE],\n\t\t\t\tpointStateOptionsHover,\n\t\t\t\tseriesColor = series.color,\n\t\t\t\tseriesNegativeColor = series.options.negativeColor,\n\t\t\t\tnormalDefaults = {\n\t\t\t\t\tstroke: seriesColor,\n\t\t\t\t\tfill: seriesColor\n\t\t\t\t},\n\t\t\t\tpoints = series.points || [], // #927\n\t\t\t\ti,\n\t\t\t\tpoint,\n\t\t\t\tseriesPointAttr = [],\n\t\t\t\tpointAttr,\n\t\t\t\tpointAttrToOptions = series.pointAttrToOptions,\n\t\t\t\thasPointSpecificOptions = series.hasPointSpecificOptions,\n\t\t\t\tdefaultLineColor = normalOptions.lineColor,\n\t\t\t\tdefaultFillColor = normalOptions.fillColor,\n\t\t\t\tturboThreshold = seriesOptions.turboThreshold,\n\t\t\t\tzones = series.zones,\n\t\t\t\tzoneAxis = series.zoneAxis || 'y',\n\t\t\t\tattr,\n\t\t\t\tkey;\n\n\t\t\t// series type specific modifications\n\t\t\tif (seriesOptions.marker) { // line, spline, area, areaspline, scatter\n\n\t\t\t\t// if no hover radius is given, default to normal radius + 2\n\t\t\t\tstateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;\n\t\t\t\tstateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;\n\n\t\t\t} else { // column, bar, pie\n\n\t\t\t\t// if no hover color is given, brighten the normal color\n\t\t\t\tstateOptionsHover.color = stateOptionsHover.color ||\n\t\t\t\t\tColor(stateOptionsHover.color || seriesColor)\n\t\t\t\t\t\t.brighten(stateOptionsHover.brightness).get();\n\n\t\t\t\t// if no hover negativeColor is given, brighten the normal negativeColor\n\t\t\t\tstateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||\n\t\t\t\t\tColor(stateOptionsHover.negativeColor || seriesNegativeColor)\n\t\t\t\t\t\t.brighten(stateOptionsHover.brightness).get();\n\t\t\t}\n\n\t\t\t// general point attributes for the series normal state\n\t\t\tseriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n\t\t\t// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n\t\t\teach([HOVER_STATE, SELECT_STATE], function (state) {\n\t\t\t\tseriesPointAttr[state] =\n\t\t\t\t\t\tseries.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n\t\t\t});\n\n\t\t\t// set it\n\t\t\tseries.pointAttr = seriesPointAttr;\n\n\n\t\t\t// Generate the point-specific attribute collections if specific point\n\t\t\t// options are given. If not, create a referance to the series wide point\n\t\t\t// attributes\n\t\t\ti = points.length;\n\t\t\tif (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tnormalOptions = (point.options && point.options.marker) || point.options;\n\t\t\t\t\tif (normalOptions && normalOptions.enabled === false) {\n\t\t\t\t\t\tnormalOptions.radius = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (zones.length) {\n\t\t\t\t\t\tvar j = 0,\n\t\t\t\t\t\t\tthreshold = zones[j];\n\t\t\t\t\t\twhile (point[zoneAxis] >= threshold.value) {\t\t\t\t\n\t\t\t\t\t\t\tthreshold = zones[++j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tpoint.color = point.fillColor = threshold.color;\n\t\t\t\t\t}\n\n\t\t\t\t\thasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868\n\n\t\t\t\t\t// check if the point has specific visual options\n\t\t\t\t\tif (point.options) {\n\t\t\t\t\t\tfor (key in pointAttrToOptions) {\n\t\t\t\t\t\t\tif (defined(normalOptions[pointAttrToOptions[key]])) {\n\t\t\t\t\t\t\t\thasPointSpecificOptions = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// a specific marker config object is defined for the individual point:\n\t\t\t\t\t// create it's own attribute collection\n\t\t\t\t\tif (hasPointSpecificOptions) {\n\t\t\t\t\t\tnormalOptions = normalOptions || {};\n\t\t\t\t\t\tpointAttr = [];\n\t\t\t\t\t\tstateOptions = normalOptions.states || {}; // reassign for individual point\n\t\t\t\t\t\tpointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n\t\t\t\t\t\t// Handle colors for column and pies\n\t\t\t\t\t\tif (!seriesOptions.marker) { // column, bar, point\n\t\t\t\t\t\t\t// If no hover color is given, brighten the normal color. #1619, #2579\n\t\t\t\t\t\t\tpointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||\n\t\t\t\t\t\t\t\tColor(point.color)\n\t\t\t\t\t\t\t\t\t.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)\n\t\t\t\t\t\t\t\t\t.get();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal point state inherits series wide normal state\n\t\t\t\t\t\tattr = { color: point.color }; // #868\n\t\t\t\t\t\tif (!defaultFillColor) { // Individual point color or negative color markers (#2219)\n\t\t\t\t\t\t\tattr.fillColor = point.color;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!defaultLineColor) {\n\t\t\t\t\t\t\tattr.lineColor = point.color; // Bubbles take point color, line markers use white\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n\t\t\t\t\t\t// inherit from point normal and series hover\n\t\t\t\t\t\tpointAttr[HOVER_STATE] = series.convertAttribs(\n\t\t\t\t\t\t\tstateOptions[HOVER_STATE],\n\t\t\t\t\t\t\tseriesPointAttr[HOVER_STATE],\n\t\t\t\t\t\t\tpointAttr[NORMAL_STATE]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// inherit from point normal and series hover\n\t\t\t\t\t\tpointAttr[SELECT_STATE] = series.convertAttribs(\n\t\t\t\t\t\t\tstateOptions[SELECT_STATE],\n\t\t\t\t\t\t\tseriesPointAttr[SELECT_STATE],\n\t\t\t\t\t\t\tpointAttr[NORMAL_STATE]\n\t\t\t\t\t\t);\n\n\n\t\t\t\t\t// no marker config object is created: copy a reference to the series-wide\n\t\t\t\t\t// attribute collection\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpointAttr = seriesPointAttr;\n\t\t\t\t\t}\n\n\t\t\t\t\tpoint.pointAttr = pointAttr;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Clear DOM objects and free up memory\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\tissue134 = /AppleWebKit\\/533/.test(userAgent),\n\t\t\t\tdestroy,\n\t\t\t\ti,\n\t\t\t\tdata = series.data || [],\n\t\t\t\tpoint,\n\t\t\t\tprop,\n\t\t\t\taxis;\n\n\t\t\t// add event hook\n\t\t\tfireEvent(series, 'destroy');\n\n\t\t\t// remove all events\n\t\t\tremoveEvent(series);\n\n\t\t\t// erase from axes\n\t\t\teach(series.axisTypes || [], function (AXIS) {\n\t\t\t\taxis = series[AXIS];\n\t\t\t\tif (axis) {\n\t\t\t\t\terase(axis.series, series);\n\t\t\t\t\taxis.isDirty = axis.forceRedraw = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// remove legend items\n\t\t\tif (series.legendItem) {\n\t\t\t\tseries.chart.legend.destroyItem(series);\n\t\t\t}\n\n\t\t\t// destroy all points with their elements\n\t\t\ti = data.length;\n\t\t\twhile (i--) {\n\t\t\t\tpoint = data[i];\n\t\t\t\tif (point && point.destroy) {\n\t\t\t\t\tpoint.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t\tseries.points = null;\n\n\t\t\t// Clear the animation timeout if we are destroying the series during initial animation\n\t\t\tclearTimeout(series.animationTimeout);\n\n\t\t\t// destroy all SVGElements associated to the series\n\t\t\teach(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',\n\t\t\t\t\t'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {\n\t\t\t\tif (series[prop]) {\n\n\t\t\t\t\t// issue 134 workaround\n\t\t\t\t\tdestroy = issue134 && prop === 'group' ?\n\t\t\t\t\t\t'hide' :\n\t\t\t\t\t\t'destroy';\n\n\t\t\t\t\tseries[prop][destroy]();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// remove from hoverSeries\n\t\t\tif (chart.hoverSeries === series) {\n\t\t\t\tchart.hoverSeries = null;\n\t\t\t}\n\t\t\terase(chart.series, series);\n\n\t\t\t// clear all members\n\t\t\tfor (prop in series) {\n\t\t\t\tdelete series[prop];\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Return the graph path of a segment\n\t\t */\n\t\tgetSegmentPath: function (segment) {\n\t\t\tvar series = this,\n\t\t\t\tsegmentPath = [],\n\t\t\t\tstep = series.options.step;\n\n\t\t\t// build the segment line\n\t\t\teach(segment, function (point, i) {\n\n\t\t\t\tvar plotX = point.plotX,\n\t\t\t\t\tplotY = point.plotY,\n\t\t\t\t\tlastPoint;\n\n\t\t\t\tif (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n\t\t\t\t\tsegmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// moveTo or lineTo\n\t\t\t\t\tsegmentPath.push(i ? L : M);\n\n\t\t\t\t\t// step line?\n\t\t\t\t\tif (step && i) {\n\t\t\t\t\t\tlastPoint = segment[i - 1];\n\t\t\t\t\t\tif (step === 'right') {\n\t\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\t\tlastPoint.plotX,\n\t\t\t\t\t\t\t\tplotY\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} else if (step === 'center') {\n\t\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\t\tlastPoint.plotY,\n\t\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\t\tplotY\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\t\tplotX,\n\t\t\t\t\t\t\t\tlastPoint.plotY\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// normal line to next point\n\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\tpoint.plotX,\n\t\t\t\t\t\tpoint.plotY\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn segmentPath;\n\t\t},\n\n\t\t/**\n\t\t * Get the graph path\n\t\t */\n\t\tgetGraphPath: function () {\n\t\t\tvar series = this,\n\t\t\t\tgraphPath = [],\n\t\t\t\tsegmentPath,\n\t\t\t\tsinglePoints = []; // used in drawTracker\n\n\t\t\t// Divide into segments and build graph and area paths\n\t\t\teach(series.segments, function (segment) {\n\n\t\t\t\tsegmentPath = series.getSegmentPath(segment);\n\n\t\t\t\t// add the segment to the graph, or a single point for tracking\n\t\t\t\tif (segment.length > 1) {\n\t\t\t\t\tgraphPath = graphPath.concat(segmentPath);\n\t\t\t\t} else {\n\t\t\t\t\tsinglePoints.push(segment[0]);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\n\t\t\tseries.singlePoints = singlePoints;\n\t\t\tseries.graphPath = graphPath;\n\n\t\t\treturn graphPath;\n\n\t\t},\n\n\t\t/**\n\t\t * Draw the actual graph\n\t\t */\n\t\tdrawGraph: function () {\n\t\t\tvar series = this,\n\t\t\t\toptions = this.options,\n\t\t\t\tprops = [['graph', options.lineColor || this.color, options.dashStyle]],\n\t\t\t\tlineWidth = options.lineWidth,\n\t\t\t\troundCap = options.linecap !== 'square',\n\t\t\t\tgraphPath = this.getGraphPath(),\n\t\t\t\tfillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph\n\t\t\t\tzones = this.zones;\n\n\t\t\teach(zones, function (threshold, i) {\n\t\t\t\tprops.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n\t\t\t});\n\t\t\t\n\t\t\t// Draw the graph\n\t\t\teach(props, function (prop, i) {\n\t\t\t\tvar graphKey = prop[0],\n\t\t\t\t\tgraph = series[graphKey],\n\t\t\t\t\tattribs;\n\n\t\t\t\tif (graph) {\n\t\t\t\t\tstop(graph); // cancel running animations, #459\n\t\t\t\t\tgraph.animate({ d: graphPath });\n\n\t\t\t\t} else if ((lineWidth || fillColor) && graphPath.length) { // #1487\n\t\t\t\t\tattribs = {\n\t\t\t\t\t\tstroke: prop[1],\n\t\t\t\t\t\t'stroke-width': lineWidth,\n\t\t\t\t\t\tfill: fillColor,\n\t\t\t\t\t\tzIndex: 1 // #1069\n\t\t\t\t\t};\n\t\t\t\t\tif (prop[2]) {\n\t\t\t\t\t\tattribs.dashstyle = prop[2];\n\t\t\t\t\t} else if (roundCap) {\n\t\t\t\t\t\tattribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n\t\t\t\t\t}\n\n\t\t\t\t\tseries[graphKey] = series.chart.renderer.path(graphPath)\n\t\t\t\t\t\t.attr(attribs)\n\t\t\t\t\t\t.add(series.group)\n\t\t\t\t\t\t.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Clip the graphs into the positive and negative coloured graphs\n\t\t */\n\t\tapplyZones: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = this.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tzones = this.zones,\n\t\t\t\ttranslatedFrom,\n\t\t\t\ttranslatedTo,\n\t\t\t\tclips = this.clips || [],\n\t\t\t\tclipAttr,\n\t\t\t\tgraph = this.graph,\n\t\t\t\tarea = this.area,\n\t\t\t\tchartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),\n\t\t\t\tzoneAxis = this.zoneAxis || 'y',\n\t\t\t\taxis = this[zoneAxis + 'Axis'],\n\t\t\t\treversed = axis.reversed,\n\t\t\t\thoriz = axis.horiz,\n\t\t\t\tignoreZones = false;\n\n\t\t\tif (zones.length && (graph || area)) {\n\t\t\t\t// The use of the Color Threshold assumes there are no gaps\n\t\t\t\t// so it is safe to hide the original graph and area\n\t\t\t\tgraph.hide();\n\t\t\t\tif (area) { area.hide(); }\n\n\t\t\t\t// Create the clips\n\t\t\t\teach(zones, function (threshold, i) {\n\t\t\t\t\ttranslatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));\n\t\t\t\t\ttranslatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));\n\n\t\t\t\t\tif (ignoreZones) {\n\t\t\t\t\t\ttranslatedFrom = translatedTo = axis.toPixels(axis.max);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (axis.isXAxis) {\n\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\tx: reversed ? translatedTo : translatedFrom,\n\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\twidth: Math.abs(translatedFrom - translatedTo), \n\t\t\t\t\t\t\theight: chartSizeMax\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (!horiz) {\n\t\t\t\t\t\t\tclipAttr.x = chart.plotHeight - clipAttr.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: reversed ? translatedFrom : translatedTo,\n\t\t\t\t\t\t\twidth: chartSizeMax, \n\t\t\t\t\t\t\theight: Math.abs(translatedFrom - translatedTo)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (horiz) {\n\t\t\t\t\t\t\tclipAttr.y = chart.plotWidth - clipAttr.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\n\t\t\t\t\t/// VML SUPPPORT\n\t\t\t\t\tif (chart.inverted && renderer.isVML) {\n\t\t\t\t\t\tif (axis.isXAxis) {\t\t\t\n\t\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\ty: reversed ? translatedFrom : translatedTo,\n\t\t\t\t\t\t\t\theight: clipAttr.width,\n\t\t\t\t\t\t\t\twidth: chart.chartWidth\n\t\t\t\t\t\t\t};\t\t\n\t\t\t\t\t\t} else {\t\t\t\t\n\t\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\t\tx: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\twidth: clipAttr.height,\n\t\t\t\t\t\t\t\theight: chart.chartHeight\n\t\t\t\t\t\t\t};\t\n\t\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t/// END OF VML SUPPORT\n\n\t\t\t\t\tif (clips[i]) {\n\t\t\t\t\t\tclips[i].animate(clipAttr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclips[i] = renderer.clipRect(clipAttr);\n\n\t\t\t\t\t\tseries['colorGraph' + i].clip(clips[i]);\n\n\t\t\t\t\t\tif (area) {\n\t\t\t\t\t\t\tseries['colorArea' + i].clip(clips[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// if this zone extends out of the axis, ignore the others\n\t\t\t\t\tignoreZones = threshold.value > axis.max;\n\t\t\t\t});\n\t\t\t\tthis.clips = clips;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Initialize and perform group inversion on series.group and series.markerGroup\n\t\t */\n\t\tinvertGroups: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart;\n\n\t\t\t// Pie, go away (#1736)\n\t\t\tif (!series.xAxis) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// A fixed size is needed for inversion to work\n\t\t\tfunction setInvert() {\n\t\t\t\tvar size = {\n\t\t\t\t\twidth: series.yAxis.len,\n\t\t\t\t\theight: series.xAxis.len\n\t\t\t\t};\n\n\t\t\t\teach(['group', 'markerGroup'], function (groupName) {\n\t\t\t\t\tif (series[groupName]) {\n\t\t\t\t\t\tseries[groupName].attr(size).invert();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\taddEvent(chart, 'resize', setInvert); // do it on resize\n\t\t\taddEvent(series, 'destroy', function () {\n\t\t\t\tremoveEvent(chart, 'resize', setInvert);\n\t\t\t});\n\n\t\t\t// Do it now\n\t\t\tsetInvert(); // do it now\n\n\t\t\t// On subsequent render and redraw, just do setInvert without setting up events again\n\t\t\tseries.invertGroups = setInvert;\n\t\t},\n\n\t\t/**\n\t\t * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n\t\t * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n\t\t */\n\t\tplotGroup: function (prop, name, visibility, zIndex, parent) {\n\t\t\tvar group = this[prop],\n\t\t\t\tisNew = !group;\n\n\t\t\t// Generate it on first call\n\t\t\tif (isNew) {\n\t\t\t\tthis[prop] = group = this.chart.renderer.g(name)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\tzIndex: zIndex || 0.1 // IE8 needs this\n\t\t\t\t\t})\n\t\t\t\t\t.add(parent);\n\t\t\t}\n\t\t\t// Place it on first and subsequent (redraw) calls\n\t\t\tgroup[isNew ? 'attr' : 'animate'](this.getPlotBox());\n\t\t\treturn group;\n\t\t},\n\n\t\t/**\n\t\t * Get the translation and scale for the plot area of this series\n\t\t */\n\t\tgetPlotBox: function () {\n\t\t\tvar chart = this.chart,\n\t\t\t\txAxis = this.xAxis,\n\t\t\t\tyAxis = this.yAxis;\n\n\t\t\t// Swap axes for inverted (#2339)\n\t\t\tif (chart.inverted) {\n\t\t\t\txAxis = yAxis;\n\t\t\t\tyAxis = this.xAxis;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttranslateX: xAxis ? xAxis.left : chart.plotLeft,\n\t\t\t\ttranslateY: yAxis ? yAxis.top : chart.plotTop,\n\t\t\t\tscaleX: 1, // #1623\n\t\t\t\tscaleY: 1\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Render the graph and markers\n\t\t */\n\t\trender: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\tgroup,\n\t\t\t\toptions = series.options,\n\t\t\t\tanimation = options.animation,\n\t\t\t\t// Animation doesn't work in IE8 quirks when the group div is hidden,\n\t\t\t\t// and looks bad in other oldIE\n\t\t\t\tanimDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,\n\t\t\t\tvisibility = series.visible ? VISIBLE : HIDDEN,\n\t\t\t\tzIndex = options.zIndex,\n\t\t\t\thasRendered = series.hasRendered,\n\t\t\t\tchartSeriesGroup = chart.seriesGroup;\n\n\t\t\t// the group\n\t\t\tgroup = series.plotGroup(\n\t\t\t\t'group',\n\t\t\t\t'series',\n\t\t\t\tvisibility,\n\t\t\t\tzIndex,\n\t\t\t\tchartSeriesGroup\n\t\t\t);\n\n\t\t\tseries.markerGroup = series.plotGroup(\n\t\t\t\t'markerGroup',\n\t\t\t\t'markers',\n\t\t\t\tvisibility,\n\t\t\t\tzIndex,\n\t\t\t\tchartSeriesGroup\n\t\t\t);\n\n\t\t\t// initiate the animation\n\t\t\tif (animDuration) {\n\t\t\t\tseries.animate(true);\n\t\t\t}\n\n\t\t\t// cache attributes for shapes\n\t\t\tseries.getAttribs();\n\n\t\t\t// SVGRenderer needs to know this before drawing elements (#1089, #1795)\n\t\t\tgroup.inverted = series.isCartesian ? chart.inverted : false;\n\n\t\t\t// draw the graph if any\n\t\t\tif (series.drawGraph) {\n\t\t\t\tseries.drawGraph();\n\t\t\t\tseries.applyZones();\n\t\t\t}\n\n\t\t\teach(series.points, function (point) {\n\t\t\t\tif (point.redraw) {\n\t\t\t\t\tpoint.redraw();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// draw the data labels (inn pies they go before the points)\n\t\t\tif (series.drawDataLabels) {\n\t\t\t\tseries.drawDataLabels();\n\t\t\t}\n\n\t\t\t// draw the points\n\t\t\tif (series.visible) {\n\t\t\t\tseries.drawPoints();\n\t\t\t}\n\n\n\t\t\t// draw the mouse tracking area\n\t\t\tif (series.drawTracker && series.options.enableMouseTracking !== false) {\n\t\t\t\tseries.drawTracker();\n\t\t\t}\n\n\t\t\t// Handle inverted series and tracker groups\n\t\t\tif (chart.inverted) {\n\t\t\t\tseries.invertGroups();\n\t\t\t}\n\n\t\t\t// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n\t\t\tif (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n\t\t\t\tgroup.clip(chart.clipRect);\n\t\t\t}\n\n\t\t\t// Run the animation\n\t\t\tif (animDuration) {\n\t\t\t\tseries.animate();\n\t\t\t} \n\n\t\t\t// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n\t\t\t// which should be available to the user).\n\t\t\tif (!hasRendered) {\n\t\t\t\tif (animDuration) {\n\t\t\t\t\tseries.animationTimeout = setTimeout(function () {\n\t\t\t\t\t\tseries.afterAnimate();\n\t\t\t\t\t}, animDuration);\n\t\t\t\t} else {\n\t\t\t\t\tseries.afterAnimate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseries.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n\t\t\t// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n\t\t\tseries.hasRendered = true;\n\t\t},\n\n\t\t/**\n\t\t * Redraw the series after an update in the axes.\n\t\t */\n\t\tredraw: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\twasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n\t\t\t\twasDirty = series.isDirty,\n\t\t\t\tgroup = series.group,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tyAxis = series.yAxis;\n\n\t\t\t// reposition on resize\n\t\t\tif (group) {\n\t\t\t\tif (chart.inverted) {\n\t\t\t\t\tgroup.attr({\n\t\t\t\t\t\twidth: chart.plotWidth,\n\t\t\t\t\t\theight: chart.plotHeight\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tgroup.animate({\n\t\t\t\t\ttranslateX: pick(xAxis && xAxis.left, chart.plotLeft),\n\t\t\t\t\ttranslateY: pick(yAxis && yAxis.top, chart.plotTop)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tseries.translate();\n\t\t\tseries.render();\n\t\t\tif (wasDirtyData) {\n\t\t\t\tfireEvent(series, 'updatedData');\n\t\t\t}\n\t\t\tif (wasDirty || wasDirtyData) {\t\t\t// #3945 recalculate the kdtree when dirty\n\t\t\t\tdelete this.kdTree; // #3868 recalculate the kdtree with dirty data\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * KD Tree && PointSearching Implementation\n\t\t */\n\n\t\tkdDimensions: 1,\n\t\tkdTree: null,\n\t\tkdAxisArray: ['plotX', 'plotY'],\n\t\tkdComparer: 'distX',\n\n\t\tsearchPoint: function (e) {\n\t\t\tvar series = this,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tyAxis = series.yAxis,\n\t\t\t\tinverted = series.chart.inverted;\n\t\t\t\n\t\t\te.plotX = inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos;\n\t\t\te.plotY = inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos;\n\n\t\t\treturn this.searchKDTree(e);\n\t\t},\n\n\t\tbuildKDTree: function () {\n\t\t\tvar series = this,\n\t\t\t\tdimensions = series.kdDimensions;\n\n\t\t\t// Internal function\n\t\t\tfunction _kdtree(points, depth, dimensions) {\n\t\t\t\tvar axis, median, length = points && points.length;\n\n\t\t\t\tif (length) {\n\n\t\t\t\t\t// alternate between the axis\n\t\t\t\t\taxis = series.kdAxisArray[depth % dimensions];\n\n\t\t\t\t\t// sort point array\n\t\t\t\t\tpoints.sort(function(a, b) {\n\t\t\t\t\t\treturn a[axis] - b[axis];\n\t\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\tmedian = Math.floor(length / 2);\n\t\t\t\t\t\n\t\t\t\t\t// build and return node\n\t\t\t\t\treturn {\n\t\t\t\t\t\tpoint: points[median],\n\t\t\t\t\t\tleft: _kdtree(points.slice(0, median), depth + 1, dimensions),\n\t\t\t\t\t\tright: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n\t\t\t\t\t};\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n\t\t\tfunction startRecursive() {\n\t\t\t\tvar points = grep(series.points, function (point) {\n\t\t\t\t\treturn point.y !== null;\n\t\t\t\t});\n\t\t\t\tseries.kdTree = _kdtree(points, dimensions, dimensions);\t\t\n\t\t\t}\n\n\t\t\tdelete series.kdTree;\n\t\t\t\n\t\t\tif (series.options.kdSync) {  // For testing tooltips, don't build async\n\t\t\t\tstartRecursive();\n\t\t\t} else {\n\t\t\t\tsetTimeout(startRecursive);\n\t\t\t}\n\t\t},\n\n\t\tsearchKDTree: function (point) {\n\t\t\tvar series = this,\n\t\t\t\tkdComparer = this.kdComparer,\n\t\t\t\tkdX = this.kdAxisArray[0],\n\t\t\t\tkdY = this.kdAxisArray[1];\n\n\t\t\t// Internal function\n\t\t\tfunction _distance(p1, p2) {\n\t\t\t\tvar x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n\t\t\t\t\ty = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n\t\t\t\t\tr = (x || 0) + (y || 0);\n\t\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tdistX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,\n\t\t\t\t\tdistY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,\n\t\t\t\t\tdistR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE\n\t\t\t\t};\n\t\t\t}\n\t\t\tfunction _search(search, tree, depth, dimensions) {\n\t\t\t\tvar point = tree.point,\n\t\t\t\t\taxis = series.kdAxisArray[depth % dimensions],\n\t\t\t\t\ttdist,\n\t\t\t\t\tsideA,\n\t\t\t\t\tsideB,\n\t\t\t\t\tret = point,\n\t\t\t\t\tnPoint1,\n\t\t\t\t\tnPoint2;\n\t\t\t\tpoint.dist = _distance(search, point);\n\n\t\t\t\t// Pick side based on distance to splitting point\n\t\t\t\ttdist = search[axis] - point[axis];\n\t\t\t\tsideA = tdist < 0 ? 'left' : 'right';\n\n\t\t\t\t// End of tree\n\t\t\t\tif (tree[sideA]) {\n\t\t\t\t\tnPoint1 =_search(search, tree[sideA], depth + 1, dimensions);\n\n\t\t\t\t\tret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);\n\n\t\t\t\t\tsideB = tdist < 0 ? 'right' : 'left';\n\t\t\t\t\tif (tree[sideB]) {\n\t\t\t\t\t\t// compare distance to current best to splitting point to decide wether to check side B or not\n\t\t\t\t\t\tif (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {\n\t\t\t\t\t\t\tnPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n\t\t\t\t\t\t\tret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (!this.kdTree) {\n\t\t\t\tthis.buildKDTree();\n\t\t\t}\n\n\t\t\tif (this.kdTree) {\n\t\t\t\treturn _search(point, \n\t\t\t\t\tthis.kdTree, this.kdDimensions, this.kdDimensions);\n\t\t\t}\n\t\t}\n\n\t}; // end Series prototype\n\n\t/**\n\t * The class for stack items\n\t */\n\tfunction StackItem(axis, options, isNegative, x, stackOption) {\n\t\t\n\t\tvar inverted = axis.chart.inverted;\n\n\t\tthis.axis = axis;\n\n\t\t// Tells if the stack is negative\n\t\tthis.isNegative = isNegative;\n\n\t\t// Save the options to be able to style the label\n\t\tthis.options = options;\n\n\t\t// Save the x value to be able to position the label later\n\t\tthis.x = x;\n\n\t\t// Initialize total value\n\t\tthis.total = null;\n\n\t\t// This will keep each points' extremes stored by series.index and point index\n\t\tthis.points = {};\n\n\t\t// Save the stack option on the series configuration object, and whether to treat it as percent\n\t\tthis.stack = stackOption;\n\n\t\t// The align options and text align varies on whether the stack is negative and\n\t\t// if the chart is inverted or not.\n\t\t// First test the user supplied value, then use the dynamic.\n\t\tthis.alignOptions = {\n\t\t\talign: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n\t\t\tverticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n\t\t\ty: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n\t\t\tx: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n\t\t};\n\n\t\tthis.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n\t}\n\n\tStackItem.prototype = {\n\t\tdestroy: function () {\n\t\t\tdestroyObjectProperties(this, this.axis);\n\t\t},\n\n\t\t/**\n\t\t * Renders the stack total label and adds it to the stack label group.\n\t\t */\n\t\trender: function (group) {\n\t\t\tvar options = this.options,\n\t\t\t\tformatOption = options.format,\n\t\t\t\tstr = formatOption ?\n\t\t\t\t\tformat(formatOption, this) : \n\t\t\t\t\toptions.formatter.call(this);  // format the text in the label\n\n\t\t\t// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n\t\t\tif (this.label) {\n\t\t\t\tthis.label.attr({text: str, visibility: HIDDEN});\n\t\t\t// Create new label\n\t\t\t} else {\n\t\t\t\tthis.label =\n\t\t\t\t\tthis.axis.chart.renderer.text(str, null, null, options.useHTML)\t\t// dummy positions, actual position updated with setOffset method in columnseries\n\t\t\t\t\t\t.css(options.style)\t\t\t\t// apply style\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\talign: this.textAlign,\t\t\t\t// fix the text-anchor\n\t\t\t\t\t\t\trotation: options.rotation,\t// rotation\n\t\t\t\t\t\t\tvisibility: HIDDEN\t\t\t\t\t// hidden until setOffset is called\n\t\t\t\t\t\t})\t\t\t\t\n\t\t\t\t\t\t.add(group);\t\t\t\t\t\t\t// add to the labels-group\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets the offset that the stack has from the x value and repositions the label.\n\t\t */\n\t\tsetOffset: function (xOffset, xWidth) {\n\t\t\tvar stackItem = this,\n\t\t\t\taxis = stackItem.axis,\n\t\t\t\tchart = axis.chart,\n\t\t\t\tinverted = chart.inverted,\n\t\t\t\tneg = this.isNegative,\t\t\t\t\t\t\t// special treatment is needed for negative stacks\n\t\t\t\ty = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n\t\t\t\tyZero = axis.translate(0),\t\t\t\t\t\t// stack origin\n\t\t\t\th = mathAbs(y - yZero),\t\t\t\t\t\t\t// stack height\n\t\t\t\tx = chart.xAxis[0].translate(this.x) + xOffset,\t// stack x position\n\t\t\t\tplotHeight = chart.plotHeight,\n\t\t\t\tstackBox = {\t// this is the box for the complete stack\n\t\t\t\t\tx: inverted ? (neg ? y : y - h) : x,\n\t\t\t\t\ty: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n\t\t\t\t\twidth: inverted ? h : xWidth,\n\t\t\t\t\theight: inverted ? xWidth : h\n\t\t\t\t},\n\t\t\t\tlabel = this.label,\n\t\t\t\talignAttr;\n\t\t\t\n\t\t\tif (label) {\n\t\t\t\tlabel.align(this.alignOptions, null, stackBox);\t// align the label to the box\n\t\t\t\t\t\n\t\t\t\t// Set visibility (#678)\n\t\t\t\talignAttr = label.alignAttr;\n\t\t\t\tlabel[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n\t\t\t}\n\t\t}\n\t};\n\n\n\t// Stacking methods defined on the Axis prototype\n\n\t/**\n\t * Build the stacks from top down\n\t */\n\tAxis.prototype.buildStacks = function () {\n\t\tvar series = this.series,\n\t\t\treversedStacks = pick(this.options.reversedStacks, true),\n\t\t\ti = series.length;\n\t\tif (!this.isXAxis) {\n\t\t\tthis.usePercentage = false;\n\t\t\twhile (i--) {\n\t\t\t\tseries[reversedStacks ? i : series.length - i - 1].setStackedPoints();\n\t\t\t}\n\t\t\t// Loop up again to compute percent stack\n\t\t\tif (this.usePercentage) {\n\t\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\t\tseries[i].setPercentStacks();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tAxis.prototype.renderStackTotals = function () {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tstacks = axis.stacks,\n\t\t\tstackKey, \n\t\t\toneStack, \n\t\t\tstackCategory,\n\t\t\tstackTotalGroup = axis.stackTotalGroup;\n\n\t\t// Create a separate group for the stack total labels\n\t\tif (!stackTotalGroup) {\n\t\t\taxis.stackTotalGroup = stackTotalGroup =\n\t\t\t\trenderer.g('stack-labels')\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tvisibility: VISIBLE,\n\t\t\t\t\t\tzIndex: 6\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t}\n\n\t\t// plotLeft/Top will change when y axis gets wider so we need to translate the\n\t\t// stackTotalGroup at every render call. See bug #506 and #516\n\t\tstackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n\t\t// Render each stack total\n\t\tfor (stackKey in stacks) {\n\t\t\toneStack = stacks[stackKey];\n\t\t\tfor (stackCategory in oneStack) {\n\t\t\t\toneStack[stackCategory].render(stackTotalGroup);\n\t\t\t}\n\t\t}\n\t};\n\n\n\t// Stacking methods defnied for Series prototype\n\n\t/**\n\t * Adds series' points value to corresponding stack\n\t */\n\tSeries.prototype.setStackedPoints = function () {\n\t\tif (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar series = this,\n\t\t\txData = series.processedXData,\n\t\t\tyData = series.processedYData,\n\t\t\tstackedYData = [],\n\t\t\tyDataLength = yData.length,\n\t\t\tseriesOptions = series.options,\n\t\t\tthreshold = seriesOptions.threshold,\n\t\t\tstackOption = seriesOptions.stack,\n\t\t\tstacking = seriesOptions.stacking,\n\t\t\tstackKey = series.stackKey,\n\t\t\tnegKey = '-' + stackKey,\n\t\t\tnegStacks = series.negStacks,\n\t\t\tyAxis = series.yAxis,\n\t\t\tstacks = yAxis.stacks,\n\t\t\toldStacks = yAxis.oldStacks,\n\t\t\tisNegative,\n\t\t\tstack,\n\t\t\tother,\n\t\t\tkey,\n\t\t\tpointKey,\n\t\t\ti,\n\t\t\tx,\n\t\t\ty;\n\n\t\t// loop over the non-null y values and read them into a local array\n\t\tfor (i = 0; i < yDataLength; i++) {\n\t\t\tx = xData[i];\n\t\t\ty = yData[i];\n\t\t\tpointKey = series.index + ',' + i;\n\n\t\t\t// Read stacked values into a stack based on the x value,\n\t\t\t// the sign of y and the stack key. Stacking is also handled for null values (#739)\n\t\t\tisNegative = negStacks && y < threshold;\n\t\t\tkey = isNegative ? negKey : stackKey;\n\n\t\t\t// Create empty object for this stack if it doesn't exist yet\n\t\t\tif (!stacks[key]) {\n\t\t\t\tstacks[key] = {};\n\t\t\t}\n\n\t\t\t// Initialize StackItem for this x\n\t\t\tif (!stacks[key][x]) {\n\t\t\t\tif (oldStacks[key] && oldStacks[key][x]) {\n\t\t\t\t\tstacks[key][x] = oldStacks[key][x];\n\t\t\t\t\tstacks[key][x].total = null;\n\t\t\t\t} else {\n\t\t\t\t\tstacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the StackItem doesn't exist, create it first\n\t\t\tstack = stacks[key][x];\n\t\t\tstack.points[pointKey] = [stack.cum || 0];\n\n\t\t\t// Add value to the stack total\n\t\t\tif (stacking === 'percent') {\n\n\t\t\t\t// Percent stacked column, totals are the same for the positive and negative stacks\n\t\t\t\tother = isNegative ? stackKey : negKey;\n\t\t\t\tif (negStacks && stacks[other] && stacks[other][x]) {\n\t\t\t\t\tother = stacks[other][x];\n\t\t\t\t\tstack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;\n\n\t\t\t\t// Percent stacked areas\n\t\t\t\t} else {\n\t\t\t\t\tstack.total = correctFloat(stack.total + (mathAbs(y) || 0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstack.total = correctFloat(stack.total + (y || 0));\n\t\t\t}\n\n\t\t\tstack.cum = (stack.cum || 0) + (y || 0);\n\n\t\t\tstack.points[pointKey].push(stack.cum);\n\t\t\tstackedYData[i] = stack.cum;\n\n\t\t}\n\n\t\tif (stacking === 'percent') {\n\t\t\tyAxis.usePercentage = true;\n\t\t}\n\n\t\tthis.stackedYData = stackedYData; // To be used in getExtremes\n\n\t\t// Reset old stacks\n\t\tyAxis.oldStacks = {};\n\t};\n\n\t/**\n\t * Iterate over all stacks and compute the absolute values to percent\n\t */\n\tSeries.prototype.setPercentStacks = function () {\n\t\tvar series = this,\n\t\t\tstackKey = series.stackKey,\n\t\t\tstacks = series.yAxis.stacks,\n\t\t\tprocessedXData = series.processedXData;\n\n\t\teach([stackKey, '-' + stackKey], function (key) {\n\t\t\tvar i = processedXData.length,\n\t\t\t\tx,\n\t\t\t\tstack,\n\t\t\t\tpointExtremes,\n\t\t\t\ttotalFactor;\n\n\t\t\twhile (i--) {\n\t\t\t\tx = processedXData[i];\n\t\t\t\tstack = stacks[key] && stacks[key][x];\n\t\t\t\tpointExtremes = stack && stack.points[series.index + ',' + i];\n\t\t\t\tif (pointExtremes) {\n\t\t\t\t\ttotalFactor = stack.total ? 100 / stack.total : 0;\n\t\t\t\t\tpointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n\t\t\t\t\tpointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n\t\t\t\t\tseries.stackedYData[i] = pointExtremes[1];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t// Extend the Chart prototype for dynamic methods\n\textend(Chart.prototype, {\n\n\t\t/**\n\t\t * Add a series dynamically after  time\n\t\t *\n\t\t * @param {Object} options The config options\n\t\t * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t *\n\t\t * @return {Object} series The newly created series object\n\t\t */\n\t\taddSeries: function (options, redraw, animation) {\n\t\t\tvar series,\n\t\t\t\tchart = this;\n\n\t\t\tif (options) {\n\t\t\t\tredraw = pick(redraw, true); // defaults to true\n\n\t\t\t\tfireEvent(chart, 'addSeries', { options: options }, function () {\n\t\t\t\t\tseries = chart.initSeries(options);\n\n\t\t\t\t\tchart.isDirtyLegend = true; // the series array is out of sync with the display\n\t\t\t\t\tchart.linkSeries();\n\t\t\t\t\tif (redraw) {\n\t\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn series;\n\t\t},\n\n\t\t/**\n\t     * Add an axis to the chart\n\t     * @param {Object} options The axis option\n\t     * @param {Boolean} isX Whether it is an X axis or a value axis\n\t     */\n\t\taddAxis: function (options, isX, redraw, animation) {\n\t\t\tvar key = isX ? 'xAxis' : 'yAxis',\n\t\t\t\tchartOptions = this.options,\n\t\t\t\taxis;\n\n\t\t\t/*jslint unused: false*/\n\t\t\taxis = new Axis(this, merge(options, {\n\t\t\t\tindex: this[key].length,\n\t\t\t\tisX: isX\n\t\t\t}));\n\t\t\t/*jslint unused: true*/\n\n\t\t\t// Push the new axis options to the chart options\n\t\t\tchartOptions[key] = splat(chartOptions[key] || {});\n\t\t\tchartOptions[key].push(options);\n\n\t\t\tif (pick(redraw, true)) {\n\t\t\t\tthis.redraw(animation);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Dim the chart and show a loading text or symbol\n\t\t * @param {String} str An optional text to show in the loading label instead of the default one\n\t\t */\n\t\tshowLoading: function (str) {\n\t\t\tvar chart = this,\n\t\t\t\toptions = chart.options,\n\t\t\t\tloadingDiv = chart.loadingDiv,\n\t\t\t\tloadingOptions = options.loading,\n\t\t\t\tsetLoadingSize = function () {\n\t\t\t\t\tif (loadingDiv) {\n\t\t\t\t\t\tcss(loadingDiv, {\n\t\t\t\t\t\t\tleft: chart.plotLeft + PX,\n\t\t\t\t\t\t\ttop: chart.plotTop + PX,\n\t\t\t\t\t\t\twidth: chart.plotWidth + PX,\n\t\t\t\t\t\t\theight: chart.plotHeight + PX\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// create the layer at the first call\n\t\t\tif (!loadingDiv) {\n\t\t\t\tchart.loadingDiv = loadingDiv = createElement(DIV, {\n\t\t\t\t\tclassName: PREFIX + 'loading'\n\t\t\t\t}, extend(loadingOptions.style, {\n\t\t\t\t\tzIndex: 10,\n\t\t\t\t\tdisplay: NONE\n\t\t\t\t}), chart.container);\n\n\t\t\t\tchart.loadingSpan = createElement(\n\t\t\t\t\t'span',\n\t\t\t\t\tnull,\n\t\t\t\t\tloadingOptions.labelStyle,\n\t\t\t\t\tloadingDiv\n\t\t\t\t);\n\t\t\t\taddEvent(chart, 'redraw', setLoadingSize); // #1080\n\t\t\t}\n\n\t\t\t// update text\n\t\t\tchart.loadingSpan.innerHTML = str || options.lang.loading;\n\n\t\t\t// show it\n\t\t\tif (!chart.loadingShown) {\n\t\t\t\tcss(loadingDiv, {\n\t\t\t\t\topacity: 0,\n\t\t\t\t\tdisplay: ''\t\t\t\t\n\t\t\t\t});\n\t\t\t\tanimate(loadingDiv, {\n\t\t\t\t\topacity: loadingOptions.style.opacity\n\t\t\t\t}, {\n\t\t\t\t\tduration: loadingOptions.showDuration || 0\n\t\t\t\t});\n\t\t\t\tchart.loadingShown = true;\n\t\t\t}\n\t\t\tsetLoadingSize();\n\t\t},\n\n\t\t/**\n\t\t * Hide the loading layer\n\t\t */\n\t\thideLoading: function () {\n\t\t\tvar options = this.options,\n\t\t\t\tloadingDiv = this.loadingDiv;\n\n\t\t\tif (loadingDiv) {\n\t\t\t\tanimate(loadingDiv, {\n\t\t\t\t\topacity: 0\n\t\t\t\t}, {\n\t\t\t\t\tduration: options.loading.hideDuration || 100,\n\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\tcss(loadingDiv, { display: NONE });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.loadingShown = false;\n\t\t}\n\t});\n\n\t// extend the Point prototype for dynamic methods\n\textend(Point.prototype, {\n\t\t/**\n\t\t * Update the point with new options (typically x/y data) and optionally redraw the series.\n\t\t *\n\t\t * @param {Object} options Point options as defined in the series.data array\n\t\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t *\n\t\t */\n\t\tupdate: function (options, redraw, animation, runEvent) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tgraphic = point.graphic,\n\t\t\t\ti,\n\t\t\t\tchart = series.chart,\n\t\t\t\tseriesOptions = series.options,\n\t\t\t\tnames = series.xAxis && series.xAxis.names;\n\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\tfunction update() {\n\n\t\t\t\tpoint.applyOptions(options);\n\n\t\t\t\t// Update visuals\n\t\t\t\tif (isObject(options) && !isArray(options)) {\n\t\t\t\t\t// Defer the actual redraw until getAttribs has been called (#3260)\n\t\t\t\t\tpoint.redraw = function () {\n\t\t\t\t\t\tif (graphic) {\n\t\t\t\t\t\t\tif (options && options.marker && options.marker.symbol) {\n\t\t\t\t\t\t\t\tpoint.graphic = graphic.destroy();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgraphic.attr(point.pointAttr[point.state || '']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options && options.dataLabels && point.dataLabel) { // #2468\n\t\t\t\t\t\t\tpoint.dataLabel = point.dataLabel.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpoint.redraw = null;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// record changes in the parallel arrays\n\t\t\t\ti = point.index;\n\t\t\t\tseries.updateParallelArrays(point, i);\n\t\t\t\tif (names && point.name) {\n\t\t\t\t\tnames[point.x] = point.name;\n\t\t\t\t}\n\n\t\t\t\tseriesOptions.data[i] = point.options;\n\n\t\t\t\t// redraw\n\t\t\t\tseries.isDirty = series.isDirtyData = true;\n\t\t\t\tif (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n\t\t\t\t\tchart.isDirtyBox = true;\n\t\t\t\t}\n\n\t\t\t\tif (chart.legend.display && seriesOptions.legendType === 'point') { // #1831, #1885, #3934\n\t\t\t\t\tseries.updateTotals();\n\t\t\t\t\tchart.legend.clearItems();\n\t\t\t\t}\n\t\t\t\tif (redraw) {\n\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire the event with a default handler of doing the update\n\t\t\tif (runEvent === false) { // When called from setData\n\t\t\t\tupdate();\n\t\t\t} else {\n\t\t\t\tpoint.firePointEvent('update', { options: options }, update);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove a point and optionally redraw the series and if necessary the axes\n\t\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t */\n\t\tremove: function (redraw, animation) {\n\t\t\tthis.series.removePoint(inArray(this, this.series.data), redraw, animation);\n\t\t}\n\t});\n\n\t// Extend the series prototype for dynamic methods\n\textend(Series.prototype, {\n\t\t/**\n\t\t * Add a point dynamically after chart load time\n\t\t * @param {Object} options Point options as given in series.data\n\t\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t\t * @param {Boolean} shift If shift is true, a point is shifted off the start\n\t\t *    of the series as one is appended to the end.\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t */\n\t\taddPoint: function (options, redraw, shift, animation) {\n\t\t\tvar series = this,\n\t\t\t\tseriesOptions = series.options,\n\t\t\t\tdata = series.data,\n\t\t\t\tgraph = series.graph,\n\t\t\t\tarea = series.area,\n\t\t\t\tchart = series.chart,\n\t\t\t\tnames = series.xAxis && series.xAxis.names,\n\t\t\t\tcurrentShift = (graph && graph.shift) || 0,\n\t\t\t\tdataOptions = seriesOptions.data,\n\t\t\t\tpoint,\n\t\t\t\tisInTheMiddle,\n\t\t\t\txData = series.xData,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tsetAnimation(animation, chart);\n\n\t\t\t// Make graph animate sideways\n\t\t\tif (shift) {\n\t\t\t\teach([graph, area, series.graphNeg, series.areaNeg], function (shape) {\n\t\t\t\t\tif (shape) {\n\t\t\t\t\t\tshape.shift = currentShift + 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (area) {\n\t\t\t\tarea.isArea = true; // needed in animation, both with and without shift\n\t\t\t}\n\n\t\t\t// Optional redraw, defaults to true\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\t// Get options and push the point to xData, yData and series.options. In series.generatePoints\n\t\t\t// the Point instance will be created on demand and pushed to the series.data array.\n\t\t\tpoint = { series: series };\n\t\t\tseries.pointClass.prototype.applyOptions.apply(point, [options]);\n\t\t\tx = point.x;\n\n\t\t\t// Get the insertion point\n\t\t\ti = xData.length;\n\t\t\tif (series.requireSorting && x < xData[i - 1]) {\n\t\t\t\tisInTheMiddle = true;\n\t\t\t\twhile (i && xData[i - 1] > x) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseries.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n\t\t\tseries.updateParallelArrays(point, i); // update it\n\n\t\t\tif (names && point.name) {\n\t\t\t\tnames[x] = point.name;\n\t\t\t}\n\t\t\tdataOptions.splice(i, 0, options);\n\n\t\t\tif (isInTheMiddle) {\n\t\t\t\tseries.data.splice(i, 0, null);\n\t\t\t\tseries.processData();\n\t\t\t}\n\n\t\t\t// Generate points to be added to the legend (#1329)\n\t\t\tif (seriesOptions.legendType === 'point') {\n\t\t\t\tseries.generatePoints();\n\t\t\t}\n\n\t\t\t// Shift the first point off the parallel arrays\n\t\t\t// todo: consider series.removePoint(i) method\n\t\t\tif (shift) {\n\t\t\t\tif (data[0] && data[0].remove) {\n\t\t\t\t\tdata[0].remove(false);\n\t\t\t\t} else {\n\t\t\t\t\tdata.shift();\n\t\t\t\t\tseries.updateParallelArrays(point, 'shift');\n\n\t\t\t\t\tdataOptions.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// redraw\n\t\t\tseries.isDirty = true;\n\t\t\tseries.isDirtyData = true;\n\t\t\tif (redraw) {\n\t\t\t\tseries.getAttribs(); // #1937\n\t\t\t\tchart.redraw();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove a point (rendered or not), by index\n\t\t */\n\t\tremovePoint: function (i, redraw, animation) {\n\n\t\t\tvar series = this,\n\t\t\t\tdata = series.data,\n\t\t\t\tpoint = data[i],\n\t\t\t\tpoints = series.points,\n\t\t\t\tchart = series.chart,\n\t\t\t\tremove = function () {\n\n\t\t\t\t\tif (data.length === points.length) {\n\t\t\t\t\t\tpoints.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t\tdata.splice(i, 1);\n\t\t\t\t\tseries.options.data.splice(i, 1);\n\t\t\t\t\tseries.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n\t\t\t\t\tif (point) {\n\t\t\t\t\t\tpoint.destroy();\n\t\t\t\t\t}\n\n\t\t\t\t\t// redraw\n\t\t\t\t\tseries.isDirty = true;\n\t\t\t\t\tseries.isDirtyData = true;\n\t\t\t\t\tif (redraw) {\n\t\t\t\t\t\tchart.redraw();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tsetAnimation(animation, chart);\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\t// Fire the event with a default handler of removing the point\n\t\t\tif (point) {\n\t\t\t\tpoint.firePointEvent('remove', null, remove);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove a series and optionally redraw the chart\n\t\t *\n\t\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t\t *    configuration\n\t\t */\n\n\t\tremove: function (redraw, animation) {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart;\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\tif (!series.isRemoving) {  /* prevent triggering native event in jQuery\n\t\t\t\t\t(calling the remove function from the remove event) */\n\t\t\t\tseries.isRemoving = true;\n\n\t\t\t\t// fire the event with a default handler of removing the point\n\t\t\t\tfireEvent(series, 'remove', null, function () {\n\n\n\t\t\t\t\t// destroy elements\n\t\t\t\t\tseries.destroy();\n\n\n\t\t\t\t\t// redraw\n\t\t\t\t\tchart.isDirtyLegend = chart.isDirtyBox = true;\n\t\t\t\t\tchart.linkSeries();\n\n\t\t\t\t\tif (redraw) {\n\t\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\t\t\tseries.isRemoving = false;\n\t\t},\n\n\t\t/**\n\t\t * Update the series with a new set of options\n\t\t */\n\t\tupdate: function (newOptions, redraw) {\n\t\t\tvar series = this,\n\t\t\t\tchart = this.chart,\n\t\t\t\t// must use user options when changing type because this.options is merged\n\t\t\t\t// in with type specific plotOptions\n\t\t\t\toldOptions = this.userOptions,\n\t\t\t\toldType = this.type,\n\t\t\t\tproto = seriesTypes[oldType].prototype,\n\t\t\t\tpreserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n\t\t\t\tn;\n\n\t\t\t// If we're changing type or zIndex, create new groups (#3380, #3404)\n\t\t\tif ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n\t\t\t\tpreserve.length = 0;\n\t\t\t}\n\n\t\t\t// Make sure groups are not destroyed (#3094)\n\t\t\teach(preserve, function (prop) {\n\t\t\t\tpreserve[prop] = series[prop];\n\t\t\t\tdelete series[prop];\n\t\t\t});\n\n\t\t\t// Do the merge, with some forced options\n\t\t\tnewOptions = merge(oldOptions, {\n\t\t\t\tanimation: false,\n\t\t\t\tindex: this.index,\n\t\t\t\tpointStart: this.xData[0] // when updating after addPoint\n\t\t\t}, { data: this.options.data }, newOptions);\n\n\t\t\t// Destroy the series and delete all properties. Reinsert all methods \n\t\t\t// and properties from the new type prototype (#2270, #3719)\n\t\t\tthis.remove(false);\n\t\t\tfor (n in proto) {\n\t\t\t\tthis[n] = UNDEFINED;\n\t\t\t}\n\t\t\textend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n\t\t\t// Re-register groups (#3094)\n\t\t\teach(preserve, function (prop) {\n\t\t\t\tseries[prop] = preserve[prop];\n\t\t\t});\n\n\t\t\tthis.init(chart, newOptions);\n\t\t\tchart.linkSeries(); // Links are lost in this.remove (#3028)\n\t\t\tif (pick(redraw, true)) {\n\t\t\t\tchart.redraw(false);\n\t\t\t}\n\t\t}\n\t});\n\n\t// Extend the Axis.prototype for dynamic methods\n\textend(Axis.prototype, {\n\n\t\t/**\n\t\t * Update the axis with a new options structure\n\t\t */\n\t\tupdate: function (newOptions, redraw) {\n\t\t\tvar chart = this.chart;\n\n\t\t\tnewOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n\t\t\tthis.destroy(true);\n\t\t\tthis._addedPlotLB = UNDEFINED; // #1611, #2887\n\n\t\t\tthis.init(chart, extend(newOptions, { events: UNDEFINED }));\n\n\t\t\tchart.isDirtyBox = true;\n\t\t\tif (pick(redraw, true)) {\n\t\t\t\tchart.redraw();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t     * Remove the axis from the chart\n\t     */\n\t\tremove: function (redraw) {\n\t\t\tvar chart = this.chart,\n\t\t\t\tkey = this.coll, // xAxis or yAxis\n\t\t\t\taxisSeries = this.series,\n\t\t\t\ti = axisSeries.length;\n\n\t\t\t// Remove associated series (#2687)\n\t\t\twhile (i--) {\n\t\t\t\tif (axisSeries[i]) {\n\t\t\t\t\taxisSeries[i].remove(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the axis\n\t\t\terase(chart.axes, this);\n\t\t\terase(chart[key], this);\n\t\t\tchart.options[key].splice(this.options.index, 1);\n\t\t\teach(chart[key], function (axis, i) { // Re-index, #1706\n\t\t\t\taxis.options.index = i;\n\t\t\t});\n\t\t\tthis.destroy();\n\t\t\tchart.isDirtyBox = true;\n\n\t\t\tif (pick(redraw, true)) {\n\t\t\t\tchart.redraw();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Update the axis title by options\n\t\t */\n\t\tsetTitle: function (newTitleOptions, redraw) {\n\t\t\tthis.update({ title: newTitleOptions }, redraw);\n\t\t},\n\n\t\t/**\n\t\t * Set new axis categories and optionally redraw\n\t\t * @param {Array} categories\n\t\t * @param {Boolean} redraw\n\t\t */\n\t\tsetCategories: function (categories, redraw) {\n\t\t\tthis.update({ categories: categories }, redraw);\n\t\t}\n\n\t});\n\n\n\t/**\n\t * LineSeries object\n\t */\n\tvar LineSeries = extendClass(Series);\n\tseriesTypes.line = LineSeries;\n\n\t/**\n\t * Set the default options for area\n\t */\n\tdefaultPlotOptions.area = merge(defaultSeriesOptions, {\n\t\tthreshold: 0\n\t\t// trackByArea: false,\n\t\t// lineColor: null, // overrides color, but lets fillColor be unaltered\n\t\t// fillOpacity: 0.75,\n\t\t// fillColor: null\n\t});\n\n\t/**\n\t * AreaSeries object\n\t */\n\tvar AreaSeries = extendClass(Series, {\n\t\ttype: 'area',\n\t\t/**\n\t\t * For stacks, don't split segments on null values. Instead, draw null values with \n\t\t * no marker. Also insert dummy points for any X position that exists in other series\n\t\t * in the stack.\n\t\t */ \n\t\tgetSegments: function () {\n\t\t\tvar series = this,\n\t\t\t\tsegments = [],\n\t\t\t\tsegment = [],\n\t\t\t\tkeys = [],\n\t\t\t\txAxis = this.xAxis,\n\t\t\t\tyAxis = this.yAxis,\n\t\t\t\tstack = yAxis.stacks[this.stackKey],\n\t\t\t\tpointMap = {},\n\t\t\t\tplotX,\n\t\t\t\tplotY,\n\t\t\t\tpoints = this.points,\n\t\t\t\tconnectNulls = this.options.connectNulls,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\tif (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue\n\t\t\t\t// Create a map where we can quickly look up the points by their X value.\n\t\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\t\tpointMap[points[i].x] = points[i];\n\t\t\t\t}\n\n\t\t\t\t// Sort the keys (#1651)\n\t\t\t\tfor (x in stack) {\n\t\t\t\t\tif (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n\t\t\t\t\t\tkeys.push(+x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeys.sort(function (a, b) {\n\t\t\t\t\treturn a - b;\n\t\t\t\t});\n\n\t\t\t\teach(keys, function (x) {\n\t\t\t\t\tvar y = 0,\n\t\t\t\t\t\tstackPoint;\n\n\t\t\t\t\tif (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t// The point exists, push it to the segment\n\t\t\t\t\t} else if (pointMap[x]) {\n\t\t\t\t\t\tsegment.push(pointMap[x]);\n\n\t\t\t\t\t// There is no point for this X value in this series, so we \n\t\t\t\t\t// insert a dummy point in order for the areas to be drawn\n\t\t\t\t\t// correctly.\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Loop down the stack to find the series below this one that has\n\t\t\t\t\t\t// a value (#1991)\n\t\t\t\t\t\tfor (i = series.index; i <= yAxis.series.length; i++) {\n\t\t\t\t\t\t\tstackPoint = stack[x].points[i + ',' + x];\n\t\t\t\t\t\t\tif (stackPoint) {\n\t\t\t\t\t\t\t\ty = stackPoint[1];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplotX = xAxis.translate(x);\n\t\t\t\t\t\tplotY = yAxis.toPixels(y, true);\n\t\t\t\t\t\tsegment.push({ \n\t\t\t\t\t\t\ty: null, \n\t\t\t\t\t\t\tplotX: plotX,\n\t\t\t\t\t\t\tclientX: plotX, \n\t\t\t\t\t\t\tplotY: plotY, \n\t\t\t\t\t\t\tyBottom: plotY,\n\t\t\t\t\t\t\tonMouseOver: noop\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (segment.length) {\n\t\t\t\t\tsegments.push(segment);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tSeries.prototype.getSegments.call(this);\n\t\t\t\tsegments = this.segments;\n\t\t\t}\n\n\t\t\tthis.segments = segments;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extend the base Series getSegmentPath method by adding the path for the area.\n\t\t * This path is pushed to the series.areaPath property.\n\t\t */\n\t\tgetSegmentPath: function (segment) {\n\t\t\t\n\t\t\tvar segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method\n\t\t\t\tareaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\n\t\t\t\ti,\n\t\t\t\toptions = this.options,\n\t\t\t\tsegLength = segmentPath.length,\n\t\t\t\ttranslatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181\n\t\t\t\tyBottom;\n\t\t\t\n\t\t\tif (segLength === 3) { // for animation from 1 to two points\n\t\t\t\tareaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n\t\t\t}\n\t\t\tif (options.stacking && !this.closedStacks) {\n\t\t\t\t\n\t\t\t\t// Follow stack back. Todo: implement areaspline. A general solution could be to \n\t\t\t\t// reverse the entire graphPath of the previous series, though may be hard with\n\t\t\t\t// splines and with series with different extremes\n\t\t\t\tfor (i = segment.length - 1; i >= 0; i--) {\n\n\t\t\t\t\tyBottom = pick(segment[i].yBottom, translatedThreshold);\n\t\t\t\t\n\t\t\t\t\t// step line?\n\t\t\t\t\tif (i < segment.length - 1 && options.step) {\n\t\t\t\t\t\tareaSegmentPath.push(segment[i + 1].plotX, yBottom);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tareaSegmentPath.push(segment[i].plotX, yBottom);\n\t\t\t\t}\n\n\t\t\t} else { // follow zero line back\n\t\t\t\tthis.closeSegment(areaSegmentPath, segment, translatedThreshold);\n\t\t\t}\n\t\t\tthis.areaPath = this.areaPath.concat(areaSegmentPath);\n\t\t\treturn segmentPath;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extendable method to close the segment path of an area. This is overridden in polar \n\t\t * charts.\n\t\t */\n\t\tcloseSegment: function (path, segment, translatedThreshold) {\n\t\t\tpath.push(\n\t\t\t\tL,\n\t\t\t\tsegment[segment.length - 1].plotX,\n\t\t\t\ttranslatedThreshold,\n\t\t\t\tL,\n\t\t\t\tsegment[0].plotX,\n\t\t\t\ttranslatedThreshold\n\t\t\t);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Draw the graph and the underlying area. This method calls the Series base\n\t\t * function and adds the area. The areaPath is calculated in the getSegmentPath\n\t\t * method called from Series.prototype.drawGraph.\n\t\t */\n\t\tdrawGraph: function () {\n\t\t\t\n\t\t\t// Define or reset areaPath\n\t\t\tthis.areaPath = [];\n\t\t\t\n\t\t\t// Call the base method\n\t\t\tSeries.prototype.drawGraph.apply(this);\n\t\t\t\n\t\t\t// Define local variables\n\t\t\tvar series = this,\n\t\t\t\tareaPath = this.areaPath,\n\t\t\t\toptions = this.options,\n\t\t\t\tzones = this.zones,\n\t\t\t\tprops = [['area', this.color, options.fillColor]]; // area name, main color, fill color\n\t\t\t\n\t\t\teach(zones, function (threshold, i) {\n\t\t\t\tprops.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);\n\t\t\t});\n\t\t\teach(props, function (prop) {\n\t\t\t\tvar areaKey = prop[0],\n\t\t\t\t\tarea = series[areaKey];\n\t\t\t\t\t\n\t\t\t\t// Create or update the area\n\t\t\t\tif (area) { // update\n\t\t\t\t\tarea.animate({ d: areaPath });\n\t\t\n\t\t\t\t} else { // create\n\t\t\t\t\tseries[areaKey] = series.chart.renderer.path(areaPath)\n\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\tfill: pick(\n\t\t\t\t\t\t\t\tprop[2],\n\t\t\t\t\t\t\t\tColor(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tzIndex: 0 // #1069\n\t\t\t\t\t\t}).add(series.group);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle\n\t});\n\n\tseriesTypes.area = AreaSeries;\n\t/**\n\t * Set the default options for spline\n\t */\n\tdefaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n\t/**\n\t * SplineSeries object\n\t */\n\tvar SplineSeries = extendClass(Series, {\n\t\ttype: 'spline',\n\n\t\t/**\n\t\t * Get the spline segment from a given point's previous neighbour to the given point\n\t\t */\n\t\tgetPointSpline: function (segment, point, i) {\n\t\t\tvar smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n\t\t\t\tdenom = smoothing + 1,\n\t\t\t\tplotX = point.plotX,\n\t\t\t\tplotY = point.plotY,\n\t\t\t\tlastPoint = segment[i - 1],\n\t\t\t\tnextPoint = segment[i + 1],\n\t\t\t\tleftContX,\n\t\t\t\tleftContY,\n\t\t\t\trightContX,\n\t\t\t\trightContY,\n\t\t\t\tret;\n\n\t\t\t// find control points\n\t\t\tif (lastPoint && nextPoint) {\n\t\t\t\n\t\t\t\tvar lastX = lastPoint.plotX,\n\t\t\t\t\tlastY = lastPoint.plotY,\n\t\t\t\t\tnextX = nextPoint.plotX,\n\t\t\t\t\tnextY = nextPoint.plotY,\n\t\t\t\t\tcorrection;\n\n\t\t\t\tleftContX = (smoothing * plotX + lastX) / denom;\n\t\t\t\tleftContY = (smoothing * plotY + lastY) / denom;\n\t\t\t\trightContX = (smoothing * plotX + nextX) / denom;\n\t\t\t\trightContY = (smoothing * plotY + nextY) / denom;\n\n\t\t\t\t// have the two control points make a straight line through main point\n\t\t\t\tcorrection = ((rightContY - leftContY) * (rightContX - plotX)) /\n\t\t\t\t\t(rightContX - leftContX) + plotY - rightContY;\n\n\t\t\t\tleftContY += correction;\n\t\t\t\trightContY += correction;\n\n\t\t\t\t// to prevent false extremes, check that control points are between\n\t\t\t\t// neighbouring points' y values\n\t\t\t\tif (leftContY > lastY && leftContY > plotY) {\n\t\t\t\t\tleftContY = mathMax(lastY, plotY);\n\t\t\t\t\trightContY = 2 * plotY - leftContY; // mirror of left control point\n\t\t\t\t} else if (leftContY < lastY && leftContY < plotY) {\n\t\t\t\t\tleftContY = mathMin(lastY, plotY);\n\t\t\t\t\trightContY = 2 * plotY - leftContY;\n\t\t\t\t}\n\t\t\t\tif (rightContY > nextY && rightContY > plotY) {\n\t\t\t\t\trightContY = mathMax(nextY, plotY);\n\t\t\t\t\tleftContY = 2 * plotY - rightContY;\n\t\t\t\t} else if (rightContY < nextY && rightContY < plotY) {\n\t\t\t\t\trightContY = mathMin(nextY, plotY);\n\t\t\t\t\tleftContY = 2 * plotY - rightContY;\n\t\t\t\t}\n\n\t\t\t\t// record for drawing in next point\n\t\t\t\tpoint.rightContX = rightContX;\n\t\t\t\tpoint.rightContY = rightContY;\n\n\t\t\t}\n\t\t\t\n\t\t\t// Visualize control points for debugging\n\t\t\t/*\n\t\t\tif (leftContX) {\n\t\t\t\tthis.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: 'red',\n\t\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\t\tfill: 'none'\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t\tthis.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n\t\t\t\t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: 'red',\n\t\t\t\t\t\t'stroke-width': 1\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t\tthis.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: 'green',\n\t\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\t\tfill: 'none'\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t\tthis.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n\t\t\t\t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: 'green',\n\t\t\t\t\t\t'stroke-width': 1\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// moveTo or lineTo\n\t\t\tif (!i) {\n\t\t\t\tret = [M, plotX, plotY];\n\t\t\t} else { // curve from last point to this\n\t\t\t\tret = [\n\t\t\t\t\t'C',\n\t\t\t\t\tlastPoint.rightContX || lastPoint.plotX,\n\t\t\t\t\tlastPoint.rightContY || lastPoint.plotY,\n\t\t\t\t\tleftContX || plotX,\n\t\t\t\t\tleftContY || plotY,\n\t\t\t\t\tplotX,\n\t\t\t\t\tplotY\n\t\t\t\t];\n\t\t\t\tlastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t});\n\tseriesTypes.spline = SplineSeries;\n\n\t/**\n\t * Set the default options for areaspline\n\t */\n\tdefaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n\t/**\n\t * AreaSplineSeries object\n\t */\n\tvar areaProto = AreaSeries.prototype,\n\t\tAreaSplineSeries = extendClass(SplineSeries, {\n\t\t\ttype: 'areaspline',\n\t\t\tclosedStacks: true, // instead of following the previous graph back, follow the threshold back\n\t\t\t\n\t\t\t// Mix in methods from the area series\n\t\t\tgetSegmentPath: areaProto.getSegmentPath,\n\t\t\tcloseSegment: areaProto.closeSegment,\n\t\t\tdrawGraph: areaProto.drawGraph,\n\t\t\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle\n\t\t});\n\n\tseriesTypes.areaspline = AreaSplineSeries;\n\n\t/**\n\t * Set the default options for column\n\t */\n\tdefaultPlotOptions.column = merge(defaultSeriesOptions, {\n\t\tborderColor: '#FFFFFF',\n\t\t//borderWidth: 1,\n\t\tborderRadius: 0,\n\t\t//colorByPoint: undefined,\n\t\tgroupPadding: 0.2,\n\t\t//grouping: true,\n\t\tmarker: null, // point options are specified in the base options\n\t\tpointPadding: 0.1,\n\t\t//pointWidth: null,\n\t\tminPointLength: 0,\n\t\tcropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n\t\tpointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n\t\tstates: {\n\t\t\thover: {\n\t\t\t\tbrightness: 0.1,\n\t\t\t\tshadow: false,\n\t\t\t\thalo: false\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tcolor: '#C0C0C0',\n\t\t\t\tborderColor: '#000000',\n\t\t\t\tshadow: false\n\t\t\t}\n\t\t},\n\t\tdataLabels: {\n\t\t\talign: null, // auto\n\t\t\tverticalAlign: null, // auto\n\t\t\ty: null\n\t\t},\n\t\tstickyTracking: false,\n\t\ttooltip: {\n\t\t\tdistance: 6\n\t\t},\n\t\tthreshold: 0\n\t});\n\n\t/**\n\t * ColumnSeries object\n\t */\n\tvar ColumnSeries = extendClass(Series, {\n\t\ttype: 'column',\n\t\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\t\tstroke: 'borderColor',\n\t\t\tfill: 'color',\n\t\t\tr: 'borderRadius'\n\t\t},\n\t\tcropShoulder: 0,\n\t\tdirectTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n\t\ttrackerGroups: ['group', 'dataLabelsGroup'],\n\t\tnegStacks: true, // use separate negative stacks, unlike area stacks where a negative \n\t\t\t// point is substracted from previous (#1910)\n\t\t\n\t\t/**\n\t\t * Initialize the series\n\t\t */\n\t\tinit: function () {\n\t\t\tSeries.prototype.init.apply(this, arguments);\n\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart;\n\n\t\t\t// if the series is added dynamically, force redraw of other\n\t\t\t// series affected by a new column\n\t\t\tif (chart.hasRendered) {\n\t\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\t\tif (otherSeries.type === series.type) {\n\t\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n\t\t * pointWidth etc. \n\t\t */\n\t\tgetColumnMetrics: function () {\n\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\txAxis = series.xAxis,\n\t\t\t\tyAxis = series.yAxis,\n\t\t\t\treversedXAxis = xAxis.reversed,\n\t\t\t\tstackKey,\n\t\t\t\tstackGroups = {},\n\t\t\t\tcolumnIndex,\n\t\t\t\tcolumnCount = 0;\n\n\t\t\t// Get the total number of column type series.\n\t\t\t// This is called on every series. Consider moving this logic to a\n\t\t\t// chart.orderStacks() function and call it on init, addSeries and removeSeries\n\t\t\tif (options.grouping === false) {\n\t\t\t\tcolumnCount = 1;\n\t\t\t} else {\n\t\t\t\teach(series.chart.series, function (otherSeries) {\n\t\t\t\t\tvar otherOptions = otherSeries.options,\n\t\t\t\t\t\totherYAxis = otherSeries.yAxis;\n\t\t\t\t\tif (otherSeries.type === series.type && otherSeries.visible &&\n\t\t\t\t\t\t\tyAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n\t\t\t\t\t\tif (otherOptions.stacking) {\n\t\t\t\t\t\t\tstackKey = otherSeries.stackKey;\n\t\t\t\t\t\t\tif (stackGroups[stackKey] === UNDEFINED) {\n\t\t\t\t\t\t\t\tstackGroups[stackKey] = columnCount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcolumnIndex = stackGroups[stackKey];\n\t\t\t\t\t\t} else if (otherOptions.grouping !== false) { // #1162\n\t\t\t\t\t\t\tcolumnIndex = columnCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\totherSeries.columnIndex = columnIndex;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar categoryWidth = mathMin(\n\t\t\t\t\tmathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n\t\t\t\t\txAxis.len // #1535\n\t\t\t\t),\n\t\t\t\tgroupPadding = categoryWidth * options.groupPadding,\n\t\t\t\tgroupWidth = categoryWidth - 2 * groupPadding,\n\t\t\t\tpointOffsetWidth = groupWidth / columnCount,\n\t\t\t\toptionPointWidth = options.pointWidth,\n\t\t\t\tpointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :\n\t\t\t\t\tpointOffsetWidth * options.pointPadding,\n\t\t\t\tpointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts\n\t\t\t\tcolIndex = (reversedXAxis ? \n\t\t\t\t\tcolumnCount - (series.columnIndex || 0) : // #1251\n\t\t\t\t\tseries.columnIndex) || 0,\n\t\t\t\tpointXOffset = pointPadding + (groupPadding + colIndex *\n\t\t\t\t\tpointOffsetWidth - (categoryWidth / 2)) *\n\t\t\t\t\t(reversedXAxis ? -1 : 1);\n\n\t\t\t// Save it for reading in linked series (Error bars particularly)\n\t\t\treturn (series.columnMetrics = { \n\t\t\t\twidth: pointWidth, \n\t\t\t\toffset: pointXOffset \n\t\t\t});\n\t\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Translate each point to the plot area coordinate system and find shape positions\n\t\t */\n\t\ttranslate: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\toptions = series.options,\n\t\t\t\tborderWidth = series.borderWidth = pick(\n\t\t\t\t\toptions.borderWidth, \n\t\t\t\t\tseries.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635\n\t\t\t\t),\n\t\t\t\tyAxis = series.yAxis,\n\t\t\t\tthreshold = options.threshold,\n\t\t\t\ttranslatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n\t\t\t\tminPointLength = pick(options.minPointLength, 5),\n\t\t\t\tmetrics = series.getColumnMetrics(),\n\t\t\t\tpointWidth = metrics.width,\n\t\t\t\tseriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n\t\t\t\tpointXOffset = series.pointXOffset = metrics.offset,\n\t\t\t\txCrisp = -(borderWidth % 2 ? 0.5 : 0),\n\t\t\t\tyCrisp = borderWidth % 2 ? 0.5 : 1;\n\n\t\t\tif (chart.renderer.isVML && chart.inverted) {\n\t\t\t\tyCrisp += 1;\n\t\t\t}\n\n\t\t\t// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n\t\t\t// columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n\t\t\t// columns (#2694).\n\t\t\tif (options.pointPadding) {\n\t\t\t\tseriesBarW = mathCeil(seriesBarW);\n\t\t\t}\n\n\t\t\tSeries.prototype.translate.apply(series);\n\n\t\t\t// Record the new values\n\t\t\teach(series.points, function (point) {\n\t\t\t\tvar yBottom = pick(point.yBottom, translatedThreshold),\n\t\t\t\t\tplotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)\n\t\t\t\t\tbarX = point.plotX + pointXOffset,\n\t\t\t\t\tbarW = seriesBarW,\n\t\t\t\t\tbarY = mathMin(plotY, yBottom),\n\t\t\t\t\tright,\n\t\t\t\t\tbottom,\n\t\t\t\t\tfromTop,\n\t\t\t\t\tbarH = mathMax(plotY, yBottom) - barY;\n\n\t\t\t\t// Handle options.minPointLength\n\t\t\t\tif (mathAbs(barH) < minPointLength) {\n\t\t\t\t\tif (minPointLength) {\n\t\t\t\t\t\tbarH = minPointLength;\n\t\t\t\t\t\tbarY =\n\t\t\t\t\t\t\tmathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n\t\t\t\t\t\t\t\tyBottom - minPointLength : // keep position\n\t\t\t\t\t\t\t\ttranslatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache for access in polar\n\t\t\t\tpoint.barX = barX;\n\t\t\t\tpoint.pointWidth = pointWidth;\n\n\t\t\t\t// Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n\t\t\t\tpoint.tooltipPos = chart.inverted ? \n\t\t\t\t\t[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : \n\t\t\t\t\t[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];\n\n\t\t\t\t// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)\n\t\t\t\tright = mathRound(barX + barW) + xCrisp;\n\t\t\t\tbarX = mathRound(barX) + xCrisp;\n\t\t\t\tbarW = right - barX;\n\n\t\t\t\tfromTop = mathAbs(barY) < 0.5;\n\t\t\t\tbottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575\n\t\t\t\tbarY = mathRound(barY) + yCrisp;\n\t\t\t\tbarH = bottom - barY;\n\n\t\t\t\t// Top edges are exceptions\n\t\t\t\tif (fromTop) {\n\t\t\t\t\tbarY -= 1;\n\t\t\t\t\tbarH += 1;\n\t\t\t\t}\n\n\t\t\t\t// Register shape type and arguments to be used in drawPoints\n\t\t\t\tpoint.shapeType = 'rect';\n\t\t\t\tpoint.shapeArgs = {\n\t\t\t\t\tx: barX,\n\t\t\t\t\ty: barY,\n\t\t\t\t\twidth: barW,\n\t\t\t\t\theight: barH\n\t\t\t\t};\n\n\t\t\t});\n\n\t\t},\n\n\t\tgetSymbol: noop,\n\t\t\n\t\t/**\n\t\t * Use a solid rectangle like the area series types\n\t\t */\n\t\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\t\t\n\t\t\n\t\t/**\n\t\t * Columns have no graph\n\t\t */\n\t\tdrawGraph: noop,\n\n\t\t/**\n\t\t * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n\t\t * apply for columns and bars. This method is inherited by scatter series.\n\t\t *\n\t\t */\n\t\tdrawPoints: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = this.chart,\n\t\t\t\toptions = series.options,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tanimationLimit = options.animationLimit || 250,\n\t\t\t\tshapeArgs,\n\t\t\t\tpointAttr;\n\n\t\t\t// draw the columns\n\t\t\teach(series.points, function (point) {\n\t\t\t\tvar plotY = point.plotY,\n\t\t\t\t\tgraphic = point.graphic,\n\t\t\t\t\tborderAttr;\n\n\t\t\t\tif (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\t\t\t\t\tshapeArgs = point.shapeArgs;\n\n\t\t\t\t\tborderAttr = defined(series.borderWidth) ? {\n\t\t\t\t\t\t'stroke-width': series.borderWidth\n\t\t\t\t\t} : {};\n\n\t\t\t\t\tpointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];\n\t\t\t\t\t\n\t\t\t\t\tif (graphic) { // update\n\t\t\t\t\t\tstop(graphic);\n\t\t\t\t\t\tgraphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoint.graphic = graphic = renderer[point.shapeType](shapeArgs)\n\t\t\t\t\t\t\t.attr(borderAttr)\n\t\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t\t.add(series.group)\n\t\t\t\t\t\t\t.shadow(options.shadow, null, options.stacking && !options.borderRadius);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (graphic) {\n\t\t\t\t\tpoint.graphic = graphic.destroy(); // #1269\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Animate the column heights one by one from zero\n\t\t * @param {Boolean} init Whether to initialize the animation or run it\n\t\t */\n\t\tanimate: function (init) {\n\t\t\tvar series = this,\n\t\t\t\tyAxis = this.yAxis,\n\t\t\t\toptions = series.options,\n\t\t\t\tinverted = this.chart.inverted,\n\t\t\t\tattr = {},\n\t\t\t\ttranslatedThreshold;\n\n\t\t\tif (hasSVG) { // VML is too slow anyway\n\t\t\t\tif (init) {\n\t\t\t\t\tattr.scaleY = 0.001;\n\t\t\t\t\ttranslatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));\n\t\t\t\t\tif (inverted) {\n\t\t\t\t\t\tattr.translateX = translatedThreshold - yAxis.len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr.translateY = translatedThreshold;\n\t\t\t\t\t}\n\t\t\t\t\tseries.group.attr(attr);\n\n\t\t\t\t} else { // run the animation\n\t\t\t\t\t\n\t\t\t\t\tattr.scaleY = 1;\n\t\t\t\t\tattr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n\t\t\t\t\tseries.group.animate(attr, series.options.animation);\n\n\t\t\t\t\t// delete this function to allow it only once\n\t\t\t\t\tseries.animate = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remove this series from the chart\n\t\t */\n\t\tremove: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart;\n\n\t\t\t// column and bar series affects other series of the same type\n\t\t\t// as they are either stacked or grouped\n\t\t\tif (chart.hasRendered) {\n\t\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\t\tif (otherSeries.type === series.type) {\n\t\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tSeries.prototype.remove.apply(series, arguments);\n\t\t}\n\t});\n\tseriesTypes.column = ColumnSeries;\n\t/**\n\t * Set the default options for bar\n\t */\n\tdefaultPlotOptions.bar = merge(defaultPlotOptions.column);\n\t/**\n\t * The Bar series class\n\t */\n\tvar BarSeries = extendClass(ColumnSeries, {\n\t\ttype: 'bar',\n\t\tinverted: true\n\t});\n\tseriesTypes.bar = BarSeries;\n\n\t/**\n\t * Set the default options for scatter\n\t */\n\tdefaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n\t\tlineWidth: 0,\n\t\tmarker: {\n\t\t\tenabled: true // Overrides auto-enabling in line series (#3647)\n\t\t},\n\t\ttooltip: {\n\t\t\theaderFormat: '<span style=\"color:{series.color}\">\\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',\n\t\t\tpointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n\t\t}\n\t});\n\n\t/**\n\t * The scatter series class\n\t */\n\tvar ScatterSeries = extendClass(Series, {\n\t\ttype: 'scatter',\n\t\tsorted: false,\n\t\trequireSorting: false,\n\t\tnoSharedTooltip: true,\n\t\ttrackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n\t\ttakeOrdinalPosition: false, // #2342\n\t\tkdDimensions: 2,\n\t\tkdComparer: 'distR',\n\t\tdrawGraph: function () {\n\t\t\tif (this.options.lineWidth) {\n\t\t\t\tSeries.prototype.drawGraph.call(this);\n\t\t\t}\n\t\t}\n\t});\n\n\tseriesTypes.scatter = ScatterSeries;\n\n\t/**\n\t * Set the default options for pie\n\t */\n\tdefaultPlotOptions.pie = merge(defaultSeriesOptions, {\n\t\tborderColor: '#FFFFFF',\n\t\tborderWidth: 1,\n\t\tcenter: [null, null],\n\t\tclip: false,\n\t\tcolorByPoint: true, // always true for pies\n\t\tdataLabels: {\n\t\t\t// align: null,\n\t\t\t// connectorWidth: 1,\n\t\t\t// connectorColor: point.color,\n\t\t\t// connectorPadding: 5,\n\t\t\tdistance: 30,\n\t\t\tenabled: true,\n\t\t\tformatter: function () { // #2945\n\t\t\t\treturn this.point.name;\n\t\t\t},\n\t\t\t// softConnector: true,\n\t\t\tx: 0\n\t\t\t// y: 0\n\t\t},\n\t\tignoreHiddenPoint: true,\n\t\t//innerSize: 0,\n\t\tlegendType: 'point',\n\t\tmarker: null, // point options are specified in the base options\n\t\tsize: null,\n\t\tshowInLegend: false,\n\t\tslicedOffset: 10,\n\t\tstates: {\n\t\t\thover: {\n\t\t\t\tbrightness: 0.1,\n\t\t\t\tshadow: false\n\t\t\t}\n\t\t},\n\t\tstickyTracking: false,\n\t\ttooltip: {\n\t\t\tfollowPointer: true\n\t\t}\n\t});\n\n\t/**\n\t * Extended point object for pies\n\t */\n\tvar PiePoint = extendClass(Point, {\n\t\t/**\n\t\t * Initiate the pie slice\n\t\t */\n\t\tinit: function () {\n\n\t\t\tPoint.prototype.init.apply(this, arguments);\n\n\t\t\tvar point = this,\n\t\t\t\ttoggleSlice;\n\n\t\t\textend(point, {\n\t\t\t\tvisible: point.visible !== false,\n\t\t\t\tname: pick(point.name, 'Slice')\n\t\t\t});\n\n\t\t\t// add event listener for select\n\t\t\ttoggleSlice = function (e) {\n\t\t\t\tpoint.slice(e.type === 'select');\n\t\t\t};\n\t\t\taddEvent(point, 'select', toggleSlice);\n\t\t\taddEvent(point, 'unselect', toggleSlice);\n\n\t\t\treturn point;\n\t\t},\n\n\t\t/**\n\t\t * Toggle the visibility of the pie slice\n\t\t * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n\t\t *    visibility is toggled\n\t\t */\n\t\tsetVisible: function (vis) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tchart = series.chart,\n\t\t\t\tdoRedraw = !series.isDirty && series.options.ignoreHiddenPoint;\n\n\t\t\t// if called without an argument, toggle visibility\n\t\t\tpoint.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n\t\t\tseries.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n\t\t\t// Show and hide associated elements\n\t\t\teach(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n\t\t\t\tif (point[key]) {\n\t\t\t\t\tpoint[key][vis ? 'show' : 'hide'](true);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (point.legendItem) {\n\t\t\t\tif (chart.hasRendered) {\n\t\t\t\t\tseries.updateTotals();\n\t\t\t\t\tchart.legend.clearItems();\n\t\t\t\t\tif (!doRedraw) {\n\t\t\t\t\t\tchart.legend.render();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchart.legend.colorizeItem(point, vis);\n\t\t\t}\n\n\t\t\t// Handle ignore hidden slices\n\t\t\tif (doRedraw) {\n\t\t\t\tseries.isDirty = true;\n\t\t\t\tchart.redraw();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set or toggle whether the slice is cut out from the pie\n\t\t * @param {Boolean} sliced When undefined, the slice state is toggled\n\t\t * @param {Boolean} redraw Whether to redraw the chart. True by default.\n\t\t */\n\t\tslice: function (sliced, redraw, animation) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tchart = series.chart,\n\t\t\t\ttranslation;\n\n\t\t\tsetAnimation(animation, chart);\n\n\t\t\t// redraw is true by default\n\t\t\tredraw = pick(redraw, true);\n\n\t\t\t// if called without an argument, toggle\n\t\t\tpoint.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n\t\t\tseries.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n\t\t\ttranslation = sliced ? point.slicedTranslation : {\n\t\t\t\ttranslateX: 0,\n\t\t\t\ttranslateY: 0\n\t\t\t};\n\n\t\t\tpoint.graphic.animate(translation);\n\t\t\t\n\t\t\tif (point.shadowGroup) {\n\t\t\t\tpoint.shadowGroup.animate(translation);\n\t\t\t}\n\n\t\t},\n\n\t\thaloPath: function (size) {\n\t\t\tvar shapeArgs = this.shapeArgs,\n\t\t\t\tchart = this.series.chart;\n\n\t\t\treturn this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n\t\t\t\tinnerR: this.shapeArgs.r,\n\t\t\t\tstart: shapeArgs.start,\n\t\t\t\tend: shapeArgs.end\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n\t * The Pie series class\n\t */\n\tvar PieSeries = {\n\t\ttype: 'pie',\n\t\tisCartesian: false,\n\t\tpointClass: PiePoint,\n\t\trequireSorting: false,\n\t\tnoSharedTooltip: true,\n\t\ttrackerGroups: ['group', 'dataLabelsGroup'],\n\t\taxisTypes: [],\n\t\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\t\tstroke: 'borderColor',\n\t\t\t'stroke-width': 'borderWidth',\n\t\t\tfill: 'color'\n\t\t},\n\n\t\t/**\n\t\t * Pies have one color each point\n\t\t */\n\t\tgetColor: noop,\n\n\t\t/**\n\t\t * Animate the pies in\n\t\t */\n\t\tanimate: function (init) {\n\t\t\tvar series = this,\n\t\t\t\tpoints = series.points,\n\t\t\t\tstartAngleRad = series.startAngleRad;\n\n\t\t\tif (!init) {\n\t\t\t\teach(points, function (point) {\n\t\t\t\t\tvar graphic = point.graphic,\n\t\t\t\t\t\targs = point.shapeArgs;\n\n\t\t\t\t\tif (graphic) {\n\t\t\t\t\t\t// start values\n\t\t\t\t\t\tgraphic.attr({\n\t\t\t\t\t\t\tr: series.center[3] / 2, // animate from inner radius (#779)\n\t\t\t\t\t\t\tstart: startAngleRad,\n\t\t\t\t\t\t\tend: startAngleRad\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// animate\n\t\t\t\t\t\tgraphic.animate({\n\t\t\t\t\t\t\tr: args.r,\n\t\t\t\t\t\t\tstart: args.start,\n\t\t\t\t\t\t\tend: args.end\n\t\t\t\t\t\t}, series.options.animation);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// delete this function to allow it only once\n\t\t\t\tseries.animate = null;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extend the basic setData method by running processData and generatePoints immediately,\n\t\t * in order to access the points from the legend.\n\t\t */\n\t\tsetData: function (data, redraw, animation, updatePoints) {\n\t\t\tSeries.prototype.setData.call(this, data, false, animation, updatePoints);\n\t\t\tthis.processData();\n\t\t\tthis.generatePoints();\n\t\t\tif (pick(redraw, true)) {\n\t\t\t\tthis.chart.redraw(animation);\n\t\t\t} \n\t\t},\n\n\t\t/**\n\t\t * Recompute total chart sum and update percentages of points.\n\t\t */\n\t\tupdateTotals: function () {\n\t\t\tvar i,\n\t\t\t\ttotal = 0,\n\t\t\t\tpoints,\n\t\t\t\tlen,\n\t\t\t\tpoint,\n\t\t\t\tignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n\t\t\t// Populate local vars\n\t\t\tpoints = this.points;\n\t\t\tlen = points.length;\n\t\t\t\n\t\t\t// Get the total sum\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tpoint = points[i];\n\n\t\t\t\t// Disallow negative values (#1530, #3623)\n\t\t\t\tif (point.y < 0) {\n\t\t\t\t\tpoint.y = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttotal += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n\t\t\t}\n\t\t\tthis.total = total;\n\n\t\t\t// Set each point's properties\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tpoint = points[i];\n\t\t\t\t//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;\n\t\t\t\tpoint.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n\t\t\t\tpoint.total = total;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extend the generatePoints method by adding total and percentage properties to each point\n\t\t */\n\t\tgeneratePoints: function () {\n\t\t\tSeries.prototype.generatePoints.call(this);\n\t\t\tthis.updateTotals();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Do translation for pie slices\n\t\t */\n\t\ttranslate: function (positions) {\n\t\t\tthis.generatePoints();\n\t\t\t\n\t\t\tvar series = this,\n\t\t\t\tcumulative = 0,\n\t\t\t\tprecision = 1000, // issue #172\n\t\t\t\toptions = series.options,\n\t\t\t\tslicedOffset = options.slicedOffset,\n\t\t\t\tconnectorOffset = slicedOffset + options.borderWidth,\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tangle,\n\t\t\t\tstartAngle = options.startAngle || 0,\n\t\t\t\tstartAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),\n\t\t\t\tendAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n\t\t\t\tcirc = endAngleRad - startAngleRad, //2 * mathPI,\n\t\t\t\tpoints = series.points,\n\t\t\t\tradiusX, // the x component of the radius vector for a given point\n\t\t\t\tradiusY,\n\t\t\t\tlabelDistance = options.dataLabels.distance,\n\t\t\t\tignoreHiddenPoint = options.ignoreHiddenPoint,\n\t\t\t\ti,\n\t\t\t\tlen = points.length,\n\t\t\t\tpoint;\n\n\t\t\t// Get positions - either an integer or a percentage string must be given.\n\t\t\t// If positions are passed as a parameter, we're in a recursive loop for adjusting\n\t\t\t// space for data labels.\n\t\t\tif (!positions) {\n\t\t\t\tseries.center = positions = series.getCenter();\n\t\t\t}\n\n\t\t\t// utility for getting the x value from a given y, used for anticollision logic in data labels\n\t\t\tseries.getX = function (y, left) {\n\n\t\t\t\tangle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n\t\t\t\treturn positions[0] +\n\t\t\t\t\t(left ? -1 : 1) *\n\t\t\t\t\t(mathCos(angle) * (positions[2] / 2 + labelDistance));\n\t\t\t};\n\n\t\t\t// Calculate the geometry for each point\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\n\t\t\t\tpoint = points[i];\n\t\t\t\t\n\t\t\t\t// set start and end angle\n\t\t\t\tstart = startAngleRad + (cumulative * circ);\n\t\t\t\tif (!ignoreHiddenPoint || point.visible) {\n\t\t\t\t\tcumulative += point.percentage / 100;\n\t\t\t\t}\n\t\t\t\tend = startAngleRad + (cumulative * circ);\n\n\t\t\t\t// set the shape\n\t\t\t\tpoint.shapeType = 'arc';\n\t\t\t\tpoint.shapeArgs = {\n\t\t\t\t\tx: positions[0],\n\t\t\t\t\ty: positions[1],\n\t\t\t\t\tr: positions[2] / 2,\n\t\t\t\t\tinnerR: positions[3] / 2,\n\t\t\t\t\tstart: mathRound(start * precision) / precision,\n\t\t\t\t\tend: mathRound(end * precision) / precision\n\t\t\t\t};\n\n\t\t\t\t// The angle must stay within -90 and 270 (#2645)\n\t\t\t\tangle = (end + start) / 2;\n\t\t\t\tif (angle > 1.5 * mathPI) {\n\t\t\t\t\tangle -= 2 * mathPI;\n\t\t\t\t} else if (angle < -mathPI / 2) {\n\t\t\t\t\tangle += 2 * mathPI;\n\t\t\t\t}\n\n\t\t\t\t// Center for the sliced out slice\n\t\t\t\tpoint.slicedTranslation = {\n\t\t\t\t\ttranslateX: mathRound(mathCos(angle) * slicedOffset),\n\t\t\t\t\ttranslateY: mathRound(mathSin(angle) * slicedOffset)\n\t\t\t\t};\n\n\t\t\t\t// set the anchor point for tooltips\n\t\t\t\tradiusX = mathCos(angle) * positions[2] / 2;\n\t\t\t\tradiusY = mathSin(angle) * positions[2] / 2;\n\t\t\t\tpoint.tooltipPos = [\n\t\t\t\t\tpositions[0] + radiusX * 0.7,\n\t\t\t\t\tpositions[1] + radiusY * 0.7\n\t\t\t\t];\n\t\t\t\t\n\t\t\t\tpoint.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;\n\t\t\t\tpoint.angle = angle;\n\n\t\t\t\t// set the anchor point for data labels\n\t\t\t\tconnectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678\n\t\t\t\tpoint.labelPos = [\n\t\t\t\t\tpositions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n\t\t\t\t\tpositions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n\t\t\t\t\tpositions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n\t\t\t\t\tpositions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n\t\t\t\t\tpositions[0] + radiusX, // landing point for connector\n\t\t\t\t\tpositions[1] + radiusY, // a/a\n\t\t\t\t\tlabelDistance < 0 ? // alignment\n\t\t\t\t\t\t'center' :\n\t\t\t\t\t\tpoint.half ? 'right' : 'left', // alignment\n\t\t\t\t\tangle // center angle\n\t\t\t\t];\n\n\t\t\t}\n\t\t},\n\t\t\n\t\tdrawGraph: null,\n\n\t\t/**\n\t\t * Draw the data points\n\t\t */\n\t\tdrawPoints: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tgroupTranslation,\n\t\t\t\t//center,\n\t\t\t\tgraphic,\n\t\t\t\t//group,\n\t\t\t\tshadow = series.options.shadow,\n\t\t\t\tshadowGroup,\n\t\t\t\tshapeArgs;\n\n\t\t\tif (shadow && !series.shadowGroup) {\n\t\t\t\tseries.shadowGroup = renderer.g('shadow')\n\t\t\t\t\t.add(series.group);\n\t\t\t}\n\n\t\t\t// draw the slices\n\t\t\teach(series.points, function (point) {\n\t\t\t\tgraphic = point.graphic;\n\t\t\t\tshapeArgs = point.shapeArgs;\n\t\t\t\tshadowGroup = point.shadowGroup;\n\n\t\t\t\t// put the shadow behind all points\n\t\t\t\tif (shadow && !shadowGroup) {\n\t\t\t\t\tshadowGroup = point.shadowGroup = renderer.g('shadow')\n\t\t\t\t\t\t.add(series.shadowGroup);\n\t\t\t\t}\n\n\t\t\t\t// if the point is sliced, use special translation, else use plot area traslation\n\t\t\t\tgroupTranslation = point.sliced ? point.slicedTranslation : {\n\t\t\t\t\ttranslateX: 0,\n\t\t\t\t\ttranslateY: 0\n\t\t\t\t};\n\n\t\t\t\t//group.translate(groupTranslation[0], groupTranslation[1]);\n\t\t\t\tif (shadowGroup) {\n\t\t\t\t\tshadowGroup.attr(groupTranslation);\n\t\t\t\t}\n\n\t\t\t\t// draw the slice\n\t\t\t\tif (graphic) {\n\t\t\t\t\tgraphic.animate(extend(shapeArgs, groupTranslation));\n\t\t\t\t} else {\n\t\t\t\t\tpoint.graphic = graphic = renderer[point.shapeType](shapeArgs)\n\t\t\t\t\t\t.setRadialReference(series.center)\n\t\t\t\t\t\t.attr(\n\t\t\t\t\t\t\tpoint.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr({ \n\t\t\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t\t\t\t//zIndex: 1 // #2722 (reversed)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.attr(groupTranslation)\n\t\t\t\t\t\t.add(series.group)\n\t\t\t\t\t\t.shadow(shadow, shadowGroup);\t\n\t\t\t\t}\n\n\t\t\t\t// detect point specific visibility (#2430)\n\t\t\t\tif (point.visible !== undefined) {\n\t\t\t\t\tpoint.setVisible(point.visible);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t},\n\n\n\t\tsearchPoint: noop,\n\n\t\t/**\n\t\t * Utility for sorting data labels\n\t\t */\n\t\tsortByAngle: function (points, sign) {\n\t\t\tpoints.sort(function (a, b) {\n\t\t\t\treturn a.angle !== undefined && (b.angle - a.angle) * sign;\n\t\t\t});\n\t\t},\t\t\n\n\t\t/**\n\t\t * Use a simple symbol from LegendSymbolMixin\n\t\t */\n\t\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\t\t/**\n\t\t * Use the getCenter method from drawLegendSymbol\n\t\t */\n\t\tgetCenter: CenteredSeriesMixin.getCenter,\n\n\t\t/**\n\t\t * Pies don't have point marker symbols\n\t\t */\n\t\tgetSymbol: noop\n\n\t};\n\tPieSeries = extendClass(Series, PieSeries);\n\tseriesTypes.pie = PieSeries;\n\n\t/**\n\t * Draw the data labels\n\t */\n\tSeries.prototype.drawDataLabels = function () {\n\n\t\tvar series = this,\n\t\t\tseriesOptions = series.options,\n\t\t\tcursor = seriesOptions.cursor,\n\t\t\toptions = seriesOptions.dataLabels,\n\t\t\tpoints = series.points,\n\t\t\tpointOptions,\n\t\t\tgeneralOptions,\n\t\t\thasRendered = series.hasRendered || 0,\n\t\t\tstr,\n\t\t\tdataLabelsGroup,\n\t\t\trenderer = series.chart.renderer;\n\n\t\tif (options.enabled || series._hasPointLabels) {\n\n\t\t\t// Process default alignment of data labels for columns\n\t\t\tif (series.dlProcessOptions) {\n\t\t\t\tseries.dlProcessOptions(options);\n\t\t\t}\n\n\t\t\t// Create a separate group for the data labels to avoid rotation\n\t\t\tdataLabelsGroup = series.plotGroup(\n\t\t\t\t'dataLabelsGroup',\n\t\t\t\t'data-labels',\n\t\t\t\toptions.defer ? HIDDEN : VISIBLE,\n\t\t\t\toptions.zIndex || 6\n\t\t\t);\n\n\t\t\tif (pick(options.defer, true)) {\n\t\t\t\tdataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n\t\t\t\tif (!hasRendered) {\n\t\t\t\t\taddEvent(series, 'afterAnimate', function () {\n\t\t\t\t\t\tif (series.visible) { // #3023, #3024\n\t\t\t\t\t\t\tdataLabelsGroup.show();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Make the labels for each point\n\t\t\tgeneralOptions = options;\n\t\t\teach(points, function (point) {\n\n\t\t\t\tvar enabled,\n\t\t\t\t\tdataLabel = point.dataLabel,\n\t\t\t\t\tlabelConfig,\n\t\t\t\t\tattr,\n\t\t\t\t\tname,\n\t\t\t\t\trotation,\n\t\t\t\t\tconnector = point.connector,\n\t\t\t\t\tisNew = true,\n\t\t\t\t\tstyle,\n\t\t\t\t\tmoreStyle = {};\n\n\t\t\t\t// Determine if each data label is enabled\n\t\t\t\tpointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n\t\t\t\tenabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282\n\n\n\t\t\t\t// If the point is outside the plot area, destroy it. #678, #820\n\t\t\t\tif (dataLabel && !enabled) {\n\t\t\t\t\tpoint.dataLabel = dataLabel.destroy();\n\n\t\t\t\t// Individual labels are disabled if the are explicitly disabled\n\t\t\t\t// in the point options, or if they fall outside the plot area.\n\t\t\t\t} else if (enabled) {\n\n\t\t\t\t\t// Create individual options structure that can be extended without\n\t\t\t\t\t// affecting others\n\t\t\t\t\toptions = merge(generalOptions, pointOptions);\n\t\t\t\t\tstyle = options.style;\n\n\t\t\t\t\trotation = options.rotation;\n\n\t\t\t\t\t// Get the string\n\t\t\t\t\tlabelConfig = point.getLabelConfig();\n\t\t\t\t\tstr = options.format ?\n\t\t\t\t\t\tformat(options.format, labelConfig) :\n\t\t\t\t\t\toptions.formatter.call(labelConfig, options);\n\n\t\t\t\t\t// Determine the color\n\t\t\t\t\tstyle.color = pick(options.color, style.color, series.color, 'black');\n\n\n\t\t\t\t\t// update existing label\n\t\t\t\t\tif (dataLabel) {\n\n\t\t\t\t\t\tif (defined(str)) {\n\t\t\t\t\t\t\tdataLabel\n\t\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\t\ttext: str\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tisNew = false;\n\n\t\t\t\t\t\t} else { // #1437 - the label is shown conditionally\n\t\t\t\t\t\t\tpoint.dataLabel = dataLabel = dataLabel.destroy();\n\t\t\t\t\t\t\tif (connector) {\n\t\t\t\t\t\t\t\tpoint.connector = connector.destroy();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// create new label\n\t\t\t\t\t} else if (defined(str)) {\n\t\t\t\t\t\tattr = {\n\t\t\t\t\t\t\t//align: align,\n\t\t\t\t\t\t\tfill: options.backgroundColor,\n\t\t\t\t\t\t\tstroke: options.borderColor,\n\t\t\t\t\t\t\t'stroke-width': options.borderWidth,\n\t\t\t\t\t\t\tr: options.borderRadius || 0,\n\t\t\t\t\t\t\trotation: rotation,\n\t\t\t\t\t\t\tpadding: options.padding,\n\t\t\t\t\t\t\tzIndex: 1\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get automated contrast color\n\t\t\t\t\t\tif (style.color === 'contrast') {\n\t\t\t\t\t\t\tmoreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? \n\t\t\t\t\t\t\t\trenderer.getContrast(point.color || series.color) : \n\t\t\t\t\t\t\t\t'#000000';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\t\tmoreStyle.cursor = cursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t// Remove unused attributes (#947)\n\t\t\t\t\t\tfor (name in attr) {\n\t\t\t\t\t\t\tif (attr[name] === UNDEFINED) {\n\t\t\t\t\t\t\t\tdelete attr[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t-999,\n\t\t\t\t\t\t\toptions.shape,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\toptions.useHTML\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr(attr)\n\t\t\t\t\t\t.css(extend(style, moreStyle))\n\t\t\t\t\t\t.add(dataLabelsGroup)\n\t\t\t\t\t\t.shadow(options.shadow);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dataLabel) {\n\t\t\t\t\t\t// Now the data label is created and placed at 0,0, so we need to align it\n\t\t\t\t\t\tseries.alignDataLabel(point, dataLabel, options, null, isNew);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Align each individual data label\n\t */\n\tSeries.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n\t\tvar chart = this.chart,\n\t\t\tinverted = chart.inverted,\n\t\t\tplotX = pick(point.plotX, -999),\n\t\t\tplotY = pick(point.plotY, -999),\n\t\t\tbBox = dataLabel.getBBox(),\n\t\t\tbaseline = chart.renderer.fontMetrics(options.style.fontSize).b,\n\t\t\trotCorr, // rotation correction\n\t\t\t// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n\t\t\tvisible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||\n\t\t\t\t(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n\t\t\talignAttr; // the final position;\n\n\t\tif (visible) {\n\n\t\t\t// The alignment box is a singular point\n\t\t\talignTo = extend({\n\t\t\t\tx: inverted ? chart.plotWidth - plotY : plotX,\n\t\t\t\ty: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t}, alignTo);\n\n\t\t\t// Add the text size for alignment calculation\n\t\t\textend(options, {\n\t\t\t\twidth: bBox.width,\n\t\t\t\theight: bBox.height\n\t\t\t});\n\n\t\t\t// Allow a hook for changing alignment in the last moment, then do the alignment\n\t\t\tif (options.rotation) { // Fancy box alignment isn't supported for rotated text\n\t\t\t\trotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723\n\t\t\t\tdataLabel[isNew ? 'attr' : 'animate']({\n\t\t\t\t\t\tx: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n\t\t\t\t\t\ty: alignTo.y + options.y + alignTo.height / 2\n\t\t\t\t\t})\n\t\t\t\t\t.attr({ // #3003\n\t\t\t\t\t\talign: options.align\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdataLabel.align(options, null, alignTo);\n\t\t\t\talignAttr = dataLabel.alignAttr;\n\n\t\t\t\t// Handle justify or crop\n\t\t\t\tif (pick(options.overflow, 'justify') === 'justify') {\n\t\t\t\t\tthis.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n\n\t\t\t\t} else if (pick(options.crop, true)) {\n\t\t\t\t\t// Now check that the data label is within the plot area\n\t\t\t\t\tvisible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n\n\t\t\t\t}\n\n\t\t\t\t// When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n\t\t\t\tif (options.shape) {\n\t\t\t\t\tdataLabel.attr({\n\t\t\t\t\t\tanchorX: point.plotX,\n\t\t\t\t\t\tanchorY: point.plotY\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// Show or hide based on the final aligned position\n\t\tif (!visible) {\n\t\t\tdataLabel.attr({ y: -999 });\n\t\t\tdataLabel.placed = false; // don't animate back in\n\t\t}\n\n\t};\n\n\t/**\n\t * If data labels fall partly outside the plot area, align them back in, in a way that\n\t * doesn't hide the point.\n\t */\n\tSeries.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n\t\tvar chart = this.chart,\n\t\t\talign = options.align,\n\t\t\tverticalAlign = options.verticalAlign,\n\t\t\toff,\n\t\t\tjustified,\n\t\t\tpadding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n\t\t// Off left\n\t\toff = alignAttr.x + padding;\n\t\tif (off < 0) {\n\t\t\tif (align === 'right') {\n\t\t\t\toptions.align = 'left';\n\t\t\t} else {\n\t\t\t\toptions.x = -off;\n\t\t\t}\n\t\t\tjustified = true;\n\t\t}\n\n\t\t// Off right\n\t\toff = alignAttr.x + bBox.width - padding;\n\t\tif (off > chart.plotWidth) {\n\t\t\tif (align === 'left') {\n\t\t\t\toptions.align = 'right';\n\t\t\t} else {\n\t\t\t\toptions.x = chart.plotWidth - off;\n\t\t\t}\n\t\t\tjustified = true;\n\t\t}\n\n\t\t// Off top\n\t\toff = alignAttr.y + padding;\n\t\tif (off < 0) {\n\t\t\tif (verticalAlign === 'bottom') {\n\t\t\t\toptions.verticalAlign = 'top';\n\t\t\t} else {\n\t\t\t\toptions.y = -off;\n\t\t\t}\n\t\t\tjustified = true;\n\t\t}\n\n\t\t// Off bottom\n\t\toff = alignAttr.y + bBox.height - padding;\n\t\tif (off > chart.plotHeight) {\n\t\t\tif (verticalAlign === 'top') {\n\t\t\t\toptions.verticalAlign = 'bottom';\n\t\t\t} else {\n\t\t\t\toptions.y = chart.plotHeight - off;\n\t\t\t}\n\t\t\tjustified = true;\n\t\t}\n\n\t\tif (justified) {\n\t\t\tdataLabel.placed = !isNew;\n\t\t\tdataLabel.align(options, null, alignTo);\n\t\t}\n\t};\n\n\t/**\n\t * Override the base drawDataLabels method by pie specific functionality\n\t */\n\tif (seriesTypes.pie) {\n\t\tseriesTypes.pie.prototype.drawDataLabels = function () {\n\t\t\tvar series = this,\n\t\t\t\tdata = series.data,\n\t\t\t\tpoint,\n\t\t\t\tchart = series.chart,\n\t\t\t\toptions = series.options.dataLabels,\n\t\t\t\tconnectorPadding = pick(options.connectorPadding, 10),\n\t\t\t\tconnectorWidth = pick(options.connectorWidth, 1),\n\t\t\t\tplotWidth = chart.plotWidth,\n\t\t\t\tplotHeight = chart.plotHeight,\n\t\t\t\tconnector,\n\t\t\t\tconnectorPath,\n\t\t\t\tsoftConnector = pick(options.softConnector, true),\n\t\t\t\tdistanceOption = options.distance,\n\t\t\t\tseriesCenter = series.center,\n\t\t\t\tradius = seriesCenter[2] / 2,\n\t\t\t\tcenterY = seriesCenter[1],\n\t\t\t\toutside = distanceOption > 0,\n\t\t\t\tdataLabel,\n\t\t\t\tdataLabelWidth,\n\t\t\t\tlabelPos,\n\t\t\t\tlabelHeight,\n\t\t\t\thalves = [// divide the points into right and left halves for anti collision\n\t\t\t\t\t[], // right\n\t\t\t\t\t[]  // left\n\t\t\t\t],\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tvisibility,\n\t\t\t\trankArr,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\toverflow = [0, 0, 0, 0], // top, right, bottom, left\n\t\t\t\tsort = function (a, b) {\n\t\t\t\t\treturn b.y - a.y;\n\t\t\t\t};\n\n\t\t\t// get out if not enabled\n\t\t\tif (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// run parent method\n\t\t\tSeries.prototype.drawDataLabels.apply(series);\n\n\t\t\t// arrange points for detection collision\n\t\t\teach(data, function (point) {\n\t\t\t\tif (point.dataLabel && point.visible) { // #407, #2510\n\t\t\t\t\thalves[point.half].push(point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/* Loop over the points in each half, starting from the top and bottom\n\t\t\t * of the pie to detect overlapping labels.\n\t\t\t */\n\t\t\ti = 2;\n\t\t\twhile (i--) {\n\n\t\t\t\tvar slots = [],\n\t\t\t\t\tslotsLength,\n\t\t\t\t\tusedSlots = [],\n\t\t\t\t\tpoints = halves[i],\n\t\t\t\t\tpos,\n\t\t\t\t\tbottom,\n\t\t\t\t\tlength = points.length,\n\t\t\t\t\tslotIndex;\n\n\t\t\t\tif (!length) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Sort by angle\n\t\t\t\tseries.sortByAngle(points, i - 0.5);\n\n\t\t\t\t// Assume equal label heights on either hemisphere (#2630)\n\t\t\t\tj = labelHeight = 0;\n\t\t\t\twhile (!labelHeight && points[j]) { // #1569\n\t\t\t\t\tlabelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\t// Only do anti-collision when we are outside the pie and have connectors (#856)\n\t\t\t\tif (distanceOption > 0) {\n\n\t\t\t\t\t// Build the slots\n\t\t\t\t\tbottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);\n\t\t\t\t\tfor (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n\t\t\t\t\t\tslots.push(pos);\n\t\t\t\t\t}\n\t\t\t\t\tslotsLength = slots.length;\n\n\n\t\t\t\t\t/* Visualize the slots\n\t\t\t\t\tif (!series.slotElements) {\n\t\t\t\t\t\tseries.slotElements = [];\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 1) {\n\t\t\t\t\t\tseries.slotElements.forEach(function (elem) {\n\t\t\t\t\t\t\telem.destroy();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tseries.slotElements.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tslots.forEach(function (pos, no) {\n\t\t\t\t\t\tvar slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n\t\t\t\t\t\t\tslotY = pos + chart.plotTop;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!isNaN(slotX)) {\n\t\t\t\t\t\t\tseries.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n\t\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\t\t\t\t\tstroke: 'silver',\n\t\t\t\t\t\t\t\t\tfill: 'rgba(0,0,255,0.1)'\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.add());\n\t\t\t\t\t\t\tseries.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n\t\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\t\tfill: 'silver'\n\t\t\t\t\t\t\t\t}).add());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t// */\n\n\t\t\t\t\t// if there are more values than available slots, remove lowest values\n\t\t\t\t\tif (length > slotsLength) {\n\t\t\t\t\t\t// create an array for sorting and ranking the points within each quarter\n\t\t\t\t\t\trankArr = [].concat(points);\n\t\t\t\t\t\trankArr.sort(sort);\n\t\t\t\t\t\tj = length;\n\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\trankArr[j].rank = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj = length;\n\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\tif (points[j].rank >= slotsLength) {\n\t\t\t\t\t\t\t\tpoints.splice(j, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = points.length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The label goes to the nearest open slot, but not closer to the edge than\n\t\t\t\t\t// the label's index.\n\t\t\t\t\tfor (j = 0; j < length; j++) {\n\n\t\t\t\t\t\tpoint = points[j];\n\t\t\t\t\t\tlabelPos = point.labelPos;\n\n\t\t\t\t\t\tvar closest = 9999,\n\t\t\t\t\t\t\tdistance,\n\t\t\t\t\t\t\tslotI;\n\n\t\t\t\t\t\t// find the closest slot index\n\t\t\t\t\t\tfor (slotI = 0; slotI < slotsLength; slotI++) {\n\t\t\t\t\t\t\tdistance = mathAbs(slots[slotI] - labelPos[1]);\n\t\t\t\t\t\t\tif (distance < closest) {\n\t\t\t\t\t\t\t\tclosest = distance;\n\t\t\t\t\t\t\t\tslotIndex = slotI;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if that slot index is closer to the edges of the slots, move it\n\t\t\t\t\t\t// to the closest appropriate slot\n\t\t\t\t\t\tif (slotIndex < j && slots[j] !== null) { // cluster at the top\n\t\t\t\t\t\t\tslotIndex = j;\n\t\t\t\t\t\t} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n\t\t\t\t\t\t\tslotIndex = slotsLength - length + j;\n\t\t\t\t\t\t\twhile (slots[slotIndex] === null) { // make sure it is not taken\n\t\t\t\t\t\t\t\tslotIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Slot is taken, find next free slot below. In the next run, the next slice will find the\n\t\t\t\t\t\t\t// slot above these, because it is the closest one\n\t\t\t\t\t\t\twhile (slots[slotIndex] === null) { // make sure it is not taken\n\t\t\t\t\t\t\t\tslotIndex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tusedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n\t\t\t\t\t\tslots[slotIndex] = null; // mark as taken\n\t\t\t\t\t}\n\t\t\t\t\t// sort them in order to fill in from the top\n\t\t\t\t\tusedSlots.sort(sort);\n\t\t\t\t}\n\n\t\t\t\t// now the used slots are sorted, fill them up sequentially\n\t\t\t\tfor (j = 0; j < length; j++) {\n\n\t\t\t\t\tvar slot, naturalY;\n\n\t\t\t\t\tpoint = points[j];\n\t\t\t\t\tlabelPos = point.labelPos;\n\t\t\t\t\tdataLabel = point.dataLabel;\n\t\t\t\t\tvisibility = point.visible === false ? HIDDEN : VISIBLE;\n\t\t\t\t\tnaturalY = labelPos[1];\n\n\t\t\t\t\tif (distanceOption > 0) {\n\t\t\t\t\t\tslot = usedSlots.pop();\n\t\t\t\t\t\tslotIndex = slot.i;\n\n\t\t\t\t\t\t// if the slot next to currrent slot is free, the y value is allowed\n\t\t\t\t\t\t// to fall back to the natural position\n\t\t\t\t\t\ty = slot.y;\n\t\t\t\t\t\tif ((naturalY > y && slots[slotIndex + 1] !== null) ||\n\t\t\t\t\t\t\t\t(naturalY < y &&  slots[slotIndex - 1] !== null)) {\n\t\t\t\t\t\t\ty = mathMin(mathMax(0, naturalY), chart.plotHeight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = naturalY;\n\t\t\t\t\t}\n\n\t\t\t\t\t// get the x - use the natural x position for first and last slot, to prevent the top\n\t\t\t\t\t// and botton slice connectors from touching each other on either side\n\t\t\t\t\tx = options.justify ?\n\t\t\t\t\t\tseriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n\t\t\t\t\t\tseries.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n\t\t\t\t\t// Record the placement and visibility\n\t\t\t\t\tdataLabel._attr = {\n\t\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\t\talign: labelPos[6]\n\t\t\t\t\t};\n\t\t\t\t\tdataLabel._pos = {\n\t\t\t\t\t\tx: x + options.x +\n\t\t\t\t\t\t\t({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n\t\t\t\t\t\ty: y + options.y - 10 // 10 is for the baseline (label vs text)\n\t\t\t\t\t};\n\t\t\t\t\tdataLabel.connX = x;\n\t\t\t\t\tdataLabel.connY = y;\n\n\n\t\t\t\t\t// Detect overflowing data labels\n\t\t\t\t\tif (this.options.size === null) {\n\t\t\t\t\t\tdataLabelWidth = dataLabel.width;\n\t\t\t\t\t\t// Overflow left\n\t\t\t\t\t\tif (x - dataLabelWidth < connectorPadding) {\n\t\t\t\t\t\t\toverflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n\t\t\t\t\t\t// Overflow right\n\t\t\t\t\t\t} else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n\t\t\t\t\t\t\toverflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Overflow top\n\t\t\t\t\t\tif (y - labelHeight / 2 < 0) {\n\t\t\t\t\t\t\toverflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);\n\n\t\t\t\t\t\t// Overflow left\n\t\t\t\t\t\t} else if (y + labelHeight / 2 > plotHeight) {\n\t\t\t\t\t\t\toverflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // for each point\n\t\t\t} // for each half\n\n\t\t\t// Do not apply the final placement and draw the connectors until we have verified\n\t\t\t// that labels are not spilling over.\n\t\t\tif (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n\t\t\t\t// Place the labels in the final position\n\t\t\t\tthis.placeDataLabels();\n\n\t\t\t\t// Draw the connectors\n\t\t\t\tif (outside && connectorWidth) {\n\t\t\t\t\teach(this.points, function (point) {\n\t\t\t\t\t\tconnector = point.connector;\n\t\t\t\t\t\tlabelPos = point.labelPos;\n\t\t\t\t\t\tdataLabel = point.dataLabel;\n\n\t\t\t\t\t\tif (dataLabel && dataLabel._pos) {\n\t\t\t\t\t\t\tvisibility = dataLabel._attr.visibility;\n\t\t\t\t\t\t\tx = dataLabel.connX;\n\t\t\t\t\t\t\ty = dataLabel.connY;\n\t\t\t\t\t\t\tconnectorPath = softConnector ? [\n\t\t\t\t\t\t\t\tM,\n\t\t\t\t\t\t\t\tx + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n\t\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\t\tx, y, // first break, next to the label\n\t\t\t\t\t\t\t\t2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n\t\t\t\t\t\t\t\tlabelPos[2], labelPos[3], // second break\n\t\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\t\tlabelPos[4], labelPos[5] // base\n\t\t\t\t\t\t\t] : [\n\t\t\t\t\t\t\t\tM,\n\t\t\t\t\t\t\t\tx + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n\t\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\t\tlabelPos[2], labelPos[3], // second break\n\t\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\t\tlabelPos[4], labelPos[5] // base\n\t\t\t\t\t\t\t];\n\n\t\t\t\t\t\t\tif (connector) {\n\t\t\t\t\t\t\t\tconnector.animate({ d: connectorPath });\n\t\t\t\t\t\t\t\tconnector.attr('visibility', visibility);\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpoint.connector = connector = series.chart.renderer.path(connectorPath).attr({\n\t\t\t\t\t\t\t\t\t'stroke-width': connectorWidth,\n\t\t\t\t\t\t\t\t\tstroke: options.connectorColor || point.color || '#606060',\n\t\t\t\t\t\t\t\t\tvisibility: visibility\n\t\t\t\t\t\t\t\t\t//zIndex: 0 // #2722 (reversed)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.add(series.dataLabelsGroup);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (connector) {\n\t\t\t\t\t\t\tpoint.connector = connector.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Perform the final placement of the data labels after we have verified that they\n\t\t * fall within the plot area.\n\t\t */\n\t\tseriesTypes.pie.prototype.placeDataLabels = function () {\n\t\t\teach(this.points, function (point) {\n\t\t\t\tvar dataLabel = point.dataLabel,\n\t\t\t\t\t_pos;\n\n\t\t\t\tif (dataLabel) {\n\t\t\t\t\t_pos = dataLabel._pos;\n\t\t\t\t\tif (_pos) {\n\t\t\t\t\t\tdataLabel.attr(dataLabel._attr);\n\t\t\t\t\t\tdataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n\t\t\t\t\t\tdataLabel.moved = true;\n\t\t\t\t\t} else if (dataLabel) {\n\t\t\t\t\t\tdataLabel.attr({ y: -999 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tseriesTypes.pie.prototype.alignDataLabel =  noop;\n\n\t\t/**\n\t\t * Verify whether the data labels are allowed to draw, or we should run more translation and data\n\t\t * label positioning to keep them inside the plot area. Returns true when data labels are ready\n\t\t * to draw.\n\t\t */\n\t\tseriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n\t\t\tvar center = this.center,\n\t\t\t\toptions = this.options,\n\t\t\t\tcenterOption = options.center,\n\t\t\t\tminSize = options.minSize || 80,\n\t\t\t\tnewSize = minSize,\n\t\t\t\tret;\n\n\t\t\t// Handle horizontal size and center\n\t\t\tif (centerOption[0] !== null) { // Fixed center\n\t\t\t\tnewSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);\n\n\t\t\t} else { // Auto center\n\t\t\t\tnewSize = mathMax(\n\t\t\t\t\tcenter[2] - overflow[1] - overflow[3], // horizontal overflow\n\t\t\t\t\tminSize\n\t\t\t\t);\n\t\t\t\tcenter[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n\t\t\t}\n\n\t\t\t// Handle vertical size and center\n\t\t\tif (centerOption[1] !== null) { // Fixed center\n\t\t\t\tnewSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);\n\n\t\t\t} else { // Auto center\n\t\t\t\tnewSize = mathMax(\n\t\t\t\t\tmathMin(\n\t\t\t\t\t\tnewSize,\n\t\t\t\t\t\tcenter[2] - overflow[0] - overflow[2] // vertical overflow\n\t\t\t\t\t),\n\t\t\t\t\tminSize\n\t\t\t\t);\n\t\t\t\tcenter[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n\t\t\t}\n\n\t\t\t// If the size must be decreased, we need to run translate and drawDataLabels again\n\t\t\tif (newSize < center[2]) {\n\t\t\t\tcenter[2] = newSize;\n\t\t\t\tthis.translate(center);\n\t\t\t\teach(this.points, function (point) {\n\t\t\t\t\tif (point.dataLabel) {\n\t\t\t\t\t\tpoint.dataLabel._pos = null; // reset\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (this.drawDataLabels) {\n\t\t\t\t\tthis.drawDataLabels();\n\t\t\t\t}\n\t\t\t// Else, return true to indicate that the pie and its labels is within the plot area\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t}\n\n\tif (seriesTypes.column) {\n\n\t\t/**\n\t\t * Override the basic data label alignment by adjusting for the position of the column\n\t\t */\n\t\tseriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n\t\t\tvar inverted = this.chart.inverted,\n\t\t\t\tseries = point.series,\n\t\t\t\tdlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n\t\t\t\tbelow = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),\n\t\t\t\tinside = pick(options.inside, !!this.options.stacking); // draw it inside the box?\n\n\t\t\t// Align to the column itself, or the top of it\n\t\t\tif (dlBox) { // Area range uses this method but not alignTo\n\t\t\t\talignTo = merge(dlBox);\n\n\t\t\t\tif (inverted) {\n\t\t\t\t\talignTo = {\n\t\t\t\t\t\tx: series.yAxis.len - alignTo.y - alignTo.height,\n\t\t\t\t\t\ty: series.xAxis.len - alignTo.x - alignTo.width,\n\t\t\t\t\t\twidth: alignTo.height,\n\t\t\t\t\t\theight: alignTo.width\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Compute the alignment box\n\t\t\t\tif (!inside) {\n\t\t\t\t\tif (inverted) {\n\t\t\t\t\t\talignTo.x += below ? 0 : alignTo.width;\n\t\t\t\t\t\talignTo.width = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\talignTo.y += below ? alignTo.height : 0;\n\t\t\t\t\t\talignTo.height = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// When alignment is undefined (typically columns and bars), display the individual\n\t\t\t// point below or above the point depending on the threshold\n\t\t\toptions.align = pick(\n\t\t\t\toptions.align,\n\t\t\t\t!inverted || inside ? 'center' : below ? 'right' : 'left'\n\t\t\t);\n\t\t\toptions.verticalAlign = pick(\n\t\t\t\toptions.verticalAlign,\n\t\t\t\tinverted || inside ? 'middle' : below ? 'top' : 'bottom'\n\t\t\t);\n\n\t\t\t// Call the parent method\n\t\t\tSeries.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n\t\t};\n\t}\n\n\n\n\t/**\n\t * Highcharts JS v4.1.4 (2015-03-10)\n\t * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.\n\t *\n\t * (c) 2010-2014 Torstein Honsi\n\t *\n\t * License: www.highcharts.com/license\n\t */\n\n\t/*global Highcharts, HighchartsAdapter */\n\t(function (H) {\n\t\tvar Chart = H.Chart,\n\t\t\teach = H.each,\n\t\t\taddEvent = HighchartsAdapter.addEvent;\n\n\t\t// Collect potensial overlapping data labels. Stack labels probably don't need to be \n\t\t// considered because they are usually accompanied by data labels that lie inside the columns.\n\t\tChart.prototype.callbacks.push(function (chart) {\n\t\t\tfunction collectAndHide() {\n\t\t\t\tvar labels = [];\n\n\t\t\t\teach(chart.series, function (series) {\n\t\t\t\t\tvar dlOptions = series.options.dataLabels;\n\t\t\t\t\tif ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n\t\t\t\t\t\teach(series.points, function (point) { \n\t\t\t\t\t\t\tif (point.dataLabel) {\n\t\t\t\t\t\t\t\tpoint.dataLabel.labelrank = point.labelrank;\n\t\t\t\t\t\t\t\tlabels.push(point.dataLabel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchart.hideOverlappingLabels(labels);\n\t\t\t}\n\n\t\t\t// Do it now ...\n\t\t\tcollectAndHide();\n\n\t\t\t// ... and after each chart redraw\n\t\t\taddEvent(chart, 'redraw', collectAndHide);\n\n\t\t});\n\n\t\t/**\n\t\t * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n\t\t * visual imression.\n\t\t */\t\t\n\t\tChart.prototype.hideOverlappingLabels = function (labels) {\n\n\t\t\tvar len = labels.length,\n\t\t\t\tlabel,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tlabel1,\n\t\t\t\tlabel2,\n\t\t\t\tintersectRect = function (pos1, pos2, size1, size2) {\n\t\t\t\t\treturn !(\n\t\t\t\t\t\tpos2.x > pos1.x + size1.width ||\n\t\t\t\t\t\tpos2.x + size2.width < pos1.x ||\n\t\t\t\t\t\tpos2.y > pos1.y + size1.height ||\n\t\t\t\t\t\tpos2.y + size2.height < pos1.y\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\n\t\t\t// Mark with initial opacity\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.oldOpacity = label.opacity;\n\t\t\t\t\tlabel.newOpacity = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Detect overlapping labels\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tlabel1 = labels[i];\n\n\t\t\t\tfor (j = i + 1; j < len; ++j) {\n\t\t\t\t\tlabel2 = labels[j];\n\t\t\t\t\tif (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && \n\t\t\t\t\t\t\tintersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {\n\t\t\t\t\t\t(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Hide or show\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\tif (label) {\n\t\t\t\t\tif (label.oldOpacity !== label.newOpacity && label.placed) {\n\t\t\t\t\t\tlabel.alignAttr.opacity = label.newOpacity;\n\t\t\t\t\t\tlabel[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.isOld = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t}(Highcharts));/**\n\t * TrackerMixin for points and graphs\n\t */\n\n\tvar TrackerMixin = Highcharts.TrackerMixin = {\n\n\t\tdrawTrackerPoint: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\tpointer = chart.pointer,\n\t\t\t\tcursor = series.options.cursor,\n\t\t\t\tcss = cursor && { cursor: cursor },\n\t\t\t\tonMouseOver = function (e) {\n\t\t\t\t\tvar target = e.target,\n\t\t\t\t\tpoint;\n\n\t\t\t\t\twhile (target && !point) {\n\t\t\t\t\t\tpoint = target.point;\n\t\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n\t\t\t\t\t\tpoint.onMouseOver(e);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// Add reference to the point\n\t\t\teach(series.points, function (point) {\n\t\t\t\tif (point.graphic) {\n\t\t\t\t\tpoint.graphic.element.point = point;\n\t\t\t\t}\n\t\t\t\tif (point.dataLabel) {\n\t\t\t\t\tpoint.dataLabel.element.point = point;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Add the event listeners, we need to do this only once\n\t\t\tif (!series._hasTracking) {\n\t\t\t\teach(series.trackerGroups, function (key) {\n\t\t\t\t\tif (series[key]) { // we don't always have dataLabelsGroup\n\t\t\t\t\t\tseries[key]\n\t\t\t\t\t\t\t.addClass(PREFIX + 'tracker')\n\t\t\t\t\t\t\t.on('mouseover', onMouseOver)\n\t\t\t\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n\t\t\t\t\t\t\t.css(css);\n\t\t\t\t\t\tif (hasTouch) {\n\t\t\t\t\t\t\tseries[key].on('touchstart', onMouseOver);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tseries._hasTracking = true;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Draw the tracker object that sits above all data labels and markers to\n\t\t * track mouse events on the graph or points. For the line type charts\n\t\t * the tracker uses the same graphPath, but with a greater stroke width\n\t\t * for better control.\n\t\t */\n\t\tdrawTrackerGraph: function () {\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\ttrackByArea = options.trackByArea,\n\t\t\t\ttrackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n\t\t\t\ttrackerPathLength = trackerPath.length,\n\t\t\t\tchart = series.chart,\n\t\t\t\tpointer = chart.pointer,\n\t\t\t\trenderer = chart.renderer,\n\t\t\t\tsnap = chart.options.tooltip.snap,\n\t\t\t\ttracker = series.tracker,\n\t\t\t\tcursor = options.cursor,\n\t\t\t\tcss = cursor && { cursor: cursor },\n\t\t\t\tsinglePoints = series.singlePoints,\n\t\t\t\tsinglePoint,\n\t\t\t\ti,\n\t\t\t\tonMouseOver = function () {\n\t\t\t\t\tif (chart.hoverSeries !== series) {\n\t\t\t\t\t\tseries.onMouseOver();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/*\n\t\t\t\t * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n\t\t\t\t * IE6: 0.002\n\t\t\t\t * IE7: 0.002\n\t\t\t\t * IE8: 0.002\n\t\t\t\t * IE9: 0.00000000001 (unlimited)\n\t\t\t\t * IE10: 0.0001 (exporting only)\n\t\t\t\t * FF: 0.00000000001 (unlimited)\n\t\t\t\t * Chrome: 0.000001\n\t\t\t\t * Safari: 0.000001\n\t\t\t\t * Opera: 0.00000000001 (unlimited)\n\t\t\t\t */\n\t\t\t\tTRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';\n\n\t\t\t// Extend end points. A better way would be to use round linecaps,\n\t\t\t// but those are not clickable in VML.\n\t\t\tif (trackerPathLength && !trackByArea) {\n\t\t\t\ti = trackerPathLength + 1;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (trackerPath[i] === M) { // extend left side\n\t\t\t\t\t\ttrackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n\t\t\t\t\t}\n\t\t\t\t\tif ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n\t\t\t\t\t\ttrackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handle single points\n\t\t\tfor (i = 0; i < singlePoints.length; i++) {\n\t\t\t\tsinglePoint = singlePoints[i];\n\t\t\t\ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n\t\t\t\tL, singlePoint.plotX + snap, singlePoint.plotY);\n\t\t\t}\n\n\t\t\t// draw the tracker\n\t\t\tif (tracker) {\n\t\t\t\ttracker.attr({ d: trackerPath });\n\t\t\t} else { // create\n\n\t\t\t\tseries.tracker = renderer.path(trackerPath)\n\t\t\t\t.attr({\n\t\t\t\t\t'stroke-linejoin': 'round', // #1225\n\t\t\t\t\tvisibility: series.visible ? VISIBLE : HIDDEN,\n\t\t\t\t\tstroke: TRACKER_FILL,\n\t\t\t\t\tfill: trackByArea ? TRACKER_FILL : NONE,\n\t\t\t\t\t'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),\n\t\t\t\t\tzIndex: 2\n\t\t\t\t})\n\t\t\t\t.add(series.group);\n\n\t\t\t\t// The tracker is added to the series group, which is clipped, but is covered\n\t\t\t\t// by the marker group. So the marker group also needs to capture events.\n\t\t\t\teach([series.tracker, series.markerGroup], function (tracker) {\n\t\t\t\t\ttracker.addClass(PREFIX + 'tracker')\n\t\t\t\t\t\t.on('mouseover', onMouseOver)\n\t\t\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n\t\t\t\t\t\t.css(css);\n\n\t\t\t\t\tif (hasTouch) {\n\t\t\t\t\t\ttracker.on('touchstart', onMouseOver);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\t/* End TrackerMixin */\n\n\n\t/**\n\t * Add tracking event listener to the series group, so the point graphics\n\t * themselves act as trackers\n\t */ \n\n\tif (seriesTypes.column) {\n\t\tColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\t\n\t}\n\n\tif (seriesTypes.pie) {\n\t\tseriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n\t}\n\n\tif (seriesTypes.scatter) {\n\t\tScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n\t}\n\n\t/* \n\t * Extend Legend for item events \n\t */ \n\textend(Legend.prototype, {\n\n\t\tsetItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {\n\t\tvar legend = this;\n\t\t// Set the events on the item group, or in case of useHTML, the item itself (#1249)\n\t\t(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n\t\t\t\titem.setState(HOVER_STATE);\n\t\t\t\tlegendItem.css(legend.options.itemHoverStyle);\n\t\t\t})\n\t\t\t.on('mouseout', function () {\n\t\t\t\tlegendItem.css(item.visible ? itemStyle : itemHiddenStyle);\n\t\t\t\titem.setState();\n\t\t\t})\n\t\t\t.on('click', function (event) {\n\t\t\t\tvar strLegendItemClick = 'legendItemClick',\n\t\t\t\t\tfnLegendItemClick = function () {\n\t\t\t\t\t\titem.setVisible();\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t// Pass over the click/touch event. #4.\n\t\t\t\tevent = {\n\t\t\t\t\tbrowserEvent: event\n\t\t\t\t};\n\n\t\t\t\t// click the name or symbol\n\t\t\t\tif (item.firePointEvent) { // point\n\t\t\t\t\titem.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n\t\t\t\t} else {\n\t\t\t\t\tfireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tcreateCheckboxForItem: function (item) {\n\t\t\tvar legend = this;\n\n\t\t\titem.checkbox = createElement('input', {\n\t\t\t\ttype: 'checkbox',\n\t\t\t\tchecked: item.selected,\n\t\t\t\tdefaultChecked: item.selected // required by IE7\n\t\t\t}, legend.options.itemCheckboxStyle, legend.chart.container);\n\n\t\t\taddEvent(item.checkbox, 'click', function (event) {\n\t\t\t\tvar target = event.target;\n\t\t\t\tfireEvent(item.series || item, 'checkboxClick', { // #3712\n\t\t\t\t\t\tchecked: target.checked,\n\t\t\t\t\t\titem: item\n\t\t\t\t\t},\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\titem.select();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t}\t\n\t});\n\n\t/* \n\t * Add pointer cursor to legend itemstyle in defaultOptions\n\t */\n\tdefaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n\t/* \n\t * Extend the Chart object with interaction\n\t */\n\n\textend(Chart.prototype, {\n\t\t/**\n\t\t * Display the zoom button\n\t\t */\n\t\tshowResetZoom: function () {\n\t\t\tvar chart = this,\n\t\t\t\tlang = defaultOptions.lang,\n\t\t\t\tbtnOptions = chart.options.chart.resetZoomButton,\n\t\t\t\ttheme = btnOptions.theme,\n\t\t\t\tstates = theme.states,\n\t\t\t\talignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\t\t\t\t\n\t\t\tthis.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)\n\t\t\t\t.attr({\n\t\t\t\t\talign: btnOptions.position.align,\n\t\t\t\t\ttitle: lang.resetZoomTitle\n\t\t\t\t})\n\t\t\t\t.add()\n\t\t\t\t.align(btnOptions.position, false, alignTo);\n\t\t\t\t\n\t\t},\n\n\t\t/**\n\t\t * Zoom out to 1:1\n\t\t */\n\t\tzoomOut: function () {\n\t\t\tvar chart = this;\n\t\t\tfireEvent(chart, 'selection', { resetSelection: true }, function () { \n\t\t\t\tchart.zoom();\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Zoom into a given portion of the chart given by axis coordinates\n\t\t * @param {Object} event\n\t\t */\n\t\tzoom: function (event) {\n\t\t\tvar chart = this,\n\t\t\t\thasZoomed,\n\t\t\t\tpointer = chart.pointer,\n\t\t\t\tdisplayButton = false,\n\t\t\t\tresetZoomButton;\n\n\t\t\t// If zoom is called with no arguments, reset the axes\n\t\t\tif (!event || event.resetSelection) {\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\thasZoomed = axis.zoom();\n\t\t\t\t});\n\t\t\t} else { // else, zoom in on all axes\n\t\t\t\teach(event.xAxis.concat(event.yAxis), function (axisData) {\n\t\t\t\t\tvar axis = axisData.axis,\n\t\t\t\t\t\tisXAxis = axis.isXAxis;\n\n\t\t\t\t\t// don't zoom more than minRange\n\t\t\t\t\tif (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n\t\t\t\t\t\thasZoomed = axis.zoom(axisData.min, axisData.max);\n\t\t\t\t\t\tif (axis.displayBtn) {\n\t\t\t\t\t\t\tdisplayButton = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// Show or hide the Reset zoom button\n\t\t\tresetZoomButton = chart.resetZoomButton;\n\t\t\tif (displayButton && !resetZoomButton) {\n\t\t\t\tchart.showResetZoom();\n\t\t\t} else if (!displayButton && isObject(resetZoomButton)) {\n\t\t\t\tchart.resetZoomButton = resetZoomButton.destroy();\n\t\t\t}\n\t\t\t\n\n\t\t\t// Redraw\n\t\t\tif (hasZoomed) {\n\t\t\t\tchart.redraw(\n\t\t\t\t\tpick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Pan the chart by dragging the mouse across the pane. This function is called\n\t\t * on mouse move, and the distance to pan is computed from chartX compared to\n\t\t * the first chartX position in the dragging operation.\n\t\t */\n\t\tpan: function (e, panning) {\n\n\t\t\tvar chart = this,\n\t\t\t\thoverPoints = chart.hoverPoints,\n\t\t\t\tdoRedraw;\n\n\t\t\t// remove active points for shared tooltip\n\t\t\tif (hoverPoints) {\n\t\t\t\teach(hoverPoints, function (point) {\n\t\t\t\t\tpoint.setState();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\teach(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n\t\t\t\tvar mousePos = e[isX ? 'chartX' : 'chartY'],\n\t\t\t\t\taxis = chart[isX ? 'xAxis' : 'yAxis'][0],\n\t\t\t\t\tstartPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],\n\t\t\t\t\thalfPointRange = (axis.pointRange || 0) / 2,\n\t\t\t\t\textremes = axis.getExtremes(),\n\t\t\t\t\tnewMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n\t\t\t\t\tnewMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,\n\t\t\t\t\tgoingLeft = startPos > mousePos; // #3613\n\n\t\t\t\tif (axis.series.length && \n\t\t\t\t\t\t(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && \n\t\t\t\t\t\t(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {\n\t\t\t\t\taxis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n\t\t\t\t\tdoRedraw = true;\n\t\t\t\t}\n\n\t\t\t\tchart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run\n\t\t\t});\n\n\t\t\tif (doRedraw) {\n\t\t\t\tchart.redraw(false);\n\t\t\t}\n\t\t\tcss(chart.container, { cursor: 'move' });\n\t\t}\n\t});\n\n\t/*\n\t * Extend the Point object with interaction\n\t */\n\textend(Point.prototype, {\n\t\t/**\n\t\t * Toggle the selection status of a point\n\t\t * @param {Boolean} selected Whether to select or unselect the point.\n\t\t * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n\t\t *\t\t this happens if the control key (Cmd on Mac) was pressed during clicking.\n\t\t */\n\t\tselect: function (selected, accumulate) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tchart = series.chart;\n\n\t\t\tselected = pick(selected, !point.selected);\n\n\t\t\t// fire the event with the defalut handler\n\t\t\tpoint.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n\t\t\t\tpoint.selected = point.options.selected = selected;\n\t\t\t\tseries.options.data[inArray(point, series.data)] = point.options;\n\n\t\t\t\tpoint.setState(selected && SELECT_STATE);\n\n\t\t\t\t// unselect all other points unless Ctrl or Cmd + click\n\t\t\t\tif (!accumulate) {\n\t\t\t\t\teach(chart.getSelectedPoints(), function (loopPoint) {\n\t\t\t\t\t\tif (loopPoint.selected && loopPoint !== point) {\n\t\t\t\t\t\t\tloopPoint.selected = loopPoint.options.selected = false;\n\t\t\t\t\t\t\tseries.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n\t\t\t\t\t\t\tloopPoint.setState(NORMAL_STATE);\n\t\t\t\t\t\t\t\tloopPoint.firePointEvent('unselect');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Runs on mouse over the point\n\t\t */\n\t\tonMouseOver: function (e) {\n\t\t\tvar point = this,\n\t\t\t\tseries = point.series,\n\t\t\t\tchart = series.chart,\n\t\t\t\ttooltip = chart.tooltip,\n\t\t\t\thoverPoint = chart.hoverPoint;\n\n\t\t\tif (chart.hoverSeries !== series) {\n\t\t\t\tseries.onMouseOver();\n\t\t\t}\t\t\n\n\t\t\t// set normal state to previous series\n\t\t\tif (hoverPoint && hoverPoint !== point) {\n\t\t\t\thoverPoint.onMouseOut();\n\t\t\t}\n\n\t\t\t// trigger the event\n\t\t\tpoint.firePointEvent('mouseOver');\n\n\t\t\t// update the tooltip\n\t\t\tif (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n\t\t\t\ttooltip.refresh(point, e);\n\t\t\t}\n\n\t\t\t// hover this\n\t\t\tpoint.setState(HOVER_STATE);\n\t\t\tchart.hoverPoint = point;\n\t\t},\n\n\t\t/**\n\t\t * Runs on mouse out from the point\n\t\t */\n\t\tonMouseOut: function () {\n\t\t\tvar chart = this.series.chart,\n\t\t\t\thoverPoints = chart.hoverPoints;\n\n\t\t\tthis.firePointEvent('mouseOut');\n\n\t\t\tif (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n\t\t\t\tthis.setState();\n\t\t\t\tchart.hoverPoint = null;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Import events from the series' and point's options. Only do it on\n\t\t * demand, to save processing time on hovering.\n\t\t */\n\t\timportEvents: function () {\n\t\t\tif (!this.hasImportedEvents) {\n\t\t\t\tvar point = this,\n\t\t\t\t\toptions = merge(point.series.options.point, point.options),\n\t\t\t\t\tevents = options.events,\n\t\t\t\t\teventType;\n\n\t\t\t\tpoint.events = events;\n\n\t\t\t\tfor (eventType in events) {\n\t\t\t\t\taddEvent(point, eventType, events[eventType]);\n\t\t\t\t}\n\t\t\t\tthis.hasImportedEvents = true;\n\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the point's state\n\t\t * @param {String} state\n\t\t */\n\t\tsetState: function (state, move) {\n\t\t\tvar point = this,\n\t\t\t\tplotX = point.plotX,\n\t\t\t\tplotY = point.plotY,\n\t\t\t\tseries = point.series,\n\t\t\t\tstateOptions = series.options.states,\n\t\t\t\tmarkerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n\t\t\t\tnormalDisabled = markerOptions && !markerOptions.enabled,\n\t\t\t\tmarkerStateOptions = markerOptions && markerOptions.states[state],\n\t\t\t\tstateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n\t\t\t\tstateMarkerGraphic = series.stateMarkerGraphic,\n\t\t\t\tpointMarker = point.marker || {},\n\t\t\t\tchart = series.chart,\n\t\t\t\tradius,\n\t\t\t\thalo = series.halo,\n\t\t\t\thaloOptions,\n\t\t\t\tnewSymbol,\n\t\t\t\tpointAttr;\n\n\t\t\tstate = state || NORMAL_STATE; // empty string\n\t\t\tpointAttr = point.pointAttr[state] || series.pointAttr[state];\n\n\t\t\tif (\n\t\t\t\t\t// already has this state\n\t\t\t\t\t(state === point.state && !move) ||\n\t\t\t\t\t// selected points don't respond to hover\n\t\t\t\t\t(point.selected && state !== SELECT_STATE) ||\n\t\t\t\t\t// series' state options is disabled\n\t\t\t\t\t(stateOptions[state] && stateOptions[state].enabled === false) ||\n\t\t\t\t\t// general point marker's state options is disabled\n\t\t\t\t\t(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n\t\t\t\t\t// individual point marker's state options is disabled\n\t\t\t\t\t(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n\t\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// apply hover styles to the existing point\n\t\t\tif (point.graphic) {\n\t\t\t\tradius = markerOptions && point.graphic.symbolName && pointAttr.r;\n\t\t\t\tpoint.graphic.attr(merge(\n\t\t\t\t\tpointAttr,\n\t\t\t\t\tradius ? { // new symbol attributes (#507, #612)\n\t\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\t\ty: plotY - radius,\n\t\t\t\t\t\twidth: 2 * radius,\n\t\t\t\t\t\theight: 2 * radius\n\t\t\t\t\t} : {}\n\t\t\t\t));\n\n\t\t\t\t// Zooming in from a range with no markers to a range with markers\n\t\t\t\tif (stateMarkerGraphic) {\n\t\t\t\t\tstateMarkerGraphic.hide();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if a graphic is not applied to each point in the normal state, create a shared\n\t\t\t\t// graphic for the hover state\n\t\t\t\tif (state && markerStateOptions) {\n\t\t\t\t\tradius = markerStateOptions.radius;\n\t\t\t\t\tnewSymbol = pointMarker.symbol || series.symbol;\n\n\t\t\t\t\t// If the point has another symbol than the previous one, throw away the\n\t\t\t\t\t// state marker graphic and force a new one (#1459)\n\t\t\t\t\tif (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n\t\t\t\t\t\tstateMarkerGraphic = stateMarkerGraphic.destroy();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add a new state marker graphic\n\t\t\t\t\tif (!stateMarkerGraphic) {\n\t\t\t\t\t\tif (newSymbol) {\n\t\t\t\t\t\t\tseries.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n\t\t\t\t\t\t\t\tnewSymbol,\n\t\t\t\t\t\t\t\tplotX - radius,\n\t\t\t\t\t\t\t\tplotY - radius,\n\t\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\t\t2 * radius\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t\t.add(series.markerGroup);\n\t\t\t\t\t\t\tstateMarkerGraphic.currentSymbol = newSymbol;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Move the existing graphic\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n\t\t\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\t\t\ty: plotY - radius\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (stateMarkerGraphic) {\n\t\t\t\t\tstateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Show me your halo\n\t\t\thaloOptions = stateOptions[state] && stateOptions[state].halo;\n\t\t\tif (haloOptions && haloOptions.size) {\n\t\t\t\tif (!halo) {\n\t\t\t\t\tseries.halo = halo = chart.renderer.path()\n\t\t\t\t\t\t.add(chart.seriesGroup);\n\t\t\t\t}\n\t\t\t\thalo.attr(extend({\n\t\t\t\t\tfill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()\n\t\t\t\t}, haloOptions.attributes))[move ? 'animate' : 'attr']({\n\t\t\t\t\td: point.haloPath(haloOptions.size)\n\t\t\t\t});\n\t\t\t} else if (halo) {\n\t\t\t\thalo.attr({ d: [] });\n\t\t\t}\n\n\t\t\tpoint.state = state;\n\t\t},\n\n\t\thaloPath: function (size) {\n\t\t\tvar series = this.series,\n\t\t\t\tchart = series.chart,\n\t\t\t\tplotBox = series.getPlotBox(),\n\t\t\t\tinverted = chart.inverted;\n\n\t\t\treturn chart.renderer.symbols.circle(\n\t\t\t\tplotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, \n\t\t\t\tplotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, \n\t\t\t\tsize * 2, \n\t\t\t\tsize * 2\n\t\t\t);\n\t\t}\n\t});\n\n\t/*\n\t * Extend the Series object with interaction\n\t */\n\n\textend(Series.prototype, {\n\t\t/**\n\t\t * Series mouse over handler\n\t\t */\n\t\tonMouseOver: function () {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\thoverSeries = chart.hoverSeries;\n\n\t\t\t// set normal state to previous series\n\t\t\tif (hoverSeries && hoverSeries !== series) {\n\t\t\t\thoverSeries.onMouseOut();\n\t\t\t}\n\n\t\t\t// trigger the event, but to save processing time,\n\t\t\t// only if defined\n\t\t\tif (series.options.events.mouseOver) {\n\t\t\t\tfireEvent(series, 'mouseOver');\n\t\t\t}\n\n\t\t\t// hover this\n\t\t\tseries.setState(HOVER_STATE);\n\t\t\tchart.hoverSeries = series;\n\t\t},\n\n\t\t/**\n\t\t * Series mouse out handler\n\t\t */\n\t\tonMouseOut: function () {\n\t\t\t// trigger the event only if listeners exist\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\tchart = series.chart,\n\t\t\t\ttooltip = chart.tooltip,\n\t\t\t\thoverPoint = chart.hoverPoint;\n\n\t\t\t// trigger mouse out on the point, which must be in this series\n\t\t\tif (hoverPoint) {\n\t\t\t\thoverPoint.onMouseOut();\n\t\t\t}\n\n\t\t\t// fire the mouse out event\n\t\t\tif (series && options.events.mouseOut) {\n\t\t\t\tfireEvent(series, 'mouseOut');\n\t\t\t}\n\n\n\t\t\t// hide the tooltip\n\t\t\tif (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n\t\t\t\ttooltip.hide();\n\t\t\t}\n\n\t\t\t// set normal state\n\t\t\tseries.setState();\n\t\t\tchart.hoverSeries = null;\n\t\t},\n\n\t\t/**\n\t\t * Set the state of the graph\n\t\t */\n\t\tsetState: function (state) {\n\t\t\tvar series = this,\n\t\t\t\toptions = series.options,\n\t\t\t\tgraph = series.graph,\n\t\t\t\tgraphNeg = series.graphNeg,\n\t\t\t\tstateOptions = options.states,\n\t\t\t\tlineWidth = options.lineWidth,\n\t\t\t\tattribs;\n\n\t\t\tstate = state || NORMAL_STATE;\n\n\t\t\tif (series.state !== state) {\n\t\t\t\tseries.state = state;\n\n\t\t\t\tif (stateOptions[state] && stateOptions[state].enabled === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (state) {\n\t\t\t\t\tlineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);\n\t\t\t\t}\n\n\t\t\t\tif (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n\t\t\t\t\tattribs = {\n\t\t\t\t\t\t'stroke-width': lineWidth\n\t\t\t\t\t};\n\t\t\t\t\t// use attr because animate will cause any other animation on the graph to stop\n\t\t\t\t\tgraph.attr(attribs);\n\t\t\t\t\tif (graphNeg) {\n\t\t\t\t\t\tgraphNeg.attr(attribs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Set the visibility of the graph\n\t\t *\n\t\t * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n\t\t *\t\t\t\tthe visibility is toggled.\n\t\t */\n\t\tsetVisible: function (vis, redraw) {\n\t\t\tvar series = this,\n\t\t\t\tchart = series.chart,\n\t\t\t\tlegendItem = series.legendItem,\n\t\t\t\tshowOrHide,\n\t\t\t\tignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n\t\t\t\toldVisibility = series.visible;\n\n\t\t\t// if called without an argument, toggle visibility\n\t\t\tseries.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;\n\t\t\tshowOrHide = vis ? 'show' : 'hide';\n\n\t\t\t// show or hide elements\n\t\t\teach(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n\t\t\t\tif (series[key]) {\n\t\t\t\t\tseries[key][showOrHide]();\n\t\t\t\t}\n\t\t\t});\n\n\n\t\t\t// hide tooltip (#1361)\n\t\t\tif (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n\t\t\t\tseries.onMouseOut();\n\t\t\t}\n\n\n\t\t\tif (legendItem) {\n\t\t\t\tchart.legend.colorizeItem(series, vis);\n\t\t\t}\n\n\n\t\t\t// rescale or adapt to resized chart\n\t\t\tseries.isDirty = true;\n\t\t\t// in a stack, all other series are affected\n\t\t\tif (series.options.stacking) {\n\t\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\t\tif (otherSeries.options.stacking && otherSeries.visible) {\n\t\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// show or hide linked series\n\t\t\teach(series.linkedSeries, function (otherSeries) {\n\t\t\t\totherSeries.setVisible(vis, false);\n\t\t\t});\n\n\t\t\tif (ignoreHiddenSeries) {\n\t\t\t\tchart.isDirtyBox = true;\n\t\t\t}\n\t\t\tif (redraw !== false) {\n\t\t\t\tchart.redraw();\n\t\t\t}\n\n\t\t\tfireEvent(series, showOrHide);\n\t\t},\n\n\t\t/**\n\t\t * Show the graph\n\t\t */\n\t\tshow: function () {\n\t\t\tthis.setVisible(true);\n\t\t},\n\n\t\t/**\n\t\t * Hide the graph\n\t\t */\n\t\thide: function () {\n\t\t\tthis.setVisible(false);\n\t\t},\n\n\n\t\t/**\n\t\t * Set the selected state of the graph\n\t\t *\n\t\t * @param selected {Boolean} True to select the series, false to unselect. If\n\t\t *\t\t\t\tUNDEFINED, the selection state is toggled.\n\t\t */\n\t\tselect: function (selected) {\n\t\t\tvar series = this;\n\t\t\t// if called without an argument, toggle\n\t\t\tseries.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n\t\t\tif (series.checkbox) {\n\t\t\t\tseries.checkbox.checked = selected;\n\t\t\t}\n\n\t\t\tfireEvent(series, selected ? 'select' : 'unselect');\n\t\t},\n\n\t\tdrawTracker: TrackerMixin.drawTrackerGraph\n\t});\n\t// global variables\n\textend(Highcharts, {\n\t\t\n\t\t// Constructors\n\t\tColor: Color,\n\t\tPoint: Point,\n\t\tTick: Tick,\t\n\t\tRenderer: Renderer,\n\t\tSVGElement: SVGElement,\n\t\tSVGRenderer: SVGRenderer,\n\t\t\n\t\t// Various\n\t\tarrayMin: arrayMin,\n\t\tarrayMax: arrayMax,\n\t\tcharts: charts,\n\t\tdateFormat: dateFormat,\n\t\terror: error,\n\t\tformat: format,\n\t\tpathAnim: pathAnim,\n\t\tgetOptions: getOptions,\n\t\thasBidiBug: hasBidiBug,\n\t\tisTouchDevice: isTouchDevice,\n\t\tsetOptions: setOptions,\n\t\taddEvent: addEvent,\n\t\tremoveEvent: removeEvent,\n\t\tcreateElement: createElement,\n\t\tdiscardElement: discardElement,\n\t\tcss: css,\n\t\teach: each,\n\t\tmap: map,\n\t\tmerge: merge,\n\t\tsplat: splat,\n\t\textendClass: extendClass,\n\t\tpInt: pInt,\n\t\tsvg: hasSVG,\n\t\tcanvas: useCanVG,\n\t\tvml: !hasSVG && !useCanVG,\n\t\tproduct: PRODUCT,\n\t\tversion: VERSION\n\t});\n\n\tmodule.exports = Highcharts;\n\t/*eslint-enable*/\n\n\n/***/ },\n\n/***/ 156:\n/*!*******************************************************!*\\\n  !*** ./~/highcharts-commonjs/~/jquery/dist/jquery.js ***!\n  \\*******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * jQuery JavaScript Library v2.1.3\n\t * http://jquery.com/\n\t *\n\t * Includes Sizzle.js\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-12-18T15:11Z\n\t */\n\n\t(function( global, factory ) {\n\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t\t// is present, execute the factory and get jQuery.\n\t\t\t// For environments that do not have a `window` with a `document`\n\t\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t\t// This accentuates the need for the creation of a real `window`.\n\t\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t\t// See ticket #14549 for more info.\n\t\t\tmodule.exports = global.document ?\n\t\t\t\tfactory( global, true ) :\n\t\t\t\tfunction( w ) {\n\t\t\t\t\tif ( !w.document ) {\n\t\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn factory( w );\n\t\t\t\t};\n\t\t} else {\n\t\t\tfactory( global );\n\t\t}\n\n\t// Pass this if window is not defined yet\n\t}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n\t// Support: Firefox 18+\n\t// Can't be in strict mode, several libs including ASP.NET trace\n\t// the stack via arguments.caller.callee and Firefox dies if\n\t// you try to trace through \"use strict\" call chains. (#13335)\n\t//\n\n\tvar arr = [];\n\n\tvar slice = arr.slice;\n\n\tvar concat = arr.concat;\n\n\tvar push = arr.push;\n\n\tvar indexOf = arr.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar support = {};\n\n\n\n\tvar\n\t\t// Use the correct document accordingly with window argument (sandbox)\n\t\tdocument = window.document,\n\n\t\tversion = \"2.1.3\",\n\n\t\t// Define a local copy of jQuery\n\t\tjQuery = function( selector, context ) {\n\t\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\t\treturn new jQuery.fn.init( selector, context );\n\t\t},\n\n\t\t// Support: Android<4.1\n\t\t// Make sure we trim BOM and NBSP\n\t\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t\t// Matches dashed string for camelizing\n\t\trmsPrefix = /^-ms-/,\n\t\trdashAlpha = /-([\\da-z])/gi,\n\n\t\t// Used by jQuery.camelCase as callback to replace()\n\t\tfcamelCase = function( all, letter ) {\n\t\t\treturn letter.toUpperCase();\n\t\t};\n\n\tjQuery.fn = jQuery.prototype = {\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// Start with an empty selector\n\t\tselector: \"\",\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function() {\n\t\t\treturn slice.call( this );\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function( num ) {\n\t\t\treturn num != null ?\n\n\t\t\t\t// Return just the one element from the set\n\t\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t\t// Return all the elements in a clean array\n\t\t\t\tslice.call( this );\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function( elems ) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\t\tret.context = this.context;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\t// (You can seed the arguments with an array of args, but this is\n\t\t// only used internally.)\n\t\teach: function( callback, args ) {\n\t\t\treturn jQuery.each( this, callback, args );\n\t\t},\n\n\t\tmap: function( callback ) {\n\t\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\t\treturn callback.call( elem, i, elem );\n\t\t\t}));\n\t\t},\n\n\t\tslice: function() {\n\t\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t\t},\n\n\t\tfirst: function() {\n\t\t\treturn this.eq( 0 );\n\t\t},\n\n\t\tlast: function() {\n\t\t\treturn this.eq( -1 );\n\t\t},\n\n\t\teq: function( i ) {\n\t\t\tvar len = this.length,\n\t\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t\t},\n\n\t\tend: function() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function() {\n\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\ttarget = arguments[0] || {},\n\t\t\ti = 1,\n\t\t\tlength = arguments.length,\n\t\t\tdeep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif ( typeof target === \"boolean\" ) {\n\t\t\tdeep = target;\n\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[ i ] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif ( i === length ) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor ( ; i < length; i++ ) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor ( name in options ) {\n\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function( msg ) {\n\t\t\tthrow new Error( msg );\n\t\t},\n\n\t\tnoop: function() {},\n\n\t\tisFunction: function( obj ) {\n\t\t\treturn jQuery.type(obj) === \"function\";\n\t\t},\n\n\t\tisArray: Array.isArray,\n\n\t\tisWindow: function( obj ) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\n\t\tisNumeric: function( obj ) {\n\t\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t\t},\n\n\t\tisPlainObject: function( obj ) {\n\t\t\t// Not plain objects:\n\t\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t\t// - DOM nodes\n\t\t\t// - window\n\t\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If the function hasn't returned already, we're confident that\n\t\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\t\treturn true;\n\t\t},\n\n\t\tisEmptyObject: function( obj ) {\n\t\t\tvar name;\n\t\t\tfor ( name in obj ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\ttype: function( obj ) {\n\t\t\tif ( obj == null ) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\t\ttypeof obj;\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function( code ) {\n\t\t\tvar script,\n\t\t\t\tindirect = eval;\n\n\t\t\tcode = jQuery.trim( code );\n\n\t\t\tif ( code ) {\n\t\t\t\t// If the code includes a valid, prologue position\n\t\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t\t// script tag into the document.\n\t\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\t\tscript.text = code;\n\t\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t\t} else {\n\t\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t\t// and removal by using an indirect global eval\n\t\t\t\t\tindirect( code );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE9-11+\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function( string ) {\n\t\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t\t},\n\n\t\tnodeName: function( elem, name ) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\n\t\t// args is for internal usage only\n\t\teach: function( obj, callback, args ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = obj.length,\n\t\t\t\tisArray = isArraylike( obj );\n\n\t\t\tif ( args ) {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// A special, fast, case for the most common use of each\n\t\t\t} else {\n\t\t\t\tif ( isArray ) {\n\t\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Support: Android<4.1\n\t\ttrim: function( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function( arr, results ) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif ( arr != null ) {\n\t\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t\t[ arr ] : arr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call( ret, arr );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function( elem, arr, i ) {\n\t\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t\t},\n\n\t\tmerge: function( first, second ) {\n\t\t\tvar len = +second.length,\n\t\t\t\tj = 0,\n\t\t\t\ti = first.length;\n\n\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function( elems, callback, invert ) {\n\t\t\tvar callbackInverse,\n\t\t\t\tmatches = [],\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tcallbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function( elems, callback, arg ) {\n\t\t\tvar value,\n\t\t\t\ti = 0,\n\t\t\t\tlength = elems.length,\n\t\t\t\tisArray = isArraylike( elems ),\n\t\t\t\tret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor ( i in elems ) {\n\t\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\t\tif ( value != null ) {\n\t\t\t\t\t\tret.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply( [], ret );\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function( fn, context ) {\n\t\t\tvar tmp, args, proxy;\n\n\t\t\tif ( typeof context === \"string\" ) {\n\t\t\t\ttmp = fn[ context ];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Simulated bind\n\t\t\targs = slice.call( arguments, 2 );\n\t\t\tproxy = function() {\n\t\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t\t};\n\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tnow: Date.now,\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\t});\n\n\tfunction isArraylike( obj ) {\n\t\tvar length = obj.length,\n\t\t\ttype = jQuery.type( obj );\n\n\t\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.nodeType === 1 && length ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 ||\n\t\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n\t * Sizzle CSS Selector Engine v2.2.0-pre\n\t * http://sizzlejs.com/\n\t *\n\t * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n\t * Released under the MIT license\n\t * http://jquery.org/license\n\t *\n\t * Date: 2014-12-16\n\t */\n\t(function( window ) {\n\n\tvar i,\n\t\tsupport,\n\t\tExpr,\n\t\tgetText,\n\t\tisXML,\n\t\ttokenize,\n\t\tcompile,\n\t\tselect,\n\t\toutermostContext,\n\t\tsortInput,\n\t\thasDuplicate,\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\tdocument,\n\t\tdocElem,\n\t\tdocumentIsHTML,\n\t\trbuggyQSA,\n\t\trbuggyMatches,\n\t\tmatches,\n\t\tcontains,\n\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\tpreferredDoc = window.document,\n\t\tdirruns = 0,\n\t\tdone = 0,\n\t\tclassCache = createCache(),\n\t\ttokenCache = createCache(),\n\t\tcompilerCache = createCache(),\n\t\tsortOrder = function( a, b ) {\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// General-purpose constants\n\t\tMAX_NEGATIVE = 1 << 31,\n\n\t\t// Instance methods\n\t\thasOwn = ({}).hasOwnProperty,\n\t\tarr = [],\n\t\tpop = arr.pop,\n\t\tpush_native = arr.push,\n\t\tpush = arr.push,\n\t\tslice = arr.slice,\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// http://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function( list, elem ) {\n\t\t\tvar i = 0,\n\t\t\t\tlen = list.length;\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tif ( list[i] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\n\t\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t\t// Regular expressions\n\n\t\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\t// http://www.w3.org/TR/css3-syntax/#characters\n\t\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t\t// Loosely modeled on CSS identifier characters\n\t\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t\t// Operator (capture 2)\n\t\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\t\"*\\\\]\",\n\n\t\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t\t// 2. simple (capture 6)\n\t\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t\t// 3. anything else (capture 2)\n\t\t\t\".*\" +\n\t\t\t\")\\\\)|)\",\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\t\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\t\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\t\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\t\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\t\trpseudo = new RegExp( pseudos ),\n\t\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\t\tmatchExpr = {\n\t\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t\t},\n\n\t\trinputs = /^(?:input|select|textarea|button)$/i,\n\t\trheader = /^h\\d$/i,\n\n\t\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\t\trsibling = /[+~]/,\n\t\trescape = /'|\\\\/g,\n\n\t\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\t\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ?\n\t\t\t\tescaped :\n\t\t\t\thigh < 0 ?\n\t\t\t\t\t// BMP codepoint\n\t\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t\t},\n\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function() {\n\t\t\tsetDocument();\n\t\t};\n\n\t// Optimize for push.apply( _, NodeList )\n\ttry {\n\t\tpush.apply(\n\t\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\t\tpreferredDoc.childNodes\n\t\t);\n\t\t// Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\t\tarr[ preferredDoc.childNodes.length ].nodeType;\n\t} catch ( e ) {\n\t\tpush = { apply: arr.length ?\n\n\t\t\t// Leverage slice if possible\n\t\t\tfunction( target, els ) {\n\t\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t\t} :\n\n\t\t\t// Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction( target, els ) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t\ti = 0;\n\t\t\t\t// Can't trust NodeList.length\n\t\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Sizzle( selector, context, results, seed ) {\n\t\tvar match, elem, m, nodeType,\n\t\t\t// QSA vars\n\t\t\ti, groups, old, nid, newContext, newSelector;\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\n\t\tcontext = context || document;\n\t\tresults = results || [];\n\t\tnodeType = context.nodeType;\n\n\t\tif ( typeof selector !== \"string\" || !selector ||\n\t\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\t\treturn results;\n\t\t}\n\n\t\tif ( !seed && documentIsHTML ) {\n\n\t\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\tif ( (m = match[1]) ) {\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Context is not a document\n\t\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// QSA path\n\t\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\t\tnid = old = expando;\n\t\t\t\tnewContext = context;\n\t\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t\t}\n\t\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch(qsaError) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// All others\n\t\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\t}\n\n\t/**\n\t * Create key-value caches of limited size\n\t * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n\t *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\t *\tdeleting the oldest entry\n\t */\n\tfunction createCache() {\n\t\tvar keys = [];\n\n\t\tfunction cache( key, value ) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[ keys.shift() ];\n\t\t\t}\n\t\t\treturn (cache[ key + \" \" ] = value);\n\t\t}\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Mark a function for special use by Sizzle\n\t * @param {Function} fn The function to mark\n\t */\n\tfunction markFunction( fn ) {\n\t\tfn[ expando ] = true;\n\t\treturn fn;\n\t}\n\n\t/**\n\t * Support testing using an element\n\t * @param {Function} fn Passed the created div and expects a boolean result\n\t */\n\tfunction assert( fn ) {\n\t\tvar div = document.createElement(\"div\");\n\n\t\ttry {\n\t\t\treturn !!fn( div );\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif ( div.parentNode ) {\n\t\t\t\tdiv.parentNode.removeChild( div );\n\t\t\t}\n\t\t\t// release memory in IE\n\t\t\tdiv = null;\n\t\t}\n\t}\n\n\t/**\n\t * Adds the same handler for all of the specified attrs\n\t * @param {String} attrs Pipe-separated list of attributes\n\t * @param {Function} handler The method that will be applied\n\t */\n\tfunction addHandle( attrs, handler ) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t\ti = attrs.length;\n\n\t\twhile ( i-- ) {\n\t\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t\t}\n\t}\n\n\t/**\n\t * Checks document order of two siblings\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n\t */\n\tfunction siblingCheck( a, b ) {\n\t\tvar cur = b && a,\n\t\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t\t// Use IE sourceIndex if available on both nodes\n\t\tif ( diff ) {\n\t\t\treturn diff;\n\t\t}\n\n\t\t// Check if b follows a\n\t\tif ( cur ) {\n\t\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\t\tif ( cur === b ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a ? 1 : -1;\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for input types\n\t * @param {String} type\n\t */\n\tfunction createInputPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for buttons\n\t * @param {String} type\n\t */\n\tfunction createButtonPseudo( type ) {\n\t\treturn function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t}\n\n\t/**\n\t * Returns a function to use in pseudos for positionals\n\t * @param {Function} fn\n\t */\n\tfunction createPositionalPseudo( fn ) {\n\t\treturn markFunction(function( argument ) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function( seed, matches ) {\n\t\t\t\tvar j,\n\t\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\t\ti = matchIndexes.length;\n\n\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Checks a node for validity as a Sizzle context\n\t * @param {Element|Object=} context\n\t * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n\t */\n\tfunction testContext( context ) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t}\n\n\t// Expose support vars for convenience\n\tsupport = Sizzle.support = {};\n\n\t/**\n\t * Detects XML nodes\n\t * @param {Element|Object} elem An element or a document\n\t * @returns {Boolean} True iff elem is a non-HTML XML node\n\t */\n\tisXML = Sizzle.isXML = function( elem ) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t};\n\n\t/**\n\t * Sets document-related variables once based on the current document\n\t * @param {Element|Object} [doc] An element or document object to use to set the document\n\t * @returns {Object} Returns the current document\n\t */\n\tsetDocument = Sizzle.setDocument = function( node ) {\n\t\tvar hasCompare, parent,\n\t\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t// If no document and documentElement is available, return\n\t\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\t\treturn document;\n\t\t}\n\n\t\t// Set our document\n\t\tdocument = doc;\n\t\tdocElem = doc.documentElement;\n\t\tparent = doc.defaultView;\n\n\t\t// Support: IE>8\n\t\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t\t// IE6-8 do not support the defaultView property so parent will be undefined\n\t\tif ( parent && parent !== parent.top ) {\n\t\t\t// IE11 does not have attachEvent, so all must suffer\n\t\t\tif ( parent.addEventListener ) {\n\t\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t\t} else if ( parent.attachEvent ) {\n\t\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t\t}\n\t\t}\n\n\t\t/* Support tests\n\t\t---------------------------------------------------------------------- */\n\t\tdocumentIsHTML = !isXML( doc );\n\n\t\t/* Attributes\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\t\tsupport.attributes = assert(function( div ) {\n\t\t\tdiv.className = \"i\";\n\t\t\treturn !div.getAttribute(\"className\");\n\t\t});\n\n\t\t/* getElement(s)By*\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\tsupport.getElementsByTagName = assert(function( div ) {\n\t\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t});\n\n\t\t// Support: IE<9\n\t\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t\t// Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\t\tsupport.getById = assert(function( div ) {\n\t\t\tdocElem.appendChild( div ).id = expando;\n\t\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t\t});\n\n\t\t// ID find and filter\n\t\tif ( support.getById ) {\n\t\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t\t}\n\t\t\t};\n\t\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\t// Support: IE6/7\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tdelete Expr.find[\"ID\"];\n\n\t\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t// Tag\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\t\tfunction( tag, context ) {\n\t\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if ( support.qsa ) {\n\t\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\tfunction( tag, context ) {\n\t\t\t\tvar elem,\n\t\t\t\t\ttmp = [],\n\t\t\t\t\ti = 0,\n\t\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif ( tag === \"*\" ) {\n\t\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t// Class\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\t\tif ( documentIsHTML ) {\n\t\t\t\treturn context.getElementsByClassName( className );\n\t\t\t}\n\t\t};\n\n\t\t/* QSA/matchesSelector\n\t\t---------------------------------------------------------------------- */\n\n\t\t// QSA and matchesSelector support\n\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\trbuggyMatches = [];\n\n\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See http://bugs.jquery.com/ticket/13378\n\t\trbuggyQSA = [];\n\n\t\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function( div ) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t\t}\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t\t}\n\n\t\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t}\n\n\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t}\n\n\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tassert(function( div ) {\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = doc.createElement(\"input\");\n\t\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t\t}\n\n\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t\t}\n\n\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\n\t\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\t\tdocElem.webkitMatchesSelector ||\n\t\t\tdocElem.mozMatchesSelector ||\n\t\t\tdocElem.oMatchesSelector ||\n\t\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\t\tassert(function( div ) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t\t// This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t\t});\n\t\t}\n\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t\t/* Contains\n\t\t---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t\t// Element contains another\n\t\t// Purposefully does not implement inclusive descendent\n\t\t// As in, an element does not contain itself\n\t\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\t\tfunction( a, b ) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t\tbup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\t\tadown.contains ?\n\t\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t\t));\n\t\t\t} :\n\t\t\tfunction( a, b ) {\n\t\t\t\tif ( b ) {\n\t\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t/* Sorting\n\t\t---------------------------------------------------------------------- */\n\n\t\t// Document order sorting\n\t\tsortOrder = hasCompare ?\n\t\tfunction( a, b ) {\n\n\t\t\t// Flag for duplicate removal\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\tif ( compare ) {\n\t\t\t\treturn compare;\n\t\t\t}\n\n\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif ( a === b ) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\taup = a.parentNode,\n\t\t\t\tbup = b.parentNode,\n\t\t\t\tap = [ a ],\n\t\t\t\tbp = [ b ];\n\n\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\tif ( !aup || !bup ) {\n\t\t\t\treturn a === doc ? -1 :\n\t\t\t\t\tb === doc ? 1 :\n\t\t\t\t\taup ? -1 :\n\t\t\t\t\tbup ? 1 :\n\t\t\t\t\tsortInput ?\n\t\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t\t0;\n\n\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t} else if ( aup === bup ) {\n\t\t\t\treturn siblingCheck( a, b );\n\t\t\t}\n\n\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\tcur = a;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tap.unshift( cur );\n\t\t\t}\n\t\t\tcur = b;\n\t\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\t\tbp.unshift( cur );\n\t\t\t}\n\n\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\twhile ( ap[i] === bp[i] ) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t\t0;\n\t\t};\n\n\t\treturn doc;\n\t};\n\n\tSizzle.matches = function( expr, elements ) {\n\t\treturn Sizzle( expr, null, null, elements );\n\t};\n\n\tSizzle.matchesSelector = function( elem, expr ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\n\t\t// Make sure that attribute selectors are quoted\n\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\t\tif ( support.matchesSelector && documentIsHTML &&\n\t\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n\t};\n\n\tSizzle.contains = function( context, elem ) {\n\t\t// Set document vars if needed\n\t\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\treturn contains( context, elem );\n\t};\n\n\tSizzle.attr = function( elem, name ) {\n\t\t// Set document vars if needed\n\t\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\t\tsetDocument( elem );\n\t\t}\n\n\t\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\t\tundefined;\n\n\t\treturn val !== undefined ?\n\t\t\tval :\n\t\t\tsupport.attributes || !documentIsHTML ?\n\t\t\t\telem.getAttribute( name ) :\n\t\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t};\n\n\tSizzle.error = function( msg ) {\n\t\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\t};\n\n\t/**\n\t * Document sorting and removing duplicates\n\t * @param {ArrayLike} results\n\t */\n\tSizzle.uniqueSort = function( results ) {\n\t\tvar elem,\n\t\t\tduplicates = [],\n\t\t\tj = 0,\n\t\t\ti = 0;\n\n\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice( 0 );\n\t\tresults.sort( sortOrder );\n\n\t\tif ( hasDuplicate ) {\n\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\t\tj = duplicates.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ( j-- ) {\n\t\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\tsortInput = null;\n\n\t\treturn results;\n\t};\n\n\t/**\n\t * Utility function for retrieving the text value of an array of DOM nodes\n\t * @param {Array|Element} elem\n\t */\n\tgetText = Sizzle.getText = function( elem ) {\n\t\tvar node,\n\t\t\tret = \"\",\n\t\t\ti = 0,\n\t\t\tnodeType = elem.nodeType;\n\n\t\tif ( !nodeType ) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile ( (node = elem[i++]) ) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText( node );\n\t\t\t}\n\t\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tret += getText( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\t\treturn elem.nodeValue;\n\t\t}\n\t\t// Do not include comment or processing instruction nodes\n\n\t\treturn ret;\n\t};\n\n\tExpr = Sizzle.selectors = {\n\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\n\t\tcreatePseudo: markFunction,\n\n\t\tmatch: matchExpr,\n\n\t\tattrHandle: {},\n\n\t\tfind: {},\n\n\t\trelative: {\n\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t},\n\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function( match ) {\n\t\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\n\t\t\t\treturn match.slice( 0, 4 );\n\t\t\t},\n\n\t\t\t\"CHILD\": function( match ) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t\t1 type (only|nth|...)\n\t\t\t\t\t2 what (child|of-type)\n\t\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t\t5 sign of xn-component\n\t\t\t\t\t6 x of xn-component\n\t\t\t\t\t7 sign of y-component\n\t\t\t\t\t8 y of y-component\n\t\t\t\t*/\n\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t\t}\n\n\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t\t} else if ( match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\treturn match;\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function( match ) {\n\t\t\t\tvar excess,\n\t\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\tif ( match[3] ) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t\t}\n\n\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\treturn match.slice( 0, 3 );\n\t\t\t}\n\t\t},\n\n\t\tfilter: {\n\n\t\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\t\tfunction() { return true; } :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CLASS\": function( className ) {\n\t\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\t\treturn pattern ||\n\t\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t\t});\n\t\t\t},\n\n\t\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\t\tif ( result == null ) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( !operator ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\t\tfalse;\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\t\tofType = what === \"of-type\";\n\n\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} :\n\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t},\n\n\t\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\t\t\t\tif ( fn[ expando ] ) {\n\t\t\t\t\treturn fn( argument );\n\t\t\t\t}\n\n\t\t\t\t// But maintain support for old signatures\n\t\t\t\tif ( fn.length > 1 ) {\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function( selector ) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t\tresults = [],\n\t\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\t\treturn matcher[ expando ] ?\n\t\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"has\": markFunction(function( selector ) {\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t\"contains\": markFunction(function( text ) {\n\t\t\t\ttext = text.replace( runescape, funescape );\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t\t}\n\t\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\t\treturn function( elem ) {\n\t\t\t\t\tvar elemLang;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function( elem ) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t\t},\n\n\t\t\t\"root\": function( elem ) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\n\t\t\t\"focus\": function( elem ) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === false;\n\t\t\t},\n\n\t\t\t\"disabled\": function( elem ) {\n\t\t\t\treturn elem.disabled === true;\n\t\t\t},\n\n\t\t\t\"checked\": function( elem ) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t\t},\n\n\t\t\t\"selected\": function( elem ) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\n\t\t\t// Contents\n\t\t\t\"empty\": function( elem ) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t\"parent\": function( elem ) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t\t},\n\n\t\t\t// Element/input types\n\t\t\t\"header\": function( elem ) {\n\t\t\t\treturn rheader.test( elem.nodeName );\n\t\t\t},\n\n\t\t\t\"input\": function( elem ) {\n\t\t\t\treturn rinputs.test( elem.nodeName );\n\t\t\t},\n\n\t\t\t\"button\": function( elem ) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\n\t\t\t\"text\": function( elem ) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t\t},\n\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function() {\n\t\t\t\treturn [ 0 ];\n\t\t\t}),\n\n\t\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\treturn [ length - 1 ];\n\t\t\t}),\n\n\t\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t\t}),\n\n\t\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\t\tvar i = 1;\n\t\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\n\t\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\t\tmatchIndexes.push( i );\n\t\t\t\t}\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t// Add button/input type pseudos\n\tfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\t\tExpr.pseudos[ i ] = createInputPseudo( i );\n\t}\n\tfor ( i in { submit: true, reset: true } ) {\n\t\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\t}\n\n\t// Easy API for creating new setFilters\n\tfunction setFilters() {}\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\n\ttokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\t\tvar matched, match, tokens, type,\n\t\t\tsoFar, groups, preFilters,\n\t\t\tcached = tokenCache[ selector + \" \" ];\n\n\t\tif ( cached ) {\n\t\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t\t}\n\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\n\t\twhile ( soFar ) {\n\n\t\t\t// Comma and first run\n\t\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\t\tif ( match ) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t\t}\n\t\t\t\tgroups.push( (tokens = []) );\n\t\t\t}\n\n\t\t\tmatched = false;\n\n\t\t\t// Combinators\n\t\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\n\t\t\t// Filters\n\t\t\tfor ( type in Expr.filter ) {\n\t\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !matched ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\t\treturn parseOnly ?\n\t\t\tsoFar.length :\n\t\t\tsoFar ?\n\t\t\t\tSizzle.error( selector ) :\n\t\t\t\t// Cache the tokens\n\t\t\t\ttokenCache( selector, groups ).slice( 0 );\n\t};\n\n\tfunction toSelector( tokens ) {\n\t\tvar i = 0,\n\t\t\tlen = tokens.length,\n\t\t\tselector = \"\";\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\t\treturn selector;\n\t}\n\n\tfunction addCombinator( matcher, combinator, base ) {\n\t\tvar dir = combinator.dir,\n\t\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\t\tdoneName = done++;\n\n\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar oldCache, outerCache,\n\t\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\t\tif ( xml ) {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t}\n\n\tfunction elementMatcher( matchers ) {\n\t\treturn matchers.length > 1 ?\n\t\t\tfunction( elem, context, xml ) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} :\n\t\t\tmatchers[0];\n\t}\n\n\tfunction multipleContexts( selector, contexts, results ) {\n\t\tvar i = 0,\n\t\t\tlen = contexts.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tSizzle( selector, contexts[i], results );\n\t\t}\n\t\treturn results;\n\t}\n\n\tfunction condense( unmatched, map, filter, context, xml ) {\n\t\tvar elem,\n\t\t\tnewUnmatched = [],\n\t\t\ti = 0,\n\t\t\tlen = unmatched.length,\n\t\t\tmapped = map != null;\n\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\t\tif ( mapped ) {\n\t\t\t\t\t\tmap.push( i );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newUnmatched;\n\t}\n\n\tfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\t\tif ( postFilter && !postFilter[ expando ] ) {\n\t\t\tpostFilter = setMatcher( postFilter );\n\t\t}\n\t\tif ( postFinder && !postFinder[ expando ] ) {\n\t\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t\t}\n\t\treturn markFunction(function( seed, results, context, xml ) {\n\t\t\tvar temp, i, elem,\n\t\t\t\tpreMap = [],\n\t\t\t\tpostMap = [],\n\t\t\t\tpreexisting = results.length,\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\t\telems,\n\n\t\t\t\tmatcherOut = matcher ?\n\t\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t\t[] :\n\n\t\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\t\tresults :\n\t\t\t\t\tmatcherIn;\n\n\t\t\t// Find primary matches\n\t\t\tif ( matcher ) {\n\t\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t\t}\n\n\t\t\t// Apply postFilter\n\t\t\tif ( postFilter ) {\n\t\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\ti = temp.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( seed ) {\n\t\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(\n\t\t\t\t\tmatcherOut === results ?\n\t\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\t\tmatcherOut\n\t\t\t\t);\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction matcherFromTokens( tokens ) {\n\t\tvar checkContext, matcher, j,\n\t\t\tlen = tokens.length,\n\t\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\ti = leadingRelative ? 1 : 0,\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t\t}, implicitRelative, true ),\n\t\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t} ];\n\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\t\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn setMatcher(\n\t\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tmatchers.push( matcher );\n\t\t\t}\n\t\t}\n\n\t\treturn elementMatcher( matchers );\n\t}\n\n\tfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t\tbyElement = elementMatchers.length > 0,\n\t\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\t\tvar elem, j, matcher,\n\t\t\t\t\tmatchedCount = 0,\n\t\t\t\t\ti = \"0\",\n\t\t\t\t\tunmatched = seed && [],\n\t\t\t\t\tsetMatched = [],\n\t\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\t\tlen = elems.length;\n\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif ( bySet ) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\tmatchedCount += i;\n\t\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif ( outermost ) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\treturn bySet ?\n\t\t\tmarkFunction( superMatcher ) :\n\t\t\tsuperMatcher;\n\t}\n\n\tcompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\t\tvar i,\n\t\t\tsetMatchers = [],\n\t\t\telementMatchers = [],\n\t\t\tcached = compilerCache[ selector + \" \" ];\n\n\t\tif ( !cached ) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif ( !match ) {\n\t\t\t\tmatch = tokenize( selector );\n\t\t\t}\n\t\t\ti = match.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\t\tif ( cached[ expando ] ) {\n\t\t\t\t\tsetMatchers.push( cached );\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push( cached );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache the compiled function\n\t\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t\t// Save selector and tokenization\n\t\t\tcached.selector = selector;\n\t\t}\n\t\treturn cached;\n\t};\n\n\t/**\n\t * A low-level selection function that works with Sizzle's compiled\n\t *  selector functions\n\t * @param {String|Function} selector A selector or a pre-compiled\n\t *  selector function built with Sizzle.compile\n\t * @param {Element} context\n\t * @param {Array} [results]\n\t * @param {Array} [seed] A set of elements to match against\n\t */\n\tselect = Sizzle.select = function( selector, context, results, seed ) {\n\t\tvar i, tokens, token, type, find,\n\t\t\tcompiled = typeof selector === \"function\" && selector,\n\t\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\t\tresults = results || [];\n\n\t\t// Try to minimize operations if there is no seed and only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if ( compiled ) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t( compiled || compile( selector, match ) )(\n\t\t\tseed,\n\t\t\tcontext,\n\t\t\t!documentIsHTML,\n\t\t\tresults,\n\t\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t\t);\n\t\treturn results;\n\t};\n\n\t// One-time assignments\n\n\t// Sort stability\n\tsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n\t// Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t// Initialize against the default document\n\tsetDocument();\n\n\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\tsupport.sortDetached = assert(function( div1 ) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n\t});\n\n\t// Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif ( !assert(function( div ) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n\t}) ) {\n\t\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\tif ( !support.attributes || !assert(function( div ) {\n\t\tdiv.innerHTML = \"<input/>\";\n\t\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\t\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n\t}) ) {\n\t\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t}\n\n\t// Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\tif ( !assert(function( div ) {\n\t\treturn div.getAttribute(\"disabled\") == null;\n\t}) ) {\n\t\taddHandle( booleans, function( elem, name, isXML ) {\n\t\t\tvar val;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn Sizzle;\n\n\t})( window );\n\n\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\n\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow( elements, qualifier, not ) {\n\t\tif ( jQuery.isFunction( qualifier ) ) {\n\t\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t\t/* jshint -W018 */\n\t\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t\t});\n\n\t\t}\n\n\t\tif ( qualifier.nodeType ) {\n\t\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\t\treturn ( elem === qualifier ) !== not;\n\t\t\t});\n\n\t\t}\n\n\t\tif ( typeof qualifier === \"string\" ) {\n\t\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t\t}\n\n\t\t\tqualifier = jQuery.filter( qualifier, elements );\n\t\t}\n\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t\t});\n\t}\n\n\tjQuery.filter = function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function( selector ) {\n\t\t\tvar i,\n\t\t\t\tlen = this.length,\n\t\t\t\tret = [],\n\t\t\t\tself = this;\n\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) );\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t\t}\n\n\t\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\t\treturn ret;\n\t\t},\n\t\tfilter: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t\t},\n\t\tnot: function( selector ) {\n\t\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t\t},\n\t\tis: function( selector ) {\n\t\t\treturn !!winnow(\n\t\t\t\tthis,\n\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector ) :\n\t\t\t\t\tselector || [],\n\t\t\t\tfalse\n\t\t\t).length;\n\t\t}\n\t});\n\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\t\t// A simple way to check for HTML strings\n\t\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t\t// Strict HTML recognition (#11290: must start with <)\n\t\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t\tinit = jQuery.fn.init = function( selector, context ) {\n\t\t\tvar match, elem;\n\n\t\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\t\tif ( !selector ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Handle HTML strings\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t\t} else {\n\t\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t\t}\n\n\t\t\t\t// Match html or make sure no context is specified for #id\n\t\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\t\tif ( match[1] ) {\n\t\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t) );\n\n\t\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.context = document;\n\t\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t\t} else {\n\t\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t\t} else if ( selector.nodeType ) {\n\t\t\t\tthis.context = this[0] = selector;\n\t\t\t\tthis.length = 1;\n\t\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\t\tselector( jQuery );\n\t\t\t}\n\n\t\t\tif ( selector.selector !== undefined ) {\n\t\t\t\tthis.selector = selector.selector;\n\t\t\t\tthis.context = selector.context;\n\t\t\t}\n\n\t\t\treturn jQuery.makeArray( selector, this );\n\t\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery( document );\n\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t\t// Methods guaranteed to produce a unique set when starting from a unique set\n\t\tguaranteedUnique = {\n\t\t\tchildren: true,\n\t\t\tcontents: true,\n\t\t\tnext: true,\n\t\t\tprev: true\n\t\t};\n\n\tjQuery.extend({\n\t\tdir: function( elem, dir, until ) {\n\t\t\tvar matched = [],\n\t\t\t\ttruncate = until !== undefined;\n\n\t\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatched.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matched;\n\t\t},\n\n\t\tsibling: function( n, elem ) {\n\t\t\tvar matched = [];\n\n\t\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\t\tmatched.push( n );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matched;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\thas: function( target ) {\n\t\t\tvar targets = jQuery( target, this ),\n\t\t\t\tl = targets.length;\n\n\t\t\treturn this.filter(function() {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function( selectors, context ) {\n\t\t\tvar cur,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tmatched = [],\n\t\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t\t0;\n\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t\t},\n\n\t\t// Determine the position of an element within the set\n\t\tindex: function( elem ) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif ( !elem ) {\n\t\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// Index in selector\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call( this,\n\n\t\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t\t);\n\t\t},\n\n\t\tadd: function( selector, context ) {\n\t\t\treturn this.pushStack(\n\t\t\t\tjQuery.unique(\n\t\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\n\t\taddBack: function( selector ) {\n\t\t\treturn this.add( selector == null ?\n\t\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t\t);\n\t\t}\n\t});\n\n\tfunction sibling( cur, dir ) {\n\t\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t\t},\n\t\tparentsUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t\t},\n\t\tnext: function( elem ) {\n\t\t\treturn sibling( elem, \"nextSibling\" );\n\t\t},\n\t\tprev: function( elem ) {\n\t\t\treturn sibling( elem, \"previousSibling\" );\n\t\t},\n\t\tnextAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t\t},\n\t\tprevAll: function( elem ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t\t},\n\t\tnextUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t\t},\n\t\tprevUntil: function( elem, i, until ) {\n\t\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t\t},\n\t\tsiblings: function( elem ) {\n\t\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t\t},\n\t\tchildren: function( elem ) {\n\t\t\treturn jQuery.sibling( elem.firstChild );\n\t\t},\n\t\tcontents: function( elem ) {\n\t\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t\t}\n\t}, function( name, fn ) {\n\t\tjQuery.fn[ name ] = function( until, selector ) {\n\t\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t\t}\n\n\t\t\tif ( this.length > 1 ) {\n\t\t\t\t// Remove duplicates\n\t\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\t\tjQuery.unique( matched );\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack( matched );\n\t\t};\n\t});\n\tvar rnotwhite = (/\\S+/g);\n\n\n\n\t// String to Object options format cache\n\tvar optionsCache = {};\n\n\t// Convert String-formatted options into Object-formatted ones and store in cache\n\tfunction createOptions( options ) {\n\t\tvar object = optionsCache[ options ] = {};\n\t\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\t\tobject[ flag ] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n\t * Create a callback list using the following parameters:\n\t *\n\t *\toptions: an optional list of space-separated options that will change how\n\t *\t\t\tthe callback list behaves or a more traditional option object\n\t *\n\t * By default a callback list will act like an event callback list and can be\n\t * \"fired\" multiple times.\n\t *\n\t * Possible options:\n\t *\n\t *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\t *\n\t *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\t *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\t *\t\t\t\t\tvalues (like a Deferred)\n\t *\n\t *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\t *\n\t *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\t *\n\t */\n\tjQuery.Callbacks = function( options ) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ?\n\t\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\t\tjQuery.extend( {}, options );\n\n\t\tvar // Last fire value (for non-forgettable lists)\n\t\t\tmemory,\n\t\t\t// Flag to know if list was already fired\n\t\t\tfired,\n\t\t\t// Flag to know if list is currently firing\n\t\t\tfiring,\n\t\t\t// First callback to fire (used internally by add and fireWith)\n\t\t\tfiringStart,\n\t\t\t// End of the loop when firing\n\t\t\tfiringLength,\n\t\t\t// Index of currently firing callback (modified by remove if needed)\n\t\t\tfiringIndex,\n\t\t\t// Actual callback list\n\t\t\tlist = [],\n\t\t\t// Stack of fire calls for repeatable lists\n\t\t\tstack = !options.once && [],\n\t\t\t// Fire callbacks\n\t\t\tfire = function( data ) {\n\t\t\t\tmemory = options.memory && data;\n\t\t\t\tfired = true;\n\t\t\t\tfiringIndex = firingStart || 0;\n\t\t\t\tfiringStart = 0;\n\t\t\t\tfiringLength = list.length;\n\t\t\t\tfiring = true;\n\t\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfiring = false;\n\t\t\t\tif ( list ) {\n\t\t\t\t\tif ( stack ) {\n\t\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tlist = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Actual Callbacks object\n\t\t\tself = {\n\t\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\t\tadd: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\t// First, we save the current length\n\t\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})( arguments );\n\t\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t\t// current firing batch?\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Remove a callback from the list\n\t\t\t\tremove: function() {\n\t\t\t\t\tif ( list ) {\n\t\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\t\tvar index;\n\t\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Check if a given callback is in the list.\n\t\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\t\thas: function( fn ) {\n\t\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t\t},\n\t\t\t\t// Remove all callbacks from the list\n\t\t\t\tempty: function() {\n\t\t\t\t\tlist = [];\n\t\t\t\t\tfiringLength = 0;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Have the list do nothing anymore\n\t\t\t\tdisable: function() {\n\t\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it disabled?\n\t\t\t\tdisabled: function() {\n\t\t\t\t\treturn !list;\n\t\t\t\t},\n\t\t\t\t// Lock the list in its current state\n\t\t\t\tlock: function() {\n\t\t\t\t\tstack = undefined;\n\t\t\t\t\tif ( !memory ) {\n\t\t\t\t\t\tself.disable();\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Is it locked?\n\t\t\t\tlocked: function() {\n\t\t\t\t\treturn !stack;\n\t\t\t\t},\n\t\t\t\t// Call all callbacks with the given context and arguments\n\t\t\t\tfireWith: function( context, args ) {\n\t\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\t\targs = args || [];\n\t\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfire( args );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Call all the callbacks with the given arguments\n\t\t\t\tfire: function() {\n\t\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// To know if the callbacks have already been called at least once\n\t\t\t\tfired: function() {\n\t\t\t\t\treturn !!fired;\n\t\t\t\t}\n\t\t\t};\n\n\t\treturn self;\n\t};\n\n\n\tjQuery.extend({\n\n\t\tDeferred: function( func ) {\n\t\t\tvar tuples = [\n\t\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t\t],\n\t\t\t\tstate = \"pending\",\n\t\t\t\tpromise = {\n\t\t\t\t\tstate: function() {\n\t\t\t\t\t\treturn state;\n\t\t\t\t\t},\n\t\t\t\t\talways: function() {\n\t\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\t\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tfns = null;\n\t\t\t\t\t\t}).promise();\n\t\t\t\t\t},\n\t\t\t\t\t// Get a promise for this deferred\n\t\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdeferred = {};\n\n\t\t\t// Keep pipe for back-compat\n\t\t\tpromise.pipe = promise.then;\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\tvar list = tuple[ 2 ],\n\t\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif ( stateString ) {\n\t\t\t\t\tlist.add(function() {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\tstate = stateString;\n\n\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t\t}\n\n\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\tpromise.promise( deferred );\n\n\t\t\t// Call given func if any\n\t\t\tif ( func ) {\n\t\t\t\tfunc.call( deferred, deferred );\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\t\tvar i = 0,\n\t\t\t\tresolveValues = slice.call( arguments ),\n\t\t\t\tlength = resolveValues.length,\n\n\t\t\t\t// the count of uncompleted subordinates\n\t\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t\t// Update function for both resolve and progress values\n\t\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\t\treturn function( value ) {\n\t\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\t\tif ( length > 1 ) {\n\t\t\t\tprogressValues = new Array( length );\n\t\t\t\tprogressContexts = new Array( length );\n\t\t\t\tresolveContexts = new Array( length );\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not waiting on anything, resolve the master\n\t\t\tif ( !remaining ) {\n\t\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\n\n\t// The deferred used on DOM ready\n\tvar readyList;\n\n\tjQuery.fn.ready = function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function( hold ) {\n\t\t\tif ( hold ) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready( true );\n\t\t\t}\n\t\t},\n\n\t\t// Handle when the DOM is ready\n\t\tready: function( wait ) {\n\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\t\tjQuery( document ).off( \"ready\" );\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * The ready event handler and self cleanup method\n\t */\n\tfunction completed() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\t\tjQuery.ready();\n\t}\n\n\tjQuery.ready.promise = function( obj ) {\n\t\tif ( !readyList ) {\n\n\t\t\treadyList = jQuery.Deferred();\n\n\t\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\t\tsetTimeout( jQuery.ready );\n\n\t\t\t} else {\n\n\t\t\t\t// Use the handy event callback\n\t\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t\t}\n\t\t}\n\t\treturn readyList.promise( obj );\n\t};\n\n\t// Kick off the DOM ready check even if the user does not\n\tjQuery.ready.promise();\n\n\n\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlen = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n\t};\n\n\n\t/**\n\t * Determines whether an object can have data\n\t */\n\tjQuery.acceptData = function( owner ) {\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\t/* jshint -W018 */\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n\t};\n\n\n\tfunction Data() {\n\t\t// Support: Android<4,\n\t\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t\t// return new empty object instead with no [[set]] accessor\n\t\tObject.defineProperty( this.cache = {}, 0, {\n\t\t\tget: function() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t});\n\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\tData.accepts = jQuery.acceptData;\n\n\tData.prototype = {\n\t\tkey: function( owner ) {\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return the key for a frozen object.\n\t\t\tif ( !Data.accepts( owner ) ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar descriptor = {},\n\t\t\t\t// Check if the owner object already has a cache key\n\t\t\t\tunlock = owner[ this.expando ];\n\n\t\t\t// If not, create one\n\t\t\tif ( !unlock ) {\n\t\t\t\tunlock = Data.uid++;\n\n\t\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\t\ttry {\n\t\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t\t// Support: Android<4\n\t\t\t\t// Fallback to a less secure definition\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure the cache object\n\t\t\tif ( !this.cache[ unlock ] ) {\n\t\t\t\tthis.cache[ unlock ] = {};\n\t\t\t}\n\n\t\t\treturn unlock;\n\t\t},\n\t\tset: function( owner, data, value ) {\n\t\t\tvar prop,\n\t\t\t\t// There may be an unlock assigned to this node,\n\t\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\t\tunlock = this.key( owner ),\n\t\t\t\tcache = this.cache[ unlock ];\n\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\tcache[ data ] = value;\n\n\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\t\t\t// Fresh assignments by object are shallow copied\n\t\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t\t} else {\n\t\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function( owner, key ) {\n\t\t\t// Either a valid cache is found, or will be created.\n\t\t\t// New caches will be created and the unlock returned,\n\t\t\t// allowing direct access to the newly created\n\t\t\t// empty data object. A valid owner object must be provided.\n\t\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\t\treturn key === undefined ?\n\t\t\t\tcache : cache[ key ];\n\t\t},\n\t\taccess: function( owner, key, value ) {\n\t\t\tvar stored;\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif ( key === undefined ||\n\t\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\t\tstored = this.get( owner, key );\n\n\t\t\t\treturn stored !== undefined ?\n\t\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t\t}\n\n\t\t\t// [*]When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set( owner, key, value );\n\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function( owner, key ) {\n\t\t\tvar i, name, camel,\n\t\t\t\tunlock = this.key( owner ),\n\t\t\t\tcache = this.cache[ unlock ];\n\n\t\t\tif ( key === undefined ) {\n\t\t\t\tthis.cache[ unlock ] = {};\n\n\t\t\t} else {\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t\t} else {\n\t\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\t\tif ( key in cache ) {\n\t\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function( owner ) {\n\t\t\treturn !jQuery.isEmptyObject(\n\t\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t\t);\n\t\t},\n\t\tdiscard: function( owner ) {\n\t\t\tif ( owner[ this.expando ] ) {\n\t\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t\t}\n\t\t}\n\t};\n\tvar data_priv = new Data();\n\n\tvar data_user = new Data();\n\n\n\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t\trmultiDash = /([A-Z])/g;\n\n\tfunction dataAttr( elem, key, data ) {\n\t\tvar name;\n\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\t\tdata = elem.getAttribute( name );\n\n\t\t\tif ( typeof data === \"string\" ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\t\tdata;\n\t\t\t\t} catch( e ) {}\n\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdata_user.set( elem, key, data );\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\tjQuery.extend({\n\t\thasData: function( elem ) {\n\t\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t\t},\n\n\t\tdata: function( elem, name, data ) {\n\t\t\treturn data_user.access( elem, name, data );\n\t\t},\n\n\t\tremoveData: function( elem, name ) {\n\t\t\tdata_user.remove( elem, name );\n\t\t},\n\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to data_priv methods, these can be deprecated.\n\t\t_data: function( elem, name, data ) {\n\t\t\treturn data_priv.access( elem, name, data );\n\t\t},\n\n\t\t_removeData: function( elem, name ) {\n\t\t\tdata_priv.remove( elem, name );\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function( key, value ) {\n\t\t\tvar i, name, data,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tattrs = elem && elem.attributes;\n\n\t\t\t// Gets all values\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( this.length ) {\n\t\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ( typeof key === \"object\" ) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tdata_user.set( this, key );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar data,\n\t\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key as-is\n\t\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key camelized\n\t\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each(function() {\n\t\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t\t// This might not apply to all properties...*\n\t\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t\t// unchanged property.\n\t\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length > 1, null, true );\n\t\t},\n\n\t\tremoveData: function( key ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.remove( this, key );\n\t\t\t});\n\t\t}\n\t});\n\n\n\tjQuery.extend({\n\t\tqueue: function( elem, type, data ) {\n\t\t\tvar queue;\n\n\t\t\tif ( elem ) {\n\t\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push( data );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function( elem, type ) {\n\t\t\ttype = type || \"fx\";\n\n\t\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\t\tstartLength = queue.length,\n\t\t\t\tfn = queue.shift(),\n\t\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\t\tnext = function() {\n\t\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif ( fn === \"inprogress\" ) {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif ( type === \"fx\" ) {\n\t\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t\t}\n\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call( elem, next, hooks );\n\t\t\t}\n\n\t\t\tif ( !startLength && hooks ) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function( elem, type ) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function( type, data ) {\n\t\t\tvar setter = 2;\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif ( arguments.length < setter ) {\n\t\t\t\treturn jQuery.queue( this[0], type );\n\t\t\t}\n\n\t\t\treturn data === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\t\tdequeue: function( type ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t});\n\t\t},\n\t\tclearQueue: function( type ) {\n\t\t\treturn this.queue( type || \"fx\", [] );\n\t\t},\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function( type, obj ) {\n\t\t\tvar tmp,\n\t\t\t\tcount = 1,\n\t\t\t\tdefer = jQuery.Deferred(),\n\t\t\t\telements = this,\n\t\t\t\ti = this.length,\n\t\t\t\tresolve = function() {\n\t\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\n\t\t\twhile ( i-- ) {\n\t\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add( resolve );\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise( obj );\n\t\t}\n\t});\n\tvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\n\tvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\n\tvar isHidden = function( elem, el ) {\n\t\t\t// isHidden might be called from jQuery#filter function;\n\t\t\t// in that case, element will be second argument\n\t\t\telem = el || elem;\n\t\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t\t};\n\n\tvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n\t(function() {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\t\tinput = document.createElement( \"input\" );\n\n\t\t// Support: Safari<=5.1\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute( \"type\", \"radio\" );\n\t\tinput.setAttribute( \"checked\", \"checked\" );\n\t\tinput.setAttribute( \"name\", \"t\" );\n\n\t\tdiv.appendChild( input );\n\n\t\t// Support: Safari<=5.1, Android<4.2\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t\t// Support: IE<=11+\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\t})();\n\tvar strundefined = typeof undefined;\n\n\n\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\n\n\tvar\n\t\trkeyEvent = /^key/,\n\t\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\t\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch ( err ) { }\n\t}\n\n\t/*\n\t * Helper functions for managing events -- not part of the public interface.\n\t * Props to Dean Edwards' addEvent library for many of the ideas.\n\t */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function( elem, types, handler, data, selector ) {\n\n\t\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = data_priv.get( elem );\n\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif ( !elemData ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif ( handler.handler ) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif ( !handler.guid ) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif ( !(events = elemData.events) ) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn );\n\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( special.add ) {\n\t\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif ( selector ) {\n\t\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push( handleObj );\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[ type ] = true;\n\t\t\t}\n\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\t\tvar j, origCount, tmp,\n\t\t\t\tevents, t, handleObj,\n\t\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\t\tt = types.length;\n\t\t\twhile ( t-- ) {\n\t\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif ( !type ) {\n\t\t\t\t\tfor ( type in events ) {\n\t\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\t\thandlers = events[ type ] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[ type ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\t\tdelete elemData.handle;\n\t\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t\t}\n\t\t},\n\n\t\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\t\teventPath = [ elem || document ],\n\t\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\t\tcur = tmp = elem = elem || document;\n\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[ jQuery.expando ] ?\n\t\t\t\tevent :\n\t\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.namespace_re = event.namespace ?\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\t\tnull;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ?\n\t\t\t\t[ event ] :\n\t\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\t\teventPath.push( cur );\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\t\tevent.type = i > 1 ?\n\t\t\t\t\tbubbleType :\n\t\t\t\t\tspecial.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\t\tif ( handle ) {\n\t\t\t\t\thandle.apply( cur, data );\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ ontype ];\n\t\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\tdispatch: function( event ) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( event );\n\n\t\t\tvar i, j, ret, matched, handleObj,\n\t\t\t\thandlerQueue = [],\n\t\t\t\targs = slice.call( arguments ),\n\t\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif ( special.postDispatch ) {\n\t\t\t\tspecial.postDispatch.call( this, event );\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function( event, handlers ) {\n\t\t\tvar i, matches, sel, handleObj,\n\t\t\t\thandlerQueue = [],\n\t\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\t\tcur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tif ( delegateCount < handlers.length ) {\n\t\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\t// Includes some event props shared by KeyEvent and MouseEvent\n\t\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\t\tfixHooks: {},\n\n\t\tkeyHooks: {\n\t\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\n\t\t\t\t// Add which for key events\n\t\t\t\tif ( event.which == null ) {\n\t\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tmouseHooks: {\n\t\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\t\tfilter: function( event, original ) {\n\t\t\t\tvar eventDoc, doc, body,\n\t\t\t\t\tbutton = original.button;\n\n\t\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t\t}\n\n\t\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t\t// Note: button is not normalized, so don't use it\n\t\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tfix: function( event ) {\n\t\t\tif ( event[ jQuery.expando ] ) {\n\t\t\t\treturn event;\n\t\t\t}\n\n\t\t\t// Create a writable copy of the event object and normalize some properties\n\t\t\tvar i, prop, copy,\n\t\t\t\ttype = event.type,\n\t\t\t\toriginalEvent = event,\n\t\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\t\tif ( !fixHook ) {\n\t\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t\t{};\n\t\t\t}\n\t\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\t\tevent = new jQuery.Event( originalEvent );\n\n\t\t\ti = copy.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = copy[ i ];\n\t\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t\t}\n\n\t\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t\t// All events should have a target; Cordova deviceready doesn't\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = document;\n\t\t\t}\n\n\t\t\t// Support: Safari 6.0+, Chrome<28\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tif ( event.target.nodeType === 3 ) {\n\t\t\t\tevent.target = event.target.parentNode;\n\t\t\t}\n\n\t\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function() {\n\t\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function( event ) {\n\t\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsimulate: function( type, elem, event, bubble ) {\n\t\t\t// Piggyback on a donor event to simulate a different one.\n\t\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t\t// simulated event prevents default then we do the same on the donor.\n\t\t\tvar e = jQuery.extend(\n\t\t\t\tnew jQuery.Event(),\n\t\t\t\tevent,\n\t\t\t\t{\n\t\t\t\t\ttype: type,\n\t\t\t\t\tisSimulated: true,\n\t\t\t\t\toriginalEvent: {}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif ( bubble ) {\n\t\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t\t} else {\n\t\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t\t}\n\t\t\tif ( e.isDefaultPrevented() ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = function( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t};\n\n\tjQuery.Event = function( src, props ) {\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif ( !(this instanceof jQuery.Event) ) {\n\t\t\treturn new jQuery.Event( src, props );\n\t\t}\n\n\t\t// Event object\n\t\tif ( src && src.type ) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t\t// Support: Android<4.0\n\t\t\t\t\tsrc.returnValue === false ?\n\t\t\t\treturnTrue :\n\t\t\t\treturnFalse;\n\n\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif ( props ) {\n\t\t\tjQuery.extend( this, props );\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t\t// Mark it as fixed\n\t\tthis[ jQuery.expando ] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\n\t\tpreventDefault: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\t\tif ( e && e.preventDefault ) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\n\t\t\tif ( e && e.stopPropagation ) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// Support: Chrome 15+\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function( orig, fix ) {\n\t\tjQuery.event.special[ orig ] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function( event ) {\n\t\t\t\tvar ret,\n\t\t\t\t\ttarget = this,\n\t\t\t\t\trelated = event.relatedTarget,\n\t\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\t// Support: Firefox, Chrome, Safari\n\t// Create \"bubbling\" focus and blur events\n\tif ( !support.focusinBubbles ) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function( event ) {\n\t\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t\t};\n\n\t\t\tjQuery.event.special[ fix ] = {\n\t\t\t\tsetup: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t\t},\n\t\t\t\tteardown: function() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\t\tif ( !attaches ) {\n\t\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tjQuery.fn.extend({\n\n\t\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\t\tvar origFn, type;\n\n\t\t\t// Types can be a map of types/handlers\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif ( data == null && fn == null ) {\n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if ( fn == null ) {\n\t\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t} else if ( !fn ) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif ( one === 1 ) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function( event ) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off( event );\n\t\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t\t}\n\t\t\treturn this.each( function() {\n\t\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t\t});\n\t\t},\n\t\tone: function( types, selector, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn, 1 );\n\t\t},\n\t\toff: function( types, selector, fn ) {\n\t\t\tvar handleObj, type;\n\t\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\t\thandleObj.selector,\n\t\t\t\t\thandleObj.handler\n\t\t\t\t);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( typeof types === \"object\" ) {\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor ( type in types ) {\n\t\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif ( fn === false ) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t\t});\n\t\t},\n\n\t\ttrigger: function( type, data ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.event.trigger( type, data, this );\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function( type, data ) {\n\t\t\tvar elem = this[0];\n\t\t\tif ( elem ) {\n\t\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t\t}\n\t\t}\n\t});\n\n\n\tvar\n\t\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t\trtagName = /<([\\w:]+)/,\n\t\trhtml = /<|&#?\\w+;/,\n\t\trnoInnerhtml = /<(?:script|style|link)/i,\n\t\t// checked=\"checked\" or checked\n\t\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\t\trscriptTypeMasked = /^true\\/(.*)/,\n\t\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t\t// We have to close these tags to support XHTML (#13200)\n\t\twrapMap = {\n\n\t\t\t// Support: IE9\n\t\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t\t_default: [ 0, \"\", \"\" ]\n\t\t};\n\n\t// Support: IE9\n\twrapMap.optgroup = wrapMap.option;\n\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\t// Support: 1.x compatibility\n\t// Manipulating tables requires a tbody\n\tfunction manipulationTarget( elem, content ) {\n\t\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\t\telem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript( elem ) {\n\t\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript( elem ) {\n\t\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\t\tif ( match ) {\n\t\t\telem.type = match[ 1 ];\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval( elems, refElements ) {\n\t\tvar i = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tdata_priv.set(\n\t\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction cloneCopyEvent( src, dest ) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\t\tif ( dest.nodeType !== 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif ( data_priv.hasData( src ) ) {\n\t\t\tpdataOld = data_priv.access( src );\n\t\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\t\tevents = pdataOld.events;\n\n\t\t\tif ( events ) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Copy user data\n\t\tif ( data_user.hasData( src ) ) {\n\t\t\tudataOld = data_user.access( src );\n\t\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\t\tdata_user.set( dest, udataCur );\n\t\t}\n\t}\n\n\tfunction getAll( context, tag ) {\n\t\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t\t[];\n\n\t\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\t\tjQuery.merge( [ context ], ret ) :\n\t\t\tret;\n\t}\n\n\t// Fix IE bugs, see support tests\n\tfunction fixInput( src, dest ) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t\tdest.checked = src.checked;\n\n\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\t\tvar i, l, srcElements, destElements,\n\t\t\t\tclone = elem.cloneNode( true ),\n\t\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Fix IE cloning issues\n\t\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll( clone );\n\t\t\t\tsrcElements = getAll( elem );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif ( dataAndEvents ) {\n\t\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll( clone, \"script\" );\n\t\t\tif ( destElements.length > 0 ) {\n\t\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t\t}\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\t\tfragment = context.createDocumentFragment(),\n\t\t\t\tnodes = [],\n\t\t\t\ti = 0,\n\t\t\t\tl = elems.length;\n\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\telem = elems[ i ];\n\n\t\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t\t// Add nodes directly\n\t\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove wrapper from fragment\n\t\t\tfragment.textContent = \"\";\n\n\t\t\ti = 0;\n\t\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t\t// that element, do not do anything\n\t\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t\t// Append to fragment\n\t\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t\t// Preserve script evaluation history\n\t\t\t\tif ( contains ) {\n\t\t\t\t\tsetGlobalEval( tmp );\n\t\t\t\t}\n\n\t\t\t\t// Capture executables\n\t\t\t\tif ( scripts ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fragment;\n\t\t},\n\n\t\tcleanData: function( elems ) {\n\t\t\tvar data, elem, type, key,\n\t\t\t\tspecial = jQuery.event.special,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Discard any remaining `user` data\n\t\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\ttext: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\tjQuery.text( this ) :\n\t\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\n\t\tappend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.appendChild( elem );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function() {\n\t\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\t\tif ( this.parentNode ) {\n\t\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\t\tvar elem,\n\t\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tempty: function() {\n\t\t\tvar elem,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function() {\n\t\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t\t});\n\t\t},\n\n\t\thtml: function( value ) {\n\t\t\treturn access( this, function( value ) {\n\t\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\t\ti = 0,\n\t\t\t\t\tl = this.length;\n\n\t\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch( e ) {}\n\t\t\t\t}\n\n\t\t\t\tif ( elem ) {\n\t\t\t\t\tthis.empty().append( value );\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length );\n\t\t},\n\n\t\treplaceWith: function() {\n\t\t\tvar arg = arguments[ 0 ];\n\n\t\t\t// Make the changes, replacing each context element with the new content\n\t\t\tthis.domManip( arguments, function( elem ) {\n\t\t\t\targ = this.parentNode;\n\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\t\tif ( arg ) {\n\t\t\t\t\targ.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t\t},\n\n\t\tdetach: function( selector ) {\n\t\t\treturn this.remove( selector, true );\n\t\t},\n\n\t\tdomManip: function( args, callback ) {\n\n\t\t\t// Flatten any nested arrays\n\t\t\targs = concat.apply( [], args );\n\n\t\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length,\n\t\t\t\tset = this,\n\t\t\t\tiNoClone = l - 1,\n\t\t\t\tvalue = args[ 0 ],\n\t\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\t\tif ( isFunction ||\n\t\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\t\treturn this.each(function( index ) {\n\t\t\t\t\tvar self = set.eq( index );\n\t\t\t\t\tif ( isFunction ) {\n\t\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t\t}\n\t\t\t\t\tself.domManip( args, callback );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( l ) {\n\t\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\t\tfirst = fragment.firstChild;\n\n\t\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\t\tfragment = first;\n\t\t\t\t}\n\n\t\t\t\tif ( first ) {\n\t\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t\t// Reenable scripts\n\t\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar elems,\n\t\t\t\tret = [],\n\t\t\t\tinsert = jQuery( selector ),\n\t\t\t\tlast = insert.length - 1,\n\t\t\t\ti = 0;\n\n\t\t\tfor ( ; i <= last; i++ ) {\n\t\t\t\telems = i === last ? this : this.clone( true );\n\t\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t\t// Support: QtWebKit\n\t\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\t\tpush.apply( ret, elems.get() );\n\t\t\t}\n\n\t\t\treturn this.pushStack( ret );\n\t\t};\n\t});\n\n\n\tvar iframe,\n\t\telemdisplay = {};\n\n\t/**\n\t * Retrieve the actual display of a element\n\t * @param {String} name nodeName of the element\n\t * @param {Object} doc Document object\n\t */\n\t// Called only from within defaultDisplay\n\tfunction actualDisplay( name, doc ) {\n\t\tvar style,\n\t\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t\t// since it was removed from specification and supported only in FF\n\t\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t\t// We don't have any data stored on the element,\n\t\t// so use \"detach\" method as fast way to get rid of the element\n\t\telem.detach();\n\n\t\treturn display;\n\t}\n\n\t/**\n\t * Try to determine the default display value of an element\n\t * @param {String} nodeName\n\t */\n\tfunction defaultDisplay( nodeName ) {\n\t\tvar doc = document,\n\t\t\tdisplay = elemdisplay[ nodeName ];\n\n\t\tif ( !display ) {\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t\t// If the simple way fails, read from inside an iframe\n\t\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t\t// Use the already-created iframe if possible\n\t\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t\t// Support: IE\n\t\t\t\tdoc.write();\n\t\t\t\tdoc.close();\n\n\t\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\t\tiframe.detach();\n\t\t\t}\n\n\t\t\t// Store the correct default display\n\t\t\telemdisplay[ nodeName ] = display;\n\t\t}\n\n\t\treturn display;\n\t}\n\tvar rmargin = (/^margin/);\n\n\tvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\n\tvar getStyles = function( elem ) {\n\t\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t\t// IE throws on elements created in popups\n\t\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t\t}\n\n\t\t\treturn window.getComputedStyle( elem, null );\n\t\t};\n\n\n\n\tfunction curCSS( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif ( computed ) {\n\t\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t\t}\n\n\t\tif ( computed ) {\n\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// Support: iOS < 6\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret !== undefined ?\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\tret + \"\" :\n\t\t\tret;\n\t}\n\n\n\tfunction addGetHookIf( conditionFn, hookFn ) {\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\tif ( conditionFn() ) {\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t\t}\n\t\t};\n\t}\n\n\n\t(function() {\n\t\tvar pixelPositionVal, boxSizingReliableVal,\n\t\t\tdocElem = document.documentElement,\n\t\t\tcontainer = document.createElement( \"div\" ),\n\t\t\tdiv = document.createElement( \"div\" );\n\n\t\tif ( !div.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE9-11+\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\t\"position:absolute\";\n\t\tcontainer.appendChild( div );\n\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\t\tdiv.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocElem.appendChild( container );\n\n\t\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t\tdocElem.removeChild( container );\n\t\t}\n\n\t\t// Support: node.js jsdom\n\t\t// Don't assume that getComputedStyle is a property of the global object\n\t\tif ( window.getComputedStyle ) {\n\t\t\tjQuery.extend( support, {\n\t\t\t\tpixelPosition: function() {\n\n\t\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\treturn pixelPositionVal;\n\t\t\t\t},\n\t\t\t\tboxSizingReliable: function() {\n\t\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\t}\n\t\t\t\t\treturn boxSizingReliableVal;\n\t\t\t\t},\n\t\t\t\treliableMarginRight: function() {\n\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\t\tvar ret,\n\t\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\t\tdocElem.removeChild( container );\n\t\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})();\n\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\tjQuery.swap = function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\n\tvar\n\t\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\t\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\t\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\t\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t\tcssNormalTransform = {\n\t\t\tletterSpacing: \"0\",\n\t\t\tfontWeight: \"400\"\n\t\t},\n\n\t\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName( style, name ) {\n\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\t\torigName = name,\n\t\t\ti = cssPrefixes.length;\n\n\t\twhile ( i-- ) {\n\t\t\tname = cssPrefixes[ i ] + capName;\n\t\t\tif ( name in style ) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\treturn origName;\n\t}\n\n\tfunction setPositiveNumber( elem, value, subtract ) {\n\t\tvar matches = rnumsplit.exec( value );\n\t\treturn matches ?\n\t\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\t\tvalue;\n\t}\n\n\tfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\t\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t\t// If we already have the right measurement, avoid augmentation\n\t\t\t4 :\n\t\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t\tname === \"width\" ? 1 : 0,\n\n\t\t\tval = 0;\n\n\t\tfor ( ; i < 4; i += 2 ) {\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif ( extra === \"margin\" ) {\n\t\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\tif ( isBorderBox ) {\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif ( extra === \"content\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t\t}\n\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t}\n\n\tfunction getWidthOrHeight( elem, name, extra ) {\n\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar valueIsBorderBox = true,\n\t\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\t\tstyles = getStyles( elem ),\n\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif ( val <= 0 || val == null ) {\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS( elem, name, styles );\n\t\t\tif ( val < 0 || val == null ) {\n\t\t\t\tval = elem.style[ name ];\n\t\t\t}\n\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif ( rnumnonpx.test(val) ) {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat( val ) || 0;\n\t\t}\n\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn ( val +\n\t\t\taugmentWidthOrHeight(\n\t\t\t\telem,\n\t\t\t\tname,\n\t\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\t\tvalueIsBorderBox,\n\t\t\t\tstyles\n\t\t\t)\n\t\t) + \"px\";\n\t}\n\n\tfunction showHide( elements, show ) {\n\t\tvar display, elem, hidden,\n\t\t\tvalues = [],\n\t\t\tindex = 0,\n\t\t\tlength = elements.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\t\tdisplay = elem.style.display;\n\t\t\tif ( show ) {\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of most of the elements in a second loop\n\t\t// to avoid the constant reflow\n\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\telem = elements[ index ];\n\t\t\tif ( !elem.style ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tjQuery.extend({\n\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function( elem, name, value, extra ) {\n\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret, type, hooks,\n\t\t\t\torigName = jQuery.camelCase( name ),\n\t\t\t\tstyle = elem.style;\n\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t\t// Check if we're setting a value\n\t\t\tif ( value !== undefined ) {\n\t\t\t\ttype = typeof value;\n\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif ( value == null || value !== value ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\t\tvalue += \"px\";\n\t\t\t\t}\n\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[ name ];\n\t\t\t}\n\t\t},\n\n\t\tcss: function( elem, name, extra, styles ) {\n\t\t\tvar val, num, hooks,\n\t\t\t\torigName = jQuery.camelCase( name );\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\t\tval = hooks.get( elem, true, extra );\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif ( val === undefined ) {\n\t\t\t\tval = curCSS( elem, name, styles );\n\t\t\t}\n\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\t\tval = cssNormalTransform[ name ];\n\t\t\t}\n\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif ( extra === \"\" || extra ) {\n\t\t\t\tnum = parseFloat( val );\n\t\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\t\tjQuery.cssHooks[ name ] = {\n\t\t\tget: function( elem, computed, extra ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function( elem, value, extra ) {\n\t\t\t\tvar styles = extra && getStyles( elem );\n\t\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) : 0\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t});\n\n\t// Support: Android 2.3\n\tjQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t}\n\t\t}\n\t);\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function( prefix, suffix ) {\n\t\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\t\texpand: function( value ) {\n\t\t\t\tvar i = 0,\n\t\t\t\t\texpanded = {},\n\n\t\t\t\t\t// Assumes a single number if not a string\n\t\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif ( !rmargin.test( prefix ) ) {\n\t\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function( name, value ) {\n\t\t\treturn access( this, function( elem, name, value ) {\n\t\t\t\tvar styles, len,\n\t\t\t\t\tmap = {},\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\t\tstyles = getStyles( elem );\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ?\n\t\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\t\tjQuery.css( elem, name );\n\t\t\t}, name, value, arguments.length > 1 );\n\t\t},\n\t\tshow: function() {\n\t\t\treturn showHide( this, true );\n\t\t},\n\t\thide: function() {\n\t\t\treturn showHide( this );\n\t\t},\n\t\ttoggle: function( state ) {\n\t\t\tif ( typeof state === \"boolean\" ) {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( isHidden( this ) ) {\n\t\t\t\t\tjQuery( this ).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery( this ).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\n\tfunction Tween( elem, options, prop, end, easing ) {\n\t\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || \"swing\";\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t\t},\n\t\tcur: function() {\n\t\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\t\treturn hooks && hooks.get ?\n\t\t\t\thooks.get( this ) :\n\t\t\t\tTween.propHooks._default.get( this );\n\t\t},\n\t\trun: function( percent ) {\n\t\t\tvar eased,\n\t\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\t\tif ( this.options.duration ) {\n\t\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\t\tif ( this.options.step ) {\n\t\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t\t}\n\n\t\t\tif ( hooks && hooks.set ) {\n\t\t\t\thooks.set( this );\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set( this );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function( tween ) {\n\t\t\t\tvar result;\n\n\t\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t\t}\n\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function( tween ) {\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE9\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function( tween ) {\n\t\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function( p ) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function( p ) {\n\t\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t\t}\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back Compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\n\n\n\tvar\n\t\tfxNow, timerId,\n\t\trfxtypes = /^(?:toggle|show|hide)$/,\n\t\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\t\trrun = /queueHooks$/,\n\t\tanimationPrefilters = [ defaultPrefilter ],\n\t\ttweeners = {\n\t\t\t\"*\": [ function( prop, value ) {\n\t\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\t\ttarget = tween.cur(),\n\t\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\t\tscale = 1,\n\t\t\t\t\tmaxIterations = 20;\n\n\t\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\t\tparts = parts || [];\n\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\tstart = +target || 1;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t\t}\n\n\t\t\t\t// Update tween properties\n\t\t\t\tif ( parts ) {\n\t\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\t\ttween.unit = unit;\n\t\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t\t+parts[ 2 ];\n\t\t\t\t}\n\n\t\t\t\treturn tween;\n\t\t\t} ]\n\t\t};\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\tsetTimeout(function() {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn ( fxNow = jQuery.now() );\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx( type, includeWidth ) {\n\t\tvar which,\n\t\t\ti = 0,\n\t\t\tattrs = { height: type };\n\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\t\twhich = cssExpand[ i ];\n\t\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t\t}\n\n\t\tif ( includeWidth ) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween( value, prop, animation ) {\n\t\tvar tween,\n\t\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter( elem, props, opts ) {\n\t\t/* jshint validthis: true */\n\t\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\t\tanim = this,\n\t\t\torig = {},\n\t\t\tstyle = elem.style,\n\t\t\thidden = elem.nodeType && isHidden( elem ),\n\t\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t\t// Handle queue: false promises\n\t\tif ( !opts.queue ) {\n\t\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\t\tif ( hooks.unqueued == null ) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function() {\n\t\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function() {\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always(function() {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Height/width overflow pass\n\t\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t\t// Make sure that nothing sneaks out\n\t\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t\t// change the overflow attribute when overflowX and\n\t\t\t// overflowY are set to the same value\n\t\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t\t// Set display property to inline-block for height/width\n\t\t\t// animations on inline elements that are having width/height animated\n\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t\t// Test default display if display is currently \"none\"\n\t\t\tcheckDisplay = display === \"none\" ?\n\t\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\n\t\tif ( opts.overflow ) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\n\t\t// show/hide pass\n\t\tfor ( prop in props ) {\n\t\t\tvalue = props[ prop ];\n\t\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\t\tdelete props[ prop ];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t\t// Any non-fx value stops us from restoring the original display value\n\t\t\t} else {\n\t\t\t\tdisplay = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t\t}\n\n\t\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\t\t\tif ( hidden ) {\n\t\t\t\tjQuery( elem ).show();\n\t\t\t} else {\n\t\t\t\tanim.done(function() {\n\t\t\t\t\tjQuery( elem ).hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\tanim.done(function() {\n\t\t\t\tvar prop;\n\n\t\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor ( prop in orig ) {\n\t\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\t\tif ( hidden ) {\n\t\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\t\tstyle.display = display;\n\t\t}\n\t}\n\n\tfunction propFilter( props, specialEasing ) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor ( index in props ) {\n\t\t\tname = jQuery.camelCase( index );\n\t\t\teasing = specialEasing[ name ];\n\t\t\tvalue = props[ index ];\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\teasing = value[ 1 ];\n\t\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t\t}\n\n\t\t\tif ( index !== name ) {\n\t\t\t\tprops[ name ] = value;\n\t\t\t\tdelete props[ index ];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[ name ];\n\t\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\t\tvalue = hooks.expand( value );\n\t\t\t\tdelete props[ name ];\n\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor ( index in value ) {\n\t\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[ name ] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation( elem, properties, options ) {\n\t\tvar result,\n\t\t\tstopped,\n\t\t\tindex = 0,\n\t\t\tlength = animationPrefilters.length,\n\t\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t\t// Don't match elem in the :animated selector\n\t\t\t\tdelete tick.elem;\n\t\t\t}),\n\t\t\ttick = function() {\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\t\tpercent = 1 - temp,\n\t\t\t\t\tindex = 0,\n\t\t\t\t\tlength = animation.tweens.length;\n\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t\t}\n\n\t\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\t\tif ( percent < 1 && length ) {\n\t\t\t\t\treturn remaining;\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = deferred.promise({\n\t\t\t\telem: elem,\n\t\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\t\toriginalProperties: properties,\n\t\t\t\toriginalOptions: options,\n\t\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\t\tduration: options.duration,\n\t\t\t\ttweens: [],\n\t\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\t\treturn tween;\n\t\t\t\t},\n\t\t\t\tstop: function( gotoEnd ) {\n\t\t\t\t\tvar index = 0,\n\t\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\t\tif ( stopped ) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tstopped = true;\n\t\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}),\n\t\t\tprops = animation.props;\n\n\t\tpropFilter( props, animation.opts.specialEasing );\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\t\tif ( result ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map( props, createTween, animation );\n\n\t\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\t\tanimation.opts.start.call( elem, animation );\n\t\t}\n\n\t\tjQuery.fx.timer(\n\t\t\tjQuery.extend( tick, {\n\t\t\t\telem: elem,\n\t\t\t\tanim: animation,\n\t\t\t\tqueue: animation.opts.queue\n\t\t\t})\n\t\t);\n\n\t\t// attach callbacks from options\n\t\treturn animation.progress( animation.opts.progress )\n\t\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t\t.fail( animation.opts.fail )\n\t\t\t.always( animation.opts.always );\n\t}\n\n\tjQuery.Animation = jQuery.extend( Animation, {\n\n\t\ttweener: function( props, callback ) {\n\t\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [ \"*\" ];\n\t\t\t} else {\n\t\t\t\tprops = props.split(\" \");\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = props.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tprop = props[ index ];\n\t\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\t\ttweeners[ prop ].unshift( callback );\n\t\t\t}\n\t\t},\n\n\t\tprefilter: function( callback, prepend ) {\n\t\t\tif ( prepend ) {\n\t\t\t\tanimationPrefilters.unshift( callback );\n\t\t\t} else {\n\t\t\t\tanimationPrefilters.push( callback );\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function( speed, easing, fn ) {\n\t\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\t\tcomplete: fn || !fn && easing ||\n\t\t\t\tjQuery.isFunction( speed ) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif ( opt.queue == null || opt.queue === true ) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function() {\n\t\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\t\topt.old.call( this );\n\t\t\t}\n\n\t\t\tif ( opt.queue ) {\n\t\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t\t// Animate to the value specified\n\t\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t\t},\n\t\tanimate: function( prop, speed, easing, callback ) {\n\t\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\t\tdoAnimation = function() {\n\t\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\t\tanim.stop( true );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ?\n\t\t\t\tthis.each( doAnimation ) :\n\t\t\t\tthis.queue( optall.queue, doAnimation );\n\t\t},\n\t\tstop: function( type, clearQueue, gotoEnd ) {\n\t\t\tvar stopQueue = function( hooks ) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop( gotoEnd );\n\t\t\t};\n\n\t\t\tif ( typeof type !== \"string\" ) {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif ( clearQueue && type !== false ) {\n\t\t\t\tthis.queue( type || \"fx\", [] );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tdata = data_priv.get( this );\n\n\t\t\t\tif ( index ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( index in data ) {\n\t\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function( type ) {\n\t\t\tif ( type !== false ) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function() {\n\t\t\t\tvar index,\n\t\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\t\ttimers = jQuery.timers,\n\t\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\t\thooks.stop.call( this, true );\n\t\t\t\t}\n\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\t\tvar cssFn = jQuery.fn[ name ];\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\t\tcssFn.apply( this, arguments ) :\n\t\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function( name, props ) {\n\t\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\t\treturn this.animate( props, speed, easing, callback );\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function() {\n\t\tvar timer,\n\t\t\ti = 0,\n\t\t\ttimers = jQuery.timers;\n\n\t\tfxNow = jQuery.now();\n\n\t\tfor ( ; i < timers.length; i++ ) {\n\t\t\ttimer = timers[ i ];\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\t\ttimers.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\n\t\tif ( !timers.length ) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function( timer ) {\n\t\tjQuery.timers.push( timer );\n\t\tif ( timer() ) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\n\tjQuery.fx.interval = 13;\n\n\tjQuery.fx.start = function() {\n\t\tif ( !timerId ) {\n\t\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t\t}\n\t};\n\n\tjQuery.fx.stop = function() {\n\t\tclearInterval( timerId );\n\t\ttimerId = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t};\n\n\n\t(function() {\n\t\tvar input = document.createElement( \"input\" ),\n\t\t\tselect = document.createElement( \"select\" ),\n\t\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\t\tinput.type = \"checkbox\";\n\n\t\t// Support: iOS<=5.1, Android<=4.2+\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\n\t\t// Support: IE<=11+\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Support: Android<=2.3\n\t\t// Options inside disabled selects are incorrectly marked as disabled\n\t\tselect.disabled = true;\n\t\tsupport.optDisabled = !opt.disabled;\n\n\t\t// Support: IE<=11+\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement( \"input\" );\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t})();\n\n\n\tvar nodeHook, boolHook,\n\t\tattrHandle = jQuery.expr.attrHandle;\n\n\tjQuery.fn.extend({\n\t\tattr: function( name, value ) {\n\t\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t\t},\n\n\t\tremoveAttr: function( name ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.removeAttr( this, name );\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function( elem, name, value ) {\n\t\t\tvar hooks, ret,\n\t\t\t\tnType = elem.nodeType;\n\n\t\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\t\treturn jQuery.prop( elem, name, value );\n\t\t\t}\n\n\t\t\t// All attributes are lowercase\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t\t}\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tif ( value === null ) {\n\t\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\n\t\t\t\t} else {\n\t\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\t\treturn ret == null ?\n\t\t\t\t\tundefined :\n\t\t\t\t\tret;\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function( elem, value ) {\n\t\t\tvar name, propName,\n\t\t\t\ti = 0,\n\t\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t\telem.removeAttribute( name );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === false ) {\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, name );\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\tjQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\t\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\t\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\t\tvar ret, handle;\n\t\t\tif ( !isXML ) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\n\n\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function( name, value ) {\n\t\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t\t},\n\n\t\tremoveProp: function( name ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t},\n\n\t\tprop: function( elem, name, value ) {\n\t\t\tvar ret, hooks, notxml,\n\t\t\t\tnType = elem.nodeType;\n\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\t\tif ( notxml ) {\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\t\thooks = jQuery.propHooks[ name ];\n\t\t\t}\n\n\t\t\tif ( value !== undefined ) {\n\t\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\t\tret :\n\t\t\t\t\t( elem[ name ] = value );\n\n\t\t\t} else {\n\t\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\t\tret :\n\t\t\t\t\telem[ name ];\n\t\t\t}\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t\t-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tif ( !support.optSelected ) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each([\n\t\t\"tabIndex\",\n\t\t\"readOnly\",\n\t\t\"maxLength\",\n\t\t\"cellSpacing\",\n\t\t\"cellPadding\",\n\t\t\"rowSpan\",\n\t\t\"colSpan\",\n\t\t\"useMap\",\n\t\t\"frameBorder\",\n\t\t\"contentEditable\"\n\t], function() {\n\t\tjQuery.propFix[ this.toLowerCase() ] = this;\n\t});\n\n\n\n\n\tvar rclass = /[\\t\\r\\n\\f]/g;\n\n\tjQuery.fn.extend({\n\t\taddClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length;\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( proceed ) {\n\t\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\" \"\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function( value ) {\n\t\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\t\ti = 0,\n\t\t\t\tlen = this.length;\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( j ) {\n\t\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ( proceed ) {\n\t\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\telem = this[ i ];\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cur ) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function( value, stateVal ) {\n\t\t\tvar type = typeof value;\n\n\t\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t\t}\n\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( type === \"string\" ) {\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\tvar className,\n\t\t\t\t\t\ti = 0,\n\t\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\t\tif ( this.className ) {\n\t\t\t\t\t\t// store className if set\n\t\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function( selector ) {\n\t\t\tvar className = \" \" + selector + \" \",\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\n\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function( value ) {\n\t\t\tvar hooks, ret, isFunction,\n\t\t\t\telem = this[0];\n\n\t\t\tif ( !arguments.length ) {\n\t\t\t\tif ( elem ) {\n\t\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tvar val;\n\n\t\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif ( val == null ) {\n\t\t\t\t\tval = \"\";\n\n\t\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\t\tval += \"\";\n\n\t\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\t\treturn val != null ?\n\t\t\t\t\t\tval :\n\t\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function( elem ) {\n\t\t\t\t\tvar value, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\t\tmax :\n\t\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function( elem, value ) {\n\t\t\t\t\tvar optionSet, option,\n\t\t\t\t\t\toptions = elem.options,\n\t\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\t\ti = options.length;\n\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\toption = options[ i ];\n\t\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif ( !support.checkOn ) {\n\t\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\n\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tjQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function( fnOver, fnOut ) {\n\t\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t\t},\n\n\t\tbind: function( types, data, fn ) {\n\t\t\treturn this.on( types, null, data, fn );\n\t\t},\n\t\tunbind: function( types, fn ) {\n\t\t\treturn this.off( types, null, fn );\n\t\t},\n\n\t\tdelegate: function( selector, types, data, fn ) {\n\t\t\treturn this.on( types, selector, data, fn );\n\t\t},\n\t\tundelegate: function( selector, types, fn ) {\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t\t}\n\t});\n\n\n\tvar nonce = jQuery.now();\n\n\tvar rquery = (/\\?/);\n\n\n\n\t// Support: Android 2.3\n\t// Workaround failure to string-cast null input\n\tjQuery.parseJSON = function( data ) {\n\t\treturn JSON.parse( data + \"\" );\n\t};\n\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t};\n\n\n\tvar\n\t\trhash = /#.*$/,\n\t\trts = /([?&])_=[^&]*/,\n\t\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t\t// #7653, #8125, #8152: local protocol detection\n\t\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t\trnoContent = /^(?:GET|HEAD)$/,\n\t\trprotocol = /^\\/\\//,\n\t\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t\t/* Prefilters\n\t\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t\t * 2) These are called:\n\t\t *    - BEFORE asking for a transport\n\t\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t\t * 3) key is the dataType\n\t\t * 4) the catchall symbol \"*\" can be used\n\t\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t\t */\n\t\tprefilters = {},\n\n\t\t/* Transports bindings\n\t\t * 1) key is the dataType\n\t\t * 2) the catchall symbol \"*\" can be used\n\t\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t\t */\n\t\ttransports = {},\n\n\t\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\t\tallTypes = \"*/\".concat( \"*\" ),\n\n\t\t// Document location\n\t\tajaxLocation = window.location.href,\n\n\t\t// Segment location into parts\n\t\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports( structure ) {\n\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function( dataTypeExpression, func ) {\n\n\t\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t\ti = 0,\n\t\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\t\tvar inspected = {},\n\t\t\tseekingTransport = ( structure === transports );\n\n\t\tfunction inspect( dataType ) {\n\t\t\tvar selected;\n\t\t\tinspected[ dataType ] = true;\n\t\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\t\treturn false;\n\t\t\t\t} else if ( seekingTransport ) {\n\t\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\t}\n\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend( target, src ) {\n\t\tvar key, deep,\n\t\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor ( key in src ) {\n\t\t\tif ( src[ key ] !== undefined ) {\n\t\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t\t}\n\t\t}\n\t\tif ( deep ) {\n\t\t\tjQuery.extend( true, target, deep );\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n\t * - finds the right dataType (mediates between content-type and expected dataType)\n\t * - returns the corresponding response\n\t */\n\tfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\t\tvar ct, type, finalDataType, firstDataType,\n\t\t\tcontents = s.contents,\n\t\t\tdataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\t\tdataTypes.shift();\n\t\t\tif ( ct === undefined ) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we're dealing with a known content-type\n\t\tif ( ct ) {\n\t\t\tfor ( type in contents ) {\n\t\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\t\tdataTypes.unshift( type );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif ( dataTypes[ 0 ] in responses ) {\n\t\t\tfinalDataType = dataTypes[ 0 ];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor ( type in responses ) {\n\t\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( !firstDataType ) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif ( finalDataType ) {\n\t\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\t\tdataTypes.unshift( finalDataType );\n\t\t\t}\n\t\t\treturn responses[ finalDataType ];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n\t * Also sets the responseXXX fields on the jqXHR instance\n\t */\n\tfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\t\tvar conv2, current, conv, tmp, prev,\n\t\t\tconverters = {},\n\t\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif ( dataTypes[ 1 ] ) {\n\t\t\tfor ( conv in s.converters ) {\n\t\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile ( current ) {\n\n\t\t\tif ( s.responseFields[ current ] ) {\n\t\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif ( !conv ) {\n\t\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: \"success\", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n\t\t\ttimeout: 0,\n\t\t\tdata: null,\n\t\t\tdataType: null,\n\t\t\tusername: null,\n\t\t\tpassword: null,\n\t\t\tcache: null,\n\t\t\tthrows: false,\n\t\t\ttraditional: false,\n\t\t\theaders: {},\n\t\t\t*/\n\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function( target, settings ) {\n\t\t\treturn settings ?\n\n\t\t\t\t// Building a settings object\n\t\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t\t// Extending ajaxSettings\n\t\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\t\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t\t// Main method\n\t\tajax: function( url, options ) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ( typeof url === \"object\" ) {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar transport,\n\t\t\t\t// URL without anti-cache param\n\t\t\t\tcacheURL,\n\t\t\t\t// Response headers\n\t\t\t\tresponseHeadersString,\n\t\t\t\tresponseHeaders,\n\t\t\t\t// timeout handle\n\t\t\t\ttimeoutTimer,\n\t\t\t\t// Cross-domain detection vars\n\t\t\t\tparts,\n\t\t\t\t// To know if global events are to be dispatched\n\t\t\t\tfireGlobals,\n\t\t\t\t// Loop variable\n\t\t\t\ti,\n\t\t\t\t// Create the final options object\n\t\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t\t// Callbacks context\n\t\t\t\tcallbackContext = s.context || s,\n\t\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\t\t\t\t// Deferreds\n\t\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode = s.statusCode || {},\n\t\t\t\t// Headers (they are sent all at once)\n\t\t\t\trequestHeaders = {},\n\t\t\t\trequestHeadersNames = {},\n\t\t\t\t// The jqXHR state\n\t\t\t\tstate = 0,\n\t\t\t\t// Default abort message\n\t\t\t\tstrAbort = \"canceled\",\n\t\t\t\t// Fake xhr\n\t\t\t\tjqXHR = {\n\t\t\t\t\treadyState: 0,\n\n\t\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\t\tvar match;\n\t\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Raw string\n\t\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Caches the header\n\t\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Overrides response content-type header\n\t\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Status-dependent callbacks\n\t\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\t\tvar code;\n\t\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t},\n\n\t\t\t\t\t// Cancel the request\n\t\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail;\n\n\t\t\t// Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\t\tif ( s.crossDomain == null ) {\n\t\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\tcacheURL = s.url;\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif ( !s.hasContent ) {\n\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif ( s.data ) {\n\t\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add anti-cache in url if needed\n\t\t\t\tif ( s.cache === false ) {\n\t\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif ( s.ifModified ) {\n\t\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t\t}\n\t\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\n\t\t\t\t\"Accept\",\n\t\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\t\ts.accepts[ \"*\" ]\n\t\t\t);\n\n\t\t\t// Check for headers option\n\t\t\tfor ( i in s.headers ) {\n\t\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t\t}\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif ( !transport ) {\n\t\t\t\tdone( -1, \"No Transport\" );\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t\t}\n\t\t\t\t// Timeout\n\t\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\tdone( -1, e );\n\t\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t\t// Called once\n\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// State is \"done\" now\n\t\t\t\tstate = 2;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif ( timeoutTimer ) {\n\t\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif ( responses ) {\n\t\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif ( isSuccess ) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif ( isSuccess ) {\n\t\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode( statusCode );\n\t\t\t\tstatusCode = undefined;\n\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\t\tif ( fireGlobals ) {\n\t\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function( url, data, callback ) {\n\t\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t\t},\n\n\t\tgetScript: function( url, callback ) {\n\t\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t\t}\n\t});\n\n\tjQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\t\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\n\n\tjQuery._evalUrl = function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\n\n\tjQuery.fn.extend({\n\t\twrapAll: function( html ) {\n\t\t\tvar wrap;\n\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( this[ 0 ] ) {\n\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\twrap.map(function() {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append( this );\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function( html ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\treturn this.each(function( i ) {\n\t\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar self = jQuery( this ),\n\t\t\t\t\tcontents = self.contents();\n\n\t\t\t\tif ( contents.length ) {\n\t\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t\t} else {\n\t\t\t\t\tself.append( html );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function( html ) {\n\t\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function() {\n\t\t\treturn this.parent().each(function() {\n\t\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t\t}\n\t\t\t}).end();\n\t\t}\n\t});\n\n\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n\n\n\n\n\tvar r20 = /%20/g,\n\t\trbracket = /\\[\\]$/,\n\t\trCRLF = /\\r?\\n/g,\n\t\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams( prefix, obj, traditional, add ) {\n\t\tvar name;\n\n\t\tif ( jQuery.isArray( obj ) ) {\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each( obj, function( i, v ) {\n\t\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd( prefix, v );\n\n\t\t\t\t} else {\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t\t// Serialize object item.\n\t\t\tfor ( name in obj ) {\n\t\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t\t}\n\n\t\t} else {\n\t\t\t// Serialize scalar item.\n\t\t\tadd( prefix, obj );\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function( a, traditional ) {\n\t\tvar prefix,\n\t\t\ts = [],\n\t\t\tadd = function( key, value ) {\n\t\t\t\t// If value is a function, invoke it and return its value\n\t\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t\t};\n\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif ( traditional === undefined ) {\n\t\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t\t}\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each( a, function() {\n\t\t\t\tadd( this.name, this.value );\n\t\t\t});\n\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor ( prefix in a ) {\n\t\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join( \"&\" ).replace( r20, \"+\" );\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function() {\n\t\t\treturn jQuery.param( this.serializeArray() );\n\t\t},\n\t\tserializeArray: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t\t})\n\t\t\t.filter(function() {\n\t\t\t\tvar type = this.type;\n\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t\t})\n\t\t\t.map(function( i, elem ) {\n\t\t\t\tvar val = jQuery( this ).val();\n\n\t\t\t\treturn val == null ?\n\t\t\t\t\tnull :\n\t\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t\t}) :\n\t\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\n\tjQuery.ajaxSettings.xhr = function() {\n\t\ttry {\n\t\t\treturn new XMLHttpRequest();\n\t\t} catch( e ) {}\n\t};\n\n\tvar xhrId = 0,\n\t\txhrCallbacks = {},\n\t\txhrSuccessStatus = {\n\t\t\t// file protocol always yields status code 0, assume 200\n\t\t\t0: 200,\n\t\t\t// Support: IE9\n\t\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t\t1223: 204\n\t\t},\n\t\txhrSupported = jQuery.ajaxSettings.xhr();\n\n\t// Support: IE9\n\t// Open requests must be manually aborted on unload (#5280)\n\t// See https://support.microsoft.com/kb/2856746 for more info\n\tif ( window.attachEvent ) {\n\t\twindow.attachEvent( \"onunload\", function() {\n\t\t\tfor ( var key in xhrCallbacks ) {\n\t\t\t\txhrCallbacks[ key ]();\n\t\t\t}\n\t\t});\n\t}\n\n\tsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\n\tjQuery.ajaxTransport(function( options ) {\n\t\tvar callback;\n\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Callback\n\t\t\t\t\tcallback = function( type ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = callback();\n\t\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\n\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /(?:java|ecma)script/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function( text ) {\n\t\t\t\tjQuery.globalEval( text );\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter( \"script\", function( s ) {\n\t\tif ( s.cache === undefined ) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif ( s.crossDomain ) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport( \"script\", function( s ) {\n\t\t// This transport only deals with cross domain requests\n\t\tif ( s.crossDomain ) {\n\t\t\tvar script, callback;\n\t\t\treturn {\n\t\t\t\tsend: function( _, complete ) {\n\t\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\t\tasync: true,\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t}).on(\n\t\t\t\t\t\t\"load error\",\n\t\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t\t},\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\n\n\n\tvar oldCallbacks = [],\n\t\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function() {\n\t\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\t\tthis[ callback ] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\t\tvar callbackName, overwritten, responseContainer,\n\t\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\t\"url\" :\n\t\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t\t);\n\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\t\ts.jsonpCallback() :\n\t\t\t\ts.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif ( jsonProp ) {\n\t\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t\t} else if ( s.jsonp !== false ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function() {\n\t\t\t\tif ( !responseContainer ) {\n\t\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t\t}\n\t\t\t\treturn responseContainer[ 0 ];\n\t\t\t};\n\n\t\t\t// force json dataType\n\t\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[ callbackName ];\n\t\t\twindow[ callbackName ] = function() {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function() {\n\t\t\t\t// Restore preexisting value\n\t\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t\t// Save back as free\n\t\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// save the callback name for future use\n\t\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\n\n\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\t\tif ( scripts && scripts.length ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t};\n\n\n\t// Keep a copy of the old load method\n\tvar _load = jQuery.fn.load;\n\n\t/**\n\t * Load a url into a page\n\t */\n\tjQuery.fn.load = function( url, params, callback ) {\n\t\tif ( typeof url !== \"string\" && _load ) {\n\t\t\treturn _load.apply( this, arguments );\n\t\t}\n\n\t\tvar selector, type, response,\n\t\t\tself = this,\n\t\t\toff = url.indexOf(\" \");\n\n\t\tif ( off >= 0 ) {\n\t\t\tselector = jQuery.trim( url.slice( off ) );\n\t\t\turl = url.slice( 0, off );\n\t\t}\n\n\t\t// If it's a function\n\t\tif ( jQuery.isFunction( params ) ) {\n\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t// Otherwise, build a param string\n\t\t} else if ( params && typeof params === \"object\" ) {\n\t\t\ttype = \"POST\";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif ( self.length > 0 ) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\t\ttype: type,\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function( responseText ) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html( selector ?\n\n\t\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t\t// Otherwise use the full result\n\t\t\t\t\tresponseText );\n\n\t\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\n\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\t\tjQuery.fn[ type ] = function( fn ) {\n\t\t\treturn this.on( type, fn );\n\t\t};\n\t});\n\n\n\n\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\n\n\n\tvar docElem = window.document.documentElement;\n\n\t/**\n\t * Gets a window from an element\n\t */\n\tfunction getWindow( elem ) {\n\t\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\n\tjQuery.offset = {\n\t\tsetOffset: function( elem, options, i ) {\n\t\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\t\tcurElem = jQuery( elem ),\n\t\t\t\tprops = {};\n\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif ( position === \"static\" ) {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif ( calculatePosition ) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t\t}\n\n\t\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\t\toptions = options.call( elem, i, curOffset );\n\t\t\t}\n\n\t\t\tif ( options.top != null ) {\n\t\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t\t}\n\t\t\tif ( options.left != null ) {\n\t\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t\t}\n\n\t\t\tif ( \"using\" in options ) {\n\t\t\t\toptions.using.call( elem, props );\n\n\t\t\t} else {\n\t\t\t\tcurElem.css( props );\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\t\toffset: function( options ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn options === undefined ?\n\t\t\t\t\tthis :\n\t\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar docElem, win,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tbox = { top: 0, left: 0 },\n\t\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\t\tif ( !doc ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\t// Make sure it's not a disconnected DOM node\n\t\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\t\treturn box;\n\t\t\t}\n\n\t\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\t\tbox = elem.getBoundingClientRect();\n\t\t\t}\n\t\t\twin = getWindow( doc );\n\t\t\treturn {\n\t\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t},\n\n\t\tposition: function() {\n\t\t\tif ( !this[ 0 ] ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent, offset,\n\t\t\t\telem = this[ 0 ],\n\t\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t\t} else {\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t\t};\n\t\t},\n\n\t\toffsetParent: function() {\n\t\t\treturn this.map(function() {\n\t\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\n\t\t\t\treturn offsetParent || docElem;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\t\tvar top = \"pageYOffset\" === prop;\n\n\t\tjQuery.fn[ method ] = function( val ) {\n\t\t\treturn access( this, function( elem, method, val ) {\n\t\t\t\tvar win = getWindow( elem );\n\n\t\t\t\tif ( val === undefined ) {\n\t\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t\t}\n\n\t\t\t\tif ( win ) {\n\t\t\t\t\twin.scrollTo(\n\t\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\t\t\t\t\telem[ method ] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length, null );\n\t\t};\n\t});\n\n\t// Support: Safari<7+, Chrome<37+\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\t\tfunction( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\tcomputed;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t});\n\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\t\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\t\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t\t};\n\t\t});\n\t});\n\n\n\t// The number of elements contained in the matched element set\n\tjQuery.fn.size = function() {\n\t\treturn this.length;\n\t};\n\n\tjQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\n\n\n\tvar\n\t\t// Map over jQuery in case of overwrite\n\t\t_jQuery = window.jQuery,\n\n\t\t// Map over the $ in case of overwrite\n\t\t_$ = window.$;\n\n\tjQuery.noConflict = function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ( typeof noGlobal === strundefined ) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\n\n\n\treturn jQuery;\n\n\t}));\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** webpack_example_with_highcharts-page-bundle.js\n **/","module.exports = global[\"$page\"] = require(\"-!/Users/amunoz/atlas/web/src/main/javascript/src/webpack_example/highcharts/highcharts-page.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/webpack_example/highcharts/highcharts-page.js\n ** module id = 0\n ** module chunks = 7\n **/","/*!\n * jQuery JavaScript Library v1.11.2\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-17T15:27Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar deletedIds = [];\n\nvar slice = deletedIds.slice;\n\nvar concat = deletedIds.concat;\n\nvar push = deletedIds.push;\n\nvar indexOf = deletedIds.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\tversion = \"1.11.2\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1, IE<9\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: deletedIds.sort,\n\tsplice: deletedIds.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar src, copyIsArray, copy, name, options, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\t/* jshint eqeqeq: false */\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar key;\n\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Handle iteration over inherited properties before own properties.\n\t\tif ( support.ownLast ) {\n\t\t\tfor ( key in obj ) {\n\t\t\t\treturn hasOwn.call( obj, key );\n\t\t\t}\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && jQuery.trim( data ) ) {\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1, IE<9\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( indexOf ) {\n\t\t\t\treturn indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\twhile ( j < len ) {\n\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\t\tif ( len !== len ) {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar args, proxy, tmp;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: function() {\n\t\treturn +( new Date() );\n\t},\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tret = jQuery.unique( ret );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tret = ret.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\t\t// Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\n\t\t\t\t\t} else if ( !(--remaining) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( !document.body ) {\n\t\t\treturn setTimeout( jQuery.ready );\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * Clean-up method for dom ready events\n */\nfunction detach() {\n\tif ( document.addEventListener ) {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\n\t} else {\n\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\twindow.detachEvent( \"onload\", completed );\n\t}\n}\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\t\tdetach();\n\t\tjQuery.ready();\n\t}\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\n\t\t// If IE event model is used\n\t\t} else {\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n\nvar strundefined = typeof undefined;\n\n\n\n// Support: IE<9\n// Iteration over object's inherited properties before its own\nvar i;\nfor ( i in jQuery( support ) ) {\n\tbreak;\n}\nsupport.ownLast = i !== \"0\";\n\n// Note: most support tests are defined in their respective modules.\n// false until the test is run\nsupport.inlineBlockNeedsLayout = false;\n\n// Execute ASAP in case we need to set body.style.zoom\njQuery(function() {\n\t// Minified: var a,b,c,d\n\tvar val, div, body, container;\n\n\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\tif ( !body || !body.style ) {\n\t\t// Return for frameset docs that don't have a body\n\t\treturn;\n\t}\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tcontainer = document.createElement( \"div\" );\n\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\tbody.appendChild( container ).appendChild( div );\n\n\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t// Support: IE<8\n\t\t// Check if natively block-level elements act like inline-block\n\t\t// elements when setting their display to 'inline' and giving\n\t\t// them layout\n\t\tdiv.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n\n\t\tsupport.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n\t\tif ( val ) {\n\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t// Support: IE<8\n\t\t\tbody.style.zoom = 1;\n\t\t}\n\t}\n\n\tbody.removeChild( container );\n});\n\n\n\n\n(function() {\n\tvar div = document.createElement( \"div\" );\n\n\t// Execute the test only if not already executed in another module.\n\tif (support.deleteExpando == null) {\n\t\t// Support: IE<9\n\t\tsupport.deleteExpando = true;\n\t\ttry {\n\t\t\tdelete div.test;\n\t\t} catch( e ) {\n\t\t\tsupport.deleteExpando = false;\n\t\t}\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n})();\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( elem ) {\n\tvar noData = jQuery.noData[ (elem.nodeName + \" \").toLowerCase() ],\n\t\tnodeType = +elem.nodeType || 1;\n\n\t// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\treturn nodeType !== 1 && nodeType !== 9 ?\n\t\tfalse :\n\n\t\t// Nodes accept data unless otherwise specified; rejection can be conditional\n\t\t!noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n};\n\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar ret, thisCache,\n\t\tinternalKey = jQuery.expando,\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t// Avoid doing any more work than we need to when trying to get data on an\n\t// object that has no data at all\n\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === \"string\" ) {\n\t\treturn;\n\t}\n\n\tif ( !id ) {\n\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t// ends up in the global cache\n\t\tif ( isNode ) {\n\t\t\tid = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n\t\t} else {\n\t\t\tid = internalKey;\n\t\t}\n\t}\n\n\tif ( !cache[ id ] ) {\n\t\t// Avoid exposing jQuery metadata on plain JS objects when the object\n\t\t// is serialized using JSON.stringify\n\t\tcache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n\t}\n\n\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t// shallow copied over onto the existing cache\n\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\tif ( pvt ) {\n\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t} else {\n\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t}\n\t}\n\n\tthisCache = cache[ id ];\n\n\t// jQuery data() is stored in a separate object inside the object's internal data\n\t// cache in order to avoid key collisions between internal data and user-defined\n\t// data.\n\tif ( !pvt ) {\n\t\tif ( !thisCache.data ) {\n\t\t\tthisCache.data = {};\n\t\t}\n\n\t\tthisCache = thisCache.data;\n\t}\n\n\tif ( data !== undefined ) {\n\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t}\n\n\t// Check for both converted-to-camel and non-converted data property names\n\t// If a data property was specified\n\tif ( typeof name === \"string\" ) {\n\n\t\t// First Try to find as-is property data\n\t\tret = thisCache[ name ];\n\n\t\t// Test for null|undefined property data\n\t\tif ( ret == null ) {\n\n\t\t\t// Try to find the camelCased property\n\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t}\n\t} else {\n\t\tret = thisCache;\n\t}\n\n\treturn ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar thisCache, i,\n\t\tisNode = elem.nodeType,\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t// If there is already no cache entry for this object, there is no\n\t// purpose in continuing\n\tif ( !cache[ id ] ) {\n\t\treturn;\n\t}\n\n\tif ( name ) {\n\n\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\tif ( thisCache ) {\n\n\t\t\t// Support array or space separated string names for data keys\n\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\tname = [ name ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t}\n\n\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t// and let the cache object itself get destroyed\n\t\t\tif ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// See jQuery.data for more information\n\tif ( !pvt ) {\n\t\tdelete cache[ id ].data;\n\n\t\t// Don't destroy the parent cache unless the internal data object\n\t\t// had been the only thing left in it\n\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Destroy the cache\n\tif ( isNode ) {\n\t\tjQuery.cleanData( [ elem ], true );\n\n\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t/* jshint eqeqeq: false */\n\t} else if ( support.deleteExpando || cache != cache.window ) {\n\t\t/* jshint eqeqeq: true */\n\t\tdelete cache[ id ];\n\n\t// When all else fails, null\n\t} else {\n\t\tcache[ id ] = null;\n\t}\n}\n\njQuery.extend({\n\tcache: {},\n\n\t// The following elements (space-suffixed to avoid Object.prototype collisions)\n\t// throw uncatchable exceptions if you attempt to set expando properties\n\tnoData: {\n\t\t\"applet \": true,\n\t\t\"embed \": true,\n\t\t// ...but Flash objects (which have this classid) *can* handle expandos\n\t\t\"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name );\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data, true );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name, true );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[0],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Special expections of .data basically thwart jQuery.access,\n\t\t// so implement the relevant behavior ourselves\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn arguments.length > 1 ?\n\n\t\t\t// Sets one value\n\t\t\tthis.each(function() {\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t}) :\n\n\t\t\t// Gets one value\n\t\t\t// Try to fetch any internally stored data first\n\t\t\telem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlength = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n};\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\t// Minified: var a,b,c\n\tvar input = document.createElement( \"input\" ),\n\t\tdiv = document.createElement( \"div\" ),\n\t\tfragment = document.createDocumentFragment();\n\n\t// Setup\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t// IE strips leading whitespace when .innerHTML is used\n\tsupport.leadingWhitespace = div.firstChild.nodeType === 3;\n\n\t// Make sure that tbody elements aren't automatically inserted\n\t// IE will insert them into empty tables\n\tsupport.tbody = !div.getElementsByTagName( \"tbody\" ).length;\n\n\t// Make sure that link elements get serialized correctly by innerHTML\n\t// This requires a wrapper element in IE\n\tsupport.htmlSerialize = !!div.getElementsByTagName( \"link\" ).length;\n\n\t// Makes sure cloning an html5 element does not cause problems\n\t// Where outerHTML is undefined, this still works\n\tsupport.html5Clone =\n\t\tdocument.createElement( \"nav\" ).cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tinput.type = \"checkbox\";\n\tinput.checked = true;\n\tfragment.appendChild( input );\n\tsupport.appendChecked = input.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE6-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tfragment.appendChild( div );\n\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<9\n\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\tsupport.noCloneEvent = true;\n\tif ( div.attachEvent ) {\n\t\tdiv.attachEvent( \"onclick\", function() {\n\t\t\tsupport.noCloneEvent = false;\n\t\t});\n\n\t\tdiv.cloneNode( true ).click();\n\t}\n\n\t// Execute the test only if not already executed in another module.\n\tif (support.deleteExpando == null) {\n\t\t// Support: IE<9\n\t\tsupport.deleteExpando = true;\n\t\ttry {\n\t\t\tdelete div.test;\n\t\t} catch( e ) {\n\t\t\tsupport.deleteExpando = false;\n\t\t}\n\t}\n})();\n\n\n(function() {\n\tvar i, eventName,\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)\n\tfor ( i in { submit: true, change: true, focusin: true }) {\n\t\teventName = \"on\" + i;\n\n\t\tif ( !(support[ i + \"Bubbles\" ] = eventName in window) ) {\n\t\t\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\t\t\tdiv.setAttribute( eventName, \"t\" );\n\t\t\tsupport[ i + \"Bubbles\" ] = div.attributes[ eventName ].expando === false;\n\t\t}\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n})();\n\n\nvar rformElems = /^(?:input|select|textarea)$/i,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\t\tvar tmp, events, t, handleObjIn,\n\t\t\tspecial, eventHandle, handleObj,\n\t\t\thandlers, type, namespaces, origType,\n\t\t\telemData = jQuery._data( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\tvar j, handleObj, tmp,\n\t\t\torigCount, t, events,\n\t\t\tspecial, handlers, type,\n\t\t\tnamespaces, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\tvar handle, ontype, cur,\n\t\t\tbubbleType, special, tmp, i,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, ret, handleObj, matched, j,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar sel, handleObj, matches, i,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\t/* jshint eqeqeq: false */\n\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\t\t\t\t/* jshint eqeqeq: true */\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Fix target property (#1925)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Support: Chrome 23+, Safari?\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar body, eventDoc, doc,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === strundefined ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: IE < 9, Android < 4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If preventDefault exists, run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// Support: IE\n\t\t// Otherwise set the returnValue property of the original event to false\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// If stopPropagation exists, run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\n\t\t// Support: IE\n\t\t// Set the cancelBubble property of the original event to true\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// IE submit delegation\nif ( !support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submit_bubble ) {\n\t\t\t\tdelete event._submit_bubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !support.changeBubbles ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tjQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tjQuery._removeData( doc, fix );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery._data( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar type, origFn;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\t\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t_default: support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\t},\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\nfunction getAll( context, tag ) {\n\tvar elems, elem,\n\t\ti = 0,\n\t\tfound = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\tundefined;\n\n\tif ( !found ) {\n\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\tfound.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], found ) :\n\t\tfound;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n\tif ( rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (jQuery.find.attr( elem, \"type\" ) !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\tif ( match ) {\n\t\telem.type = match[1];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar elem,\n\t\ti = 0;\n\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n\tvar nodeName, e, data;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\tif ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\tdata = jQuery._data( dest );\n\n\t\tfor ( e in data.events ) {\n\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t}\n\n\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\tdest.removeAttribute( jQuery.expando );\n\t}\n\n\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdisableScript( dest ).text = src.text;\n\t\trestoreScript( dest );\n\n\t// IE6-10 improperly clones children of object elements using classid.\n\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t} else if ( nodeName === \"object\" ) {\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar destElements, node, clone, i, srcElements,\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\tif ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( (!support.noCloneEvent || !support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\t// Fix all IE cloning issues\n\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\tdestElements = srcElements = node = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar j, elem, contains,\n\t\t\ttmp, tag, tbody, wrap,\n\t\t\tl = elems.length,\n\n\t\t\t// Ensure a safe fragment\n\t\t\tsafe = createSafeFragment( context ),\n\n\t\t\tnodes = [],\n\t\t\ti = 0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = (rtagName.exec( elem ) || [ \"\", \"\" ])[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\tif ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\tif ( !support.tbody ) {\n\n\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t\t0;\n\n\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fix #11356: Clear elements from fragment\n\t\tif ( tmp ) {\n\t\t\tsafe.removeChild( tmp );\n\t\t}\n\n\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\tif ( !support.appendChecked ) {\n\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t\t}\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttmp = null;\n\n\t\treturn safe;\n\t},\n\n\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\tvar elem, type, id, data,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tdeleteExpando = support.deleteExpando,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== strundefined ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdeletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ (rtagName.exec( value ) || [ \"\", \"\" ])[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar first, node, hasScripts,\n\t\t\tscripts, doc, fragment,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[0],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[0] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[i], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\tfragment = first = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone(true);\n\t\t\tjQuery( insert[i] )[ original ]( elems );\n\n\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n\n(function() {\n\tvar shrinkWrapBlocksVal;\n\n\tsupport.shrinkWrapBlocks = function() {\n\t\tif ( shrinkWrapBlocksVal != null ) {\n\t\t\treturn shrinkWrapBlocksVal;\n\t\t}\n\n\t\t// Will be changed later if needed.\n\t\tshrinkWrapBlocksVal = false;\n\n\t\t// Minified: var b,c,d\n\t\tvar div, body, container;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t// Support: IE6\n\t\t// Check if elements with layout shrink-wrap their children\n\t\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t\t// Reset CSS: box-sizing; display; margin; border\n\t\t\tdiv.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;\" +\n\t\t\t\t\"padding:1px;width:1px;zoom:1\";\n\t\t\tdiv.appendChild( document.createElement( \"div\" ) ).style.width = \"5px\";\n\t\t\tshrinkWrapBlocksVal = div.offsetWidth !== 3;\n\t\t}\n\n\t\tbody.removeChild( container );\n\n\t\treturn shrinkWrapBlocksVal;\n\t};\n\n})();\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\n\n\nvar getStyles, curCSS,\n\trposition = /^(top|right|bottom|left)$/;\n\nif ( window.getComputedStyle ) {\n\tgetStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t\tif ( computed ) {\n\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\";\n\t};\n} else if ( document.documentElement.currentStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn elem.currentStyle;\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar left, rs, rsLeft, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\t\tret = computed ? computed[ name ] : undefined;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trs = elem.runtimeStyle;\n\t\t\trsLeft = rs && rs.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\" || \"auto\";\n\t};\n}\n\n\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tvar condition = conditionFn();\n\n\t\t\tif ( condition == null ) {\n\t\t\t\t// The test was not ready at this point; screw the hook this time\n\t\t\t\t// but check again when needed next time.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( condition ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t// remove it.\n\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\t// Minified: var b,c,d,e,f,g, h,i\n\tvar div, style, a, pixelPositionVal, boxSizingReliableVal,\n\t\treliableHiddenOffsetsVal, reliableMarginRightVal;\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\ta = div.getElementsByTagName( \"a\" )[ 0 ];\n\tstyle = a && a.style;\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !style ) {\n\t\treturn;\n\t}\n\n\tstyle.cssText = \"float:left;opacity:.5\";\n\n\t// Support: IE<9\n\t// Make sure that element opacity exists (as opposed to filter)\n\tsupport.opacity = style.opacity === \"0.5\";\n\n\t// Verify style float existence\n\t// (IE uses styleFloat instead of cssFloat)\n\tsupport.cssFloat = !!style.cssFloat;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Support: Firefox<29, Android 2.3\n\t// Vendor-prefix box-sizing\n\tsupport.boxSizing = style.boxSizing === \"\" || style.MozBoxSizing === \"\" ||\n\t\tstyle.WebkitBoxSizing === \"\";\n\n\tjQuery.extend(support, {\n\t\treliableHiddenOffsets: function() {\n\t\t\tif ( reliableHiddenOffsetsVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableHiddenOffsetsVal;\n\t\t},\n\n\t\tboxSizingReliable: function() {\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\n\t\tpixelPosition: function() {\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelPositionVal;\n\t\t},\n\n\t\t// Support: Android 2.3\n\t\treliableMarginRight: function() {\n\t\t\tif ( reliableMarginRightVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginRightVal;\n\t\t}\n\t});\n\n\tfunction computeStyleTests() {\n\t\t// Minified: var b,c,d,j\n\t\tvar div, body, container, contents;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\n\t\t// Support: IE<9\n\t\t// Assume reasonable values in the absence of getComputedStyle\n\t\tpixelPositionVal = boxSizingReliableVal = false;\n\t\treliableMarginRightVal = true;\n\n\t\t// Check for getComputedStyle so that this code is not run in IE<9.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tpixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tboxSizingReliableVal =\n\t\t\t\t( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tcontents = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\tcontents.style.cssText = div.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\tcontents.style.marginRight = contents.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\treliableMarginRightVal =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );\n\n\t\t\tdiv.removeChild( contents );\n\t\t}\n\n\t\t// Support: IE8\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\tcontents = div.getElementsByTagName( \"td\" );\n\t\tcontents[ 0 ].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\tif ( reliableHiddenOffsetsVal ) {\n\t\t\tcontents[ 0 ].style.display = \"\";\n\t\t\tcontents[ 1 ].style.display = \"none\";\n\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t}\n\n\t\tbody.removeChild( container );\n\t}\n\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n\t\t\t\t// Support: IE\n\t\t\t\t// Swallow errors from 'invalid' CSS values (#5509)\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar num, val, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tsupport.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\nif ( !support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = jQuery._data( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tjQuery._data( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !support.shrinkWrapBlocks() ) {\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = jQuery._data( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\t// Minified: var a,b,c,d,e\n\tvar input, div, select, a, opt;\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\n\t// First batch of tests.\n\tselect = document.createElement(\"select\");\n\topt = select.appendChild( document.createElement(\"option\") );\n\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\ta.style.cssText = \"top:1px\";\n\n\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\tsupport.getSetAttribute = div.className !== \"t\";\n\n\t// Get the style information from getAttribute\n\t// (IE uses .cssText instead)\n\tsupport.style = /top/.test( a.getAttribute(\"style\") );\n\n\t// Make sure that URLs aren't manipulated\n\t// (IE normalizes it by default)\n\tsupport.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\tsupport.checkOn = !!input.value;\n\n\t// Make sure that a selected-by-default option has a working selected property.\n\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\tsupport.optSelected = opt.selected;\n\n\t// Tests for enctype support on a form (#6743)\n\tsupport.enctype = !!document.createElement(\"form\").enctype;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE8 only\n\t// Check if we can trust getAttribute(\"value\")\n\tinput = document.createElement( \"input\" );\n\tinput.setAttribute( \"value\", \"\" );\n\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t// Check if an input maintains its value after becoming a radio\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\tif ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {\n\n\t\t\t\t\t\t// Support: IE6\n\t\t\t\t\t\t// When new option element is added to select box we need to\n\t\t\t\t\t\t// force reflow of newly added node in order to workaround delay\n\t\t\t\t\t\t// of initialization properties\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toption.selected = optionSet = true;\n\n\t\t\t\t\t\t} catch ( _ ) {\n\n\t\t\t\t\t\t\t// Will be executed only in IE6\n\t\t\t\t\t\t\toption.scrollHeight;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toption.selected = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\n\t\t\t\treturn options;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle,\n\truseDefault = /^(?:checked|selected)$/i,\n\tgetSetAttribute = support.getSetAttribute,\n\tgetSetInput = support.input;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\tif ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hook for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t// IE<8 needs the *property* name\n\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t} else {\n\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t}\n\n\t\treturn name;\n\t}\n};\n\n// Retrieve booleans specially\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n\t\tfunction( elem, name, isXML ) {\n\t\t\tvar ret, handle;\n\t\t\tif ( !isXML ) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t} :\n\t\tfunction( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n});\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n\tjQuery.attrHooks.value = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.defaultValue = value;\n\t\t\t} else {\n\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.value = value += \"\";\n\n\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\tif ( name === \"value\" || value === elem.getAttribute( name ) ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Some attributes are constructed with empty-string values when not defined\n\tattrHandle.id = attrHandle.name = attrHandle.coords =\n\t\tfunction( elem, name, isXML ) {\n\t\t\tvar ret;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn (ret = elem.getAttributeNode( name )) && ret.value !== \"\" ?\n\t\t\t\t\tret.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n\n\t// Fixing value retrieval on a button requires this module\n\tjQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( ret && ret.specified ) {\n\t\t\t\treturn ret.value;\n\t\t\t}\n\t\t},\n\t\tset: nodeHook.set\n\t};\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tset: function( elem, value, name ) {\n\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\nif ( !support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\treturn elem.style.cssText || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t}\n\t};\n}\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each(function() {\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch( e ) {}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\treturn tabindex ?\n\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !support.hrefNormalized ) {\n\t// href/src property should get the full normalized URL (#10299/#12915)\n\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\t\tjQuery.propHooks[ name ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t}\n\t\t};\n\t});\n}\n\n// Support: Safari, IE9+\n// mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// IE6/7 call enctype encoding\nif ( !support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\nvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\njQuery.parseJSON = function( data ) {\n\t// Attempt to parse using the native JSON parser first\n\tif ( window.JSON && window.JSON.parse ) {\n\t\t// Support: Android 2.3\n\t\t// Workaround failure to string-cast null input\n\t\treturn window.JSON.parse( data + \"\" );\n\t}\n\n\tvar requireNonComma,\n\t\tdepth = null,\n\t\tstr = jQuery.trim( data + \"\" );\n\n\t// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n\t// after removing valid tokens\n\treturn str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n\t\t// Force termination if we see a misplaced comma\n\t\tif ( requireNonComma && comma ) {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\t// Perform no more replacements after returning to outermost depth\n\t\tif ( depth === 0 ) {\n\t\t\treturn token;\n\t\t}\n\n\t\t// Commas must not follow \"[\", \"{\", or \",\"\n\t\trequireNonComma = open || comma;\n\n\t\t// Determine new depth\n\t\t// array/object open (\"[\" or \"{\"): depth += true - false (increment)\n\t\t// array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n\t\t// other cases (\",\" or primitive): depth += true - true (numeric cast)\n\t\tdepth += !close - !open;\n\n\t\t// Remove this token\n\t\treturn \"\";\n\t}) ) ?\n\t\t( Function( \"return \" + str ) )() :\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\ttry {\n\t\tif ( window.DOMParser ) { // Standard\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t} else { // IE\n\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\txml.async = \"false\";\n\t\t\txml.loadXML( data );\n\t\t}\n\t} catch( e ) {\n\t\txml = undefined;\n\t}\n\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType.charAt( 0 ) === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar deep, key,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\tvar firstDataType, ct, finalDataType, type,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\ttransport,\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function(i) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\t\t(!support.reliableHiddenOffsets() &&\n\t\t\t((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n};\n\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\t// Support: IE6+\n\tfunction() {\n\n\t\t// XHR cannot access local files, always use ActiveX for that case\n\t\treturn !this.isLocal &&\n\n\t\t\t// Support: IE7-8\n\t\t\t// oldIE XHR does not support non-RFC2616 methods (#13240)\n\t\t\t// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n\t\t\t// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n\t\t\t// Although this check for six methods instead of eight\n\t\t\t// since IE also does not support \"trace\" and \"connect\"\n\t\t\t/^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n\n\t\t\tcreateStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE<10\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t}\n\t});\n}\n\n// Determine support properties\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n\tjQuery.ajaxTransport(function( options ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !options.crossDomain || support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n\t\t\t\t\t\t// request header to a null-value.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// To keep consistent with other XHR implementations, cast the value\n\t\t\t\t\t\t// to string and ignore `undefined`.\n\t\t\t\t\t\tif ( headers[ i ] !== undefined ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] + \"\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( options.hasContent && options.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\tvar status, statusText, responses;\n\n\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\t\t\t\t\t\t\t// Clean up\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = undefined;\n\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\n\t\t\t\t\t\t\t// Abort manually if needed\n\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\tstatus = xhr.status;\n\n\t\t\t\t\t\t\t\t// Support: IE<10\n\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\tif ( !status && options.isLocal && !options.crossDomain ) {\n\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, xhr.getAllResponseHeaders() );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( !options.async ) {\n\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\tsetTimeout( callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add to the list of active xhr callbacks\n\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t} catch( e ) {}\n}\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\tscript.async = true;\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, response, type,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off, url.length ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\tjQuery.inArray(\"auto\", [ curCSSTop, curCSSLeft ] ) > -1;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ],\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ];\n\n\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery/dist/jquery.js\n ** module id = 1\n ** module chunks = 1 6 7 8\n **/","\"use strict\";\n\nvar $ = require('jquery');\nvar Highcharts = require('highcharts-commonjs');\n\nexports.display = function() {\n\n    var chartOptions = {\n        title: {\n            text: 'Monthly Average Temperature',\n            x: -20 //center\n        },\n        subtitle: {\n            text: 'Source: WorldClimate.com',\n            x: -20\n        },\n        xAxis: {\n            categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        },\n        yAxis: {\n            title: {\n                text: 'Temperature (C)'\n            },\n            plotLines: [{\n                value: 0,\n                width: 1,\n                color: '#808080'\n            }]\n        },\n        tooltip: {\n            valueSuffix: 'C'\n        },\n        legend: {\n            layout: 'vertical',\n            align: 'right',\n            verticalAlign: 'middle',\n            borderWidth: 0\n        },\n        series: [{\n            name: 'Tokyo',\n            data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6]\n        }, {\n            name: 'New York',\n            data: [-0.2, 0.8, 5.7, 11.3, 17.0, 22.0, 24.8, 24.1, 20.1, 14.1, 8.6, 2.5]\n        }, {\n            name: 'Berlin',\n            data: [-0.9, 0.6, 3.5, 8.4, 13.5, 17.0, 18.6, 17.9, 14.3, 9.0, 3.9, 1.0]\n        }, {\n            name: 'London',\n            data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8]\n        }]\n    };\n\n    Highcharts.createChart(\n        document.getElementById(\"container\"),\n        chartOptions\n    );\n\n\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/webpack_example/highcharts/highcharts-page.js\n ** module id = 9\n ** module chunks = 7\n **/","'use strict';\n\nvar Highcharts = require('./src/highcharts.src.js');\n\nmodule.exports = {\n  createChart: function(div, options, callback) {\n    options.chart = options.chart || {};\n    options.chart.renderTo = div;\n    return new Highcharts.Chart(options, callback);\n  },\n  destroy: function(chart) {\n    chart.destroy();\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/highcharts-commonjs/index.js\n ** module id = 20\n ** module chunks = 6 7\n **/","/*eslint-disable*/\n'use strict';\nvar jquery = require('jquery');\nvar Highcharts;\nvar HighchartsAdapter;\n\n// ==ClosureCompiler==\n// @compilation_level SIMPLE_OPTIMIZATIONS\n\n/**\n * @license Highcharts JS v4.1.4 (2015-03-10)\n *\n * (c) 2009-2014 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n// JSLint options:\n/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */\n/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */\n// encapsulated variables\nvar UNDEFINED,\n\tdoc = document,\n\twin = window,\n\tmath = Math,\n\tmathRound = math.round,\n\tmathFloor = math.floor,\n\tmathCeil = math.ceil,\n\tmathMax = math.max,\n\tmathMin = math.min,\n\tmathAbs = math.abs,\n\tmathCos = math.cos,\n\tmathSin = math.sin,\n\tmathPI = math.PI,\n\tdeg2rad = mathPI * 2 / 360,\n\n\n\t// some variables\n\tuserAgent = navigator.userAgent,\n\tisOpera = win.opera,\n\tisIE = /(msie|trident)/i.test(userAgent) && !isOpera,\n\tdocMode8 = doc.documentMode === 8,\n\tisWebKit = /AppleWebKit/.test(userAgent),\n\tisFirefox = /Firefox/.test(userAgent),\n\tisTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n\tSVG_NS = 'http://www.w3.org/2000/svg',\n\thasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n\thasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n\tuseCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,\n\tRenderer,\n\thasTouch,\n\tsymbolSizes = {},\n\tidCounter = 0,\n\tgarbageBin,\n\tdefaultOptions,\n\tdateFormat, // function\n\tglobalAnimation,\n\tpathAnim,\n\ttimeUnits,\n\tnoop = function () { return UNDEFINED; },\n\tcharts = [],\n\tchartCount = 0,\n\tPRODUCT = 'Highcharts',\n\tVERSION = '4.1.4',\n\n\t// some constants for frequently used strings\n\tDIV = 'div',\n\tABSOLUTE = 'absolute',\n\tRELATIVE = 'relative',\n\tHIDDEN = 'hidden',\n\tPREFIX = 'highcharts-',\n\tVISIBLE = 'visible',\n\tPX = 'px',\n\tNONE = 'none',\n\tM = 'M',\n\tL = 'L',\n\tnumRegex = /^[0-9]+$/,\n\tNORMAL_STATE = '',\n\tHOVER_STATE = 'hover',\n\tSELECT_STATE = 'select',\n\tmarginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n\t\n\t// Object for extending Axis\n\tAxisPlotLineOrBandExtension,\n\n\t// constants for attributes\n\tSTROKE_WIDTH = 'stroke-width',\n\n\t// time methods, changed based on whether or not UTC is used\n\tDate,  // Allow using a different Date class\n\tmakeTime,\n\ttimezoneOffset,\n\tgetTimezoneOffset,\n\tgetMinutes,\n\tgetHours,\n\tgetDay,\n\tgetDate,\n\tgetMonth,\n\tgetFullYear,\n\tsetMinutes,\n\tsetHours,\n\tsetDate,\n\tsetMonth,\n\tsetFullYear,\n\n\n\t// lookup over the types and the associated classes\n\tseriesTypes = {},\n\tHighcharts;\n\n// The Highcharts namespace\nHighcharts = {};\n\nHighcharts.seriesTypes = seriesTypes;\n\n/**\n * Extend an object with the members of another\n * @param {Object} a The object to be extended\n * @param {Object} b The object to add to the first one\n */\nvar extend = Highcharts.extend = function (a, b) {\n\tvar n;\n\tif (!a) {\n\t\ta = {};\n\t}\n\tfor (n in b) {\n\t\ta[n] = b[n];\n\t}\n\treturn a;\n};\n\t\n/**\n * Deep merge two or more objects and return a third object. If the first argument is\n * true, the contents of the second object is copied into the first object.\n * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n * it copied properties from extended prototypes. \n */\nfunction merge() {\n\tvar i,\n\t\targs = arguments,\n\t\tlen,\n\t\tret = {},\n\t\tdoCopy = function (copy, original) {\n\t\t\tvar value, key;\n\n\t\t\t// An object is replacing a primitive\n\t\t\tif (typeof copy !== 'object') {\n\t\t\t\tcopy = {};\n\t\t\t}\n\n\t\t\tfor (key in original) {\n\t\t\t\tif (original.hasOwnProperty(key)) {\n\t\t\t\t\tvalue = original[key];\n\n\t\t\t\t\t// Copy the contents of objects, but not arrays or DOM nodes\n\t\t\t\t\tif (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&\n\t\t\t\t\t\t\tkey !== 'renderTo' && typeof value.nodeType !== 'number') {\n\t\t\t\t\t\tcopy[key] = doCopy(copy[key] || {}, value);\n\t\t\t\t\n\t\t\t\t\t// Primitives and arrays are copied over directly\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcopy[key] = original[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn copy;\n\t\t};\n\n\t// If first argument is true, copy into the existing object. Used in setOptions.\n\tif (args[0] === true) {\n\t\tret = args[1];\n\t\targs = Array.prototype.slice.call(args, 2);\n\t}\n\n\t// For each argument, extend the return\n\tlen = args.length;\n\tfor (i = 0; i < len; i++) {\n\t\tret = doCopy(ret, args[i]);\n\t}\n\n\treturn ret;\n}\n\n/**\n * Shortcut for parseInt\n * @param {Object} s\n * @param {Number} mag Magnitude\n */\nfunction pInt(s, mag) {\n\treturn parseInt(s, mag || 10);\n}\n\n/**\n * Check for string\n * @param {Object} s\n */\nfunction isString(s) {\n\treturn typeof s === 'string';\n}\n\n/**\n * Check for object\n * @param {Object} obj\n */\nfunction isObject(obj) {\n\treturn obj && typeof obj === 'object';\n}\n\n/**\n * Check for array\n * @param {Object} obj\n */\nfunction isArray(obj) {\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n/**\n * Check for number\n * @param {Object} n\n */\nfunction isNumber(n) {\n\treturn typeof n === 'number';\n}\n\nfunction log2lin(num) {\n\treturn math.log(num) / math.LN10;\n}\nfunction lin2log(num) {\n\treturn math.pow(10, num);\n}\n\n/**\n * Remove last occurence of an item from an array\n * @param {Array} arr\n * @param {Mixed} item\n */\nfunction erase(arr, item) {\n\tvar i = arr.length;\n\twhile (i--) {\n\t\tif (arr[i] === item) {\n\t\t\tarr.splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//return arr;\n}\n\n/**\n * Returns true if the object is not null or undefined. Like MooTools' $.defined.\n * @param {Object} obj\n */\nfunction defined(obj) {\n\treturn obj !== UNDEFINED && obj !== null;\n}\n\n/**\n * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n * it attempts to set expando properties on the SVG element, which is not allowed.\n *\n * @param {Object} elem The DOM element to receive the attribute(s)\n * @param {String|Object} prop The property or an abject of key-value pairs\n * @param {String} value The value if a single property is set\n */\nfunction attr(elem, prop, value) {\n\tvar key,\n\t\tret;\n\n\t// if the prop is a string\n\tif (isString(prop)) {\n\t\t// set the value\n\t\tif (defined(value)) {\n\t\t\telem.setAttribute(prop, value);\n\n\t\t// get the value\n\t\t} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n\t\t\tret = elem.getAttribute(prop);\n\t\t}\n\n\t// else if prop is defined, it is a hash of key/value pairs\n\t} else if (defined(prop) && isObject(prop)) {\n\t\tfor (key in prop) {\n\t\t\telem.setAttribute(key, prop[key]);\n\t\t}\n\t}\n\treturn ret;\n}\n/**\n * Check if an element is an array, and if not, make it into an array. Like\n * MooTools' $.splat.\n */\nfunction splat(obj) {\n\treturn isArray(obj) ? obj : [obj];\n}\n\n\n/**\n * Return the first value that is defined. Like MooTools' $.pick.\n */\nvar pick = Highcharts.pick = function () {\n\tvar args = arguments,\n\t\ti,\n\t\targ,\n\t\tlength = args.length;\n\tfor (i = 0; i < length; i++) {\n\t\targ = args[i];\n\t\tif (arg !== UNDEFINED && arg !== null) {\n\t\t\treturn arg;\n\t\t}\n\t}\n};\n\n/**\n * Set CSS on a given element\n * @param {Object} el\n * @param {Object} styles Style object with camel case property names\n */\nfunction css(el, styles) {\n\tif (isIE && !hasSVG) { // #2686\n\t\tif (styles && styles.opacity !== UNDEFINED) {\n\t\t\tstyles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n\t\t}\n\t}\n\textend(el.style, styles);\n}\n\n/**\n * Utility function to create element with attributes and styles\n * @param {Object} tag\n * @param {Object} attribs\n * @param {Object} styles\n * @param {Object} parent\n * @param {Object} nopad\n */\nfunction createElement(tag, attribs, styles, parent, nopad) {\n\tvar el = doc.createElement(tag);\n\tif (attribs) {\n\t\textend(el, attribs);\n\t}\n\tif (nopad) {\n\t\tcss(el, {padding: 0, border: NONE, margin: 0});\n\t}\n\tif (styles) {\n\t\tcss(el, styles);\n\t}\n\tif (parent) {\n\t\tparent.appendChild(el);\n\t}\n\treturn el;\n}\n\n/**\n * Extend a prototyped class by new members\n * @param {Object} parent\n * @param {Object} members\n */\nfunction extendClass(parent, members) {\n\tvar object = function () { return UNDEFINED; };\n\tobject.prototype = new parent();\n\textend(object.prototype, members);\n\treturn object;\n}\n\n/**\n * Pad a string to a given length by adding 0 to the beginning\n * @param {Number} number\n * @param {Number} length\n */\nfunction pad(number, length) {\n\t// Create an array of the remaining length +1 and join it with 0's\n\treturn new Array((length || 2) + 1 - String(number).length).join(0) + number;\n}\n\n/**\n * Wrap a method with extended functionality, preserving the original function\n * @param {Object} obj The context object that the method belongs to \n * @param {String} method The name of the method to extend\n * @param {Function} func A wrapper function callback. This function is called with the same arguments\n * as the original function, except that the original function is unshifted and passed as the first \n * argument. \n */\nvar wrap = Highcharts.wrap = function (obj, method, func) {\n\tvar proceed = obj[method];\n\tobj[method] = function () {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\targs.unshift(proceed);\n\t\treturn func.apply(this, args);\n\t};\n};\n\n\nfunction getTZOffset(timestamp) {\n\treturn ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;\n}\n\n/**\n * Based on http://www.php.net/manual/en/function.strftime.php\n * @param {String} format\n * @param {Number} timestamp\n * @param {Boolean} capitalize\n */\ndateFormat = function (format, timestamp, capitalize) {\n\tif (!defined(timestamp) || isNaN(timestamp)) {\n\t\treturn 'Invalid date';\n\t}\n\tformat = pick(format, '%Y-%m-%d %H:%M:%S');\n\n\tvar date = new Date(timestamp - getTZOffset(timestamp)),\n\t\tkey, // used in for constuct below\n\t\t// get the basic time values\n\t\thours = date[getHours](),\n\t\tday = date[getDay](),\n\t\tdayOfMonth = date[getDate](),\n\t\tmonth = date[getMonth](),\n\t\tfullYear = date[getFullYear](),\n\t\tlang = defaultOptions.lang,\n\t\tlangWeekdays = lang.weekdays,\n\n\t\t// List all format keys. Custom formats can be added from the outside. \n\t\treplacements = extend({\n\n\t\t\t// Day\n\t\t\t'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n\t\t\t'A': langWeekdays[day], // Long weekday, like 'Monday'\n\t\t\t'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n\t\t\t'e': dayOfMonth, // Day of the month, 1 through 31\n\t\t\t'w': day,\n\n\t\t\t// Week (none implemented)\n\t\t\t//'W': weekNumber(),\n\n\t\t\t// Month\n\t\t\t'b': lang.shortMonths[month], // Short month, like 'Jan'\n\t\t\t'B': lang.months[month], // Long month, like 'January'\n\t\t\t'm': pad(month + 1), // Two digit month number, 01 through 12\n\n\t\t\t// Year\n\t\t\t'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n\t\t\t'Y': fullYear, // Four digits year, like 2009\n\n\t\t\t// Time\n\t\t\t'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n\t\t\t'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n\t\t\t'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n\t\t\t'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n\t\t\t'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n\t\t\t'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n\t\t\t'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n\t\t\t'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n\t\t}, Highcharts.dateFormats);\n\n\n\t// do the replaces\n\tfor (key in replacements) {\n\t\twhile (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n\t\t\tformat = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n\t\t}\n\t}\n\n\t// Optionally capitalize the string and return\n\treturn capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n};\n\n/** \n * Format a single variable. Similar to sprintf, without the % prefix.\n */\nfunction formatSingle(format, val) {\n\tvar floatRegex = /f$/,\n\t\tdecRegex = /\\.([0-9])/,\n\t\tlang = defaultOptions.lang,\n\t\tdecimals;\n\n\tif (floatRegex.test(format)) { // float\n\t\tdecimals = format.match(decRegex);\n\t\tdecimals = decimals ? decimals[1] : -1;\n\t\tif (val !== null) {\n\t\t\tval = Highcharts.numberFormat(\n\t\t\t\tval,\n\t\t\t\tdecimals,\n\t\t\t\tlang.decimalPoint,\n\t\t\t\tformat.indexOf(',') > -1 ? lang.thousandsSep : ''\n\t\t\t);\n\t\t}\n\t} else {\n\t\tval = dateFormat(format, val);\n\t}\n\treturn val;\n}\n\n/**\n * Format a string according to a subset of the rules of Python's String.format method.\n */\nfunction format(str, ctx) {\n\tvar splitter = '{',\n\t\tisInside = false,\n\t\tsegment,\n\t\tvalueAndFormat,\n\t\tpath,\n\t\ti,\n\t\tlen,\n\t\tret = [],\n\t\tval,\n\t\tindex;\n\t\n\twhile ((index = str.indexOf(splitter)) !== -1) {\n\t\t\n\t\tsegment = str.slice(0, index);\n\t\tif (isInside) { // we're on the closing bracket looking back\n\t\t\t\n\t\t\tvalueAndFormat = segment.split(':');\n\t\t\tpath = valueAndFormat.shift().split('.'); // get first and leave format\n\t\t\tlen = path.length;\n\t\t\tval = ctx;\n\n\t\t\t// Assign deeper paths\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tval = val[path[i]];\n\t\t\t}\n\n\t\t\t// Format the replacement\n\t\t\tif (valueAndFormat.length) {\n\t\t\t\tval = formatSingle(valueAndFormat.join(':'), val);\n\t\t\t}\n\n\t\t\t// Push the result and advance the cursor\n\t\t\tret.push(val);\n\t\t\t\n\t\t} else {\n\t\t\tret.push(segment);\n\t\t\t\n\t\t}\n\t\tstr = str.slice(index + 1); // the rest\n\t\tisInside = !isInside; // toggle\n\t\tsplitter = isInside ? '}' : '{'; // now look for next matching bracket\n\t}\n\tret.push(str);\n\treturn ret.join('');\n}\n\n/**\n * Get the magnitude of a number\n */\nfunction getMagnitude(num) {\n\treturn math.pow(10, mathFloor(math.log(num) / math.LN10));\n}\n\n/**\n * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n * @param {Number} interval\n * @param {Array} multiples\n * @param {Number} magnitude\n * @param {Object} options\n */\nfunction normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {\n\tvar normalized, \n\t\ti,\n\t\tretInterval = interval;\n\n\t// round to a tenfold of 1, 2, 2.5 or 5\n\tmagnitude = pick(magnitude, 1);\n\tnormalized = interval / magnitude;\n\n\t// multiples for a linear scale\n\tif (!multiples) {\n\t\tmultiples = [1, 2, 2.5, 5, 10];\n\n\t\t// the allowDecimals option\n\t\tif (allowDecimals === false) {\n\t\t\tif (magnitude === 1) {\n\t\t\t\tmultiples = [1, 2, 5, 10];\n\t\t\t} else if (magnitude <= 0.1) {\n\t\t\t\tmultiples = [1 / magnitude];\n\t\t\t}\n\t\t}\n\t}\n\n\t// normalize the interval to the nearest multiple\n\tfor (i = 0; i < multiples.length; i++) {\n\t\tretInterval = multiples[i];\n\t\tif ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n\t\t\t(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// multiply back to the correct magnitude\n\tretInterval *= magnitude;\n\t\n\treturn retInterval;\n}\n\n\n/**\n * Utility method that sorts an object array and keeping the order of equal items.\n * ECMA script standard does not specify the behaviour when items are equal.\n */\nfunction stableSort(arr, sortFunction) {\n\tvar length = arr.length,\n\t\tsortValue,\n\t\ti;\n\n\t// Add index to each item\n\tfor (i = 0; i < length; i++) {\n\t\tarr[i].ss_i = i; // stable sort index\n\t}\n\n\tarr.sort(function (a, b) {\n\t\tsortValue = sortFunction(a, b);\n\t\treturn sortValue === 0 ? a.ss_i - b.ss_i : sortValue;\n\t});\n\n\t// Remove index from items\n\tfor (i = 0; i < length; i++) {\n\t\tdelete arr[i].ss_i; // stable sort index\n\t}\n}\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nfunction arrayMin(data) {\n\tvar i = data.length,\n\t\tmin = data[0];\n\n\twhile (i--) {\n\t\tif (data[i] < min) {\n\t\t\tmin = data[i];\n\t\t}\n\t}\n\treturn min;\n}\n\n/**\n * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n * method is slightly slower, but safe.\n */\nfunction arrayMax(data) {\n\tvar i = data.length,\n\t\tmax = data[0];\n\n\twhile (i--) {\n\t\tif (data[i] > max) {\n\t\t\tmax = data[i];\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n * It loops all properties and invokes destroy if there is a destroy method. The property is\n * then delete'ed.\n * @param {Object} The object to destroy properties on\n * @param {Object} Exception, do not destroy this property, only delete it.\n */\nfunction destroyObjectProperties(obj, except) {\n\tvar n;\n\tfor (n in obj) {\n\t\t// If the object is non-null and destroy is defined\n\t\tif (obj[n] && obj[n] !== except && obj[n].destroy) {\n\t\t\t// Invoke the destroy\n\t\t\tobj[n].destroy();\n\t\t}\n\n\t\t// Delete the property from the object.\n\t\tdelete obj[n];\n\t}\n}\n\n\n/**\n * Discard an element by moving it to the bin and delete\n * @param {Object} The HTML node to discard\n */\nfunction discardElement(element) {\n\t// create a garbage bin element, not part of the DOM\n\tif (!garbageBin) {\n\t\tgarbageBin = createElement(DIV);\n\t}\n\n\t// move the node and empty bin\n\tif (element) {\n\t\tgarbageBin.appendChild(element);\n\t}\n\tgarbageBin.innerHTML = '';\n}\n\n/**\n * Provide error messages for debugging, with links to online explanation \n */\nfunction error (code, stop) {\n\tvar msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n\tif (stop) {\n\t\tthrow msg;\n\t}\n\t// else ...\n\tif (win.console) {\n\t\tconsole.log(msg);\n\t}\n}\n\n/**\n * Fix JS round off float errors\n * @param {Number} num\n */\nfunction correctFloat(num) {\n\treturn parseFloat(\n\t\tnum.toPrecision(14)\n\t);\n}\n\n/**\n * Set the global animation to either a given value, or fall back to the\n * given chart's animation option\n * @param {Object} animation\n * @param {Object} chart\n */\nfunction setAnimation(animation, chart) {\n\tglobalAnimation = pick(animation, chart.animation);\n}\n\n/**\n * The time unit lookup\n */\ntimeUnits = {\n\tmillisecond: 1,\n\tsecond: 1000,\n\tminute: 60000,\n\thour: 3600000,\n\tday: 24 * 3600000,\n\tweek: 7 * 24 * 3600000,\n\tmonth: 28 * 24 * 3600000,\n\tyear: 364 * 24 * 3600000\n};\n\n\n/**\n * Format a number and return a string based on input settings\n * @param {Number} number The input number to format\n * @param {Number} decimals The amount of decimals\n * @param {String} decPoint The decimal point, defaults to the one given in the lang options\n * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n */\nHighcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {\n\tvar lang = defaultOptions.lang,\n\t\t// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/\n\t\tn = +number || 0,\n\t\tc = decimals === -1 ?\n\t\t\tmathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).\n\t\t\t(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),\n\t\td = decPoint === undefined ? lang.decimalPoint : decPoint,\n\t\tt = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,\n\t\ts = n < 0 ? \"-\" : \"\",\n\t\ti = String(pInt(n = mathAbs(n).toFixed(c))),\n\t\tj = i.length > 3 ? i.length % 3 : 0;\n\n\treturn (s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) +\n\t\t\t(c ? d + mathAbs(n - i).toFixed(c).slice(2) : \"\"));\n};\n/**\n * Path interpolation algorithm used across adapters\n */\npathAnim = {\n\t/**\n\t * Prepare start and end values so that the path can be animated one to one\n\t */\n\tinit: function (elem, fromD, toD) {\n\t\tfromD = fromD || '';\n\t\tvar shift = elem.shift,\n\t\t\tbezier = fromD.indexOf('C') > -1,\n\t\t\tnumParams = bezier ? 7 : 3,\n\t\t\tendLength,\n\t\t\tslice,\n\t\t\ti,\n\t\t\tstart = fromD.split(' '),\n\t\t\tend = [].concat(toD), // copy\n\t\t\tstartBaseLine,\n\t\t\tendBaseLine,\n\t\t\tsixify = function (arr) { // in splines make move points have six parameters like bezier curves\n\t\t\t\ti = arr.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (arr[i] === M) {\n\t\t\t\t\t\tarr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (bezier) {\n\t\t\tsixify(start);\n\t\t\tsixify(end);\n\t\t}\n\n\t\t// pull out the base lines before padding\n\t\tif (elem.isArea) {\n\t\t\tstartBaseLine = start.splice(start.length - 6, 6);\n\t\t\tendBaseLine = end.splice(end.length - 6, 6);\n\t\t}\n\n\t\t// if shifting points, prepend a dummy point to the end path\n\t\tif (shift <= end.length / numParams && start.length === end.length) {\n\t\t\twhile (shift--) {\n\t\t\t\tend = [].concat(end).splice(0, numParams).concat(end);\n\t\t\t}\n\t\t}\n\t\telem.shift = 0; // reset for following animations\n\n\t\t// copy and append last point until the length matches the end length\n\t\tif (start.length) {\n\t\t\tendLength = end.length;\n\t\t\twhile (start.length < endLength) {\n\n\t\t\t\t//bezier && sixify(start);\n\t\t\t\tslice = [].concat(start).splice(start.length - numParams, numParams);\n\t\t\t\tif (bezier) { // disable first control point\n\t\t\t\t\tslice[numParams - 6] = slice[numParams - 2];\n\t\t\t\t\tslice[numParams - 5] = slice[numParams - 1];\n\t\t\t\t}\n\t\t\t\tstart = start.concat(slice);\n\t\t\t}\n\t\t}\n\n\t\tif (startBaseLine) { // append the base lines for areas\n\t\t\tstart = start.concat(startBaseLine);\n\t\t\tend = end.concat(endBaseLine);\n\t\t}\n\t\treturn [start, end];\n\t},\n\n\t/**\n\t * Interpolate each value of the path and return the array\n\t */\n\tstep: function (start, end, pos, complete) {\n\t\tvar ret = [],\n\t\t\ti = start.length,\n\t\t\tstartVal;\n\n\t\tif (pos === 1) { // land on the final path without adjustment points appended in the ends\n\t\t\tret = complete;\n\n\t\t} else if (i === end.length && pos < 1) {\n\t\t\twhile (i--) {\n\t\t\t\tstartVal = parseFloat(start[i]);\n\t\t\t\tret[i] =\n\t\t\t\t\tisNaN(startVal) ? // a letter instruction like M or L\n\t\t\t\t\t\tstart[i] :\n\t\t\t\t\t\tpos * (parseFloat(end[i] - startVal)) + startVal;\n\n\t\t\t}\n\t\t} else { // if animation is finished or length not matching, land on right value\n\t\t\tret = end;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n(function ($) {\n\t/**\n\t * The default HighchartsAdapter for jQuery\n\t */\n\tHighchartsAdapter =  ($ && {\n\t\t\n\t\t/**\n\t\t * Initialize the adapter by applying some extensions to jQuery\n\t\t */\n\t\tinit: function (pathAnim) {\n\t\t\t\n\t\t\t// extend the animate function to allow SVG animations\n\t\t\tvar Fx = $.fx;\n\t\t\t\n\t\t\t/*jslint unparam: true*//* allow unused param x in this function */\n\t\t\t$.extend($.easing, {\n\t\t\t\teaseOutQuad: function (x, t, b, c, d) {\n\t\t\t\t\treturn -c * (t /= d) * (t - 2) + b;\n\t\t\t\t}\n\t\t\t});\n\t\t\t/*jslint unparam: false*/\n\t\t\n\t\t\t// extend some methods to check for elem.attr, which means it is a Highcharts SVG object\n\t\t\t$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {\n\t\t\t\tvar obj = Fx.step,\n\t\t\t\t\tbase;\n\t\t\t\t\t\n\t\t\t\t// Handle different parent objects\n\t\t\t\tif (fn === 'cur') {\n\t\t\t\t\tobj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype\n\t\t\t\t\n\t\t\t\t} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model\n\t\t\t\t\tobj = $.Tween.propHooks[fn];\n\t\t\t\t\tfn = 'set';\n\t\t\t\t}\n\t\t\n\t\t\t\t// Overwrite the method\n\t\t\t\tbase = obj[fn];\n\t\t\t\tif (base) { // step.width and step.height don't exist in jQuery < 1.7\n\t\t\n\t\t\t\t\t// create the extended function replacement\n\t\t\t\t\tobj[fn] = function (fx) {\n\n\t\t\t\t\t\tvar elem;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Fx.prototype.cur does not use fx argument\n\t\t\t\t\t\tfx = i ? fx : this;\n\n\t\t\t\t\t\t// Don't run animations on textual properties like align (#1821)\n\t\t\t\t\t\tif (fx.prop === 'align') {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t// shortcut\n\t\t\t\t\t\telem = fx.elem;\n\t\t\n\t\t\t\t\t\t// Fx.prototype.cur returns the current value. The other ones are setters\n\t\t\t\t\t\t// and returning a value has no effect.\n\t\t\t\t\t\treturn elem.attr ? // is SVG element wrapper\n\t\t\t\t\t\t\telem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method\n\t\t\t\t\t\t\tbase.apply(this, arguments); // use jQuery's built-in method\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+\n\t\t\twrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {\n\t\t\t\treturn elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);\n\t\t\t});\n\t\t\t\n\t\t\t// Define the setter function for d (path definitions)\n\t\t\tthis.addAnimSetter('d', function (fx) {\n\t\t\t\tvar elem = fx.elem,\n\t\t\t\t\tends;\n\t\t\n\t\t\t\t// Normally start and end should be set in state == 0, but sometimes,\n\t\t\t\t// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped\n\t\t\t\t// in these cases\n\t\t\t\tif (!fx.started) {\n\t\t\t\t\tends = pathAnim.init(elem, elem.d, elem.toD);\n\t\t\t\t\tfx.start = ends[0];\n\t\t\t\t\tfx.end = ends[1];\n\t\t\t\t\tfx.started = true;\n\t\t\t\t}\n\t\t\n\t\t\t\t// Interpolate each value of the path\n\t\t\t\telem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));\n\t\t\t});\n\t\t\t\n\t\t\t/**\n\t\t\t * Utility for iterating over an array. Parameters are reversed compared to jQuery.\n\t\t\t * @param {Array} arr\n\t\t\t * @param {Function} fn\n\t\t\t */\n\t\t\tthis.each = Array.prototype.forEach ?\n\t\t\t\tfunction (arr, fn) { // modern browsers\n\t\t\t\t\treturn Array.prototype.forEach.call(arr, fn);\n\t\t\t\t\t\n\t\t\t\t} : \n\t\t\t\tfunction (arr, fn) { // legacy\n\t\t\t\t\tvar i, \n\t\t\t\t\t\tlen = arr.length;\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fn.call(arr[i], arr[i], i, arr) === false) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Add an animation setter for a specific property\n\t\t */\n\t\taddAnimSetter: function (prop, setter) {\n\t\t\t// jQuery 1.8 style\n\t\t\tif ($.Tween) {\n\t\t\t\t$.Tween.propHooks[prop] = {\n\t\t\t\t\tset: setter\n\t\t\t\t};\n\t\t\t// pre 1.8\n\t\t\t} else {\n\t\t\t\t$.fx.step[prop] = setter;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Downloads a script and executes a callback when done.\n\t\t * @param {String} scriptLocation\n\t\t * @param {Function} callback\n\t\t */\n\t\tgetScript: $.getScript,\n\t\t\n\t\t/**\n\t\t * Return the index of an item in an array, or -1 if not found\n\t\t */\n\t\tinArray: $.inArray,\n\t\t\n\t\t/**\n\t\t * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.\n\t\t * @param {Object} elem The HTML element\n\t\t * @param {String} method Which method to run on the wrapped element\n\t\t */\n\t\tadapterRun: function (elem, method) {\n\t\t\treturn $(elem)[method]();\n\t\t},\n\t\n\t\t/**\n\t\t * Filter an array\n\t\t */\n\t\tgrep: $.grep,\n\t\n\t\t/**\n\t\t * Map an array\n\t\t * @param {Array} arr\n\t\t * @param {Function} fn\n\t\t */\n\t\tmap: function (arr, fn) {\n\t\t\t//return jQuery.map(arr, fn);\n\t\t\tvar results = [],\n\t\t\t\ti = 0,\n\t\t\t\tlen = arr.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tresults[i] = fn.call(arr[i], arr[i], i, arr);\n\t\t\t}\n\t\t\treturn results;\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Get the position of an element relative to the top left of the page\n\t\t */\n\t\toffset: function (el) {\n\t\t\treturn $(el).offset();\n\t\t},\n\t\n\t\t/**\n\t\t * Add an event listener\n\t\t * @param {Object} el A HTML element or custom object\n\t\t * @param {String} event The event type\n\t\t * @param {Function} fn The event handler\n\t\t */\n\t\taddEvent: function (el, event, fn) {\n\t\t\t$(el).bind(event, fn);\n\t\t},\n\t\n\t\t/**\n\t\t * Remove event added with addEvent\n\t\t * @param {Object} el The object\n\t\t * @param {String} eventType The event type. Leave blank to remove all events.\n\t\t * @param {Function} handler The function to remove\n\t\t */\n\t\tremoveEvent: function (el, eventType, handler) {\n\t\t\t// workaround for jQuery issue with unbinding custom events:\n\t\t\t// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2\n\t\t\tvar func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';\n\t\t\tif (doc[func] && el && !el[func]) {\n\t\t\t\tel[func] = function () {};\n\t\t\t}\n\t\n\t\t\t$(el).unbind(eventType, handler);\n\t\t},\n\t\n\t\t/**\n\t\t * Fire an event on a custom object\n\t\t * @param {Object} el\n\t\t * @param {String} type\n\t\t * @param {Object} eventArguments\n\t\t * @param {Function} defaultFunction\n\t\t */\n\t\tfireEvent: function (el, type, eventArguments, defaultFunction) {\n\t\t\tvar event = $.Event(type),\n\t\t\t\tdetachedType = 'detached' + type,\n\t\t\t\tdefaultPrevented;\n\t\n\t\t\t// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts\n\t\t\t// never uses these properties, Chrome includes them in the default click event and\n\t\t\t// raises the warning when they are copied over in the extend statement below.\n\t\t\t//\n\t\t\t// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid\n\t\t\t// testing if they are there (warning in chrome) the only option is to test if running IE.\n\t\t\tif (!isIE && eventArguments) {\n\t\t\t\tdelete eventArguments.layerX;\n\t\t\t\tdelete eventArguments.layerY;\n\t\t\t\tdelete eventArguments.returnValue;\n\t\t\t}\n\t\n\t\t\textend(event, eventArguments);\n\t\n\t\t\t// Prevent jQuery from triggering the object method that is named the\n\t\t\t// same as the event. For example, if the event is 'select', jQuery\n\t\t\t// attempts calling el.select and it goes into a loop.\n\t\t\tif (el[type]) {\n\t\t\t\tel[detachedType] = el[type];\n\t\t\t\tel[type] = null;\n\t\t\t}\n\t\n\t\t\t// Wrap preventDefault and stopPropagation in try/catch blocks in\n\t\t\t// order to prevent JS errors when cancelling events on non-DOM\n\t\t\t// objects. #615.\n\t\t\t/*jslint unparam: true*/\n\t\t\t$.each(['preventDefault', 'stopPropagation'], function (i, fn) {\n\t\t\t\tvar base = event[fn];\n\t\t\t\tevent[fn] = function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbase.call(event);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (fn === 'preventDefault') {\n\t\t\t\t\t\t\tdefaultPrevented = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\t/*jslint unparam: false*/\n\t\n\t\t\t// trigger it\n\t\t\t$(el).trigger(event);\n\t\n\t\t\t// attach the method\n\t\t\tif (el[detachedType]) {\n\t\t\t\tel[type] = el[detachedType];\n\t\t\t\tel[detachedType] = null;\n\t\t\t}\n\t\n\t\t\tif (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {\n\t\t\t\tdefaultFunction(event);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extension method needed for MooTools\n\t\t */\n\t\twashMouseEvent: function (e) {\n\t\t\tvar ret = e.originalEvent || e;\n\t\t\t\n\t\t\t// computed by jQuery, needed by IE8\n\t\t\tif (ret.pageX === UNDEFINED) { // #1236\n\t\t\t\tret.pageX = e.pageX;\n\t\t\t\tret.pageY = e.pageY;\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t},\n\t\n\t\t/**\n\t\t * Animate a HTML element or SVG element wrapper\n\t\t * @param {Object} el\n\t\t * @param {Object} params\n\t\t * @param {Object} options jQuery-like animation options: duration, easing, callback\n\t\t */\n\t\tanimate: function (el, params, options) {\n\t\t\tvar $el = $(el);\n\t\t\tif (!el.style) {\n\t\t\t\tel.style = {}; // #1881\n\t\t\t}\n\t\t\tif (params.d) {\n\t\t\t\tel.toD = params.d; // keep the array form for paths, used in $.fx.step.d\n\t\t\t\tparams.d = 1; // because in jQuery, animating to an array has a different meaning\n\t\t\t}\n\t\n\t\t\t$el.stop();\n\t\t\tif (params.opacity !== UNDEFINED && el.attr) {\n\t\t\t\tparams.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)\n\t\t\t}\n\t\t\tel.hasAnim = 1; // #3342\n\t\t\t$el.animate(params, options);\n\t\n\t\t},\n\t\t/**\n\t\t * Stop running animation\n\t\t */\n\t\tstop: function (el) {\n\t\t\tif (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy\n\t\t\t\t$(el).stop();\n\t\t\t}\n\t\t}\n\t});\n}(jquery));\n\n\n// check for a custom HighchartsAdapter defined prior to this file\nvar globalAdapter = HighchartsAdapter,\n\tadapter = globalAdapter || {};\n\t\n// Initialize the adapter\nif (globalAdapter) {\n\tglobalAdapter.init.call(globalAdapter, pathAnim);\n}\n\n\n// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object\n// and all the utility functions will be null. In that case they are populated by the\n// default adapters below.\nvar adapterRun = adapter.adapterRun,\n\tgetScript = adapter.getScript,\n\tinArray = adapter.inArray,\n\teach = Highcharts.each = adapter.each,\n\tgrep = adapter.grep,\n\toffset = adapter.offset,\n\tmap = adapter.map,\n\taddEvent = adapter.addEvent,\n\tremoveEvent = adapter.removeEvent,\n\tfireEvent = adapter.fireEvent,\n\twashMouseEvent = adapter.washMouseEvent,\n\tanimate = adapter.animate,\n\tstop = adapter.stop;\n\n\n\n/* ****************************************************************************\n * Handle the options                                                         *\n *****************************************************************************/\ndefaultOptions = {\n\tcolors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', \n\t\t    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n\tsymbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n\tlang: {\n\t\tloading: 'Loading...',\n\t\tmonths: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n\t\t\t\t'August', 'September', 'October', 'November', 'December'],\n\t\tshortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n\t\tweekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n\t\tdecimalPoint: '.',\n\t\tnumericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n\t\tresetZoom: 'Reset zoom',\n\t\tresetZoomTitle: 'Reset zoom level 1:1',\n\t\tthousandsSep: ' '\n\t},\n\tglobal: {\n\t\tuseUTC: true,\n\t\t//timezoneOffset: 0,\n\t\tcanvasToolsURL: 'http://code.highcharts.com/4.1.4/modules/canvas-tools.js',\n\t\tVMLRadialGradientURL: 'http://code.highcharts.com/4.1.4/gfx/vml-radial-gradient.png'\n\t},\n\tchart: {\n\t\t//animation: true,\n\t\t//alignTicks: false,\n\t\t//reflow: true,\n\t\t//className: null,\n\t\t//events: { load, selection },\n\t\t//margin: [null],\n\t\t//marginTop: null,\n\t\t//marginRight: null,\n\t\t//marginBottom: null,\n\t\t//marginLeft: null,\n\t\tborderColor: '#4572A7',\n\t\t//borderWidth: 0,\n\t\tborderRadius: 0,\n\t\tdefaultSeriesType: 'line',\n\t\tignoreHiddenSeries: true,\n\t\t//inverted: false,\n\t\t//shadow: false,\n\t\tspacing: [10, 10, 15, 10],\n\t\t//spacingTop: 10,\n\t\t//spacingRight: 10,\n\t\t//spacingBottom: 15,\n\t\t//spacingLeft: 10,\n\t\t//style: {\n\t\t//\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n\t\t//\tfontSize: '12px'\n\t\t//},\n\t\tbackgroundColor: '#FFFFFF',\n\t\t//plotBackgroundColor: null,\n\t\tplotBorderColor: '#C0C0C0',\n\t\t//plotBorderWidth: 0,\n\t\t//plotShadow: false,\n\t\t//zoomType: ''\n\t\tresetZoomButton: {\n\t\t\ttheme: {\n\t\t\t\tzIndex: 20\n\t\t\t},\n\t\t\tposition: {\n\t\t\t\talign: 'right',\n\t\t\t\tx: -10,\n\t\t\t\t//verticalAlign: 'top',\n\t\t\t\ty: 10\n\t\t\t}\n\t\t\t// relativeTo: 'plot'\n\t\t}\n\t},\n\ttitle: {\n\t\ttext: 'Chart title',\n\t\talign: 'center',\n\t\t// floating: false,\n\t\tmargin: 15,\n\t\t// x: 0,\n\t\t// verticalAlign: 'top',\n\t\t// y: null,\n\t\tstyle: {\n\t\t\tcolor: '#333333',\n\t\t\tfontSize: '18px'\n\t\t}\n\n\t},\n\tsubtitle: {\n\t\ttext: '',\n\t\talign: 'center',\n\t\t// floating: false\n\t\t// x: 0,\n\t\t// verticalAlign: 'top',\n\t\t// y: null,\n\t\tstyle: {\n\t\t\tcolor: '#555555'\n\t\t}\n\t},\n\n\tplotOptions: {\n\t\tline: { // base series options\n\t\t\tallowPointSelect: false,\n\t\t\tshowCheckbox: false,\n\t\t\tanimation: {\n\t\t\t\tduration: 1000\n\t\t\t},\n\t\t\t//connectNulls: false,\n\t\t\t//cursor: 'default',\n\t\t\t//clip: true,\n\t\t\t//dashStyle: null,\n\t\t\t//enableMouseTracking: true,\n\t\t\tevents: {},\n\t\t\t//legendIndex: 0,\n\t\t\t//linecap: 'round',\n\t\t\tlineWidth: 2,\n\t\t\t//shadow: false,\n\t\t\t// stacking: null,\n\t\t\tmarker: {\n\t\t\t\t//enabled: true,\n\t\t\t\t//symbol: null,\n\t\t\t\tlineWidth: 0,\n\t\t\t\tradius: 4,\n\t\t\t\tlineColor: '#FFFFFF',\n\t\t\t\t//fillColor: null,\n\t\t\t\tstates: { // states for a single point\n\t\t\t\t\thover: {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tlineWidthPlus: 1,\n\t\t\t\t\t\tradiusPlus: 2\n\t\t\t\t\t},\n\t\t\t\t\tselect: {\n\t\t\t\t\t\tfillColor: '#FFFFFF',\n\t\t\t\t\t\tlineColor: '#000000',\n\t\t\t\t\t\tlineWidth: 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpoint: {\n\t\t\t\tevents: {}\n\t\t\t},\n\t\t\tdataLabels: {\n\t\t\t\talign: 'center',\n\t\t\t\t// defer: true,\n\t\t\t\t// enabled: false,\n\t\t\t\tformatter: function () {\n\t\t\t\t\treturn this.y === null ? '' : Highcharts.numberFormat(this.y, -1);\n\t\t\t\t},\n\t\t\t\tstyle: {\n\t\t\t\t\tcolor: 'contrast',\n\t\t\t\t\tfontSize: '11px',\n\t\t\t\t\tfontWeight: 'bold',\n\t\t\t\t\ttextShadow: '0 0 6px contrast, 0 0 3px contrast'\n\t\t\t\t},\n\t\t\t\tverticalAlign: 'bottom', // above singular point\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\t// backgroundColor: undefined,\n\t\t\t\t// borderColor: undefined,\n\t\t\t\t// borderRadius: undefined,\n\t\t\t\t// borderWidth: undefined,\n\t\t\t\tpadding: 5\n\t\t\t\t// shadow: false\n\t\t\t},\n\t\t\tcropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n\t\t\tpointRange: 0,\n\t\t\t//pointStart: 0,\n\t\t\t//pointInterval: 1,\n\t\t\t//showInLegend: null, // auto: true for standalone series, false for linked series\n\t\t\tstates: { // states for the entire series\n\t\t\t\thover: {\n\t\t\t\t\t//enabled: false,\n\t\t\t\t\tlineWidthPlus: 1,\n\t\t\t\t\tmarker: {\n\t\t\t\t\t\t// lineWidth: base + 1,\n\t\t\t\t\t\t// radius: base + 1\n\t\t\t\t\t},\n\t\t\t\t\thalo: {\n\t\t\t\t\t\tsize: 10,\n\t\t\t\t\t\topacity: 0.25\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tselect: {\n\t\t\t\t\tmarker: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tstickyTracking: true,\n\t\t\t//tooltip: {\n\t\t\t\t//pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b>'\n\t\t\t\t//valueDecimals: null,\n\t\t\t\t//xDateFormat: '%A, %b %e, %Y',\n\t\t\t\t//valuePrefix: '',\n\t\t\t\t//ySuffix: ''\t\t\t\t\n\t\t\t//}\n\t\t\tturboThreshold: 1000\n\t\t\t// zIndex: null\n\t\t}\n\t},\n\tlabels: {\n\t\t//items: [],\n\t\tstyle: {\n\t\t\t//font: defaultFont,\n\t\t\tposition: ABSOLUTE,\n\t\t\tcolor: '#3E576F'\n\t\t}\n\t},\n\tlegend: {\n\t\tenabled: true,\n\t\talign: 'center',\n\t\t//floating: false,\n\t\tlayout: 'horizontal',\n\t\tlabelFormatter: function () {\n\t\t\treturn this.name;\n\t\t},\n\t\t//borderWidth: 0,\n\t\tborderColor: '#909090',\n\t\tborderRadius: 0,\n\t\tnavigation: {\n\t\t\t// animation: true,\n\t\t\tactiveColor: '#274b6d',\n\t\t\t// arrowSize: 12\n\t\t\tinactiveColor: '#CCC'\n\t\t\t// style: {} // text styles\n\t\t},\n\t\t// margin: 20,\n\t\t// reversed: false,\n\t\tshadow: false,\n\t\t// backgroundColor: null,\n\t\t/*style: {\n\t\t\tpadding: '5px'\n\t\t},*/\n\t\titemStyle: {\t\t\t\n\t\t\tcolor: '#333333',\n\t\t\tfontSize: '12px',\n\t\t\tfontWeight: 'bold'\n\t\t},\n\t\titemHoverStyle: {\n\t\t\t//cursor: 'pointer', removed as of #601\n\t\t\tcolor: '#000'\n\t\t},\n\t\titemHiddenStyle: {\n\t\t\tcolor: '#CCC'\n\t\t},\n\t\titemCheckboxStyle: {\n\t\t\tposition: ABSOLUTE,\n\t\t\twidth: '13px', // for IE precision\n\t\t\theight: '13px'\n\t\t},\n\t\t// itemWidth: undefined,\n\t\t// symbolRadius: 0,\n\t\t// symbolWidth: 16,\n\t\tsymbolPadding: 5,\n\t\tverticalAlign: 'bottom',\n\t\t// width: undefined,\n\t\tx: 0,\n\t\ty: 0,\n\t\ttitle: {\n\t\t\t//text: null,\n\t\t\tstyle: {\n\t\t\t\tfontWeight: 'bold'\n\t\t\t}\n\t\t}\t\t\t\n\t},\n\n\tloading: {\n\t\t// hideDuration: 100,\n\t\tlabelStyle: {\n\t\t\tfontWeight: 'bold',\n\t\t\tposition: RELATIVE,\n\t\t\ttop: '45%'\n\t\t},\n\t\t// showDuration: 0,\n\t\tstyle: {\n\t\t\tposition: ABSOLUTE,\n\t\t\tbackgroundColor: 'white',\n\t\t\topacity: 0.5,\n\t\t\ttextAlign: 'center'\n\t\t}\n\t},\n\n\ttooltip: {\n\t\tenabled: true,\n\t\tanimation: hasSVG,\n\t\t//crosshairs: null,\n\t\tbackgroundColor: 'rgba(249, 249, 249, .85)',\n\t\tborderWidth: 1,\n\t\tborderRadius: 3,\n\t\tdateTimeLabelFormats: { \n\t\t\tmillisecond: '%A, %b %e, %H:%M:%S.%L',\n\t\t\tsecond: '%A, %b %e, %H:%M:%S',\n\t\t\tminute: '%A, %b %e, %H:%M',\n\t\t\thour: '%A, %b %e, %H:%M',\n\t\t\tday: '%A, %b %e, %Y',\n\t\t\tweek: 'Week from %A, %b %e, %Y',\n\t\t\tmonth: '%B %Y',\n\t\t\tyear: '%Y'\n\t\t},\n\t\tfooterFormat: '',\n\t\t//formatter: defaultFormatter,\n\t\theaderFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n\t\tpointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n\t\tshadow: true,\n\t\t//shape: 'callout',\n\t\t//shared: false,\n\t\tsnap: isTouchDevice ? 25 : 10,\n\t\tstyle: {\n\t\t\tcolor: '#333333',\n\t\t\tcursor: 'default',\n\t\t\tfontSize: '12px',\n\t\t\tpadding: '8px',\n\t\t\twhiteSpace: 'nowrap'\n\t\t}\n\t\t//xDateFormat: '%A, %b %e, %Y',\n\t\t//valueDecimals: null,\n\t\t//valuePrefix: '',\n\t\t//valueSuffix: ''\n\t},\n\n\tcredits: {\n\t\tenabled: true,\n\t\ttext: 'Highcharts.com',\n\t\thref: 'http://www.highcharts.com',\n\t\tposition: {\n\t\t\talign: 'right',\n\t\t\tx: -10,\n\t\t\tverticalAlign: 'bottom',\n\t\t\ty: -5\n\t\t},\n\t\tstyle: {\n\t\t\tcursor: 'pointer',\n\t\t\tcolor: '#909090',\n\t\t\tfontSize: '9px'\n\t\t}\n\t}\n};\n\n\n\n\n// Series defaults\nvar defaultPlotOptions = defaultOptions.plotOptions,\n\tdefaultSeriesOptions = defaultPlotOptions.line;\n\n// set the default time methods\nsetTimeMethods();\n\n\n\n/**\n * Set the time methods globally based on the useUTC option. Time method can be either\n * local time or UTC (default).\n */\nfunction setTimeMethods() {\n\tvar globalOptions = defaultOptions.global,\n\t\tuseUTC = globalOptions.useUTC,\n\t\tGET = useUTC ? 'getUTC' : 'get',\n\t\tSET = useUTC ? 'setUTC' : 'set';\n\n\n\tDate = globalOptions.Date || window.Date;\n\ttimezoneOffset = useUTC && globalOptions.timezoneOffset;\n\tgetTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n\tmakeTime = function (year, month, date, hours, minutes, seconds) {\n\t\tvar d;\n\t\tif (useUTC) {\n\t\t\td = Date.UTC.apply(0, arguments);\n\t\t\td += getTZOffset(d);\n\t\t} else {\n\t\t\td = new Date(\n\t\t\t\tyear,\n\t\t\t\tmonth,\n\t\t\t\tpick(date, 1),\n\t\t\t\tpick(hours, 0),\n\t\t\t\tpick(minutes, 0),\n\t\t\t\tpick(seconds, 0)\n\t\t\t).getTime();\n\t\t}\n\t\treturn d;\n\t};\n\tgetMinutes =  GET + 'Minutes';\n\tgetHours =    GET + 'Hours';\n\tgetDay =      GET + 'Day';\n\tgetDate =     GET + 'Date';\n\tgetMonth =    GET + 'Month';\n\tgetFullYear = GET + 'FullYear';\n\tsetMinutes =  SET + 'Minutes';\n\tsetHours =    SET + 'Hours';\n\tsetDate =     SET + 'Date';\n\tsetMonth =    SET + 'Month';\n\tsetFullYear = SET + 'FullYear';\n\n}\n\n/**\n * Merge the default options with custom options and return the new options structure\n * @param {Object} options The new custom options\n */\nfunction setOptions(options) {\n\t\n\t// Copy in the default options\n\tdefaultOptions = merge(true, defaultOptions, options);\n\t\n\t// Apply UTC\n\tsetTimeMethods();\n\n\treturn defaultOptions;\n}\n\n/**\n * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n * wasn't enough because the setOptions method created a new object.\n */\nfunction getOptions() {\n\treturn defaultOptions;\n}\n\n\n/**\n * Handle color operations. The object methods are chainable.\n * @param {String} input The input color in either rbga or hex format\n */\nvar rgbaRegEx = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n\thexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n\trgbRegEx = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/;\n\nvar Color = function (input) {\n\t// declare variables\n\tvar rgba = [], result, stops;\n\n\t/**\n\t * Parse the input color to rgba array\n\t * @param {String} input\n\t */\n\tfunction init(input) {\n\n\t\t// Gradients\n\t\tif (input && input.stops) {\n\t\t\tstops = map(input.stops, function (stop) {\n\t\t\t\treturn Color(stop[1]);\n\t\t\t});\n\n\t\t// Solid colors\n\t\t} else {\n\t\t\t// rgba\n\t\t\tresult = rgbaRegEx.exec(input);\n\t\t\tif (result) {\n\t\t\t\trgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n\t\t\t} else { \n\t\t\t\t// hex\n\t\t\t\tresult = hexRegEx.exec(input);\n\t\t\t\tif (result) {\n\t\t\t\t\trgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n\t\t\t\t} else {\n\t\t\t\t\t// rgb\n\t\t\t\t\tresult = rgbRegEx.exec(input);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\trgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\n\t}\n\t/**\n\t * Return the color a specified format\n\t * @param {String} format\n\t */\n\tfunction get(format) {\n\t\tvar ret;\n\n\t\tif (stops) {\n\t\t\tret = merge(input);\n\t\t\tret.stops = [].concat(ret.stops);\n\t\t\teach(stops, function (stop, i) {\n\t\t\t\tret.stops[i] = [ret.stops[i][0], stop.get(format)];\n\t\t\t});\n\n\t\t// it's NaN if gradient colors on a column chart\n\t\t} else if (rgba && !isNaN(rgba[0])) {\n\t\t\tif (format === 'rgb') {\n\t\t\t\tret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n\t\t\t} else if (format === 'a') {\n\t\t\t\tret = rgba[3];\n\t\t\t} else {\n\t\t\t\tret = 'rgba(' + rgba.join(',') + ')';\n\t\t\t}\n\t\t} else {\n\t\t\tret = input;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Brighten the color\n\t * @param {Number} alpha\n\t */\n\tfunction brighten(alpha) {\n\t\tif (stops) {\n\t\t\teach(stops, function (stop) {\n\t\t\t\tstop.brighten(alpha);\n\t\t\t});\n\t\t\n\t\t} else if (isNumber(alpha) && alpha !== 0) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\trgba[i] += pInt(alpha * 255);\n\n\t\t\t\tif (rgba[i] < 0) {\n\t\t\t\t\trgba[i] = 0;\n\t\t\t\t}\n\t\t\t\tif (rgba[i] > 255) {\n\t\t\t\t\trgba[i] = 255;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Set the color's opacity to a given alpha value\n\t * @param {Number} alpha\n\t */\n\tfunction setOpacity(alpha) {\n\t\trgba[3] = alpha;\n\t\treturn this;\n\t}\n\n\t// initialize: parse the input\n\tinit(input);\n\n\t// public methods\n\treturn {\n\t\tget: get,\n\t\tbrighten: brighten,\n\t\trgba: rgba,\n\t\tsetOpacity: setOpacity,\n\t\traw: input\n\t};\n};\n\n\n/**\n * A wrapper object for SVG elements\n */\nfunction SVGElement() {}\n\nSVGElement.prototype = {\n\t\n\t// Default base for animation\n\topacity: 1,\n\t// For labels, these CSS properties are applied to the <text> node directly\n\ttextProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', \n\t\t'lineHeight', 'width', 'textDecoration', 'textShadow'],\n\t\n\t/**\n\t * Initialize the SVG renderer\n\t * @param {Object} renderer\n\t * @param {String} nodeName\n\t */\n\tinit: function (renderer, nodeName) {\n\t\tvar wrapper = this;\n\t\twrapper.element = nodeName === 'span' ?\n\t\t\tcreateElement(nodeName) :\n\t\t\tdoc.createElementNS(SVG_NS, nodeName);\n\t\twrapper.renderer = renderer;\n\t},\n\t\n\t/**\n\t * Animate a given attribute\n\t * @param {Object} params\n\t * @param {Number} options The same options as in jQuery animation\n\t * @param {Function} complete Function to perform at the end of animation\n\t */\n\tanimate: function (params, options, complete) {\n\t\tvar animOptions = pick(options, globalAnimation, true);\n\t\tstop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n\t\tif (animOptions) {\n\t\t\tanimOptions = merge(animOptions, {}); //#2625\n\t\t\tif (complete) { // allows using a callback with the global animation without overwriting it\n\t\t\t\tanimOptions.complete = complete;\n\t\t\t}\n\t\t\tanimate(this, params, animOptions);\n\t\t} else {\n\t\t\tthis.attr(params);\n\t\t\tif (complete) {\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Build an SVG gradient out of a common JavaScript configuration object\n\t */\n\tcolorGradient: function (color, prop, elem) {\n\t\tvar renderer = this.renderer,\n\t\t\tcolorObject,\n\t\t\tgradName,\n\t\t\tgradAttr,\n\t\t\tgradients,\n\t\t\tgradientObject,\n\t\t\tstops,\n\t\t\tstopColor,\n\t\t\tstopOpacity,\n\t\t\tradialReference,\n\t\t\tn,\n\t\t\tid,\n\t\t\tkey = [];\n\n\t\t// Apply linear or radial gradients\n\t\tif (color.linearGradient) {\n\t\t\tgradName = 'linearGradient';\n\t\t} else if (color.radialGradient) {\n\t\t\tgradName = 'radialGradient';\n\t\t}\n\n\t\tif (gradName) {\n\t\t\tgradAttr = color[gradName];\n\t\t\tgradients = renderer.gradients;\n\t\t\tstops = color.stops;\n\t\t\tradialReference = elem.radialReference;\n\n\t\t\t// Keep < 2.2 kompatibility\n\t\t\tif (isArray(gradAttr)) {\n\t\t\t\tcolor[gradName] = gradAttr = {\n\t\t\t\t\tx1: gradAttr[0],\n\t\t\t\t\ty1: gradAttr[1],\n\t\t\t\t\tx2: gradAttr[2],\n\t\t\t\t\ty2: gradAttr[3],\n\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Correct the radial gradient for the radial reference system\n\t\t\tif (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n\t\t\t\tgradAttr = merge(gradAttr, {\n\t\t\t\t\tcx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n\t\t\t\t\tcy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n\t\t\t\t\tr: gradAttr.r * radialReference[2],\n\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Build the unique key to detect whether we need to create a new element (#1282)\n\t\t\tfor (n in gradAttr) {\n\t\t\t\tif (n !== 'id') {\n\t\t\t\t\tkey.push(n, gradAttr[n]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (n in stops) {\n\t\t\t\tkey.push(stops[n]);\n\t\t\t}\n\t\t\tkey = key.join(',');\n\n\t\t\t// Check if a gradient object with the same config object is created within this renderer\n\t\t\tif (gradients[key]) {\n\t\t\t\tid = gradients[key].attr('id');\n\n\t\t\t} else {\n\n\t\t\t\t// Set the id and create the element\n\t\t\t\tgradAttr.id = id = PREFIX + idCounter++;\n\t\t\t\tgradients[key] = gradientObject = renderer.createElement(gradName)\n\t\t\t\t\t.attr(gradAttr)\n\t\t\t\t\t.add(renderer.defs);\n\n\n\t\t\t\t// The gradient needs to keep a list of stops to be able to destroy them\n\t\t\t\tgradientObject.stops = [];\n\t\t\t\teach(stops, function (stop) {\n\t\t\t\t\tvar stopObject;\n\t\t\t\t\tif (stop[1].indexOf('rgba') === 0) {\n\t\t\t\t\t\tcolorObject = Color(stop[1]);\n\t\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t\t}\n\t\t\t\t\tstopObject = renderer.createElement('stop').attr({\n\t\t\t\t\t\toffset: stop[0],\n\t\t\t\t\t\t'stop-color': stopColor,\n\t\t\t\t\t\t'stop-opacity': stopOpacity\n\t\t\t\t\t}).add(gradientObject);\n\n\t\t\t\t\t// Add the stop element to the gradient\n\t\t\t\t\tgradientObject.stops.push(stopObject);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set the reference to the gradient object\n\t\t\telem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');\n\t\t} \n\t},\n\n\t/**\n\t * Apply a polyfill to the text-stroke CSS property, by copying the text element\n\t * and apply strokes to the copy.\n\t *\n\t * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color\n\t * TODO: \n\t * - update defaults\n\t */\n\tapplyTextShadow: function (textShadow) {\n\t\tvar elem = this.element,\n\t\t\ttspans,\n\t\t\thasContrast = textShadow.indexOf('contrast') !== -1,\n\t\t\t// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n\t\t\t// this again with new IE release. In exports, the rendering is passed to PhantomJS. \n\t\t\tsupports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);\n\n\t\t// When the text shadow is set to contrast, use dark stroke for light text and vice versa\n\t\tif (hasContrast) {\n\t\t\ttextShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n\t\t}\n\n\t\t/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n\t\tif (elem.textContent.indexOf('2.') === 0) {\n\t\t\telem.style['text-shadow'] = 'none';\n\t\t\tsupports = false;\n\t\t}\n\t\t// */\n\n\t\t// No reason to polyfill, we've got native support\n\t\tif (supports) {\n\t\t\tif (hasContrast) { // Apply the altered style\n\t\t\t\tcss(elem, {\n\t\t\t\t\ttextShadow: textShadow\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\n\t\t\tthis.fakeTS = true; // Fake text shadow\n\n\t\t\t// In order to get the right y position of the clones, \n\t\t\t// copy over the y setter\n\t\t\tthis.ySetter = this.xSetter;\n\n\t\t\ttspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\t\t\teach(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n\t\t\t\tvar firstChild = elem.firstChild,\n\t\t\t\t\tcolor,\n\t\t\t\t\tstrokeWidth;\n\t\t\t\t\n\t\t\t\ttextShadow = textShadow.split(' ');\n\t\t\t\tcolor = textShadow[textShadow.length - 1];\n\n\t\t\t\t// Approximately tune the settings to the text-shadow behaviour\n\t\t\t\tstrokeWidth = textShadow[textShadow.length - 2];\n\n\t\t\t\tif (strokeWidth) {\n\t\t\t\t\teach(tspans, function (tspan, y) {\n\t\t\t\t\t\tvar clone;\n\n\t\t\t\t\t\t// Let the first line start at the correct X position\n\t\t\t\t\t\tif (y === 0) {\n\t\t\t\t\t\t\ttspan.setAttribute('x', elem.getAttribute('x'));\n\t\t\t\t\t\t\ty = elem.getAttribute('y');\n\t\t\t\t\t\t\ttspan.setAttribute('y', y || 0);\n\t\t\t\t\t\t\tif (y === null) {\n\t\t\t\t\t\t\t\telem.setAttribute('y', 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the clone and apply shadow properties\n\t\t\t\t\t\tclone = tspan.cloneNode(1);\n\t\t\t\t\t\tattr(clone, {\n\t\t\t\t\t\t\t'class': PREFIX + 'text-shadow',\n\t\t\t\t\t\t\t'fill': color,\n\t\t\t\t\t\t\t'stroke': color,\n\t\t\t\t\t\t\t'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),\n\t\t\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t\t\t});\n\t\t\t\t\t\telem.insertBefore(clone, firstChild);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Set or get a given attribute\n\t * @param {Object|String} hash\n\t * @param {Mixed|Undefined} val\n\t */\n\tattr: function (hash, val) {\n\t\tvar key,\n\t\t\tvalue,\n\t\t\telement = this.element,\n\t\t\thasSetSymbolSize,\n\t\t\tret = this,\n\t\t\tskipAttr;\n\n\t\t// single key-value pair\n\t\tif (typeof hash === 'string' && val !== UNDEFINED) {\n\t\t\tkey = hash;\n\t\t\thash = {};\n\t\t\thash[key] = val;\n\t\t}\n\n\t\t// used as a getter: first argument is a string, second is undefined\n\t\tif (typeof hash === 'string') {\n\t\t\tret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\t\t\n\t\t// setter\n\t\t} else {\n\n\t\t\tfor (key in hash) {\n\t\t\t\tvalue = hash[key];\n\t\t\t\tskipAttr = false;\n\n\n\n\t\t\t\tif (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n\t\t\t\t\tif (!hasSetSymbolSize) {\n\t\t\t\t\t\tthis.symbolAttr(hash);\n\t\t\t\t\t\thasSetSymbolSize = true;\n\t\t\t\t\t}\n\t\t\t\t\tskipAttr = true;\n\t\t\t\t}\n\n\t\t\t\tif (this.rotation && (key === 'x' || key === 'y')) {\n\t\t\t\t\tthis.doTransform = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!skipAttr) {\n\t\t\t\t\t(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);\n\t\t\t\t}\n\n\t\t\t\t// Let the shadow follow the main element\n\t\t\t\tif (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n\t\t\t\t\tthis.updateShadows(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update transform. Do this outside the loop to prevent redundant updating for batch setting\n\t\t\t// of attributes.\n\t\t\tif (this.doTransform) {\n\t\t\t\tthis.updateTransform();\n\t\t\t\tthis.doTransform = false;\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tupdateShadows: function (key, value) {\n\t\tvar shadows = this.shadows,\n\t\t\ti = shadows.length;\n\t\twhile (i--) {\n\t\t\tshadows[i].setAttribute(\n\t\t\t\tkey,\n\t\t\t\tkey === 'height' ?\n\t\t\t\t\tmathMax(value - (shadows[i].cutHeight || 0), 0) :\n\t\t\t\t\tkey === 'd' ? this.d : value\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t * Add a class name to an element\n\t */\n\taddClass: function (className) {\n\t\tvar element = this.element,\n\t\t\tcurrentClassName = attr(element, 'class') || '';\n\n\t\tif (currentClassName.indexOf(className) === -1) {\n\t\t\tattr(element, 'class', currentClassName + ' ' + className);\n\t\t}\n\t\treturn this;\n\t},\n\t/* hasClass and removeClass are not (yet) needed\n\thasClass: function (className) {\n\t\treturn attr(this.element, 'class').indexOf(className) !== -1;\n\t},\n\tremoveClass: function (className) {\n\t\tattr(this.element, 'class', attr(this.element, 'class').replace(className, ''));\n\t\treturn this;\n\t},\n\t*/\n\n\t/**\n\t * If one of the symbol size affecting parameters are changed,\n\t * check all the others only once for each call to an element's\n\t * .attr() method\n\t * @param {Object} hash\n\t */\n\tsymbolAttr: function (hash) {\n\t\tvar wrapper = this;\n\n\t\teach(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n\t\t\twrapper[key] = pick(hash[key], wrapper[key]);\n\t\t});\n\n\t\twrapper.attr({\n\t\t\td: wrapper.renderer.symbols[wrapper.symbolName](\n\t\t\t\twrapper.x,\n\t\t\t\twrapper.y,\n\t\t\t\twrapper.width,\n\t\t\t\twrapper.height,\n\t\t\t\twrapper\n\t\t\t)\n\t\t});\n\t},\n\n\t/**\n\t * Apply a clipping path to this object\n\t * @param {String} id\n\t */\n\tclip: function (clipRect) {\n\t\treturn this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n\t},\n\n\t/**\n\t * Calculate the coordinates needed for drawing a rectangle crisply and return the\n\t * calculated attributes\n\t * @param {Number} strokeWidth\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\tcrisp: function (rect) {\n\n\t\tvar wrapper = this,\n\t\t\tkey,\n\t\t\tattribs = {},\n\t\t\tnormalizer,\n\t\t\tstrokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;\n\n\t\tnormalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n\t\t// normalize for crisp edges\n\t\trect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;\n\t\trect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;\n\t\trect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);\n\t\trect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);\n\t\trect.strokeWidth = strokeWidth;\n\n\t\tfor (key in rect) {\n\t\t\tif (wrapper[key] !== rect[key]) { // only set attribute if changed\n\t\t\t\twrapper[key] = attribs[key] = rect[key];\n\t\t\t}\n\t\t}\n\n\t\treturn attribs;\n\t},\n\n\t/**\n\t * Set styles for the element\n\t * @param {Object} styles\n\t */\n\tcss: function (styles) {\n\t\tvar elemWrapper = this,\n\t\t\toldStyles = elemWrapper.styles,\n\t\t\tnewStyles = {},\n\t\t\telem = elemWrapper.element,\n\t\t\ttextWidth,\n\t\t\tn,\n\t\t\tserializedCss = '',\n\t\t\thyphenate,\n\t\t\thasNew = !oldStyles;\n\n\t\t// convert legacy\n\t\tif (styles && styles.color) {\n\t\t\tstyles.fill = styles.color;\n\t\t}\n\n\t\t// Filter out existing styles to increase performance (#2640)\n\t\tif (oldStyles) {\n\t\t\tfor (n in styles) {\n\t\t\t\tif (styles[n] !== oldStyles[n]) {\n\t\t\t\t\tnewStyles[n] = styles[n];\n\t\t\t\t\thasNew = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasNew) {\n\t\t\ttextWidth = elemWrapper.textWidth = \n\t\t\t\t(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || \n\t\t\t\telemWrapper.textWidth; // #3501\n\n\t\t\t// Merge the new styles with the old ones\n\t\t\tif (oldStyles) {\n\t\t\t\tstyles = extend(\n\t\t\t\t\toldStyles,\n\t\t\t\t\tnewStyles\n\t\t\t\t);\n\t\t\t}\t\t\n\n\t\t\t// store object\n\t\t\telemWrapper.styles = styles;\n\n\t\t\tif (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {\n\t\t\t\tdelete styles.width;\n\t\t\t}\n\n\t\t\t// serialize and set style attribute\n\t\t\tif (isIE && !hasSVG) {\n\t\t\t\tcss(elemWrapper.element, styles);\n\t\t\t} else {\n\t\t\t\t/*jslint unparam: true*/\n\t\t\t\thyphenate = function (a, b) { return '-' + b.toLowerCase(); };\n\t\t\t\t/*jslint unparam: false*/\n\t\t\t\tfor (n in styles) {\n\t\t\t\t\tserializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n\t\t\t\t}\n\t\t\t\tattr(elem, 'style', serializedCss); // #1881\n\t\t\t}\n\n\n\t\t\t// re-build text\n\t\t\tif (textWidth && elemWrapper.added) {\n\t\t\t\telemWrapper.renderer.buildText(elemWrapper);\n\t\t\t}\n\t\t}\n\n\t\treturn elemWrapper;\n\t},\n\n\t/**\n\t * Add an event listener\n\t * @param {String} eventType\n\t * @param {Function} handler\n\t */\n\ton: function (eventType, handler) {\n\t\tvar svgElement = this,\n\t\t\telement = svgElement.element;\n\t\t\n\t\t// touch\n\t\tif (hasTouch && eventType === 'click') {\n\t\t\telement.ontouchstart = function (e) {\t\t\t\n\t\t\t\tsvgElement.touchEventFired = Date.now();\t\t\t\t\n\t\t\t\te.preventDefault();\n\t\t\t\thandler.call(element, e);\n\t\t\t};\n\t\t\telement.onclick = function (e) {\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tif (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n\t\t\t\t\thandler.call(element, e);\n\t\t\t\t}\n\t\t\t};\t\t\t\n\t\t} else {\n\t\t\t// simplest possible event model for internal use\n\t\t\telement['on' + eventType] = handler;\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Set the coordinates needed to draw a consistent radial gradient across\n\t * pie slices regardless of positioning inside the chart. The format is\n\t * [centerX, centerY, diameter] in pixels.\n\t */\n\tsetRadialReference: function (coordinates) {\n\t\tthis.element.radialReference = coordinates;\n\t\treturn this;\n\t},\n\n\t/**\n\t * Move an object and its children by x and y values\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\ttranslate: function (x, y) {\n\t\treturn this.attr({\n\t\t\ttranslateX: x,\n\t\t\ttranslateY: y\n\t\t});\n\t},\n\n\t/**\n\t * Invert a group, rotate and flip\n\t */\n\tinvert: function () {\n\t\tvar wrapper = this;\n\t\twrapper.inverted = true;\n\t\twrapper.updateTransform();\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Private method to update the transform attribute based on internal\n\t * properties\n\t */\n\tupdateTransform: function () {\n\t\tvar wrapper = this,\n\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\tscaleX = wrapper.scaleX,\n\t\t\tscaleY = wrapper.scaleY,\n\t\t\tinverted = wrapper.inverted,\n\t\t\trotation = wrapper.rotation,\n\t\t\telement = wrapper.element,\n\t\t\ttransform;\n\n\t\t// flipping affects translate as adjustment for flipping around the group's axis\n\t\tif (inverted) {\n\t\t\ttranslateX += wrapper.attr('width');\n\t\t\ttranslateY += wrapper.attr('height');\n\t\t}\n\n\t\t// Apply translate. Nearly all transformed elements have translation, so instead\n\t\t// of checking for translate = 0, do it always (#1767, #1846).\n\t\ttransform = ['translate(' + translateX + ',' + translateY + ')'];\n\n\t\t// apply rotation\n\t\tif (inverted) {\n\t\t\ttransform.push('rotate(90) scale(-1,1)');\n\t\t} else if (rotation) { // text rotation\n\t\t\ttransform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\t\t\t\n\t\t\t// Delete bBox memo when the rotation changes\n\t\t\t//delete wrapper.bBox;\n\t\t}\n\n\t\t// apply scale\n\t\tif (defined(scaleX) || defined(scaleY)) {\n\t\t\ttransform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n\t\t}\n\n\t\tif (transform.length) {\n\t\t\telement.setAttribute('transform', transform.join(' '));\n\t\t}\n\t},\n\t/**\n\t * Bring the element to the front\n\t */\n\ttoFront: function () {\n\t\tvar element = this.element;\n\t\telement.parentNode.appendChild(element);\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Break down alignment options like align, verticalAlign, x and y\n\t * to x and y relative to the chart.\n\t *\n\t * @param {Object} alignOptions\n\t * @param {Boolean} alignByTranslate\n\t * @param {String[Object} box The box to align to, needs a width and height. When the\n\t *\t\tbox is a string, it refers to an object in the Renderer. For example, when\n\t *\t\tbox is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n\t *\t\tx and y properties.\n\t *\n\t */\n\talign: function (alignOptions, alignByTranslate, box) {\n\t\tvar align,\n\t\t\tvAlign,\n\t\t\tx,\n\t\t\ty,\n\t\t\tattribs = {},\n\t\t\talignTo,\n\t\t\trenderer = this.renderer,\n\t\t\talignedObjects = renderer.alignedObjects;\n\n\t\t// First call on instanciate\n\t\tif (alignOptions) {\n\t\t\tthis.alignOptions = alignOptions;\n\t\t\tthis.alignByTranslate = alignByTranslate;\n\t\t\tif (!box || isString(box)) { // boxes other than renderer handle this internally\n\t\t\t\tthis.alignTo = alignTo = box || 'renderer';\n\t\t\t\terase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n\t\t\t\talignedObjects.push(this);\n\t\t\t\tbox = null; // reassign it below\n\t\t\t}\n\n\t\t// When called on resize, no arguments are supplied\n\t\t} else {\n\t\t\talignOptions = this.alignOptions;\n\t\t\talignByTranslate = this.alignByTranslate;\n\t\t\talignTo = this.alignTo;\n\t\t}\n\n\t\tbox = pick(box, renderer[alignTo], renderer);\n\n\t\t// Assign variables\n\t\talign = alignOptions.align;\n\t\tvAlign = alignOptions.verticalAlign;\n\t\tx = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\t\ty = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n\t\t// Align\n\t\tif (align === 'right' || align === 'center') {\n\t\t\tx += (box.width - (alignOptions.width || 0)) /\n\t\t\t\t\t{ right: 1, center: 2 }[align];\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n\t\t// Vertical align\n\t\tif (vAlign === 'bottom' || vAlign === 'middle') {\n\t\t\ty += (box.height - (alignOptions.height || 0)) /\n\t\t\t\t\t({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n\t\t// Animate only if already placed\n\t\tthis[this.placed ? 'animate' : 'attr'](attribs);\n\t\tthis.placed = true;\n\t\tthis.alignAttr = attribs;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the bounding box (width, height, x and y) for the element\n\t */\n\tgetBBox: function (reload) {\n\t\tvar wrapper = this,\n\t\t\tbBox,// = wrapper.bBox,\n\t\t\trenderer = wrapper.renderer,\n\t\t\twidth,\n\t\t\theight,\n\t\t\trotation = wrapper.rotation,\n\t\t\telement = wrapper.element,\n\t\t\tstyles = wrapper.styles,\n\t\t\trad = rotation * deg2rad,\n\t\t\ttextStr = wrapper.textStr,\n\t\t\ttextShadow,\n\t\t\telemStyle = element.style,\n\t\t\ttoggleTextShadowShim,\n\t\t\tcacheKey;\n\n\t\tif (textStr !== UNDEFINED) {\n\n\t\t\t// Properties that affect bounding box\n\t\t\tcacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n\t\t\t// Since numbers are monospaced, and numerical labels appear a lot in a chart,\n\t\t\t// we assume that a label of n characters has the same bounding box as others \n\t\t\t// of the same length.\n\t\t\tif (textStr === '' || numRegex.test(textStr)) {\n\t\t\t\tcacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n\t\t\t// Caching all strings reduces rendering time by 4-5%.\n\t\t\t} else {\n\t\t\t\tcacheKey = textStr + cacheKey;\n\t\t\t}\n\t\t}\n\n\t\tif (cacheKey && !reload) {\n\t\t\tbBox = renderer.cache[cacheKey];\n\t\t}\n\n\t\t// No cache found\n\t\tif (!bBox) {\n\n\t\t\t// SVG elements\n\t\t\tif (element.namespaceURI === SVG_NS || renderer.forExport) {\n\t\t\t\ttry { // Fails in Firefox if the container has display: none.\n\n\t\t\t\t\t// When the text shadow shim is used, we need to hide the fake shadows\n\t\t\t\t\t// to get the correct bounding box (#3872)\n\t\t\t\t\ttoggleTextShadowShim = this.fakeTS && function (display) {\n\t\t\t\t\t\teach(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {\n\t\t\t\t\t\t\ttspan.style.display = display;\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t// Workaround for #3842, Firefox reporting wrong bounding box for shadows\n\t\t\t\t\tif (isFirefox && elemStyle.textShadow) {\n\t\t\t\t\t\ttextShadow = elemStyle.textShadow;\n\t\t\t\t\t\telemStyle.textShadow = '';\n\t\t\t\t\t} else if (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim(NONE);\n\t\t\t\t\t}\n\n\t\t\t\t\tbBox = element.getBBox ?\n\t\t\t\t\t\t// SVG: use extend because IE9 is not allowed to change width and height in case\n\t\t\t\t\t\t// of rotation (below)\n\t\t\t\t\t\textend({}, element.getBBox()) :\n\t\t\t\t\t\t// Canvas renderer and legacy IE in export mode\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twidth: element.offsetWidth,\n\t\t\t\t\t\t\theight: element.offsetHeight\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// #3842\n\t\t\t\t\tif (textShadow) {\n\t\t\t\t\t\telemStyle.textShadow = textShadow;\n\t\t\t\t\t} else if (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim('');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// If the bBox is not set, the try-catch block above failed. The other condition\n\t\t\t\t// is for Opera that returns a width of -Infinity on hidden elements.\n\t\t\t\tif (!bBox || bBox.width < 0) {\n\t\t\t\t\tbBox = { width: 0, height: 0 };\n\t\t\t\t}\n\n\n\t\t\t// VML Renderer or useHTML within SVG\n\t\t\t} else {\n\n\t\t\t\tbBox = wrapper.htmlGetBBox();\n\n\t\t\t}\n\n\t\t\t// True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n\t\t\t// need to compensated for rotation\n\t\t\tif (renderer.isSVG) {\n\t\t\t\twidth = bBox.width;\n\t\t\t\theight = bBox.height;\n\n\t\t\t\t// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n\t\t\t\tif (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n\t\t\t\t\tbBox.height = height = 14;\n\t\t\t\t}\n\n\t\t\t\t// Adjust for rotated text\n\t\t\t\tif (rotation) {\n\t\t\t\t\tbBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n\t\t\t\t\tbBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache it\n\t\t\trenderer.cache[cacheKey] = bBox;\n\t\t}\n\t\treturn bBox;\n\t},\n\n\t/**\n\t * Show the element\n\t */\n\tshow: function (inherit) {\n\t\t// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)\n\t\tif (inherit && this.element.namespaceURI === SVG_NS) {\n\t\t\tthis.element.removeAttribute('visibility');\n\t\t} else {\n\t\t\tthis.attr({ visibility: inherit ? 'inherit' : VISIBLE });\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Hide the element\n\t */\n\thide: function () {\n\t\treturn this.attr({ visibility: HIDDEN });\n\t},\n\n\tfadeOut: function (duration) {\n\t\tvar elemWrapper = this;\n\t\telemWrapper.animate({\n\t\t\topacity: 0\n\t\t}, {\n\t\t\tduration: duration || 150,\n\t\t\tcomplete: function () {\n\t\t\t\telemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Add the element\n\t * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n\t *\tto append the element to the renderer.box.\n\t */\n\tadd: function (parent) {\n\n\t\tvar renderer = this.renderer,\n\t\t\telement = this.element,\n\t\t\tinserted;\n\n\t\tif (parent) {\n\t\t\tthis.parentGroup = parent;\n\t\t}\n\n\t\t// mark as inverted\n\t\tthis.parentInverted = parent && parent.inverted;\n\n\t\t// build formatted text\n\t\tif (this.textStr !== undefined) {\n\t\t\trenderer.buildText(this);\n\t\t}\n\n\t\t// Mark as added\n\t\tthis.added = true;\n\n\t\t// If we're adding to renderer root, or other elements in the group \n\t\t// have a z index, we need to handle it\n\t\tif (!parent || parent.handleZ || this.zIndex) {\n\t\t\tinserted = this.zIndexSetter();\n\t\t}\n\n\t\t// If zIndex is not handled, append at the end\n\t\tif (!inserted) {\n\t\t\t(parent ? parent.element : renderer.box).appendChild(element);\n\t\t}\n\n\t\t// fire an event for internal hooks\n\t\tif (this.onAdd) {\n\t\t\tthis.onAdd();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Removes a child either by removeChild or move to garbageBin.\n\t * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n\t */\n\tsafeRemoveChild: function (element) {\n\t\tvar parentNode = element.parentNode;\n\t\tif (parentNode) {\n\t\t\tparentNode.removeChild(element);\n\t\t}\n\t},\n\n\t/**\n\t * Destroy the element and element wrapper\n\t */\n\tdestroy: function () {\n\t\tvar wrapper = this,\n\t\t\telement = wrapper.element || {},\n\t\t\tshadows = wrapper.shadows,\n\t\t\tparentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n\t\t\tgrandParent,\n\t\t\tkey,\n\t\t\ti;\n\n\t\t// remove events\n\t\telement.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n\t\tstop(wrapper); // stop running animations\n\n\t\tif (wrapper.clipPath) {\n\t\t\twrapper.clipPath = wrapper.clipPath.destroy();\n\t\t}\n\n\t\t// Destroy stops in case this is a gradient object\n\t\tif (wrapper.stops) {\n\t\t\tfor (i = 0; i < wrapper.stops.length; i++) {\n\t\t\t\twrapper.stops[i] = wrapper.stops[i].destroy();\n\t\t\t}\n\t\t\twrapper.stops = null;\n\t\t}\n\n\t\t// remove element\n\t\twrapper.safeRemoveChild(element);\n\n\t\t// destroy shadows\n\t\tif (shadows) {\n\t\t\teach(shadows, function (shadow) {\n\t\t\t\twrapper.safeRemoveChild(shadow);\n\t\t\t});\n\t\t}\n\n\t\t// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n\t\twhile (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n\t\t\tgrandParent = parentToClean.parentGroup;\n\t\t\twrapper.safeRemoveChild(parentToClean.div);\n\t\t\tdelete parentToClean.div;\n\t\t\tparentToClean = grandParent;\n\t\t}\n\n\t\t// remove from alignObjects\n\t\tif (wrapper.alignTo) {\n\t\t\terase(wrapper.renderer.alignedObjects, wrapper);\n\t\t}\n\n\t\tfor (key in wrapper) {\n\t\t\tdelete wrapper[key];\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Add a shadow to the element. Must be done after the element is added to the DOM\n\t * @param {Boolean|Object} shadowOptions\n\t */\n\tshadow: function (shadowOptions, group, cutOff) {\n\t\tvar shadows = [],\n\t\t\ti,\n\t\t\tshadow,\n\t\t\telement = this.element,\n\t\t\tstrokeWidth,\n\t\t\tshadowWidth,\n\t\t\tshadowElementOpacity,\n\n\t\t\t// compensate for inverted plot area\n\t\t\ttransform;\n\n\n\t\tif (shadowOptions) {\n\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n\t\t\ttransform = this.parentInverted ?\n\t\t\t\t'(-1,-1)' :\n\t\t\t\t'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n\t\t\tfor (i = 1; i <= shadowWidth; i++) {\n\t\t\t\tshadow = element.cloneNode(0);\n\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\t\t\t\tattr(shadow, {\n\t\t\t\t\t'isShadow': 'true',\n\t\t\t\t\t'stroke': shadowOptions.color || 'black',\n\t\t\t\t\t'stroke-opacity': shadowElementOpacity * i,\n\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t'transform': 'translate' + transform,\n\t\t\t\t\t'fill': NONE\n\t\t\t\t});\n\t\t\t\tif (cutOff) {\n\t\t\t\t\tattr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n\t\t\t\t\tshadow.cutHeight = strokeWidth;\n\t\t\t\t}\n\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t} else {\n\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t}\n\n\t\t\t\tshadows.push(shadow);\n\t\t\t}\n\n\t\t\tthis.shadows = shadows;\n\t\t}\n\t\treturn this;\n\n\t},\n\n\txGetter: function (key) {\n\t\tif (this.element.nodeName === 'circle') {\n\t\t\tkey = { x: 'cx', y: 'cy' }[key] || key;\n\t\t}\n\t\treturn this._defaultGetter(key);\n\t},\n\n\t/** \n\t * Get the current value of an attribute or pseudo attribute, used mainly\n\t * for animation.\n\t */\n\t_defaultGetter: function (key) {\n\t\tvar ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n\t\tif (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n\t\t\tret = parseFloat(ret);\n\t\t}\n\t\treturn ret;\n\t},\n\n\n\tdSetter: function (value, key, element) {\n\t\tif (value && value.join) { // join path\n\t\t\tvalue = value.join(' ');\n\t\t}\n\t\tif (/(NaN| {2}|^$)/.test(value)) {\n\t\t\tvalue = 'M 0 0';\n\t\t}\n\t\telement.setAttribute(key, value);\n\n\t\tthis[key] = value;\n\t},\n\tdashstyleSetter: function (value) {\n\t\tvar i;\n\t\tvalue = value && value.toLowerCase();\n\t\tif (value) {\n\t\t\tvalue = value\n\t\t\t\t.replace('shortdashdotdot', '3,1,1,1,1,1,')\n\t\t\t\t.replace('shortdashdot', '3,1,1,1')\n\t\t\t\t.replace('shortdot', '1,1,')\n\t\t\t\t.replace('shortdash', '3,1,')\n\t\t\t\t.replace('longdash', '8,3,')\n\t\t\t\t.replace(/dot/g, '1,3,')\n\t\t\t\t.replace('dash', '4,3,')\n\t\t\t\t.replace(/,$/, '')\n\t\t\t\t.split(','); // ending comma\n\n\t\t\ti = value.length;\n\t\t\twhile (i--) {\n\t\t\t\tvalue[i] = pInt(value[i]) * this['stroke-width'];\n\t\t\t}\n\t\t\tvalue = value.join(',')\n\t\t\t\t.replace('NaN', 'none'); // #3226\n\t\t\tthis.element.setAttribute('stroke-dasharray', value);\n\t\t}\n\t},\n\talignSetter: function (value) {\n\t\tthis.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);\n\t},\n\topacitySetter: function (value, key, element) {\n\t\tthis[key] = value;\n\t\telement.setAttribute(key, value);\n\t},\n\ttitleSetter: function (value) {\n\t\tvar titleNode = this.element.getElementsByTagName('title')[0];\n\t\tif (!titleNode) {\n\t\t\ttitleNode = doc.createElementNS(SVG_NS, 'title');\n\t\t\tthis.element.appendChild(titleNode);\n\t\t}\n\t\ttitleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895\n\t},\n\ttextSetter: function (value) {\n\t\tif (value !== this.textStr) {\n\t\t\t// Delete bBox memo when the text changes\n\t\t\tdelete this.bBox;\n\t\t\n\t\t\tthis.textStr = value;\n\t\t\tif (this.added) {\n\t\t\t\tthis.renderer.buildText(this);\n\t\t\t}\n\t\t}\n\t},\n\tfillSetter: function (value, key, element) {\n\t\tif (typeof value === 'string') {\n\t\t\telement.setAttribute(key, value);\n\t\t} else if (value) {\n\t\t\tthis.colorGradient(value, key, element);\n\t\t}\n\t},\n\tzIndexSetter: function (value, key) {\n\t\tvar renderer = this.renderer,\n\t\t\tparentGroup = this.parentGroup,\n\t\t\tparentWrapper = parentGroup || renderer,\n\t\t\tparentNode = parentWrapper.element || renderer.box,\n\t\t\tchildNodes,\n\t\t\totherElement,\n\t\t\totherZIndex,\n\t\t\telement = this.element,\n\t\t\tinserted,\n\t\t\trun = this.added,\n\t\t\ti;\n\t\t\n\t\tif (defined(value)) {\n\t\t\telement.setAttribute(key, value); // So we can read it for other elements in the group\n\t\t\tvalue = +value;\n\t\t\tif (this[key] === value) { // Only update when needed (#3865)\n\t\t\t\trun = false;\n\t\t\t}\n\t\t\tthis[key] = value;\n\t\t}\n\n\t\t// Insert according to this and other elements' zIndex. Before .add() is called,\n\t\t// nothing is done. Then on add, or by later calls to zIndexSetter, the node\n\t\t// is placed on the right place in the DOM.\n\t\tif (run) {\n\t\t\tvalue = this.zIndex;\n\n\t\t\tif (value && parentGroup) {\n\t\t\t\tparentGroup.handleZ = true;\n\t\t\t}\n\t\t\n\t\t\tchildNodes = parentNode.childNodes;\n\t\t\tfor (i = 0; i < childNodes.length && !inserted; i++) {\n\t\t\t\totherElement = childNodes[i];\n\t\t\t\totherZIndex = attr(otherElement, 'zIndex');\n\t\t\t\tif (otherElement !== element && (\n\t\t\t\t\t\t// Insert before the first element with a higher zIndex\n\t\t\t\t\t\tpInt(otherZIndex) > value ||\n\t\t\t\t\t\t// If no zIndex given, insert before the first element with a zIndex\n\t\t\t\t\t\t(!defined(value) && defined(otherZIndex))\n\n\t\t\t\t\t\t)) {\n\t\t\t\t\tparentNode.insertBefore(element, otherElement);\n\t\t\t\t\tinserted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!inserted) {\n\t\t\t\tparentNode.appendChild(element);\n\t\t\t}\n\t\t}\n\t\treturn inserted;\n\t},\n\t_defaultSetter: function (value, key, element) {\n\t\telement.setAttribute(key, value);\n\t}\n};\n\n// Some shared setters and getters\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\nSVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = \n\t\tSVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = \n\t\tSVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n\tthis[key] = value;\n\tthis.doTransform = true;\n};\n\n// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n// stroke attribute altogether. #1270, #1369, #3065, #3072.\nSVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n\tthis[key] = value;\n\t// Only apply the stroke attribute if the stroke width is defined and larger than 0\n\tif (this.stroke && this['stroke-width']) {\n\t\tthis.strokeWidth = this['stroke-width'];\n\t\tSVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n\t\telement.setAttribute('stroke-width', this['stroke-width']);\n\t\tthis.hasStroke = true;\n\t} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n\t\telement.removeAttribute('stroke');\n\t\tthis.hasStroke = false;\n\t}\n};\n\n\n/**\n * The default SVG renderer\n */\nvar SVGRenderer = function () {\n\tthis.init.apply(this, arguments);\n};\nSVGRenderer.prototype = {\n\tElement: SVGElement,\n\n\t/**\n\t * Initialize the SVGRenderer\n\t * @param {Object} container\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Boolean} forExport\n\t */\n\tinit: function (container, width, height, style, forExport) {\n\t\tvar renderer = this,\n\t\t\tloc = location,\n\t\t\tboxWrapper,\n\t\t\telement,\n\t\t\tdesc;\n\n\t\tboxWrapper = renderer.createElement('svg')\n\t\t\t.attr({\n\t\t\t\tversion: '1.1'\n\t\t\t})\n\t\t\t.css(this.getStyle(style));\n\t\telement = boxWrapper.element;\n\t\tcontainer.appendChild(element);\n\n\t\t// For browsers other than IE, add the namespace attribute (#1978)\n\t\tif (container.innerHTML.indexOf('xmlns') === -1) {\n\t\t\tattr(element, 'xmlns', SVG_NS);\n\t\t}\n\n\t\t// object properties\n\t\trenderer.isSVG = true;\n\t\trenderer.box = element;\n\t\trenderer.boxWrapper = boxWrapper;\n\t\trenderer.alignedObjects = [];\n\n\t\t// Page url used for internal references. #24, #672, #1070\n\t\trenderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n\t\t\tloc.href\n\t\t\t\t.replace(/#.*?$/, '') // remove the hash\n\t\t\t\t.replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n\t\t\t\t.replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n\t\t\t'';\n\n\t\t// Add description\n\t\tdesc = this.createElement('desc').add();\n\t\tdesc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));\n\n\n\t\trenderer.defs = this.createElement('defs').add();\n\t\trenderer.forExport = forExport;\n\t\trenderer.gradients = {}; // Object where gradient SvgElements are stored\n\t\trenderer.cache = {}; // Cache for numerical bounding boxes\n\n\t\trenderer.setSize(width, height, false);\n\n\n\n\t\t// Issue 110 workaround:\n\t\t// In Firefox, if a div is positioned by percentage, its pixel position may land\n\t\t// between pixels. The container itself doesn't display this, but an SVG element\n\t\t// inside this container will be drawn at subpixel precision. In order to draw\n\t\t// sharp lines, this must be compensated for. This doesn't seem to work inside\n\t\t// iframes though (like in jsFiddle).\n\t\tvar subPixelFix, rect;\n\t\tif (isFirefox && container.getBoundingClientRect) {\n\t\t\trenderer.subPixelFix = subPixelFix = function () {\n\t\t\t\tcss(container, { left: 0, top: 0 });\n\t\t\t\trect = container.getBoundingClientRect();\n\t\t\t\tcss(container, {\n\t\t\t\t\tleft: (mathCeil(rect.left) - rect.left) + PX,\n\t\t\t\t\ttop: (mathCeil(rect.top) - rect.top) + PX\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// run the fix now\n\t\t\tsubPixelFix();\n\n\t\t\t// run it on resize\n\t\t\taddEvent(win, 'resize', subPixelFix);\n\t\t}\n\t},\n\n\tgetStyle: function (style) {\n\t\treturn (this.style = extend({\n\t\t\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n\t\t\tfontSize: '12px'\n\t\t}, style));\n\t},\n\n\t/**\n\t * Detect whether the renderer is hidden. This happens when one of the parent elements\n\t * has display: none. #608.\n\t */\n\tisHidden: function () {\n\t\treturn !this.boxWrapper.getBBox().width;\n\t},\n\n\t/**\n\t * Destroys the renderer and its allocated members.\n\t */\n\tdestroy: function () {\n\t\tvar renderer = this,\n\t\t\trendererDefs = renderer.defs;\n\t\trenderer.box = null;\n\t\trenderer.boxWrapper = renderer.boxWrapper.destroy();\n\n\t\t// Call destroy on all gradient elements\n\t\tdestroyObjectProperties(renderer.gradients || {});\n\t\trenderer.gradients = null;\n\n\t\t// Defs are null in VMLRenderer\n\t\t// Otherwise, destroy them here.\n\t\tif (rendererDefs) {\n\t\t\trenderer.defs = rendererDefs.destroy();\n\t\t}\n\n\t\t// Remove sub pixel fix handler\n\t\t// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n\t\t// See issue #982\n\t\tif (renderer.subPixelFix) {\n\t\t\tremoveEvent(win, 'resize', renderer.subPixelFix);\n\t\t}\n\n\t\trenderer.alignedObjects = null;\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Create a wrapper for an SVG element\n\t * @param {Object} nodeName\n\t */\n\tcreateElement: function (nodeName) {\n\t\tvar wrapper = new this.Element();\n\t\twrapper.init(this, nodeName);\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Dummy function for use in canvas renderer\n\t */\n\tdraw: function () {},\n\n\t/**\n\t * Parse a simple HTML string into SVG tspans\n\t *\n\t * @param {Object} textNode The parent text SVG node\n\t */\n\tbuildText: function (wrapper) {\n\t\tvar textNode = wrapper.element,\n\t\t\trenderer = this,\n\t\t\tforExport = renderer.forExport,\n\t\t\ttextStr = pick(wrapper.textStr, '').toString(),\n\t\t\thasMarkup = textStr.indexOf('<') !== -1,\n\t\t\tlines,\n\t\t\tchildNodes = textNode.childNodes,\n\t\t\tstyleRegex,\n\t\t\threfRegex,\n\t\t\tparentX = attr(textNode, 'x'),\n\t\t\ttextStyles = wrapper.styles,\n\t\t\twidth = wrapper.textWidth,\n\t\t\ttextLineHeight = textStyles && textStyles.lineHeight,\n\t\t\ttextShadow = textStyles && textStyles.textShadow,\n\t\t\tellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n\t\t\ti = childNodes.length,\n\t\t\ttempParent = width && !wrapper.added && this.box,\n\t\t\tgetLineHeight = function (tspan) {\n\t\t\t\treturn textLineHeight ? \n\t\t\t\t\tpInt(textLineHeight) :\n\t\t\t\t\trenderer.fontMetrics(\n\t\t\t\t\t\t/(px|em)$/.test(tspan && tspan.style.fontSize) ?\n\t\t\t\t\t\t\ttspan.style.fontSize :\n\t\t\t\t\t\t\t((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),\n\t\t\t\t\t\ttspan\n\t\t\t\t\t).h;\n\t\t\t},\n\t\t\tunescapeAngleBrackets = function (inputStr) {\n\t\t\t\treturn inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n\t\t\t};\n\n\t\t/// remove old text\n\t\twhile (i--) {\n\t\t\ttextNode.removeChild(childNodes[i]);\n\t\t}\n\n\t\t// Skip tspans, add text directly to text node. The forceTSpan is a hook \n\t\t// used in text outline hack.\n\t\tif (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n\t\t\ttextNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\t\t\treturn;\n\n\t\t// Complex strings, add more logic\n\t\t} else {\n\n\t\t\tstyleRegex = /<.*style=\"([^\"]+)\".*>/;\n\t\t\threfRegex = /<.*href=\"(http[^\"]+)\".*>/;\n\n\t\t\tif (tempParent) {\n\t\t\t\ttempParent.appendChild(textNode); // attach it to the DOM to read offset width\n\t\t\t}\n\n\t\t\tif (hasMarkup) {\n\t\t\t\tlines = textStr\n\t\t\t\t\t.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n\t\t\t\t\t.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\t\t\t\t\t.replace(/<a/g, '<span')\n\t\t\t\t\t.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n\t\t\t\t\t.split(/<br.*?>/g);\n\n\t\t\t} else {\n\t\t\t\tlines = [textStr];\n\t\t\t}\n\n\n\t\t\t// remove empty line at end\n\t\t\tif (lines[lines.length - 1] === '') {\n\t\t\t\tlines.pop();\n\t\t\t}\n\n\t\t\t\n\t\t\t// build the lines\n\t\t\teach(lines, function (line, lineNo) {\n\t\t\t\tvar spans, spanNo = 0;\n\n\t\t\t\tline = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n\t\t\t\tspans = line.split('|||');\n\n\t\t\t\teach(spans, function (span) {\n\t\t\t\t\tif (span !== '' || spans.length === 1) {\n\t\t\t\t\t\tvar attributes = {},\n\t\t\t\t\t\t\ttspan = doc.createElementNS(SVG_NS, 'tspan'),\n\t\t\t\t\t\t\tspanStyle; // #390\n\t\t\t\t\t\tif (styleRegex.test(span)) {\n\t\t\t\t\t\t\tspanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n\t\t\t\t\t\t\tattr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n\t\t\t\t\t\t\tcss(tspan, { cursor: 'pointer' });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tspan = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n\t\t\t\t\t\t// Nested tags aren't supported, and cause crash in Safari (#1596)\n\t\t\t\t\t\tif (span !== ' ') {\n\n\t\t\t\t\t\t\t// add the text node\n\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(span));\n\n\t\t\t\t\t\t\tif (!spanNo) { // first span in a line, align it to the left\n\t\t\t\t\t\t\t\tif (lineNo && parentX !== null) {\n\t\t\t\t\t\t\t\t\tattributes.x = parentX;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tattributes.dx = 0; // #16\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// add attributes\n\t\t\t\t\t\t\tattr(tspan, attributes);\n\n\t\t\t\t\t\t\t// Append it\n\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\n\t\t\t\t\t\t\t// first span on subsequent line, add the line height\n\t\t\t\t\t\t\tif (!spanNo && lineNo) {\n\n\t\t\t\t\t\t\t\t// allow getting the right offset height in exporting in IE\n\t\t\t\t\t\t\t\tif (!hasSVG && forExport) {\n\t\t\t\t\t\t\t\t\tcss(tspan, { display: 'block' });\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the line height based on the font size of either\n\t\t\t\t\t\t\t\t// the text element or the tspan element\n\t\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t'dy',\n\t\t\t\t\t\t\t\t\tgetLineHeight(tspan)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*if (width) {\n\t\t\t\t\t\t\t\trenderer.breakText(wrapper, width);\n\t\t\t\t\t\t\t}*/\n\n\t\t\t\t\t\t\t// Check width and apply soft breaks or ellipsis\n\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\tvar words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n\t\t\t\t\t\t\t\t\thasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n\t\t\t\t\t\t\t\t\ttooLong,\n\t\t\t\t\t\t\t\t\twasTooLong,\n\t\t\t\t\t\t\t\t\tactualWidth,\n\t\t\t\t\t\t\t\t\trest = [],\n\t\t\t\t\t\t\t\t\tdy = getLineHeight(tspan),\n\t\t\t\t\t\t\t\t\tsoftLineNo = 1,\n\t\t\t\t\t\t\t\t\trotation = wrapper.rotation,\n\t\t\t\t\t\t\t\t\twordStr = span, // for ellipsis\n\t\t\t\t\t\t\t\t\tcursor = wordStr.length, // binary search cursor\n\t\t\t\t\t\t\t\t\tbBox;\n\n\t\t\t\t\t\t\t\twhile ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n\t\t\t\t\t\t\t\t\twrapper.rotation = 0; // discard rotation when computing box\n\t\t\t\t\t\t\t\t\tbBox = wrapper.getBBox(true);\n\t\t\t\t\t\t\t\t\tactualWidth = bBox.width;\n\n\t\t\t\t\t\t\t\t\t// Old IE cannot measure the actualWidth for SVG elements (#2314)\n\t\t\t\t\t\t\t\t\tif (!hasSVG && renderer.forExport) {\n\t\t\t\t\t\t\t\t\t\tactualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttooLong = actualWidth > width;\n\n\t\t\t\t\t\t\t\t\t// For ellipsis, do a binary search for the correct string length\n\t\t\t\t\t\t\t\t\tif (wasTooLong === undefined) {\n\t\t\t\t\t\t\t\t\t\twasTooLong = tooLong; // First time\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (ellipsis && wasTooLong) {\n\t\t\t\t\t\t\t\t\t\tcursor /= 2;\n\n\t\t\t\t\t\t\t\t\t\tif (wordStr === '' || (!tooLong && cursor < 0.5)) {\n\t\t\t\t\t\t\t\t\t\t\twords = []; // All ok, break out\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (tooLong) {\n\t\t\t\t\t\t\t\t\t\t\t\twasTooLong = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\twordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));\n\t\t\t\t\t\t\t\t\t\t\twords = [wordStr + '\\u2026'];\n\t\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Looping down, this is the first word sequence that is not too long,\n\t\t\t\t\t\t\t\t\t// so we can move on to build the next line.\n\t\t\t\t\t\t\t\t\t} else if (!tooLong || words.length === 1) {\n\t\t\t\t\t\t\t\t\t\twords = rest;\n\t\t\t\t\t\t\t\t\t\trest = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\t\tsoftLineNo++;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(SVG_NS, 'tspan');\n\t\t\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tif (spanStyle) { // #390\n\t\t\t\t\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (actualWidth > width) { // a single word is pressing it out\n\t\t\t\t\t\t\t\t\t\t\twidth = actualWidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else { // append to existing line tspan\n\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\trest.unshift(words.pop());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (wasTooLong) {\n\t\t\t\t\t\t\t\t\twrapper.attr('title', wrapper.textStr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrapper.rotation = rotation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tspanNo++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (tempParent) {\n\t\t\t\ttempParent.removeChild(textNode); // attach it to the DOM to read offset width\n\t\t\t}\n\n\t\t\t// Apply the text shadow\n\t\t\tif (textShadow && wrapper.applyTextShadow) {\n\t\t\t\twrapper.applyTextShadow(textShadow);\n\t\t\t}\n\t\t}\n\t},\n\n\t\n\n\t/*\n\tbreakText: function (wrapper, width) {\n\t\tvar bBox = wrapper.getBBox(),\n\t\t\tnode = wrapper.element,\n\t\t\ttextLength = node.textContent.length,\n\t\t\tpos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width\n\t\t\tincrement = 0,\n\t\t\tfinalPos;\n\n\t\tif (bBox.width > width) {\n\t\t\twhile (finalPos === undefined) {\n\t\t\t\ttextLength = node.getSubStringLength(0, pos);\n\n\t\t\t\tif (textLength <= width) {\n\t\t\t\t\tif (increment === -1) {\n\t\t\t\t\t\tfinalPos = pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tincrement = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (increment === 1) {\n\t\t\t\t\t\tfinalPos = pos - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tincrement = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos += increment;\n\t\t\t}\n\t\t}\n\t\tconsole.log(finalPos, node.getSubStringLength(0, finalPos))\n\t},\n\t*/\n\n\t/** \n\t * Returns white for dark colors and black for bright colors\n\t */\n\tgetContrast: function (color) {\n\t\tcolor = Color(color).rgba;\n\t\treturn color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';\n\t},\n\n\t/**\n\t * Create a button with preset states\n\t * @param {String} text\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Function} callback\n\t * @param {Object} normalState\n\t * @param {Object} hoverState\n\t * @param {Object} pressedState\n\t */\n\tbutton: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n\t\tvar label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n\t\t\tcurState = 0,\n\t\t\tstateOptions,\n\t\t\tstateStyle,\n\t\t\tnormalStyle,\n\t\t\thoverStyle,\n\t\t\tpressedStyle,\n\t\t\tdisabledStyle,\n\t\t\tverticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n\t\t// Normal state - prepare the attributes\n\t\tnormalState = merge({\n\t\t\t'stroke-width': 1,\n\t\t\tstroke: '#CCCCCC',\n\t\t\tfill: {\n\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\tstops: [\n\t\t\t\t\t[0, '#FEFEFE'],\n\t\t\t\t\t[1, '#F6F6F6']\n\t\t\t\t]\n\t\t\t},\n\t\t\tr: 2,\n\t\t\tpadding: 5,\n\t\t\tstyle: {\n\t\t\t\tcolor: 'black'\n\t\t\t}\n\t\t}, normalState);\n\t\tnormalStyle = normalState.style;\n\t\tdelete normalState.style;\n\n\t\t// Hover state\n\t\thoverState = merge(normalState, {\n\t\t\tstroke: '#68A',\n\t\t\tfill: {\n\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\tstops: [\n\t\t\t\t\t[0, '#FFF'],\n\t\t\t\t\t[1, '#ACF']\n\t\t\t\t]\n\t\t\t}\n\t\t}, hoverState);\n\t\thoverStyle = hoverState.style;\n\t\tdelete hoverState.style;\n\n\t\t// Pressed state\n\t\tpressedState = merge(normalState, {\n\t\t\tstroke: '#68A',\n\t\t\tfill: {\n\t\t\t\tlinearGradient: verticalGradient,\n\t\t\t\tstops: [\n\t\t\t\t\t[0, '#9BD'],\n\t\t\t\t\t[1, '#CDF']\n\t\t\t\t]\n\t\t\t}\n\t\t}, pressedState);\n\t\tpressedStyle = pressedState.style;\n\t\tdelete pressedState.style;\n\n\t\t// Disabled state\n\t\tdisabledState = merge(normalState, {\n\t\t\tstyle: {\n\t\t\t\tcolor: '#CCC'\n\t\t\t}\n\t\t}, disabledState);\n\t\tdisabledStyle = disabledState.style;\n\t\tdelete disabledState.style;\n\n\t\t// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n\t\taddEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tlabel.attr(hoverState)\n\t\t\t\t\t.css(hoverStyle);\n\t\t\t}\n\t\t});\n\t\taddEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tstateOptions = [normalState, hoverState, pressedState][curState];\n\t\t\t\tstateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n\t\t\t\tlabel.attr(stateOptions)\n\t\t\t\t\t.css(stateStyle);\n\t\t\t}\n\t\t});\n\n\t\tlabel.setState = function (state) {\n\t\t\tlabel.state = curState = state;\n\t\t\tif (!state) {\n\t\t\t\tlabel.attr(normalState)\n\t\t\t\t\t.css(normalStyle);\n\t\t\t} else if (state === 2) {\n\t\t\t\tlabel.attr(pressedState)\n\t\t\t\t\t.css(pressedStyle);\n\t\t\t} else if (state === 3) {\n\t\t\t\tlabel.attr(disabledState)\n\t\t\t\t\t.css(disabledStyle);\n\t\t\t}\n\t\t};\n\n\t\treturn label\n\t\t\t.on('click', function () {\n\t\t\t\tif (curState !== 3) {\n\t\t\t\t\tcallback.call(label);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.attr(normalState)\n\t\t\t.css(extend({ cursor: 'default' }, normalStyle));\n\t},\n\n\t/**\n\t * Make a straight line crisper by not spilling out to neighbour pixels\n\t * @param {Array} points\n\t * @param {Number} width\n\t */\n\tcrispLine: function (points, width) {\n\t\t// points format: [M, 0, 0, L, 100, 0]\n\t\t// normalize to a crisp line\n\t\tif (points[1] === points[4]) {\n\t\t\t// Substract due to #1129. Now bottom and left axis gridlines behave the same.\n\t\t\tpoints[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);\n\t\t}\n\t\tif (points[2] === points[5]) {\n\t\t\tpoints[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n\t\t}\n\t\treturn points;\n\t},\n\n\n\t/**\n\t * Draw a path\n\t * @param {Array} path An SVG path in array form\n\t */\n\tpath: function (path) {\n\t\tvar attr = {\n\t\t\tfill: NONE\n\t\t};\n\t\tif (isArray(path)) {\n\t\t\tattr.d = path;\n\t\t} else if (isObject(path)) { // attributes\n\t\t\textend(attr, path);\n\t\t}\n\t\treturn this.createElement('path').attr(attr);\n\t},\n\n\t/**\n\t * Draw and return an SVG circle\n\t * @param {Number} x The x position\n\t * @param {Number} y The y position\n\t * @param {Number} r The radius\n\t */\n\tcircle: function (x, y, r) {\n\t\tvar attr = isObject(x) ?\n\t\t\tx :\n\t\t\t{\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tr: r\n\t\t\t},\n\t\t\twrapper = this.createElement('circle');\n\n\t\twrapper.xSetter = function (value) {\n\t\t\tthis.element.setAttribute('cx', value);\n\t\t};\n\t\twrapper.ySetter = function (value) {\n\t\t\tthis.element.setAttribute('cy', value);\n\t\t};\n\t\treturn wrapper.attr(attr);\n\t},\n\n\t/**\n\t * Draw and return an arc\n\t * @param {Number} x X position\n\t * @param {Number} y Y position\n\t * @param {Number} r Radius\n\t * @param {Number} innerR Inner radius like used in donut charts\n\t * @param {Number} start Starting angle\n\t * @param {Number} end Ending angle\n\t */\n\tarc: function (x, y, r, innerR, start, end) {\n\t\tvar arc;\n\n\t\tif (isObject(x)) {\n\t\t\ty = x.y;\n\t\t\tr = x.r;\n\t\t\tinnerR = x.innerR;\n\t\t\tstart = x.start;\n\t\t\tend = x.end;\n\t\t\tx = x.x;\n\t\t}\n\n\t\t// Arcs are defined as symbols for the ability to set\n\t\t// attributes in attr and animate\n\t\tarc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n\t\t\tinnerR: innerR || 0,\n\t\t\tstart: start || 0,\n\t\t\tend: end || 0\n\t\t});\n\t\tarc.r = r; // #959\n\t\treturn arc;\n\t},\n\n\t/**\n\t * Draw and return a rectangle\n\t * @param {Number} x Left position\n\t * @param {Number} y Top position\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Number} r Border corner radius\n\t * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n\t */\n\trect: function (x, y, width, height, r, strokeWidth) {\n\n\t\tr = isObject(x) ? x.r : r;\n\n\t\tvar wrapper = this.createElement('rect'),\n\t\t\tattribs = isObject(x) ? x : x === UNDEFINED ? {} : {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: mathMax(width, 0),\n\t\t\t\theight: mathMax(height, 0)\n\t\t\t};\n\n\t\tif (strokeWidth !== UNDEFINED) {\n\t\t\tattribs.strokeWidth = strokeWidth;\n\t\t\tattribs = wrapper.crisp(attribs);\n\t\t}\n\n\t\tif (r) {\n\t\t\tattribs.r = r;\n\t\t}\n\n\t\twrapper.rSetter = function (value) {\n\t\t\tattr(this.element, {\n\t\t\t\trx: value,\n\t\t\t\try: value\n\t\t\t});\n\t\t};\n\t\t\n\t\treturn wrapper.attr(attribs);\n\t},\n\n\t/**\n\t * Resize the box and re-align all aligned elements\n\t * @param {Object} width\n\t * @param {Object} height\n\t * @param {Boolean} animate\n\t *\n\t */\n\tsetSize: function (width, height, animate) {\n\t\tvar renderer = this,\n\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\ti = alignedObjects.length;\n\n\t\trenderer.width = width;\n\t\trenderer.height = height;\n\n\t\trenderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t});\n\n\t\twhile (i--) {\n\t\t\talignedObjects[i].align();\n\t\t}\n\t},\n\n\t/**\n\t * Create a group\n\t * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n\t *\t This can be used for styling and scripting.\n\t */\n\tg: function (name) {\n\t\tvar elem = this.createElement('g');\n\t\treturn defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n\t},\n\n\t/**\n\t * Display an image\n\t * @param {String} src\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\timage: function (src, x, y, width, height) {\n\t\tvar attribs = {\n\t\t\t\tpreserveAspectRatio: NONE\n\t\t\t},\n\t\t\telemWrapper;\n\n\t\t// optional properties\n\t\tif (arguments.length > 1) {\n\t\t\textend(attribs, {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\telemWrapper = this.createElement('image').attr(attribs);\n\n\t\t// set the href in the xlink namespace\n\t\tif (elemWrapper.element.setAttributeNS) {\n\t\t\telemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n\t\t\t\t'href', src);\n\t\t} else {\n\t\t\t// could be exporting in IE\n\t\t\t// using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n\t\t\telemWrapper.element.setAttribute('hc-svg-href', src);\n\t\t}\n\t\treturn elemWrapper;\n\t},\n\n\t/**\n\t * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n\t *\n\t * @param {Object} symbol\n\t * @param {Object} x\n\t * @param {Object} y\n\t * @param {Object} radius\n\t * @param {Object} options\n\t */\n\tsymbol: function (symbol, x, y, width, height, options) {\n\n\t\tvar obj,\n\n\t\t\t// get the symbol definition function\n\t\t\tsymbolFn = this.symbols[symbol],\n\n\t\t\t// check if there's a path defined for this symbol\n\t\t\tpath = symbolFn && symbolFn(\n\t\t\t\tmathRound(x),\n\t\t\t\tmathRound(y),\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toptions\n\t\t\t),\n\n\t\t\timageElement,\n\t\t\timageRegex = /^url\\((.*?)\\)$/,\n\t\t\timageSrc,\n\t\t\timageSize,\n\t\t\tcenterImage;\n\n\t\tif (path) {\n\n\t\t\tobj = this.path(path);\n\t\t\t// expando properties for use in animate and attr\n\t\t\textend(obj, {\n\t\t\t\tsymbolName: symbol,\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\textend(obj, options);\n\t\t\t}\n\n\n\t\t// image symbols\n\t\t} else if (imageRegex.test(symbol)) {\n\n\t\t\t// On image load, set the size and position\n\t\t\tcenterImage = function (img, size) {\n\t\t\t\tif (img.element) { // it may be destroyed in the meantime (#1390)\n\t\t\t\t\timg.attr({\n\t\t\t\t\t\twidth: size[0],\n\t\t\t\t\t\theight: size[1]\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!img.alignByTranslate) { // #185\n\t\t\t\t\t\timg.translate(\n\t\t\t\t\t\t\tmathRound((width - size[0]) / 2), // #1378\n\t\t\t\t\t\t\tmathRound((height - size[1]) / 2)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\timageSrc = symbol.match(imageRegex)[1];\n\t\t\timageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);\n\n\t\t\t// Ireate the image synchronously, add attribs async\n\t\t\tobj = this.image(imageSrc)\n\t\t\t\t.attr({\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t});\n\t\t\tobj.isImg = true;\n\n\t\t\tif (imageSize) {\n\t\t\t\tcenterImage(obj, imageSize);\n\t\t\t} else {\n\t\t\t\t// Initialize image to be 0 size so export will still function if there's no cached sizes.\n\t\t\t\tobj.attr({ width: 0, height: 0 });\n\n\t\t\t\t// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n\t\t\t\t// the created element must be assigned to a variable in order to load (#292).\n\t\t\t\timageElement = createElement('img', {\n\t\t\t\t\tonload: function () {\n\t\t\t\t\t\tcenterImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\t\t\t\t\t},\n\t\t\t\t\tsrc: imageSrc\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t/**\n\t * An extendable collection of functions for defining symbol paths.\n\t */\n\tsymbols: {\n\t\t'circle': function (x, y, w, h) {\n\t\t\tvar cpw = 0.166 * w;\n\t\t\treturn [\n\t\t\t\tM, x + w / 2, y,\n\t\t\t\t'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n\t\t\t\t'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'square': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\tM, x, y,\n\t\t\t\tL, x + w, y,\n\t\t\t\tx + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\tM, x + w / 2, y,\n\t\t\t\tL, x + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle-down': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\tM, x, y,\n\t\t\t\tL, x + w, y,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'diamond': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\tM, x + w / 2, y,\n\t\t\t\tL, x + w, y + h / 2,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\tx, y + h / 2,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'arc': function (x, y, w, h, options) {\n\t\t\tvar start = options.start,\n\t\t\t\tradius = options.r || w || h,\n\t\t\t\tend = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\topen = options.open,\n\t\t\t\tcosStart = mathCos(start),\n\t\t\t\tsinStart = mathSin(start),\n\t\t\t\tcosEnd = mathCos(end),\n\t\t\t\tsinEnd = mathSin(end),\n\t\t\t\tlongArc = options.end - start < mathPI ? 0 : 1;\n\n\t\t\treturn [\n\t\t\t\tM,\n\t\t\t\tx + radius * cosStart,\n\t\t\t\ty + radius * sinStart,\n\t\t\t\t'A', // arcTo\n\t\t\t\tradius, // x radius\n\t\t\t\tradius, // y radius\n\t\t\t\t0, // slanting\n\t\t\t\tlongArc, // long or short arc\n\t\t\t\t1, // clockwise\n\t\t\t\tx + radius * cosEnd,\n\t\t\t\ty + radius * sinEnd,\n\t\t\t\topen ? M : L,\n\t\t\t\tx + innerRadius * cosEnd,\n\t\t\t\ty + innerRadius * sinEnd,\n\t\t\t\t'A', // arcTo\n\t\t\t\tinnerRadius, // x radius\n\t\t\t\tinnerRadius, // y radius\n\t\t\t\t0, // slanting\n\t\t\t\tlongArc, // long or short arc\n\t\t\t\t0, // clockwise\n\t\t\t\tx + innerRadius * cosStart,\n\t\t\t\ty + innerRadius * sinStart,\n\n\t\t\t\topen ? '' : 'Z' // close\n\t\t\t];\n\t\t},\n\n\t\t/**\n\t\t * Callout shape used for default tooltips, also used for rounded rectangles in VML\n\t\t */\n\t\tcallout: function (x, y, w, h, options) {\n\t\t\tvar arrowLength = 6,\n\t\t\t\thalfDistance = 6,\n\t\t\t\tr = mathMin((options && options.r) || 0, w, h),\n\t\t\t\tsafeDistance = r + halfDistance,\n\t\t\t\tanchorX = options && options.anchorX,\n\t\t\t\tanchorY = options && options.anchorY,\n\t\t\t\tpath,\n\t\t\t\tnormalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;\n\n\t\t\tx += normalizer;\n\t\t\ty += normalizer;\n\t\t\tpath = [\n\t\t\t\t'M', x + r, y, \n\t\t\t\t'L', x + w - r, y, // top side\n\t\t\t\t'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n\t\t\t\t'L', x + w, y + h - r, // right side\n\t\t\t\t'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n\t\t\t\t'L', x + r, y + h, // bottom side\n\t\t\t\t'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n\t\t\t\t'L', x, y + r, // left side\n\t\t\t\t'C', x, y, x, y, x + r, y // top-right corner\n\t\t\t];\n\t\t\t\n\t\t\tif (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t'L', x + w, anchorY - halfDistance, \n\t\t\t\t\tx + w + arrowLength, anchorY,\n\t\t\t\t\tx + w, anchorY + halfDistance,\n\t\t\t\t\tx + w, y + h - r\n\t\t\t\t);\n\t\t\t} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n\t\t\t\tpath.splice(33, 3, \n\t\t\t\t\t'L', x, anchorY + halfDistance, \n\t\t\t\t\tx - arrowLength, anchorY,\n\t\t\t\t\tx, anchorY - halfDistance,\n\t\t\t\t\tx, y + r\n\t\t\t\t);\n\t\t\t} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n\t\t\t\tpath.splice(23, 3,\n\t\t\t\t\t'L', anchorX + halfDistance, y + h,\n\t\t\t\t\tanchorX, y + h + arrowLength,\n\t\t\t\t\tanchorX - halfDistance, y + h,\n\t\t\t\t\tx + r, y + h\n\t\t\t\t);\n\t\t\t} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n\t\t\t\tpath.splice(3, 3,\n\t\t\t\t\t'L', anchorX - halfDistance, y,\n\t\t\t\t\tanchorX, y - arrowLength,\n\t\t\t\t\tanchorX + halfDistance, y,\n\t\t\t\t\tw - r, y\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\t},\n\n\t/**\n\t * Define a clipping rectangle\n\t * @param {String} id\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\tclipRect: function (x, y, width, height) {\n\t\tvar wrapper,\n\t\t\tid = PREFIX + idCounter++,\n\n\t\t\tclipPath = this.createElement('clipPath').attr({\n\t\t\t\tid: id\n\t\t\t}).add(this.defs);\n\n\t\twrapper = this.rect(x, y, width, height, 0).add(clipPath);\n\t\twrapper.id = id;\n\t\twrapper.clipPath = clipPath;\n\t\twrapper.count = 0;\n\n\t\treturn wrapper;\n\t},\n\n\n\t\n\n\n\t/**\n\t * Add text to the SVG object\n\t * @param {String} str\n\t * @param {Number} x Left position\n\t * @param {Number} y Top position\n\t * @param {Boolean} useHTML Use HTML to render the text\n\t */\n\ttext: function (str, x, y, useHTML) {\n\n\t\t// declare variables\n\t\tvar renderer = this,\n\t\t\tfakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n\t\t\twrapper,\n\t\t\tattr = {};\n\n\t\tif (useHTML && !renderer.forExport) {\n\t\t\treturn renderer.html(str, x, y);\n\t\t}\n\n\t\tattr.x = Math.round(x || 0); // X is always needed for line-wrap logic\n\t\tif (y) {\n\t\t\tattr.y = Math.round(y);\n\t\t}\n\t\tif (str || str === 0) {\n\t\t\tattr.text = str;\n\t\t}\n\n\t\twrapper = renderer.createElement('text')\n\t\t\t.attr(attr);\n\n\t\t// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n\t\tif (fakeSVG) {\n\t\t\twrapper.css({\n\t\t\t\tposition: ABSOLUTE\n\t\t\t});\n\t\t}\n\n\t\tif (!useHTML) {\n\t\t\twrapper.xSetter = function (value, key, element) {\n\t\t\t\tvar tspans = element.getElementsByTagName('tspan'),\n\t\t\t\t\ttspan,\n\t\t\t\t\tparentVal = element.getAttribute(key),\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < tspans.length; i++) {\n\t\t\t\t\ttspan = tspans[i];\n\t\t\t\t\t// If the x values are equal, the tspan represents a linebreak\n\t\t\t\t\tif (tspan.getAttribute(key) === parentVal) {\n\t\t\t\t\t\ttspan.setAttribute(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telement.setAttribute(key, value);\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Utility to return the baseline offset and total line height from the font size\n\t */\n\tfontMetrics: function (fontSize, elem) {\n\t\tfontSize = fontSize || this.style.fontSize;\n\t\tif (elem && win.getComputedStyle) {\n\t\t\telem = elem.element || elem; // SVGElement\n\t\t\tfontSize = win.getComputedStyle(elem, \"\").fontSize;\n\t\t}\n\t\tfontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n\t\t// Empirical values found by comparing font size and bounding box height.\n\t\t// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n\t\tvar lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),\n\t\t\tbaseline = mathRound(lineHeight * 0.8);\n\n\t\treturn {\n\t\t\th: lineHeight,\n\t\t\tb: baseline,\n\t\t\tf: fontSize\n\t\t};\n\t},\n\n\t/**\n\t * Correct X and Y positioning of a label for rotation (#1764)\n\t */\n\trotCorr: function (baseline, rotation, alterY) {\n\t\tvar y = baseline;\n\t\tif (rotation && alterY) {\n\t\t\ty = mathMax(y * mathCos(rotation * deg2rad), 4);\n\t\t}\n\t\treturn {\n\t\t\tx: (-baseline / 3) * mathSin(rotation * deg2rad),\n\t\t\ty: y\n\t\t};\n\t},\n\n\t/**\n\t * Add a label, a text item that can hold a colored or gradient background\n\t * as well as a border and shadow.\n\t * @param {string} str\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {String} shape\n\t * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n\t *\tcoordinates it should be pinned to\n\t * @param {Number} anchorY\n\t * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n\t *\tlike renderer.text, or to the upper border of the rectangle.\n\t * @param {String} className Class name for the group\n\t */\n\tlabel: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n\t\tvar renderer = this,\n\t\t\twrapper = renderer.g(className),\n\t\t\ttext = renderer.text('', 0, 0, useHTML)\n\t\t\t\t.attr({\n\t\t\t\t\tzIndex: 1\n\t\t\t\t}),\n\t\t\t\t//.add(wrapper),\n\t\t\tbox,\n\t\t\tbBox,\n\t\t\talignFactor = 0,\n\t\t\tpadding = 3,\n\t\t\tpaddingLeft = 0,\n\t\t\twidth,\n\t\t\theight,\n\t\t\twrapperX,\n\t\t\twrapperY,\n\t\t\tcrispAdjust = 0,\n\t\t\tdeferredAttr = {},\n\t\t\tbaselineOffset,\n\t\t\tneedsBox;\n\n\t\t/**\n\t\t * This function runs after the label is added to the DOM (when the bounding box is\n\t\t * available), and after the text of the label is updated to detect the new bounding\n\t\t * box and reflect it in the border box.\n\t\t */\n\t\tfunction updateBoxSize() {\n\t\t\tvar boxX,\n\t\t\t\tboxY,\n\t\t\t\tstyle = text.element.style;\n\n\t\t\tbBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && \n\t\t\t\ttext.getBBox(); //#3295 && 3514 box failure when string equals 0\n\t\t\twrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n\t\t\twrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n\t\t\t// update the label-scoped y offset\n\t\t\tbaselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\t\t\t\n\t\t\tif (needsBox) {\n\n\t\t\t\t// create the border box if it is not already present\n\t\t\t\tif (!box) {\n\t\t\t\t\tboxX = mathRound(-alignFactor * padding);\n\t\t\t\t\tboxY = baseline ? -baselineOffset : 0;\n\n\t\t\t\t\twrapper.box = box = shape ?\n\t\t\t\t\t\trenderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :\n\t\t\t\t\t\trenderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n\t\t\t\t\tbox.attr('fill', NONE).add(wrapper);\n\t\t\t\t}\n\n\t\t\t\t// apply the box attributes\n\t\t\t\tif (!box.isImg) { // #1630\n\t\t\t\t\tbox.attr(extend({\n\t\t\t\t\t\twidth: mathRound(wrapper.width),\n\t\t\t\t\t\theight: mathRound(wrapper.height)\n\t\t\t\t\t}, deferredAttr));\n\t\t\t\t}\n\t\t\t\tdeferredAttr = null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * This function runs after setting text or padding, but only if padding is changed\n\t\t */\n\t\tfunction updateTextPadding() {\n\t\t\tvar styles = wrapper.styles,\n\t\t\t\ttextAlign = styles && styles.textAlign,\n\t\t\t\tx = paddingLeft + padding * (1 - alignFactor),\n\t\t\t\ty;\n\n\t\t\t// determin y based on the baseline\n\t\t\ty = baseline ? 0 : baselineOffset;\n\n\t\t\t// compensate for alignment\n\t\t\tif (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n\t\t\t\tx += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n\t\t\t}\n\n\t\t\t// update if anything changed\n\t\t\tif (x !== text.x || y !== text.y) {\n\t\t\t\ttext.attr('x', x);\n\t\t\t\tif (y !== UNDEFINED) {\n\t\t\t\t\t// As a workaround for #3649, use translation instead of y attribute. #3649\n\t\t\t\t\t// is a rendering bug in WebKit for Retina (Mac, iOS, PhantomJS) that \n\t\t\t\t\t// results in duplicated text when an y attribute is used in combination \n\t\t\t\t\t// with a CSS text-style.\n\t\t\t\t\ttext.attr(text.element.nodeName === 'SPAN' ? 'y' : 'translateY', y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// record current values\n\t\t\ttext.x = x;\n\t\t\ttext.y = y;\n\t\t}\n\n\t\t/**\n\t\t * Set a box attribute, or defer it if the box is not yet created\n\t\t * @param {Object} key\n\t\t * @param {Object} value\n\t\t */\n\t\tfunction boxAttr(key, value) {\n\t\t\tif (box) {\n\t\t\t\tbox.attr(key, value);\n\t\t\t} else {\n\t\t\t\tdeferredAttr[key] = value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * After the text element is added, get the desired size of the border box\n\t\t * and add it before the text in the DOM.\n\t\t */\n\t\twrapper.onAdd = function () {\n\t\t\ttext.add(wrapper);\n\t\t\twrapper.attr({\n\t\t\t\ttext: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\n\t\t\tif (box && defined(anchorX)) {\n\t\t\t\twrapper.attr({\n\t\t\t\t\tanchorX: anchorX,\n\t\t\t\t\tanchorY: anchorY\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * Add specific attribute setters.\n\t\t */\n\n\t\t// only change local variables\n\t\twrapper.widthSetter = function (value) {\n\t\t\twidth = value;\n\t\t};\n\t\twrapper.heightSetter = function (value) {\n\t\t\theight = value;\n\t\t};\n\t\twrapper.paddingSetter =  function (value) {\n\t\t\tif (defined(value) && value !== padding) {\n\t\t\t\tpadding = wrapper.padding = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\t\twrapper.paddingLeftSetter =  function (value) {\n\t\t\tif (defined(value) && value !== paddingLeft) {\n\t\t\t\tpaddingLeft = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\n\n\t\t// change local variable and prevent setting attribute on the group\n\t\twrapper.alignSetter = function (value) {\n\t\t\talignFactor = { left: 0, center: 0.5, right: 1 }[value];\n\t\t};\n\n\t\t// apply these to the box and the text alike\n\t\twrapper.textSetter = function (value) {\n\t\t\tif (value !== UNDEFINED) {\n\t\t\t\ttext.textSetter(value);\n\t\t\t}\n\t\t\tupdateBoxSize();\n\t\t\tupdateTextPadding();\n\t\t};\n\n\t\t// apply these to the box but not to the text\n\t\twrapper['stroke-widthSetter'] = function (value, key) {\n\t\t\tif (value) {\n\t\t\t\tneedsBox = true;\n\t\t\t}\n\t\t\tcrispAdjust = value % 2 / 2;\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\twrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n\t\t\tif (key === 'fill' && value) {\n\t\t\t\tneedsBox = true;\n\t\t\t}\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\twrapper.anchorXSetter = function (value, key) {\n\t\t\tanchorX = value;\n\t\t\tboxAttr(key, value + crispAdjust - wrapperX);\n\t\t};\n\t\twrapper.anchorYSetter = function (value, key) {\n\t\t\tanchorY = value;\n\t\t\tboxAttr(key, value - wrapperY);\n\t\t};\n\n\t\t// rename attributes\n\t\twrapper.xSetter = function (value) {\n\t\t\twrapper.x = value; // for animation getter\n\t\t\tif (alignFactor) {\n\t\t\t\tvalue -= alignFactor * ((width || bBox.width) + padding);\n\t\t\t}\n\t\t\twrapperX = mathRound(value);\n\t\t\twrapper.attr('translateX', wrapperX);\n\t\t};\n\t\twrapper.ySetter = function (value) {\n\t\t\twrapperY = wrapper.y = mathRound(value);\n\t\t\twrapper.attr('translateY', wrapperY);\n\t\t};\n\n\t\t// Redirect certain methods to either the box or the text\n\t\tvar baseCss = wrapper.css;\n\t\treturn extend(wrapper, {\n\t\t\t/**\n\t\t\t * Pick up some properties and apply them to the text instead of the wrapper\n\t\t\t */\n\t\t\tcss: function (styles) {\n\t\t\t\tif (styles) {\n\t\t\t\t\tvar textStyles = {};\n\t\t\t\t\tstyles = merge(styles); // create a copy to avoid altering the original object (#537)\n\t\t\t\t\teach(wrapper.textProps, function (prop) {\n\t\t\t\t\t\tif (styles[prop] !== UNDEFINED) {\n\t\t\t\t\t\t\ttextStyles[prop] = styles[prop];\n\t\t\t\t\t\t\tdelete styles[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttext.css(textStyles);\n\t\t\t\t}\n\t\t\t\treturn baseCss.call(wrapper, styles);\n\t\t\t},\n\t\t\t/**\n\t\t\t * Return the bounding box of the box, not the group\n\t\t\t */\n\t\t\tgetBBox: function () {\n\t\t\t\treturn {\n\t\t\t\t\twidth: bBox.width + 2 * padding,\n\t\t\t\t\theight: bBox.height + 2 * padding,\n\t\t\t\t\tx: bBox.x - padding,\n\t\t\t\t\ty: bBox.y - padding\n\t\t\t\t};\n\t\t\t},\n\t\t\t/**\n\t\t\t * Apply the shadow to the box\n\t\t\t */\n\t\t\tshadow: function (b) {\n\t\t\t\tif (box) {\n\t\t\t\t\tbox.shadow(b);\n\t\t\t\t}\n\t\t\t\treturn wrapper;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Destroy and release memory.\n\t\t\t */\n\t\t\tdestroy: function () {\n\n\t\t\t\t// Added by button implementation\n\t\t\t\tremoveEvent(wrapper.element, 'mouseenter');\n\t\t\t\tremoveEvent(wrapper.element, 'mouseleave');\n\n\t\t\t\tif (text) {\n\t\t\t\t\ttext = text.destroy();\n\t\t\t\t}\n\t\t\t\tif (box) {\n\t\t\t\t\tbox = box.destroy();\n\t\t\t\t}\n\t\t\t\t// Call base implementation to destroy the rest\n\t\t\t\tSVGElement.prototype.destroy.call(wrapper);\n\n\t\t\t\t// Release local pointers (#1298)\n\t\t\t\twrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n\t\t\t}\n\t\t});\n\t}\n}; // end SVGRenderer\n\n\n// general renderer\nRenderer = SVGRenderer;\n// extend SvgElement for useHTML option\nextend(SVGElement.prototype, {\n\t/**\n\t * Apply CSS to HTML elements. This is used in text within SVG rendering and\n\t * by the VML renderer\n\t */\n\thtmlCss: function (styles) {\n\t\tvar wrapper = this,\n\t\t\telement = wrapper.element,\n\t\t\ttextWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n\t\tif (textWidth) {\n\t\t\tdelete styles.width;\n\t\t\twrapper.textWidth = textWidth;\n\t\t\twrapper.updateTransform();\n\t\t}\n\t\tif (styles && styles.textOverflow === 'ellipsis') {\n\t\t\tstyles.whiteSpace = 'nowrap';\n\t\t\tstyles.overflow = 'hidden';\n\t\t}\n\t\twrapper.styles = extend(wrapper.styles, styles);\n\t\tcss(wrapper.element, styles);\n\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * VML and useHTML method for calculating the bounding box based on offsets\n\t * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n\t * use the cached value\n\t *\n\t * @return {Object} A hash containing values for x, y, width and height\n\t */\n\n\thtmlGetBBox: function () {\n\t\tvar wrapper = this,\n\t\t\telement = wrapper.element;\n\n\t\t// faking getBBox in exported SVG in legacy IE\n\t\t// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n\t\tif (element.nodeName === 'text') {\n\t\t\telement.style.position = ABSOLUTE;\n\t\t}\n\n\t\treturn {\n\t\t\tx: element.offsetLeft,\n\t\t\ty: element.offsetTop,\n\t\t\twidth: element.offsetWidth,\n\t\t\theight: element.offsetHeight\n\t\t};\n\t},\n\n\t/**\n\t * VML override private method to update elements based on internal\n\t * properties based on SVG transform\n\t */\n\thtmlUpdateTransform: function () {\n\t\t// aligning non added elements is expensive\n\t\tif (!this.added) {\n\t\t\tthis.alignOnAdd = true;\n\t\t\treturn;\n\t\t}\n\n\t\tvar wrapper = this,\n\t\t\trenderer = wrapper.renderer,\n\t\t\telem = wrapper.element,\n\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\tx = wrapper.x || 0,\n\t\t\ty = wrapper.y || 0,\n\t\t\talign = wrapper.textAlign || 'left',\n\t\t\talignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n\t\t\tshadows = wrapper.shadows,\n\t\t\tstyles = wrapper.styles;\n\n\t\t// apply translate\n\t\tcss(elem, {\n\t\t\tmarginLeft: translateX,\n\t\t\tmarginTop: translateY\n\t\t});\n\t\tif (shadows) { // used in labels/tooltip\n\t\t\teach(shadows, function (shadow) {\n\t\t\t\tcss(shadow, {\n\t\t\t\t\tmarginLeft: translateX + 1,\n\t\t\t\t\tmarginTop: translateY + 1\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// apply inversion\n\t\tif (wrapper.inverted) { // wrapper is a group\n\t\t\teach(elem.childNodes, function (child) {\n\t\t\t\trenderer.invertChild(child, elem);\n\t\t\t});\n\t\t}\n\n\t\tif (elem.tagName === 'SPAN') {\n\n\t\t\tvar width,\n\t\t\t\trotation = wrapper.rotation,\n\t\t\t\tbaseline,\n\t\t\t\ttextWidth = pInt(wrapper.textWidth),\n\t\t\t\tcurrentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');\n\n\t\t\tif (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n\t\t\t\tbaseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n\t\t\t\t// Renderer specific handling of span rotation\n\t\t\t\tif (defined(rotation)) {\n\t\t\t\t\twrapper.setSpanRotation(rotation, alignCorrection, baseline);\n\t\t\t\t}\n\n\t\t\t\twidth = pick(wrapper.elemWidth, elem.offsetWidth);\n\n\t\t\t\t// Update textWidth\n\t\t\t\tif (width > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n\t\t\t\t\tcss(elem, {\n\t\t\t\t\t\twidth: textWidth + PX,\n\t\t\t\t\t\tdisplay: 'block',\n\t\t\t\t\t\twhiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331\n\t\t\t\t\t});\n\t\t\t\t\twidth = textWidth;\n\t\t\t\t}\n\n\t\t\t\twrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);\n\t\t\t}\n\n\t\t\t// apply position with correction\n\t\t\tcss(elem, {\n\t\t\t\tleft: (x + (wrapper.xCorr || 0)) + PX,\n\t\t\t\ttop: (y + (wrapper.yCorr || 0)) + PX\n\t\t\t});\n\n\t\t\t// force reflow in webkit to apply the left and top on useHTML element (#1249)\n\t\t\tif (isWebKit) {\n\t\t\t\tbaseline = elem.offsetHeight; // assigned to baseline for JSLint purpose\n\t\t\t}\n\n\t\t\t// record current text transform\n\t\t\twrapper.cTT = currentTextTransform;\n\t\t}\n\t},\n\n\t/**\n\t * Set the rotation of an individual HTML span\n\t */\n\tsetSpanRotation: function (rotation, alignCorrection, baseline) {\n\t\tvar rotationStyle = {},\n\t\t\tcssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n\n\t\trotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n\t\trotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n\t\tcss(this.element, rotationStyle);\n\t},\n\n\t/**\n\t * Get the correction in X and Y positioning as the element is rotated.\n\t */\n\tgetSpanCorrection: function (width, baseline, alignCorrection) {\n\t\tthis.xCorr = -width * alignCorrection;\n\t\tthis.yCorr = -baseline;\n\t}\n});\n\n// Extend SvgRenderer for useHTML option.\nextend(SVGRenderer.prototype, {\n\t/**\n\t * Create HTML text node. This is used by the VML renderer as well as the SVG\n\t * renderer through the useHTML option.\n\t *\n\t * @param {String} str\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\thtml: function (str, x, y) {\n\t\tvar wrapper = this.createElement('span'),\n\t\t\telement = wrapper.element,\n\t\t\trenderer = wrapper.renderer;\n\n\t\t// Text setter\n\t\twrapper.textSetter = function (value) {\n\t\t\tif (value !== element.innerHTML) {\n\t\t\t\tdelete this.bBox;\n\t\t\t}\n\t\t\telement.innerHTML = this.textStr = value;\n\t\t};\n\n\t\t// Various setters which rely on update transform\n\t\twrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n\t\t\tif (key === 'align') {\n\t\t\t\tkey = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n\t\t\t}\n\t\t\twrapper[key] = value;\n\t\t\twrapper.htmlUpdateTransform();\n\t\t};\n\n\t\t// Set the default attributes\n\t\twrapper.attr({\n\t\t\t\ttext: str,\n\t\t\t\tx: mathRound(x),\n\t\t\t\ty: mathRound(y)\n\t\t\t})\n\t\t\t.css({\n\t\t\t\tposition: ABSOLUTE,\n\t\t\t\tfontFamily: this.style.fontFamily,\n\t\t\t\tfontSize: this.style.fontSize\n\t\t\t});\n\n\t\t// Keep the whiteSpace style outside the wrapper.styles collection\n\t\telement.style.whiteSpace = 'nowrap';\n\n\t\t// Use the HTML specific .css method\n\t\twrapper.css = wrapper.htmlCss;\n\n\t\t// This is specific for HTML within SVG\n\t\tif (renderer.isSVG) {\n\t\t\twrapper.add = function (svgGroupWrapper) {\n\n\t\t\t\tvar htmlGroup,\n\t\t\t\t\tcontainer = renderer.box.parentNode,\n\t\t\t\t\tparentGroup,\n\t\t\t\t\tparents = [];\n\n\t\t\t\tthis.parentGroup = svgGroupWrapper;\n\n\t\t\t\t// Create a mock group to hold the HTML elements\n\t\t\t\tif (svgGroupWrapper) {\n\t\t\t\t\thtmlGroup = svgGroupWrapper.div;\n\t\t\t\t\tif (!htmlGroup) {\n\n\t\t\t\t\t\t// Read the parent chain into an array and read from top down\n\t\t\t\t\t\tparentGroup = svgGroupWrapper;\n\t\t\t\t\t\twhile (parentGroup) {\n\n\t\t\t\t\t\t\tparents.push(parentGroup);\n\n\t\t\t\t\t\t\t// Move up to the next parent group\n\t\t\t\t\t\t\tparentGroup = parentGroup.parentGroup;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ensure dynamically updating position when any parent is translated\n\t\t\t\t\t\teach(parents.reverse(), function (parentGroup) {\n\t\t\t\t\t\t\tvar htmlGroupStyle;\n\n\t\t\t\t\t\t\t// Create a HTML div and append it to the parent div to emulate\n\t\t\t\t\t\t\t// the SVG group structure\n\t\t\t\t\t\t\thtmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {\n\t\t\t\t\t\t\t\tclassName: attr(parentGroup.element, 'class')\n\t\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\t\tposition: ABSOLUTE,\n\t\t\t\t\t\t\t\tleft: (parentGroup.translateX || 0) + PX,\n\t\t\t\t\t\t\t\ttop: (parentGroup.translateY || 0) + PX\n\t\t\t\t\t\t\t}, htmlGroup || container); // the top group is appended to container\n\n\t\t\t\t\t\t\t// Shortcut\n\t\t\t\t\t\t\thtmlGroupStyle = htmlGroup.style;\n\n\t\t\t\t\t\t\t// Set listeners to update the HTML div's position whenever the SVG group\n\t\t\t\t\t\t\t// position is changed\n\t\t\t\t\t\t\textend(parentGroup, {\n\t\t\t\t\t\t\t\ttranslateXSetter: function (value, key) {\n\t\t\t\t\t\t\t\t\thtmlGroupStyle.left = value + PX;\n\t\t\t\t\t\t\t\t\tparentGroup[key] = value;\n\t\t\t\t\t\t\t\t\tparentGroup.doTransform = true;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttranslateYSetter: function (value, key) {\n\t\t\t\t\t\t\t\t\thtmlGroupStyle.top = value + PX;\n\t\t\t\t\t\t\t\t\tparentGroup[key] = value;\n\t\t\t\t\t\t\t\t\tparentGroup.doTransform = true;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tvisibilitySetter: function (value, key) {\n\t\t\t\t\t\t\t\t\thtmlGroupStyle[key] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thtmlGroup = container;\n\t\t\t\t}\n\n\t\t\t\thtmlGroup.appendChild(element);\n\n\t\t\t\t// Shared with VML:\n\t\t\t\twrapper.added = true;\n\t\t\t\tif (wrapper.alignOnAdd) {\n\t\t\t\t\twrapper.htmlUpdateTransform();\n\t\t\t\t}\n\n\t\t\t\treturn wrapper;\n\t\t\t};\n\t\t}\n\t\treturn wrapper;\n\t}\n});\n\n/* ****************************************************************************\n *                                                                            *\n * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n *                                                                            *\n * For applications and websites that don't need IE support, like platform    *\n * targeted mobile apps and web apps, this code can be removed.               *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * @constructor\n */\nvar VMLRenderer, VMLElement;\nif (!hasSVG && !useCanVG) {\n\n/**\n * The VML element wrapper.\n */\nVMLElement = {\n\n\t/**\n\t * Initialize a new VML element wrapper. It builds the markup as a string\n\t * to minimize DOM traffic.\n\t * @param {Object} renderer\n\t * @param {Object} nodeName\n\t */\n\tinit: function (renderer, nodeName) {\n\t\tvar wrapper = this,\n\t\t\tmarkup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n\t\t\tstyle = ['position: ', ABSOLUTE, ';'],\n\t\t\tisDiv = nodeName === DIV;\n\n\t\t// divs and shapes need size\n\t\tif (nodeName === 'shape' || isDiv) {\n\t\t\tstyle.push('left:0;top:0;width:1px;height:1px;');\n\t\t}\n\t\tstyle.push('visibility: ', isDiv ? HIDDEN : VISIBLE);\n\n\t\tmarkup.push(' style=\"', style.join(''), '\"/>');\n\n\t\t// create element with default attributes and style\n\t\tif (nodeName) {\n\t\t\tmarkup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n\t\t\t\tmarkup.join('')\n\t\t\t\t: renderer.prepVML(markup);\n\t\t\twrapper.element = createElement(markup);\n\t\t}\n\n\t\twrapper.renderer = renderer;\n\t},\n\n\t/**\n\t * Add the node to the given parent\n\t * @param {Object} parent\n\t */\n\tadd: function (parent) {\n\t\tvar wrapper = this,\n\t\t\trenderer = wrapper.renderer,\n\t\t\telement = wrapper.element,\n\t\t\tbox = renderer.box,\n\t\t\tinverted = parent && parent.inverted,\n\n\t\t\t// get the parent node\n\t\t\tparentNode = parent ?\n\t\t\t\tparent.element || parent :\n\t\t\t\tbox;\n\n\n\t\t// if the parent group is inverted, apply inversion on all children\n\t\tif (inverted) { // only on groups\n\t\t\trenderer.invertChild(element, parentNode);\n\t\t}\n\n\t\t// append it\n\t\tparentNode.appendChild(element);\n\n\t\t// align text after adding to be able to read offset\n\t\twrapper.added = true;\n\t\tif (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n\t\t\twrapper.updateTransform();\n\t\t}\n\n\t\t// fire an event for internal hooks\n\t\tif (wrapper.onAdd) {\n\t\t\twrapper.onAdd();\n\t\t}\n\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * VML always uses htmlUpdateTransform\n\t */\n\tupdateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n\t/**\n\t * Set the rotation of a span with oldIE's filter\n\t */\n\tsetSpanRotation: function () {\n\t\t// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n\t\t// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n\t\t// has support for CSS3 transform. The getBBox method also needs to be updated\n\t\t// to compensate for the rotation, like it currently does for SVG.\n\t\t// Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n\t\tvar rotation = this.rotation,\n\t\t\tcostheta = mathCos(rotation * deg2rad),\n\t\t\tsintheta = mathSin(rotation * deg2rad);\n\t\t\t\t\t\n\t\tcss(this.element, {\n\t\t\tfilter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n\t\t\t\t', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n\t\t\t\t', sizingMethod=\\'auto expand\\')'].join('') : NONE\n\t\t});\n\t},\n\n\t/**\n\t * Get the positioning correction for the span after rotating. \n\t */\n\tgetSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n\t\tvar costheta = rotation ? mathCos(rotation * deg2rad) : 1,\n\t\t\tsintheta = rotation ? mathSin(rotation * deg2rad) : 0,\n\t\t\theight = pick(this.elemHeight, this.element.offsetHeight),\n\t\t\tquad,\n\t\t\tnonLeft = align && align !== 'left';\n\n\t\t// correct x and y\n\t\tthis.xCorr = costheta < 0 && -width;\n\t\tthis.yCorr = sintheta < 0 && -height;\n\n\t\t// correct for baseline and corners spilling out after rotation\n\t\tquad = costheta * sintheta < 0;\n\t\tthis.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n\t\tthis.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n\t\t// correct for the length/height of the text\n\t\tif (nonLeft) {\n\t\t\tthis.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n\t\t\tif (rotation) {\n\t\t\t\tthis.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n\t\t\t}\n\t\t\tcss(this.element, {\n\t\t\t\ttextAlign: align\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n\t * as the parameter and returns a string.\n\t */\n\tpathToVML: function (value) {\n\t\t// convert paths\n\t\tvar i = value.length,\n\t\t\tpath = [];\n\n\t\twhile (i--) {\n\n\t\t\t// Multiply by 10 to allow subpixel precision.\n\t\t\t// Substracting half a pixel seems to make the coordinates\n\t\t\t// align with SVG, but this hasn't been tested thoroughly\n\t\t\tif (isNumber(value[i])) {\n\t\t\t\tpath[i] = mathRound(value[i] * 10) - 5;\n\t\t\t} else if (value[i] === 'Z') { // close the path\n\t\t\t\tpath[i] = 'x';\n\t\t\t} else {\n\t\t\t\tpath[i] = value[i];\n\n\t\t\t\t// When the start X and end X coordinates of an arc are too close,\n\t\t\t\t// they are rounded to the same value above. In this case, substract or \n\t\t\t\t// add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n\t\t\t\tif (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n\t\t\t\t\t// Start and end X\n\t\t\t\t\tif (path[i + 5] === path[i + 7]) {\n\t\t\t\t\t\tpath[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t\t// Start and end Y\n\t\t\t\t\tif (path[i + 6] === path[i + 8]) {\n\t\t\t\t\t\tpath[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// Loop up again to handle path shortcuts (#2132)\n\t\t/*while (i++ < path.length) {\n\t\t\tif (path[i] === 'H') { // horizontal line to\n\t\t\t\tpath[i] = 'L';\n\t\t\t\tpath.splice(i + 2, 0, path[i - 1]);\n\t\t\t} else if (path[i] === 'V') { // vertical line to\n\t\t\t\tpath[i] = 'L';\n\t\t\t\tpath.splice(i + 1, 0, path[i - 2]);\n\t\t\t}\n\t\t}*/\n\t\treturn path.join(' ') || 'x';\n\t},\n\n\t/**\n\t * Set the element's clipping to a predefined rectangle\n\t *\n\t * @param {String} id The id of the clip rectangle\n\t */\n\tclip: function (clipRect) {\n\t\tvar wrapper = this,\n\t\t\tclipMembers,\n\t\t\tcssRet;\n\n\t\tif (clipRect) {\n\t\t\tclipMembers = clipRect.members;\n\t\t\terase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n\t\t\tclipMembers.push(wrapper);\n\t\t\twrapper.destroyClip = function () {\n\t\t\t\terase(clipMembers, wrapper);\n\t\t\t};\n\t\t\tcssRet = clipRect.getCSS(wrapper);\n\n\t\t} else {\n\t\t\tif (wrapper.destroyClip) {\n\t\t\t\twrapper.destroyClip();\n\t\t\t}\n\t\t\tcssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n\t\t}\n\n\t\treturn wrapper.css(cssRet);\n\n\t},\n\n\t/**\n\t * Set styles for the element\n\t * @param {Object} styles\n\t */\n\tcss: SVGElement.prototype.htmlCss,\n\n\t/**\n\t * Removes a child either by removeChild or move to garbageBin.\n\t * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n\t */\n\tsafeRemoveChild: function (element) {\n\t\t// discardElement will detach the node from its parent before attaching it\n\t\t// to the garbage bin. Therefore it is important that the node is attached and have parent.\n\t\tif (element.parentNode) {\n\t\t\tdiscardElement(element);\n\t\t}\n\t},\n\n\t/**\n\t * Extend element.destroy by removing it from the clip members array\n\t */\n\tdestroy: function () {\n\t\tif (this.destroyClip) {\n\t\t\tthis.destroyClip();\n\t\t}\n\n\t\treturn SVGElement.prototype.destroy.apply(this);\n\t},\n\n\t/**\n\t * Add an event listener. VML override for normalizing event parameters.\n\t * @param {String} eventType\n\t * @param {Function} handler\n\t */\n\ton: function (eventType, handler) {\n\t\t// simplest possible event model for internal use\n\t\tthis.element['on' + eventType] = function () {\n\t\t\tvar evt = win.event;\n\t\t\tevt.target = evt.srcElement;\n\t\t\thandler(evt);\n\t\t};\n\t\treturn this;\n\t},\n\n\t/**\n\t * In stacked columns, cut off the shadows so that they don't overlap\n\t */\n\tcutOffPath: function (path, length) {\n\n\t\tvar len;\n\n\t\tpath = path.split(/[ ,]/);\n\t\tlen = path.length;\n\n\t\tif (len === 9 || len === 11) {\n\t\t\tpath[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n\t\t}\n\t\treturn path.join(' ');\n\t},\n\n\t/**\n\t * Apply a drop shadow by copying elements and giving them different strokes\n\t * @param {Boolean|Object} shadowOptions\n\t */\n\tshadow: function (shadowOptions, group, cutOff) {\n\t\tvar shadows = [],\n\t\t\ti,\n\t\t\telement = this.element,\n\t\t\trenderer = this.renderer,\n\t\t\tshadow,\n\t\t\telemStyle = element.style,\n\t\t\tmarkup,\n\t\t\tpath = element.path,\n\t\t\tstrokeWidth,\n\t\t\tmodifiedPath,\n\t\t\tshadowWidth,\n\t\t\tshadowElementOpacity;\n\n\t\t// some times empty paths are not strings\n\t\tif (path && typeof path.value !== 'string') {\n\t\t\tpath = 'x';\n\t\t}\n\t\tmodifiedPath = path;\n\n\t\tif (shadowOptions) {\n\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n\t\t\tfor (i = 1; i <= 3; i++) {\n\n\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n\t\t\t\t// Cut off shadows for stacked column items\n\t\t\t\tif (cutOff) {\n\t\t\t\t\tmodifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n\t\t\t\t}\n\n\t\t\t\tmarkup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n\t\t\t\t\t'\" filled=\"false\" path=\"', modifiedPath,\n\t\t\t\t\t'\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n\n\t\t\t\tshadow = createElement(renderer.prepVML(markup),\n\t\t\t\t\tnull, {\n\t\t\t\t\t\tleft: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n\t\t\t\t\t\ttop: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (cutOff) {\n\t\t\t\t\tshadow.cutOff = strokeWidth + 1;\n\t\t\t\t}\n\n\t\t\t\t// apply the opacity\n\t\t\t\tmarkup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n\t\t\t\tcreateElement(renderer.prepVML(markup), null, null, shadow);\n\n\n\t\t\t\t// insert it\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t} else {\n\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t}\n\n\t\t\t\t// record it\n\t\t\t\tshadows.push(shadow);\n\n\t\t\t}\n\n\t\t\tthis.shadows = shadows;\n\t\t}\n\t\treturn this;\n\t},\n\tupdateShadows: noop, // Used in SVG only\n\n\tsetAttr: function (key, value) {\n\t\tif (docMode8) { // IE8 setAttribute bug\n\t\t\tthis.element[key] = value;\n\t\t} else {\n\t\t\tthis.element.setAttribute(key, value);\n\t\t}\n\t},\n\tclassSetter: function (value) {\n\t\t// IE8 Standards mode has problems retrieving the className unless set like this\n\t\tthis.element.className = value;\n\t},\n\tdashstyleSetter: function (value, key, element) {\n\t\tvar strokeElem = element.getElementsByTagName('stroke')[0] ||\n\t\t\tcreateElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n\t\tstrokeElem[key] = value || 'solid';\n\t\tthis[key] = value; /* because changing stroke-width will change the dash length\n\t\t\tand cause an epileptic effect */\n\t},\n\tdSetter: function (value, key, element) {\n\t\tvar i,\n\t\t\tshadows = this.shadows;\n\t\tvalue = value || [];\n\t\tthis.d = value.join && value.join(' '); // used in getter for animation\n\n\t\telement.path = value = this.pathToVML(value);\n\n\t\t// update shadows\n\t\tif (shadows) {\n\t\t\ti = shadows.length;\n\t\t\twhile (i--) {\n\t\t\t\tshadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n\t\t\t}\n\t\t}\n\t\tthis.setAttr(key, value);\n\t},\n\tfillSetter: function (value, key, element) {\n\t\tvar nodeName = element.nodeName;\n\t\tif (nodeName === 'SPAN') { // text color\n\t\t\telement.style.color = value;\n\t\t} else if (nodeName !== 'IMG') { // #1336\n\t\t\telement.filled = value !== NONE;\n\t\t\tthis.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n\t\t}\n\t},\n\topacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n\trotationSetter: function (value, key, element) {\n\t\tvar style = element.style;\n\t\tthis[key] = style[key] = value; // style is for #1873\n\n\t\t// Correction for the 1x1 size of the shape container. Used in gauge needles.\n\t\tstyle.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n\t\tstyle.top = mathRound(mathCos(value * deg2rad)) + PX;\n\t},\n\tstrokeSetter: function (value, key, element) {\n\t\tthis.setAttr('strokecolor', this.renderer.color(value, element, key));\n\t},\n\t'stroke-widthSetter': function (value, key, element) {\n\t\telement.stroked = !!value; // VML \"stroked\" attribute\n\t\tthis[key] = value; // used in getter, issue #113\n\t\tif (isNumber(value)) {\n\t\t\tvalue += PX;\n\t\t}\n\t\tthis.setAttr('strokeweight', value);\n\t},\n\ttitleSetter: function (value, key) {\n\t\tthis.setAttr(key, value);\n\t},\n\tvisibilitySetter: function (value, key, element) {\n\n\t\t// Handle inherited visibility\n\t\tif (value === 'inherit') {\n\t\t\tvalue = VISIBLE;\n\t\t}\n\t\t\n\t\t// Let the shadow follow the main element\n\t\tif (this.shadows) {\n\t\t\teach(this.shadows, function (shadow) {\n\t\t\t\tshadow.style[key] = value;\n\t\t\t});\n\t\t}\n\n\t\t// Instead of toggling the visibility CSS property, move the div out of the viewport.\n\t\t// This works around #61 and #586\n\t\tif (element.nodeName === 'DIV') {\n\t\t\tvalue = value === HIDDEN ? '-999em' : 0;\n\n\t\t\t// In order to redraw, IE7 needs the div to be visible when tucked away\n\t\t\t// outside the viewport. So the visibility is actually opposite of\n\t\t\t// the expected value. This applies to the tooltip only.\n\t\t\tif (!docMode8) {\n\t\t\t\telement.style[key] = value ? VISIBLE : HIDDEN;\n\t\t\t}\n\t\t\tkey = 'top';\n\t\t}\n\t\telement.style[key] = value;\n\t},\n\txSetter: function (value, key, element) {\n\t\tthis[key] = value; // used in getter\n\n\t\tif (key === 'x') {\n\t\t\tkey = 'left';\n\t\t} else if (key === 'y') {\n\t\t\tkey = 'top';\n\t\t}/* else {\n\t\t\tvalue = mathMax(0, value); // don't set width or height below zero (#311)\n\t\t}*/\n\n\t\t// clipping rectangle special\n\t\tif (this.updateClipping) {\n\t\t\tthis[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n\t\t\tthis.updateClipping();\n\t\t} else {\n\t\t\t// normal\n\t\t\telement.style[key] = value;\n\t\t}\n\t},\n\tzIndexSetter: function (value, key, element) {\n\t\telement.style[key] = value;\n\t}\n};\nHighcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n// Some shared setters\nVMLElement.prototype.ySetter =\n\tVMLElement.prototype.widthSetter = \n\tVMLElement.prototype.heightSetter = \n\tVMLElement.prototype.xSetter;\n\n\n/**\n * The VML renderer\n */\nvar VMLRendererExtension = { // inherit SVGRenderer\n\n\tElement: VMLElement,\n\tisIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n\t/**\n\t * Initialize the VMLRenderer\n\t * @param {Object} container\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\tinit: function (container, width, height, style) {\n\t\tvar renderer = this,\n\t\t\tboxWrapper,\n\t\t\tbox,\n\t\t\tcss;\n\n\t\trenderer.alignedObjects = [];\n\n\t\tboxWrapper = renderer.createElement(DIV)\n\t\t\t.css(extend(this.getStyle(style), { position: RELATIVE}));\n\t\tbox = boxWrapper.element;\n\t\tcontainer.appendChild(boxWrapper.element);\n\n\n\t\t// generate the containing box\n\t\trenderer.isVML = true;\n\t\trenderer.box = box;\n\t\trenderer.boxWrapper = boxWrapper;\n\t\trenderer.cache = {};\n\n\n\t\trenderer.setSize(width, height, false);\n\n\t\t// The only way to make IE6 and IE7 print is to use a global namespace. However,\n\t\t// with IE8 the only way to make the dynamic shapes visible in screen and print mode\n\t\t// seems to be to add the xmlns attribute and the behaviour style inline.\n\t\tif (!doc.namespaces.hcv) {\n\n\t\t\tdoc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n\t\t\t// Setup default CSS (#2153, #2368, #2384)\n\t\t\tcss = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n\t\t\t\t'{ behavior:url(#default#VML); display: inline-block; } ';\n\t\t\ttry {\n\t\t\t\tdoc.createStyleSheet().cssText = css;\n\t\t\t} catch (e) {\n\t\t\t\tdoc.styleSheets[0].cssText += css;\n\t\t\t}\n\n\t\t}\n\t},\n\n\n\t/**\n\t * Detect whether the renderer is hidden. This happens when one of the parent elements\n\t * has display: none\n\t */\n\tisHidden: function () {\n\t\treturn !this.box.offsetWidth;\n\t},\n\n\t/**\n\t * Define a clipping rectangle. In VML it is accomplished by storing the values\n\t * for setting the CSS style to all associated members.\n\t *\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\tclipRect: function (x, y, width, height) {\n\n\t\t// create a dummy element\n\t\tvar clipRect = this.createElement(),\n\t\t\tisObj = isObject(x);\n\n\t\t// mimic a rectangle with its style object for automatic updating in attr\n\t\treturn extend(clipRect, {\n\t\t\tmembers: [],\n\t\t\tcount: 0,\n\t\t\tleft: (isObj ? x.x : x) + 1,\n\t\t\ttop: (isObj ? x.y : y) + 1,\n\t\t\twidth: (isObj ? x.width : width) - 1,\n\t\t\theight: (isObj ? x.height : height) - 1,\n\t\t\tgetCSS: function (wrapper) {\n\t\t\t\tvar element = wrapper.element,\n\t\t\t\t\tnodeName = element.nodeName,\n\t\t\t\t\tisShape = nodeName === 'shape',\n\t\t\t\t\tinverted = wrapper.inverted,\n\t\t\t\t\trect = this,\n\t\t\t\t\ttop = rect.top - (isShape ? element.offsetTop : 0),\n\t\t\t\t\tleft = rect.left,\n\t\t\t\t\tright = left + rect.width,\n\t\t\t\t\tbottom = top + rect.height,\n\t\t\t\t\tret = {\n\t\t\t\t\t\tclip: 'rect(' +\n\t\t\t\t\t\t\tmathRound(inverted ? left : top) + 'px,' +\n\t\t\t\t\t\t\tmathRound(inverted ? bottom : right) + 'px,' +\n\t\t\t\t\t\t\tmathRound(inverted ? right : bottom) + 'px,' +\n\t\t\t\t\t\t\tmathRound(inverted ? top : left) + 'px)'\n\t\t\t\t\t};\n\n\t\t\t\t// issue 74 workaround\n\t\t\t\tif (!inverted && docMode8 && nodeName === 'DIV') {\n\t\t\t\t\textend(ret, {\n\t\t\t\t\t\twidth: right + PX,\n\t\t\t\t\t\theight: bottom + PX\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// used in attr and animation to update the clipping of all members\n\t\t\tupdateClipping: function () {\n\t\t\t\teach(clipRect.members, function (member) {\n\t\t\t\t\tif (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n\t\t\t\t\t\tmember.css(clipRect.getCSS(member));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t},\n\n\n\t/**\n\t * Take a color and return it if it's a string, make it a gradient if it's a\n\t * gradient configuration object, and apply opacity.\n\t *\n\t * @param {Object} color The color or config object\n\t */\n\tcolor: function (color, elem, prop, wrapper) {\n\t\tvar renderer = this,\n\t\t\tcolorObject,\n\t\t\tregexRgba = /^rgba/,\n\t\t\tmarkup,\n\t\t\tfillType,\n\t\t\tret = NONE;\n\n\t\t// Check for linear or radial gradient\n\t\tif (color && color.linearGradient) {\n\t\t\tfillType = 'gradient';\n\t\t} else if (color && color.radialGradient) {\n\t\t\tfillType = 'pattern';\n\t\t}\n\n\n\t\tif (fillType) {\n\n\t\t\tvar stopColor,\n\t\t\t\tstopOpacity,\n\t\t\t\tgradient = color.linearGradient || color.radialGradient,\n\t\t\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2,\n\t\t\t\topacity1,\n\t\t\t\topacity2,\n\t\t\t\tcolor1,\n\t\t\t\tcolor2,\n\t\t\t\tfillAttr = '',\n\t\t\t\tstops = color.stops,\n\t\t\t\tfirstStop,\n\t\t\t\tlastStop,\n\t\t\t\tcolors = [],\n\t\t\t\taddFillNode = function () {\n\t\t\t\t\t// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n\t\t\t\t\t// are reversed.\n\t\t\t\t\tmarkup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n\t\t\t\t\t\t'\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n\t\t\t\t\tcreateElement(renderer.prepVML(markup), null, null, elem);\n\t\t\t\t};\n\n\t\t\t// Extend from 0 to 1\n\t\t\tfirstStop = stops[0];\n\t\t\tlastStop = stops[stops.length - 1];\n\t\t\tif (firstStop[0] > 0) {\n\t\t\t\tstops.unshift([\n\t\t\t\t\t0,\n\t\t\t\t\tfirstStop[1]\n\t\t\t\t]);\n\t\t\t}\n\t\t\tif (lastStop[0] < 1) {\n\t\t\t\tstops.push([\n\t\t\t\t\t1,\n\t\t\t\t\tlastStop[1]\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\t// Compute the stops\n\t\t\teach(stops, function (stop, i) {\n\t\t\t\tif (regexRgba.test(stop[1])) {\n\t\t\t\t\tcolorObject = Color(stop[1]);\n\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t} else {\n\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t}\n\n\t\t\t\t// Build the color attribute\n\t\t\t\tcolors.push((stop[0] * 100) + '% ' + stopColor);\n\n\t\t\t\t// Only start and end opacities are allowed, so we use the first and the last\n\t\t\t\tif (!i) {\n\t\t\t\t\topacity1 = stopOpacity;\n\t\t\t\t\tcolor2 = stopColor;\n\t\t\t\t} else {\n\t\t\t\t\topacity2 = stopOpacity;\n\t\t\t\t\tcolor1 = stopColor;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Apply the gradient to fills only.\n\t\t\tif (prop === 'fill') {\n\n\t\t\t\t// Handle linear gradient angle\n\t\t\t\tif (fillType === 'gradient') {\n\t\t\t\t\tx1 = gradient.x1 || gradient[0] || 0;\n\t\t\t\t\ty1 = gradient.y1 || gradient[1] || 0;\n\t\t\t\t\tx2 = gradient.x2 || gradient[2] || 0;\n\t\t\t\t\ty2 = gradient.y2 || gradient[3] || 0;\n\t\t\t\t\tfillAttr = 'angle=\"' + (90  - math.atan(\n\t\t\t\t\t\t(y2 - y1) / // y vector\n\t\t\t\t\t\t(x2 - x1) // x vector\n\t\t\t\t\t\t) * 180 / mathPI) + '\"';\n\n\t\t\t\t\taddFillNode();\n\n\t\t\t\t// Radial (circular) gradient\n\t\t\t\t} else {\n\n\t\t\t\t\tvar r = gradient.r,\n\t\t\t\t\t\tsizex = r * 2,\n\t\t\t\t\t\tsizey = r * 2,\n\t\t\t\t\t\tcx = gradient.cx,\n\t\t\t\t\t\tcy = gradient.cy,\n\t\t\t\t\t\tradialReference = elem.radialReference,\n\t\t\t\t\t\tbBox,\n\t\t\t\t\t\tapplyRadialGradient = function () {\n\t\t\t\t\t\t\tif (radialReference) {\n\t\t\t\t\t\t\t\tbBox = wrapper.getBBox();\n\t\t\t\t\t\t\t\tcx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n\t\t\t\t\t\t\t\tcy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n\t\t\t\t\t\t\t\tsizex *= radialReference[2] / bBox.width;\n\t\t\t\t\t\t\t\tsizey *= radialReference[2] / bBox.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n\t\t\t\t\t\t\t\t'size=\"' + sizex + ',' + sizey + '\" ' +\n\t\t\t\t\t\t\t\t'origin=\"0.5,0.5\" ' +\n\t\t\t\t\t\t\t\t'position=\"' + cx + ',' + cy + '\" ' +\n\t\t\t\t\t\t\t\t'color2=\"' + color2 + '\" ';\n\n\t\t\t\t\t\t\taddFillNode();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// Apply radial gradient\n\t\t\t\t\tif (wrapper.added) {\n\t\t\t\t\t\tapplyRadialGradient();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We need to know the bounding box to get the size and position right\n\t\t\t\t\t\twrapper.onAdd = applyRadialGradient;\n\t\t\t\t\t}\n\n\t\t\t\t\t// The fill element's color attribute is broken in IE8 standards mode, so we\n\t\t\t\t\t// need to set the parent shape's fillcolor attribute instead.\n\t\t\t\t\tret = color1;\n\t\t\t\t}\n\n\t\t\t// Gradients are not supported for VML stroke, return the first color. #722.\n\t\t\t} else {\n\t\t\t\tret = stopColor;\n\t\t\t}\n\n\t\t// if the color is an rgba color, split it and add a fill node\n\t\t// to hold the opacity component\n\t\t} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n\t\t\tcolorObject = Color(color);\n\n\t\t\tmarkup = ['<', prop, ' opacity=\"', colorObject.get('a'), '\"/>'];\n\t\t\tcreateElement(this.prepVML(markup), null, null, elem);\n\n\t\t\tret = colorObject.get('rgb');\n\n\n\t\t} else {\n\t\t\tvar propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n\t\t\tif (propNodes.length) {\n\t\t\t\tpropNodes[0].opacity = 1;\n\t\t\t\tpropNodes[0].type = 'solid';\n\t\t\t}\n\t\t\tret = color;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * Take a VML string and prepare it for either IE8 or IE6/IE7.\n\t * @param {Array} markup A string array of the VML markup to prepare\n\t */\n\tprepVML: function (markup) {\n\t\tvar vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n\t\t\tisIE8 = this.isIE8;\n\n\t\tmarkup = markup.join('');\n\n\t\tif (isIE8) { // add xmlns and style inline\n\t\t\tmarkup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n\t\t\tif (markup.indexOf('style=\"') === -1) {\n\t\t\t\tmarkup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n\t\t\t} else {\n\t\t\t\tmarkup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n\t\t\t}\n\n\t\t} else { // add namespace\n\t\t\tmarkup = markup.replace('<', '<hcv:');\n\t\t}\n\n\t\treturn markup;\n\t},\n\n\t/**\n\t * Create rotated and aligned text\n\t * @param {String} str\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\ttext: SVGRenderer.prototype.html,\n\n\t/**\n\t * Create and return a path element\n\t * @param {Array} path\n\t */\n\tpath: function (path) {\n\t\tvar attr = {\n\t\t\t// subpixel precision down to 0.1 (width and height = 1px)\n\t\t\tcoordsize: '10 10'\n\t\t};\n\t\tif (isArray(path)) {\n\t\t\tattr.d = path;\n\t\t} else if (isObject(path)) { // attributes\n\t\t\textend(attr, path);\n\t\t}\n\t\t// create the shape\n\t\treturn this.createElement('shape').attr(attr);\n\t},\n\n\t/**\n\t * Create and return a circle element. In VML circles are implemented as\n\t * shapes, which is faster than v:oval\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} r\n\t */\n\tcircle: function (x, y, r) {\n\t\tvar circle = this.symbol('circle');\n\t\tif (isObject(x)) {\n\t\t\tr = x.r;\n\t\t\ty = x.y;\n\t\t\tx = x.x;\n\t\t}\n\t\tcircle.isCircle = true; // Causes x and y to mean center (#1682)\n\t\tcircle.r = r;\n\t\treturn circle.attr({ x: x, y: y });\n\t},\n\n\t/**\n\t * Create a group using an outer div and an inner v:group to allow rotating\n\t * and flipping. A simple v:group would have problems with positioning\n\t * child HTML elements and CSS clip.\n\t *\n\t * @param {String} name The name of the group\n\t */\n\tg: function (name) {\n\t\tvar wrapper,\n\t\t\tattribs;\n\n\t\t// set the class name\n\t\tif (name) {\n\t\t\tattribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n\t\t}\n\n\t\t// the div to hold HTML and clipping\n\t\twrapper = this.createElement(DIV).attr(attribs);\n\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * VML override to create a regular HTML image\n\t * @param {String} src\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @param {Number} width\n\t * @param {Number} height\n\t */\n\timage: function (src, x, y, width, height) {\n\t\tvar obj = this.createElement('img')\n\t\t\t.attr({ src: src });\n\n\t\tif (arguments.length > 1) {\n\t\t\tobj.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t},\n\n\t/**\n\t * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n\t */\n\tcreateElement: function (nodeName) {\n\t\treturn nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);\t\n\t},\n\n\t/**\n\t * In the VML renderer, each child of an inverted div (group) is inverted\n\t * @param {Object} element\n\t * @param {Object} parentNode\n\t */\n\tinvertChild: function (element, parentNode) {\n\t\tvar ren = this,\n\t\t\tparentStyle = parentNode.style,\n\t\t\timgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n\t\tcss(element, {\n\t\t\tflip: 'x',\n\t\t\tleft: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n\t\t\ttop: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n\t\t\trotation: -90\n\t\t});\n\n\t\t// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n\t\teach(element.childNodes, function (child) {\n\t\t\tren.invertChild(child, element);\n\t\t});\n\t},\n\n\t/**\n\t * Symbol definitions that override the parent SVG renderer's symbols\n\t *\n\t */\n\tsymbols: {\n\t\t// VML specific arc function\n\t\tarc: function (x, y, w, h, options) {\n\t\t\tvar start = options.start,\n\t\t\t\tend = options.end,\n\t\t\t\tradius = options.r || w || h,\n\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\tcosStart = mathCos(start),\n\t\t\t\tsinStart = mathSin(start),\n\t\t\t\tcosEnd = mathCos(end),\n\t\t\t\tsinEnd = mathSin(end),\n\t\t\t\tret;\n\n\t\t\tif (end - start === 0) { // no angle, don't show it.\n\t\t\t\treturn ['x'];\n\t\t\t}\n\n\t\t\tret = [\n\t\t\t\t'wa', // clockwise arc to\n\t\t\t\tx - radius, // left\n\t\t\t\ty - radius, // top\n\t\t\t\tx + radius, // right\n\t\t\t\ty + radius, // bottom\n\t\t\t\tx + radius * cosStart, // start x\n\t\t\t\ty + radius * sinStart, // start y\n\t\t\t\tx + radius * cosEnd, // end x\n\t\t\t\ty + radius * sinEnd  // end y\n\t\t\t];\n\n\t\t\tif (options.open && !innerRadius) {\n\t\t\t\tret.push(\n\t\t\t\t\t'e',\n\t\t\t\t\tM,\n\t\t\t\t\tx,// - innerRadius,\n\t\t\t\t\ty// - innerRadius\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.push(\n\t\t\t\t'at', // anti clockwise arc to\n\t\t\t\tx - innerRadius, // left\n\t\t\t\ty - innerRadius, // top\n\t\t\t\tx + innerRadius, // right\n\t\t\t\ty + innerRadius, // bottom\n\t\t\t\tx + innerRadius * cosEnd, // start x\n\t\t\t\ty + innerRadius * sinEnd, // start y\n\t\t\t\tx + innerRadius * cosStart, // end x\n\t\t\t\ty + innerRadius * sinStart, // end y\n\t\t\t\t'x', // finish path\n\t\t\t\t'e' // close\n\t\t\t);\n\n\t\t\tret.isArc = true;\n\t\t\treturn ret;\n\n\t\t},\n\t\t// Add circle symbol path. This performs significantly faster than v:oval.\n\t\tcircle: function (x, y, w, h, wrapper) {\n\n\t\t\tif (wrapper) {\n\t\t\t\tw = h = 2 * wrapper.r;\n\t\t\t}\n\n\t\t\t// Center correction, #1682\n\t\t\tif (wrapper && wrapper.isCircle) {\n\t\t\t\tx -= w / 2;\n\t\t\t\ty -= h / 2;\n\t\t\t}\n\n\t\t\t// Return the path\n\t\t\treturn [\n\t\t\t\t'wa', // clockwisearcto\n\t\t\t\tx, // left\n\t\t\t\ty, // top\n\t\t\t\tx + w, // right\n\t\t\t\ty + h, // bottom\n\t\t\t\tx + w, // start x\n\t\t\t\ty + h / 2,     // start y\n\t\t\t\tx + w, // end x\n\t\t\t\ty + h / 2,     // end y\n\t\t\t\t//'x', // finish path\n\t\t\t\t'e' // close\n\t\t\t];\n\t\t},\n\t\t/**\n\t\t * Add rectangle symbol path which eases rotation and omits arcsize problems\n\t\t * compared to the built-in VML roundrect shape. When borders are not rounded,\n\t\t * use the simpler square path, else use the callout path without the arrow.\n\t\t */\n\t\trect: function (x, y, w, h, options) {\n\t\t\treturn SVGRenderer.prototype.symbols[\n\t\t\t\t!defined(options) || !options.r ? 'square' : 'callout'\n\t\t\t].call(0, x, y, w, h, options);\n\t\t}\n\t}\n};\nHighcharts.VMLRenderer = VMLRenderer = function () {\n\tthis.init.apply(this, arguments);\n};\nVMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n\t// general renderer\n\tRenderer = VMLRenderer;\n}\n\n// This method is used with exporting in old IE, when emulating SVG (see #2314)\nSVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n\tvar measuringSpan = doc.createElement('span'),\n\t\toffsetWidth,\n\ttextNode = doc.createTextNode(text);\n\n\tmeasuringSpan.appendChild(textNode);\n\tcss(measuringSpan, styles);\n\tthis.box.appendChild(measuringSpan);\n\toffsetWidth = measuringSpan.offsetWidth;\n\tdiscardElement(measuringSpan); // #2463\n\treturn offsetWidth;\n};\n\n\n/* ****************************************************************************\n *                                                                            *\n * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n *                                                                            *\n *****************************************************************************/\n/* ****************************************************************************\n *                                                                            *\n * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n * TARGETING THAT SYSTEM.                                                     *\n *                                                                            *\n *****************************************************************************/\nvar CanVGRenderer,\n\tCanVGController;\n\nif (useCanVG) {\n\t/**\n\t * The CanVGRenderer is empty from start to keep the source footprint small.\n\t * When requested, the CanVGController downloads the rest of the source packaged\n\t * together with the canvg library.\n\t */\n\tHighcharts.CanVGRenderer = CanVGRenderer = function () {\n\t\t// Override the global SVG namespace to fake SVG/HTML that accepts CSS\n\t\tSVG_NS = 'http://www.w3.org/1999/xhtml';\n\t};\n\n\t/**\n\t * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but \n\t * the implementation from SvgRenderer will not be merged in until first render.\n\t */\n\tCanVGRenderer.prototype.symbols = {};\n\n\t/**\n\t * Handles on demand download of canvg rendering support.\n\t */\n\tCanVGController = (function () {\n\t\t// List of renderering calls\n\t\tvar deferredRenderCalls = [];\n\n\t\t/**\n\t\t * When downloaded, we are ready to draw deferred charts.\n\t\t */\n\t\tfunction drawDeferred() {\n\t\t\tvar callLength = deferredRenderCalls.length,\n\t\t\t\tcallIndex;\n\n\t\t\t// Draw all pending render calls\n\t\t\tfor (callIndex = 0; callIndex < callLength; callIndex++) {\n\t\t\t\tdeferredRenderCalls[callIndex]();\n\t\t\t}\n\t\t\t// Clear the list\n\t\t\tdeferredRenderCalls = [];\n\t\t}\n\n\t\treturn {\n\t\t\tpush: function (func, scriptLocation) {\n\t\t\t\t// Only get the script once\n\t\t\t\tif (deferredRenderCalls.length === 0) {\n\t\t\t\t\tgetScript(scriptLocation, drawDeferred);\n\t\t\t\t}\n\t\t\t\t// Register render call\n\t\t\t\tdeferredRenderCalls.push(func);\n\t\t\t}\n\t\t};\n\t}());\n\n\tRenderer = CanVGRenderer;\n} // end CanVGRenderer\n\n/* ****************************************************************************\n *                                                                            *\n * END OF ANDROID < 3 SPECIFIC CODE                                           *\n *                                                                            *\n *****************************************************************************/\n\n/**\n * The Tick class\n */\nfunction Tick(axis, pos, type, noLabel) {\n\tthis.axis = axis;\n\tthis.pos = pos;\n\tthis.type = type || '';\n\tthis.isNew = true;\n\n\tif (!type && !noLabel) {\n\t\tthis.addLabel();\n\t}\n}\n\nTick.prototype = {\n\t/**\n\t * Write the tick label\n\t */\n\taddLabel: function () {\n\t\tvar tick = this,\n\t\t\taxis = tick.axis,\n\t\t\toptions = axis.options,\n\t\t\tchart = axis.chart,\n\t\t\tcategories = axis.categories,\n\t\t\tnames = axis.names,\n\t\t\tpos = tick.pos,\n\t\t\tlabelOptions = options.labels,\n\t\t\tstr,\n\t\t\ttickPositions = axis.tickPositions,\n\t\t\tisFirst = pos === tickPositions[0],\n\t\t\tisLast = pos === tickPositions[tickPositions.length - 1],\n\t\t\tvalue = categories ?\n\t\t\t\tpick(categories[pos], names[pos], pos) :\n\t\t\t\tpos,\n\t\t\tlabel = tick.label,\n\t\t\ttickPositionInfo = tickPositions.info,\n\t\t\tdateTimeLabelFormat;\n\n\t\t// Set the datetime label format. If a higher rank is set for this position, use that. If not,\n\t\t// use the general format.\n\t\tif (axis.isDatetimeAxis && tickPositionInfo) {\n\t\t\tdateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n\t\t}\n\t\t// set properties for access in render method\n\t\ttick.isFirst = isFirst;\n\t\ttick.isLast = isLast;\n\n\t\t// get the string\n\t\tstr = axis.labelFormatter.call({\n\t\t\taxis: axis,\n\t\t\tchart: chart,\n\t\t\tisFirst: isFirst,\n\t\t\tisLast: isLast,\n\t\t\tdateTimeLabelFormat: dateTimeLabelFormat,\n\t\t\tvalue: axis.isLog ? correctFloat(lin2log(value)) : value\n\t\t});\n\n\t\t// prepare CSS\n\t\t//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n\t\t\n\t\t// first call\n\t\tif (!defined(label)) {\n\n\t\t\ttick.label = label =\n\t\t\t\tdefined(str) && labelOptions.enabled ?\n\t\t\t\t\tchart.renderer.text(\n\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tlabelOptions.useHTML\n\t\t\t\t\t\t)\n\t\t\t\t\t\t//.attr(attr)\n\t\t\t\t\t\t// without position absolute, IE export sometimes is wrong\n\t\t\t\t\t\t.css(merge(labelOptions.style))\n\t\t\t\t\t\t.add(axis.labelGroup) :\n\t\t\t\t\tnull;\n\t\t\ttick.labelLength = label && label.getBBox().width; // Un-rotated length\n\t\t\ttick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n\t\t// update\n\t\t} else if (label) {\n\t\t\tlabel.attr({ text: str });\n\t\t}\n\t},\n\n\t/**\n\t * Get the offset height or width of the label\n\t */\n\tgetLabelSize: function () {\n\t\treturn this.label ?\n\t\t\tthis.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n\t\t\t0;\n\t},\n\n\t/**\n\t * Handle the label overflow by adjusting the labels to the left and right edge, or\n\t * hide them if they collide into the neighbour label.\n\t */\n\thandleOverflow: function (xy) {\n\t\tvar axis = this.axis,\n\t\t\tpxPos = xy.x,\n\t\t\tchartWidth = axis.chart.chartWidth,\n\t\t\tspacing = axis.chart.spacing,\n\t\t\tleftBound = pick(axis.labelLeft, spacing[3]),\n\t\t\trightBound = pick(axis.labelRight, chartWidth - spacing[1]),\n\t\t\tlabel = this.label,\n\t\t\trotation = this.rotation,\n\t\t\tfactor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n\t\t\tlabelWidth = label.getBBox().width,\n\t\t\tslotWidth = axis.slotWidth,\n\t\t\tleftPos,\n\t\t\trightPos,\n\t\t\ttextWidth;\n\n\t\t// Check if the label overshoots the chart spacing box. If it does, move it.\n\t\t// If it now overshoots the slotWidth, add ellipsis.\n\t\tif (!rotation) {\n\t\t\tleftPos = pxPos - factor * labelWidth;\n\t\t\trightPos = pxPos + factor * labelWidth;\n\n\t\t\tif (leftPos < leftBound) {\n\t\t\t\tslotWidth -= leftBound - leftPos;\n\t\t\t\txy.x = leftBound;\n\t\t\t\tlabel.attr({ align: 'left' });\t\t\t\t\n\t\t\t} else if (rightPos > rightBound) {\n\t\t\t\tslotWidth -= rightPos - rightBound;\n\t\t\t\txy.x = rightBound;\n\t\t\t\tlabel.attr({ align: 'right' });\n\t\t\t}\n\n\t\t\tif (labelWidth > slotWidth) {\n\t\t\t\ttextWidth = slotWidth;\n\t\t\t}\n\t\t\n\n\t\t// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n\t\t} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n\t\t\ttextWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);\n\t\t} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n\t\t\ttextWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));\n\t\t}\n\n\t\tif (textWidth) {\n\t\t\tlabel.css({\n\t\t\t\twidth: textWidth,\n\t\t\t\ttextOverflow: 'ellipsis'\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Get the x and y position for ticks and labels\n\t */\n\tgetPosition: function (horiz, pos, tickmarkOffset, old) {\n\t\tvar axis = this.axis,\n\t\t\tchart = axis.chart,\n\t\t\tcHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n\t\treturn {\n\t\t\tx: horiz ?\n\t\t\t\taxis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n\t\t\t\taxis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n\t\t\ty: horiz ?\n\t\t\t\tcHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n\t\t\t\tcHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n\t\t};\n\n\t},\n\n\t/**\n\t * Get the x, y position of the tick label\n\t */\n\tgetLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n\t\tvar axis = this.axis,\n\t\t\ttransA = axis.transA,\n\t\t\treversed = axis.reversed,\n\t\t\tstaggerLines = axis.staggerLines,\n\t\t\trotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n\t\t\tyOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),\n\t\t\tline;\n\n\t\tx = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n\t\t\ttickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n\t\ty = y + yOffset - (tickmarkOffset && !horiz ?\n\t\t\ttickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n\t\t// Correct for staggered labels\n\t\tif (staggerLines) {\n\t\t\tline = (index / (step || 1) % staggerLines);\n\t\t\ty += line * (axis.labelOffset / staggerLines);\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: mathRound(y)\n\t\t};\n\t},\n\n\t/**\n\t * Extendible method to return the path of the marker\n\t */\n\tgetMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n\t\treturn renderer.crispLine([\n\t\t\t\tM,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tL,\n\t\t\t\tx + (horiz ? 0 : -tickLength),\n\t\t\t\ty + (horiz ? tickLength : 0)\n\t\t\t], tickWidth);\n\t},\n\n\t/**\n\t * Put everything in place\n\t *\n\t * @param index {Number}\n\t * @param old {Boolean} Use old coordinates to prepare an animation into new position\n\t */\n\trender: function (index, old, opacity) {\n\t\tvar tick = this,\n\t\t\taxis = tick.axis,\n\t\t\toptions = axis.options,\n\t\t\tchart = axis.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\thoriz = axis.horiz,\n\t\t\ttype = tick.type,\n\t\t\tlabel = tick.label,\n\t\t\tpos = tick.pos,\n\t\t\tlabelOptions = options.labels,\n\t\t\tgridLine = tick.gridLine,\n\t\t\tgridPrefix = type ? type + 'Grid' : 'grid',\n\t\t\ttickPrefix = type ? type + 'Tick' : 'tick',\n\t\t\tgridLineWidth = options[gridPrefix + 'LineWidth'],\n\t\t\tgridLineColor = options[gridPrefix + 'LineColor'],\n\t\t\tdashStyle = options[gridPrefix + 'LineDashStyle'],\n\t\t\ttickLength = options[tickPrefix + 'Length'],\n\t\t\ttickWidth = options[tickPrefix + 'Width'] || 0,\n\t\t\ttickColor = options[tickPrefix + 'Color'],\n\t\t\ttickPosition = options[tickPrefix + 'Position'],\n\t\t\tgridLinePath,\n\t\t\tmark = tick.mark,\n\t\t\tmarkPath,\n\t\t\tstep = /*axis.labelStep || */labelOptions.step,\n\t\t\tattribs,\n\t\t\tshow = true,\n\t\t\ttickmarkOffset = axis.tickmarkOffset,\n\t\t\txy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n\t\t\tx = xy.x,\n\t\t\ty = xy.y,\n\t\t\treverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n\t\topacity = pick(opacity, 1);\n\t\tthis.isActive = true;\n\n\t\t// create the grid line\n\t\tif (gridLineWidth) {\n\t\t\tgridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n\t\t\tif (gridLine === UNDEFINED) {\n\t\t\t\tattribs = {\n\t\t\t\t\tstroke: gridLineColor,\n\t\t\t\t\t'stroke-width': gridLineWidth\n\t\t\t\t};\n\t\t\t\tif (dashStyle) {\n\t\t\t\t\tattribs.dashstyle = dashStyle;\n\t\t\t\t}\n\t\t\t\tif (!type) {\n\t\t\t\t\tattribs.zIndex = 1;\n\t\t\t\t}\n\t\t\t\tif (old) {\n\t\t\t\t\tattribs.opacity = 0;\n\t\t\t\t}\n\t\t\t\ttick.gridLine = gridLine =\n\t\t\t\t\tgridLineWidth ?\n\t\t\t\t\t\trenderer.path(gridLinePath)\n\t\t\t\t\t\t\t.attr(attribs).add(axis.gridGroup) :\n\t\t\t\t\t\tnull;\n\t\t\t}\n\n\t\t\t// If the parameter 'old' is set, the current call will be followed\n\t\t\t// by another call, therefore do not do any animations this time\n\t\t\tif (!old && gridLine && gridLinePath) {\n\t\t\t\tgridLine[tick.isNew ? 'attr' : 'animate']({\n\t\t\t\t\td: gridLinePath,\n\t\t\t\t\topacity: opacity\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// create the tick mark\n\t\tif (tickWidth && tickLength) {\n\n\t\t\t// negate the length\n\t\t\tif (tickPosition === 'inside') {\n\t\t\t\ttickLength = -tickLength;\n\t\t\t}\n\t\t\tif (axis.opposite) {\n\t\t\t\ttickLength = -tickLength;\n\t\t\t}\n\n\t\t\tmarkPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);\n\t\t\tif (mark) { // updating\n\t\t\t\tmark.animate({\n\t\t\t\t\td: markPath,\n\t\t\t\t\topacity: opacity\n\t\t\t\t});\n\t\t\t} else { // first time\n\t\t\t\ttick.mark = renderer.path(\n\t\t\t\t\tmarkPath\n\t\t\t\t).attr({\n\t\t\t\t\tstroke: tickColor,\n\t\t\t\t\t'stroke-width': tickWidth,\n\t\t\t\t\topacity: opacity\n\t\t\t\t}).add(axis.axisGroup);\n\t\t\t}\n\t\t}\n\n\t\t// the label is created on init - now move it into place\n\t\tif (label && !isNaN(x)) {\n\t\t\tlabel.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n\t\t\t// Apply show first and show last. If the tick is both first and last, it is\n\t\t\t// a single centered tick, in which case we show the label anyway (#2100).\n\t\t\tif ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n\t\t\t\t\t(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n\t\t\t\tshow = false;\n\n\t\t\t// Handle label overflow and show or hide accordingly\n\t\t\t} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n\t\t\t\ttick.handleOverflow(xy);\n\t\t\t}\n\n\t\t\t// apply step\n\t\t\tif (step && index % step) {\n\t\t\t\t// show those indices dividable by step\n\t\t\t\tshow = false;\n\t\t\t}\n\n\t\t\t// Set the new position, and show or hide\n\t\t\tif (show && !isNaN(xy.y)) {\n\t\t\t\txy.opacity = opacity;\n\t\t\t\tlabel[tick.isNew ? 'attr' : 'animate'](xy);\n\t\t\t\ttick.isNew = false;\n\t\t\t} else {\n\t\t\t\tlabel.attr('y', -9999); // #1338\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Destructor for the tick prototype\n\t */\n\tdestroy: function () {\n\t\tdestroyObjectProperties(this, this.axis);\n\t}\n};\n\n/**\n * The object wrapper for plot lines and plot bands\n * @param {Object} options\n */\nHighcharts.PlotLineOrBand = function (axis, options) {\n\tthis.axis = axis;\n\n\tif (options) {\n\t\tthis.options = options;\n\t\tthis.id = options.id;\n\t}\n};\n\nHighcharts.PlotLineOrBand.prototype = {\n\t\n\t/**\n\t * Render the plot line or plot band. If it is already existing,\n\t * move it.\n\t */\n\trender: function () {\n\t\tvar plotLine = this,\n\t\t\taxis = plotLine.axis,\n\t\t\thoriz = axis.horiz,\n\t\t\toptions = plotLine.options,\n\t\t\toptionsLabel = options.label,\n\t\t\tlabel = plotLine.label,\n\t\t\twidth = options.width,\n\t\t\tto = options.to,\n\t\t\tfrom = options.from,\n\t\t\tisBand = defined(from) && defined(to),\n\t\t\tvalue = options.value,\n\t\t\tdashStyle = options.dashStyle,\n\t\t\tsvgElem = plotLine.svgElem,\n\t\t\tpath = [],\n\t\t\taddEvent,\n\t\t\teventType,\n\t\t\txs,\n\t\t\tys,\n\t\t\tx,\n\t\t\ty,\n\t\t\tcolor = options.color,\n\t\t\tzIndex = options.zIndex,\n\t\t\tevents = options.events,\n\t\t\tattribs = {},\n\t\t\trenderer = axis.chart.renderer;\n\n\t\t// logarithmic conversion\n\t\tif (axis.isLog) {\n\t\t\tfrom = log2lin(from);\n\t\t\tto = log2lin(to);\n\t\t\tvalue = log2lin(value);\n\t\t}\n\n\t\t// plot line\n\t\tif (width) {\n\t\t\tpath = axis.getPlotLinePath(value, width);\n\t\t\tattribs = {\n\t\t\t\tstroke: color,\n\t\t\t\t'stroke-width': width\n\t\t\t};\n\t\t\tif (dashStyle) {\n\t\t\t\tattribs.dashstyle = dashStyle;\n\t\t\t}\n\t\t} else if (isBand) { // plot band\n\n\t\t\tpath = axis.getPlotBandPath(from, to, options);\n\t\t\tif (color) {\n\t\t\t\tattribs.fill = color;\n\t\t\t}\n\t\t\tif (options.borderWidth) {\n\t\t\t\tattribs.stroke = options.borderColor;\n\t\t\t\tattribs['stroke-width'] = options.borderWidth;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t// zIndex\n\t\tif (defined(zIndex)) {\n\t\t\tattribs.zIndex = zIndex;\n\t\t}\n\n\t\t// common for lines and bands\n\t\tif (svgElem) {\n\t\t\tif (path) {\n\t\t\t\tsvgElem.animate({\n\t\t\t\t\td: path\n\t\t\t\t}, null, svgElem.onGetPath);\n\t\t\t} else {\n\t\t\t\tsvgElem.hide();\n\t\t\t\tsvgElem.onGetPath = function () {\n\t\t\t\t\tsvgElem.show();\n\t\t\t\t};\n\t\t\t\tif (label) {\n\t\t\t\t\tplotLine.label = label = label.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (path && path.length) {\n\t\t\tplotLine.svgElem = svgElem = renderer.path(path)\n\t\t\t\t.attr(attribs).add();\n\n\t\t\t// events\n\t\t\tif (events) {\n\t\t\t\taddEvent = function (eventType) {\n\t\t\t\t\tsvgElem.on(eventType, function (e) {\n\t\t\t\t\t\tevents[eventType].apply(plotLine, [e]);\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tfor (eventType in events) {\n\t\t\t\t\taddEvent(eventType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the plot band/line label\n\t\tif (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {\n\t\t\t// apply defaults\n\t\t\toptionsLabel = merge({\n\t\t\t\talign: horiz && isBand && 'center',\n\t\t\t\tx: horiz ? !isBand && 4 : 10,\n\t\t\t\tverticalAlign : !horiz && isBand && 'middle',\n\t\t\t\ty: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n\t\t\t\trotation: horiz && !isBand && 90\n\t\t\t}, optionsLabel);\n\n\t\t\t// add the SVG element\n\t\t\tif (!label) {\n\t\t\t\tattribs = {\n\t\t\t\t\talign: optionsLabel.textAlign || optionsLabel.align,\n\t\t\t\t\trotation: optionsLabel.rotation\n\t\t\t\t};\n\t\t\t\tif (defined(zIndex)) {\n\t\t\t\t\tattribs.zIndex = zIndex;\n\t\t\t\t}\n\t\t\t\tplotLine.label = label = renderer.text(\n\t\t\t\t\t\toptionsLabel.text,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\toptionsLabel.useHTML\n\t\t\t\t\t)\n\t\t\t\t\t.attr(attribs)\n\t\t\t\t\t.css(optionsLabel.style)\n\t\t\t\t\t.add();\n\t\t\t}\n\n\t\t\t// get the bounding box and align the label\n\t\t\t// #3000 changed to better handle choice between plotband or plotline\n\t\t\txs = [path[1], path[4], (isBand ? path[6] : path[1])];\n\t\t\tys = [path[2], path[5], (isBand ? path[7] : path[2])];\n\t\t\tx = arrayMin(xs);\n\t\t\ty = arrayMin(ys);\n\n\t\t\tlabel.align(optionsLabel, false, {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: arrayMax(xs) - x,\n\t\t\t\theight: arrayMax(ys) - y\n\t\t\t});\n\t\t\tlabel.show();\n\n\t\t} else if (label) { // move out of sight\n\t\t\tlabel.hide();\n\t\t}\n\n\t\t// chainable\n\t\treturn plotLine;\n\t},\n\n\t/**\n\t * Remove the plot line or band\n\t */\n\tdestroy: function () {\n\t\t// remove it from the lookup\n\t\terase(this.axis.plotLinesAndBands, this);\n\t\t\n\t\tdelete this.axis;\n\t\tdestroyObjectProperties(this);\n\t}\n};\n\n/**\n * Object with members for extending the Axis prototype\n */\n\nAxisPlotLineOrBandExtension = {\n\n\t/**\n\t * Create the path for a plot band\n\t */ \n\tgetPlotBandPath: function (from, to) {\n\t\tvar toPath = this.getPlotLinePath(to, null, null, true),\n\t\t\tpath = this.getPlotLinePath(from, null, null, true);\n\n\t\tif (path && toPath && path.toString() !== toPath.toString()) { // #3836\n\t\t\tpath.push(\n\t\t\t\ttoPath[4],\n\t\t\t\ttoPath[5],\n\t\t\t\ttoPath[1],\n\t\t\t\ttoPath[2]\n\t\t\t);\n\t\t} else { // outside the axis area\n\t\t\tpath = null;\n\t\t}\n\t\t\n\t\treturn path;\n\t},\n\n\taddPlotBand: function (options) {\n\t\treturn this.addPlotBandOrLine(options, 'plotBands');\n\t},\n\t\n\taddPlotLine: function (options) {\n\t\treturn this.addPlotBandOrLine(options, 'plotLines');\n\t},\n\n\t/**\n\t * Add a plot band or plot line after render time\n\t *\n\t * @param options {Object} The plotBand or plotLine configuration object\n\t */\n\taddPlotBandOrLine: function (options, coll) {\n\t\tvar obj = new Highcharts.PlotLineOrBand(this, options).render(),\n\t\t\tuserOptions = this.userOptions;\n\n\t\tif (obj) { // #2189\n\t\t\t// Add it to the user options for exporting and Axis.update\n\t\t\tif (coll) {\n\t\t\t\tuserOptions[coll] = userOptions[coll] || [];\n\t\t\t\tuserOptions[coll].push(options); \n\t\t\t}\n\t\t\tthis.plotLinesAndBands.push(obj); \n\t\t}\n\t\t\n\t\treturn obj;\n\t},\n\n\t/**\n\t * Remove a plot band or plot line from the chart by id\n\t * @param {Object} id\n\t */\n\tremovePlotBandOrLine: function (id) {\n\t\tvar plotLinesAndBands = this.plotLinesAndBands,\n\t\t\toptions = this.options,\n\t\t\tuserOptions = this.userOptions,\n\t\t\ti = plotLinesAndBands.length;\n\t\twhile (i--) {\n\t\t\tif (plotLinesAndBands[i].id === id) {\n\t\t\t\tplotLinesAndBands[i].destroy();\n\t\t\t}\n\t\t}\n\t\teach([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n\t\t\ti = arr.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (arr[i].id === id) {\n\t\t\t\t\terase(arr, arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Create a new axis object\n * @param {Object} chart\n * @param {Object} options\n */\nvar Axis = Highcharts.Axis = function () {\n\tthis.init.apply(this, arguments);\n};\n\nAxis.prototype = {\n\n\t/**\n\t * Default options for the X axis - the Y axis has extended defaults\n\t */\n\tdefaultOptions: {\n\t\t// allowDecimals: null,\n\t\t// alternateGridColor: null,\n\t\t// categories: [],\n\t\tdateTimeLabelFormats: {\n\t\t\tmillisecond: '%H:%M:%S.%L',\n\t\t\tsecond: '%H:%M:%S',\n\t\t\tminute: '%H:%M',\n\t\t\thour: '%H:%M',\n\t\t\tday: '%e. %b',\n\t\t\tweek: '%e. %b',\n\t\t\tmonth: '%b \\'%y',\n\t\t\tyear: '%Y'\n\t\t},\n\t\tendOnTick: false,\n\t\tgridLineColor: '#D8D8D8',\n\t\t// gridLineDashStyle: 'solid',\n\t\t// gridLineWidth: 0,\n\t\t// reversed: false,\n\n\t\tlabels: {\n\t\t\tenabled: true,\n\t\t\t// rotation: 0,\n\t\t\t// align: 'center',\n\t\t\t// step: null,\n\t\t\tstyle: {\n\t\t\t\tcolor: '#606060',\n\t\t\t\tcursor: 'default',\n\t\t\t\tfontSize: '11px'\n\t\t\t},\n\t\t\tx: 0,\n\t\t\ty: 15\n\t\t\t/*formatter: function () {\n\t\t\t\treturn this.value;\n\t\t\t},*/\n\t\t},\n\t\tlineColor: '#C0D0E0',\n\t\tlineWidth: 1,\n\t\t//linkedTo: null,\n\t\t//max: undefined,\n\t\t//min: undefined,\n\t\tminPadding: 0.01,\n\t\tmaxPadding: 0.01,\n\t\t//minRange: null,\n\t\tminorGridLineColor: '#E0E0E0',\n\t\t// minorGridLineDashStyle: null,\n\t\tminorGridLineWidth: 1,\n\t\tminorTickColor: '#A0A0A0',\n\t\t//minorTickInterval: null,\n\t\tminorTickLength: 2,\n\t\tminorTickPosition: 'outside', // inside or outside\n\t\t//minorTickWidth: 0,\n\t\t//opposite: false,\n\t\t//offset: 0,\n\t\t//plotBands: [{\n\t\t//\tevents: {},\n\t\t//\tzIndex: 1,\n\t\t//\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n\t\t//}],\n\t\t//plotLines: [{\n\t\t//\tevents: {}\n\t\t//  dashStyle: {}\n\t\t//\tzIndex:\n\t\t//\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n\t\t//}],\n\t\t//reversed: false,\n\t\t// showFirstLabel: true,\n\t\t// showLastLabel: true,\n\t\tstartOfWeek: 1,\n\t\tstartOnTick: false,\n\t\ttickColor: '#C0D0E0',\n\t\t//tickInterval: null,\n\t\ttickLength: 10,\n\t\ttickmarkPlacement: 'between', // on or between\n\t\ttickPixelInterval: 100,\n\t\ttickPosition: 'outside',\n\t\ttickWidth: 1,\n\t\ttitle: {\n\t\t\t//text: null,\n\t\t\talign: 'middle', // low, middle or high\n\t\t\t//margin: 0 for horizontal, 10 for vertical axes,\n\t\t\t//rotation: 0,\n\t\t\t//side: 'outside',\n\t\t\tstyle: {\n\t\t\t\tcolor: '#707070'\n\t\t\t}\n\t\t\t//x: 0,\n\t\t\t//y: 0\n\t\t},\n\t\ttype: 'linear' // linear, logarithmic or datetime\n\t},\n\n\t/**\n\t * This options set extends the defaultOptions for Y axes\n\t */\n\tdefaultYAxisOptions: {\n\t\tendOnTick: true,\n\t\tgridLineWidth: 1,\n\t\ttickPixelInterval: 72,\n\t\tshowLastLabel: true,\n\t\tlabels: {\n\t\t\tx: -8,\n\t\t\ty: 3\n\t\t},\n\t\tlineWidth: 0,\n\t\tmaxPadding: 0.05,\n\t\tminPadding: 0.05,\n\t\tstartOnTick: true,\n\t\ttickWidth: 0,\n\t\ttitle: {\n\t\t\trotation: 270,\n\t\t\ttext: 'Values'\n\t\t},\n\t\tstackLabels: {\n\t\t\tenabled: false,\n\t\t\t//align: dynamic,\n\t\t\t//y: dynamic,\n\t\t\t//x: dynamic,\n\t\t\t//verticalAlign: dynamic,\n\t\t\t//textAlign: dynamic,\n\t\t\t//rotation: 0,\n\t\t\tformatter: function () {\n\t\t\t\treturn Highcharts.numberFormat(this.total, -1);\n\t\t\t},\n\t\t\tstyle: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n\t\t}\n\t},\n\n\t/**\n\t * These options extend the defaultOptions for left axes\n\t */\n\tdefaultLeftAxisOptions: {\n\t\tlabels: {\n\t\t\tx: -15,\n\t\t\ty: null\n\t\t},\n\t\ttitle: {\n\t\t\trotation: 270\n\t\t}\n\t},\n\n\t/**\n\t * These options extend the defaultOptions for right axes\n\t */\n\tdefaultRightAxisOptions: {\n\t\tlabels: {\n\t\t\tx: 15,\n\t\t\ty: null\n\t\t},\n\t\ttitle: {\n\t\t\trotation: 90\n\t\t}\n\t},\n\n\t/**\n\t * These options extend the defaultOptions for bottom axes\n\t */\n\tdefaultBottomAxisOptions: {\n\t\tlabels: {\n\t\t\tautoRotation: [-45],\n\t\t\tx: 0,\n\t\t\ty: null // based on font size\n\t\t\t// overflow: undefined,\n\t\t\t// staggerLines: null\n\t\t},\n\t\ttitle: {\n\t\t\trotation: 0\n\t\t}\n\t},\n\t/**\n\t * These options extend the defaultOptions for top axes\n\t */\n\tdefaultTopAxisOptions: {\n\t\tlabels: {\n\t\t\tautoRotation: [-45],\n\t\t\tx: 0,\n\t\t\ty: -15\n\t\t\t// overflow: undefined\n\t\t\t// staggerLines: null\n\t\t},\n\t\ttitle: {\n\t\t\trotation: 0\n\t\t}\n\t},\n\n\t/**\n\t * Initialize the axis\n\t */\n\tinit: function (chart, userOptions) {\n\n\n\t\tvar isXAxis = userOptions.isX,\n\t\t\taxis = this;\n\n\t\t// Flag, is the axis horizontal\n\t\taxis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n\t\t// Flag, isXAxis\n\t\taxis.isXAxis = isXAxis;\n\t\taxis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n\t\taxis.opposite = userOptions.opposite; // needed in setOptions\n\t\taxis.side = userOptions.side || (axis.horiz ?\n\t\t\t\t(axis.opposite ? 0 : 2) : // top : bottom\n\t\t\t\t(axis.opposite ? 1 : 3));  // right : left\n\n\t\taxis.setOptions(userOptions);\n\n\n\t\tvar options = this.options,\n\t\t\ttype = options.type,\n\t\t\tisDatetimeAxis = type === 'datetime';\n\n\t\taxis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n\t\t// Flag, stagger lines or not\n\t\taxis.userOptions = userOptions;\n\n\t\t//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n\t\taxis.minPixelPadding = 0;\n\t\t//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series\n\t\t//axis.ignoreMaxPadding = UNDEFINED;\n\n\t\taxis.chart = chart;\n\t\taxis.reversed = options.reversed;\n\t\taxis.zoomEnabled = options.zoomEnabled !== false;\n\n\t\t// Initial categories\n\t\taxis.categories = options.categories || type === 'category';\n\t\taxis.names = axis.names || []; // Preserve on update (#3830)\n\n\t\t// Elements\n\t\t//axis.axisGroup = UNDEFINED;\n\t\t//axis.gridGroup = UNDEFINED;\n\t\t//axis.axisTitle = UNDEFINED;\n\t\t//axis.axisLine = UNDEFINED;\n\n\t\t// Shorthand types\n\t\taxis.isLog = type === 'logarithmic';\n\t\taxis.isDatetimeAxis = isDatetimeAxis;\n\n\t\t// Flag, if axis is linked to another axis\n\t\taxis.isLinked = defined(options.linkedTo);\n\t\t// Linked axis.\n\t\t//axis.linkedParent = UNDEFINED;\n\n\t\t// Tick positions\n\t\t//axis.tickPositions = UNDEFINED; // array containing predefined positions\n\t\t// Tick intervals\n\t\t//axis.tickInterval = UNDEFINED;\n\t\t//axis.minorTickInterval = UNDEFINED;\n\n\t\t\n\t\t// Major ticks\n\t\taxis.ticks = {};\n\t\taxis.labelEdge = [];\n\t\t// Minor ticks\n\t\taxis.minorTicks = {};\n\n\t\t// List of plotLines/Bands\n\t\taxis.plotLinesAndBands = [];\n\n\t\t// Alternate bands\n\t\taxis.alternateBands = {};\n\n\t\t// Axis metrics\n\t\t//axis.left = UNDEFINED;\n\t\t//axis.top = UNDEFINED;\n\t\t//axis.width = UNDEFINED;\n\t\t//axis.height = UNDEFINED;\n\t\t//axis.bottom = UNDEFINED;\n\t\t//axis.right = UNDEFINED;\n\t\t//axis.transA = UNDEFINED;\n\t\t//axis.transB = UNDEFINED;\n\t\t//axis.oldTransA = UNDEFINED;\n\t\taxis.len = 0;\n\t\t//axis.oldMin = UNDEFINED;\n\t\t//axis.oldMax = UNDEFINED;\n\t\t//axis.oldUserMin = UNDEFINED;\n\t\t//axis.oldUserMax = UNDEFINED;\n\t\t//axis.oldAxisLength = UNDEFINED;\n\t\taxis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n\t\taxis.range = options.range;\n\t\taxis.offset = options.offset || 0;\n\n\n\t\t// Dictionary for stacks\n\t\taxis.stacks = {};\n\t\taxis.oldStacks = {};\n\t\t\n\t\t// Min and max in the data\n\t\t//axis.dataMin = UNDEFINED,\n\t\t//axis.dataMax = UNDEFINED,\n\n\t\t// The axis range\n\t\taxis.max = null;\n\t\taxis.min = null;\n\n\t\t// User set min and max\n\t\t//axis.userMin = UNDEFINED,\n\t\t//axis.userMax = UNDEFINED,\n\n\t\t// Crosshair options\n\t\taxis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n\t\t// Run Axis\n\n\t\tvar eventType,\n\t\t\tevents = axis.options.events;\n\n\t\t// Register\n\t\tif (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n\t\t\tif (isXAxis && !this.isColorAxis) { // #2713\n\t\t\t\tchart.axes.splice(chart.xAxis.length, 0, axis);\n\t\t\t} else {\n\t\t\t\tchart.axes.push(axis);\n\t\t\t}\n\n\t\t\tchart[axis.coll].push(axis);\n\t\t}\n\n\t\taxis.series = axis.series || []; // populated by Series\n\n\t\t// inverted charts have reversed xAxes as default\n\t\tif (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n\t\t\taxis.reversed = true;\n\t\t}\n\n\t\taxis.removePlotBand = axis.removePlotBandOrLine;\n\t\taxis.removePlotLine = axis.removePlotBandOrLine;\n\n\n\t\t// register event listeners\n\t\tfor (eventType in events) {\n\t\t\taddEvent(axis, eventType, events[eventType]);\n\t\t}\n\n\t\t// extend logarithmic axis\n\t\tif (axis.isLog) {\n\t\t\taxis.val2lin = log2lin;\n\t\t\taxis.lin2val = lin2log;\n\t\t}\n\t},\n\n\t/**\n\t * Merge and set options\n\t */\n\tsetOptions: function (userOptions) {\n\t\tthis.options = merge(\n\t\t\tthis.defaultOptions,\n\t\t\tthis.isXAxis ? {} : this.defaultYAxisOptions,\n\t\t\t[this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n\t\t\t\tthis.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n\t\t\tmerge(\n\t\t\t\tdefaultOptions[this.coll], // if set in setOptions (#1053)\n\t\t\t\tuserOptions\n\t\t\t)\n\t\t);\n\t},\n\n\t/**\n\t * The default label formatter. The context is a special config object for the label.\n\t */\n\tdefaultLabelFormatter: function () {\n\t\tvar axis = this.axis,\n\t\t\tvalue = this.value,\n\t\t\tcategories = axis.categories,\n\t\t\tdateTimeLabelFormat = this.dateTimeLabelFormat,\n\t\t\tnumericSymbols = defaultOptions.lang.numericSymbols,\n\t\t\ti = numericSymbols && numericSymbols.length,\n\t\t\tmulti,\n\t\t\tret,\n\t\t\tformatOption = axis.options.labels.format,\n\n\t\t\t// make sure the same symbol is added for all labels on a linear axis\n\t\t\tnumericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n\t\tif (formatOption) {\n\t\t\tret = format(formatOption, this);\n\n\t\t} else if (categories) {\n\t\t\tret = value;\n\n\t\t} else if (dateTimeLabelFormat) { // datetime axis\n\t\t\tret = dateFormat(dateTimeLabelFormat, value);\n\n\t\t} else if (i && numericSymbolDetector >= 1000) {\n\t\t\t// Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n\t\t\t// If we are to enable this in tooltip or other places as well, we can move this\n\t\t\t// logic to the numberFormatter and enable it by a parameter.\n\t\t\twhile (i-- && ret === UNDEFINED) {\n\t\t\t\tmulti = Math.pow(1000, i + 1);\n\t\t\t\tif (numericSymbolDetector >= multi && numericSymbols[i] !== null) {\n\t\t\t\t\tret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ret === UNDEFINED) {\n\t\t\tif (mathAbs(value) >= 10000) { // add thousands separators\n\t\t\t\tret = Highcharts.numberFormat(value, 0);\n\n\t\t\t} else { // small numbers\n\t\t\t\tret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * Get the minimum and maximum for the series of each axis\n\t */\n\tgetSeriesExtremes: function () {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart;\n\n\t\taxis.hasVisibleSeries = false;\n\n\t\t// Reset properties in case we're redrawing (#3353)\n\t\taxis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;\n\t\t\n\t\tif (axis.buildStacks) {\n\t\t\taxis.buildStacks();\n\t\t}\n\n\t\t// loop through this axis' series\n\t\teach(axis.series, function (series) {\n\n\t\t\tif (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n\t\t\t\tvar seriesOptions = series.options,\n\t\t\t\t\txData,\n\t\t\t\t\tthreshold = seriesOptions.threshold,\n\t\t\t\t\tseriesDataMin,\n\t\t\t\t\tseriesDataMax;\n\n\t\t\t\taxis.hasVisibleSeries = true;\n\n\t\t\t\t// Validate threshold in logarithmic axes\n\t\t\t\tif (axis.isLog && threshold <= 0) {\n\t\t\t\t\tthreshold = null;\n\t\t\t\t}\n\n\t\t\t\t// Get dataMin and dataMax for X axes\n\t\t\t\tif (axis.isXAxis) {\n\t\t\t\t\txData = series.xData;\n\t\t\t\t\tif (xData.length) {\n\t\t\t\t\t\taxis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));\n\t\t\t\t\t\taxis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n\t\t\t\t\t}\n\n\t\t\t\t// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n\t\t\t\t} else {\n\n\t\t\t\t\t// Get this particular series extremes\n\t\t\t\t\tseries.getExtremes();\n\t\t\t\t\tseriesDataMax = series.dataMax;\n\t\t\t\t\tseriesDataMin = series.dataMin;\n\n\t\t\t\t\t// Get the dataMin and dataMax so far. If percentage is used, the min and max are\n\t\t\t\t\t// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n\t\t\t\t\t// doesn't have active y data, we continue with nulls\n\t\t\t\t\tif (defined(seriesDataMin) && defined(seriesDataMax)) {\n\t\t\t\t\t\taxis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n\t\t\t\t\t\taxis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Adjust to threshold\n\t\t\t\t\tif (defined(threshold)) {\n\t\t\t\t\t\tif (axis.dataMin >= threshold) {\n\t\t\t\t\t\t\taxis.dataMin = threshold;\n\t\t\t\t\t\t\taxis.ignoreMinPadding = true;\n\t\t\t\t\t\t} else if (axis.dataMax < threshold) {\n\t\t\t\t\t\t\taxis.dataMax = threshold;\n\t\t\t\t\t\t\taxis.ignoreMaxPadding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Translate from axis value to pixel position on the chart, or back\n\t *\n\t */\n\ttranslate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n\t\tvar axis = this,\n\t\t\tsign = 1,\n\t\t\tcvsOffset = 0,\n\t\t\tlocalA = old ? axis.oldTransA : axis.transA,\n\t\t\tlocalMin = old ? axis.oldMin : axis.min,\n\t\t\treturnValue,\n\t\t\tminPixelPadding = axis.minPixelPadding,\n\t\t\tdoPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;\n\n\t\tif (!localA) {\n\t\t\tlocalA = axis.transA;\n\t\t}\n\n\t\t// In vertical axes, the canvas coordinates start from 0 at the top like in\n\t\t// SVG.\n\t\tif (cvsCoord) {\n\t\t\tsign *= -1; // canvas coordinates inverts the value\n\t\t\tcvsOffset = axis.len;\n\t\t}\n\n\t\t// Handle reversed axis\n\t\tif (axis.reversed) {\n\t\t\tsign *= -1;\n\t\t\tcvsOffset -= sign * (axis.sector || axis.len);\n\t\t}\n\n\t\t// From pixels to value\n\t\tif (backwards) { // reverse translation\n\n\t\t\tval = val * sign + cvsOffset;\n\t\t\tval -= minPixelPadding;\n\t\t\treturnValue = val / localA + localMin; // from chart pixel to value\n\t\t\tif (doPostTranslate) { // log and ordinal axes\n\t\t\t\treturnValue = axis.lin2val(returnValue);\n\t\t\t}\n\n\t\t// From value to pixels\n\t\t} else {\n\t\t\tif (doPostTranslate) { // log and ordinal axes\n\t\t\t\tval = axis.val2lin(val);\n\t\t\t}\n\t\t\tif (pointPlacement === 'between') {\n\t\t\t\tpointPlacement = 0.5;\n\t\t\t}\n\t\t\treturnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n\t\t\t\t(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n\t\t}\n\n\t\treturn returnValue;\n\t},\n\n\t/**\n\t * Utility method to translate an axis value to pixel position.\n\t * @param {Number} value A value in terms of axis units\n\t * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n\t *        or just the axis/pane itself.\n\t */\n\ttoPixels: function (value, paneCoordinates) {\n\t\treturn this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n\t},\n\n\t/*\n\t * Utility method to translate a pixel position in to an axis value\n\t * @param {Number} pixel The pixel value coordinate\n\t * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n\t *        axis/pane itself.\n\t */\n\ttoValue: function (pixel, paneCoordinates) {\n\t\treturn this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n\t},\n\n\t/**\n\t * Create the path for a plot line that goes from the given value on\n\t * this axis, across the plot to the opposite side\n\t * @param {Number} value\n\t * @param {Number} lineWidth Used for calculation crisp line\n\t * @param {Number] old Use old coordinates (for resizing and rescaling)\n\t */\n\tgetPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart,\n\t\t\taxisLeft = axis.left,\n\t\t\taxisTop = axis.top,\n\t\t\tx1,\n\t\t\ty1,\n\t\t\tx2,\n\t\t\ty2,\n\t\t\tcHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n\t\t\tcWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n\t\t\tskip,\n\t\t\ttransB = axis.transB,\n\t\t\t/**\n\t\t\t * Check if x is between a and b. If not, either move to a/b or skip, \n\t\t\t * depending on the force parameter.\n\t\t\t */\n\t\t\tbetween = function (x, a, b) {\n\t\t\t\tif (x < a || x > b) {\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tx = mathMin(mathMax(a, x), b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t};\n\n\t\ttranslatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n\t\tx1 = x2 = mathRound(translatedValue + transB);\n\t\ty1 = y2 = mathRound(cHeight - translatedValue - transB);\n\n\t\tif (isNaN(translatedValue)) { // no min or max\n\t\t\tskip = true;\n\n\t\t} else if (axis.horiz) {\n\t\t\ty1 = axisTop;\n\t\t\ty2 = cHeight - axis.bottom;\n\t\t\tx1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n\t\t} else {\n\t\t\tx1 = axisLeft;\n\t\t\tx2 = cWidth - axis.right;\n\t\t\ty1 = y2 = between(y1, axisTop, axisTop + axis.height);\n\t\t}\n\t\treturn skip && !force ?\n\t\t\tnull :\n\t\t\tchart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);\n\t},\n\n\t/**\n\t * Set the tick positions of a linear axis to round values like whole tens or every five.\n\t */\n\tgetLinearTickPositions: function (tickInterval, min, max) {\n\t\tvar pos,\n\t\t\tlastPos,\n\t\t\troundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n\t\t\troundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n\t\t\ttickPositions = [];\n\n\t\t// For single points, add a tick regardless of the relative position (#2662)\n\t\tif (min === max && isNumber(min)) {\n\t\t\treturn [min];\n\t\t}\n\n\t\t// Populate the intermediate values\n\t\tpos = roundedMin;\n\t\twhile (pos <= roundedMax) {\n\n\t\t\t// Place the tick on the rounded value\n\t\t\ttickPositions.push(pos);\n\n\t\t\t// Always add the raw tickInterval, not the corrected one.\n\t\t\tpos = correctFloat(pos + tickInterval);\n\n\t\t\t// If the interval is not big enough in the current min - max range to actually increase\n\t\t\t// the loop variable, we need to break out to prevent endless loop. Issue #619\n\t\t\tif (pos === lastPos) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Record the last value\n\t\t\tlastPos = pos;\n\t\t}\n\t\treturn tickPositions;\n\t},\n\n\t/**\n\t * Return the minor tick positions. For logarithmic axes, reuse the same logic\n\t * as for major ticks.\n\t */\n\tgetMinorTickPositions: function () {\n\t\tvar axis = this,\n\t\t\toptions = axis.options,\n\t\t\ttickPositions = axis.tickPositions,\n\t\t\tminorTickInterval = axis.minorTickInterval,\n\t\t\tminorTickPositions = [],\n\t\t\tpos,\n\t\t\ti,\n\t\t\tmin = axis.min,\n\t\t\tmax = axis.max,\n\t\t\trange = max - min,\n\t\t\tlen;\n\n\t\t// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n\t\tif (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n\t\t\tif (axis.isLog) {\n\t\t\t\tlen = tickPositions.length;\n\t\t\t\tfor (i = 1; i < len; i++) {\n\t\t\t\t\tminorTickPositions = minorTickPositions.concat(\n\t\t\t\t\t\taxis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n\t\t\t\tminorTickPositions = minorTickPositions.concat(\n\t\t\t\t\taxis.getTimeTicks(\n\t\t\t\t\t\taxis.normalizeTimeTickInterval(minorTickInterval),\n\t\t\t\t\t\tmin,\n\t\t\t\t\t\tmax,\n\t\t\t\t\t\toptions.startOfWeek\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfor (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n\t\t\t\t\tminorTickPositions.push(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taxis.trimTicks(minorTickPositions); // #3652 #3743\n\t\treturn minorTickPositions;\n\t},\n\n\t/**\n\t * Adjust the min and max for the minimum range. Keep in mind that the series data is\n\t * not yet processed, so we don't have information on data cropping and grouping, or\n\t * updated axis.pointRange or series.pointRange. The data can't be processed until\n\t * we have finally established min and max.\n\t */\n\tadjustForMinRange: function () {\n\t\tvar axis = this,\n\t\t\toptions = axis.options,\n\t\t\tmin = axis.min,\n\t\t\tmax = axis.max,\n\t\t\tzoomOffset,\n\t\t\tspaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n\t\t\tclosestDataRange,\n\t\t\ti,\n\t\t\tdistance,\n\t\t\txData,\n\t\t\tloopLength,\n\t\t\tminArgs,\n\t\t\tmaxArgs;\n\n\t\t// Set the automatic minimum range based on the closest point distance\n\t\tif (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n\t\t\tif (defined(options.min) || defined(options.max)) {\n\t\t\t\taxis.minRange = null; // don't do this again\n\n\t\t\t} else {\n\n\t\t\t\t// Find the closest distance between raw data points, as opposed to\n\t\t\t\t// closestPointRange that applies to processed points (cropped and grouped)\n\t\t\t\teach(axis.series, function (series) {\n\t\t\t\t\txData = series.xData;\n\t\t\t\t\tloopLength = series.xIncrement ? 1 : xData.length - 1;\n\t\t\t\t\tfor (i = loopLength; i > 0; i--) {\n\t\t\t\t\t\tdistance = xData[i] - xData[i - 1];\n\t\t\t\t\t\tif (closestDataRange === UNDEFINED || distance < closestDataRange) {\n\t\t\t\t\t\t\tclosestDataRange = distance;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\taxis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n\t\t\t}\n\t\t}\n\n\t\t// if minRange is exceeded, adjust\n\t\tif (max - min < axis.minRange) {\n\t\t\tvar minRange = axis.minRange;\n\t\t\tzoomOffset = (minRange - max + min) / 2;\n\n\t\t\t// if min and max options have been set, don't go beyond it\n\t\t\tminArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n\t\t\tif (spaceAvailable) { // if space is available, stay within the data range\n\t\t\t\tminArgs[2] = axis.dataMin;\n\t\t\t}\n\t\t\tmin = arrayMax(minArgs);\n\n\t\t\tmaxArgs = [min + minRange, pick(options.max, min + minRange)];\n\t\t\tif (spaceAvailable) { // if space is availabe, stay within the data range\n\t\t\t\tmaxArgs[2] = axis.dataMax;\n\t\t\t}\n\n\t\t\tmax = arrayMin(maxArgs);\n\n\t\t\t// now if the max is adjusted, adjust the min back\n\t\t\tif (max - min < minRange) {\n\t\t\t\tminArgs[0] = max - minRange;\n\t\t\t\tminArgs[1] = pick(options.min, max - minRange);\n\t\t\t\tmin = arrayMax(minArgs);\n\t\t\t}\n\t\t}\n\n\t\t// Record modified extremes\n\t\taxis.min = min;\n\t\taxis.max = max;\n\t},\n\n\t/**\n\t * Update translation information\n\t */\n\tsetAxisTranslation: function (saveOld) {\n\t\tvar axis = this,\n\t\t\trange = axis.max - axis.min,\n\t\t\tpointRange = axis.axisPointRange || 0,\n\t\t\tclosestPointRange,\n\t\t\tminPointOffset = 0,\n\t\t\tpointRangePadding = 0,\n\t\t\tlinkedParent = axis.linkedParent,\n\t\t\tordinalCorrection,\n\t\t\thasCategories = !!axis.categories,\n\t\t\ttransA = axis.transA,\n\t\t\tisXAxis = axis.isXAxis;\n\n\t\t// Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n\t\tif (isXAxis || hasCategories || pointRange) {\n\t\t\tif (linkedParent) {\n\t\t\t\tminPointOffset = linkedParent.minPointOffset;\n\t\t\t\tpointRangePadding = linkedParent.pointRangePadding;\n\n\t\t\t} else {\n\t\t\t\teach(axis.series, function (series) {\n\t\t\t\t\tvar seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806\n\t\t\t\t\t\tpointPlacement = series.options.pointPlacement,\n\t\t\t\t\t\tseriesClosestPointRange = series.closestPointRange;\n\n\t\t\t\t\tif (seriesPointRange > range) { // #1446\n\t\t\t\t\t\tseriesPointRange = 0;\n\t\t\t\t\t}\n\t\t\t\t\tpointRange = mathMax(pointRange, seriesPointRange);\n\n\t\t\t\t\tif (!axis.single) {\n\t\t\t\t\t\t// minPointOffset is the value padding to the left of the axis in order to make\n\t\t\t\t\t\t// room for points with a pointRange, typically columns. When the pointPlacement option\n\t\t\t\t\t\t// is 'between' or 'on', this padding does not apply.\n\t\t\t\t\t\tminPointOffset = mathMax(\n\t\t\t\t\t\t\tminPointOffset,\n\t\t\t\t\t\t\tisString(pointPlacement) ? 0 : seriesPointRange / 2\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Determine the total padding needed to the length of the axis to make room for the\n\t\t\t\t\t\t// pointRange. If the series' pointPlacement is 'on', no padding is added.\n\t\t\t\t\t\tpointRangePadding = mathMax(\n\t\t\t\t\t\t\tpointRangePadding,\n\t\t\t\t\t\t\tpointPlacement === 'on' ? 0 : seriesPointRange\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the closestPointRange\n\t\t\t\t\tif (!series.noSharedTooltip && defined(seriesClosestPointRange)) {\n\t\t\t\t\t\tclosestPointRange = defined(closestPointRange) ?\n\t\t\t\t\t\t\tmathMin(closestPointRange, seriesClosestPointRange) :\n\t\t\t\t\t\t\tseriesClosestPointRange;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Record minPointOffset and pointRangePadding\n\t\t\tordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n\t\t\taxis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n\t\t\taxis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n\t\t\t// pointRange means the width reserved for each point, like in a column chart\n\t\t\taxis.pointRange = mathMin(pointRange, range);\n\n\t\t\t// closestPointRange means the closest distance between points. In columns\n\t\t\t// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n\t\t\t// is some other value\n\t\t\tif (isXAxis) {\n\t\t\t\taxis.closestPointRange = closestPointRange;\n\t\t\t}\n\t\t}\n\n\t\t// Secondary values\n\t\tif (saveOld) {\n\t\t\taxis.oldTransA = transA;\n\t\t}\n\t\taxis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n\t\taxis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n\t\taxis.minPixelPadding = transA * minPointOffset;\n\t},\n\n\t/**\n\t * Set the tick positions to round values and optionally extend the extremes\n\t * to the nearest tick\n\t */\n\tsetTickInterval: function (secondPass) {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart,\n\t\t\toptions = axis.options,\n\t\t\tisLog = axis.isLog,\n\t\t\tisDatetimeAxis = axis.isDatetimeAxis,\n\t\t\tisXAxis = axis.isXAxis,\n\t\t\tisLinked = axis.isLinked,\n\t\t\tmaxPadding = options.maxPadding,\n\t\t\tminPadding = options.minPadding,\n\t\t\tlength,\n\t\t\tlinkedParentExtremes,\n\t\t\ttickIntervalOption = options.tickInterval,\n\t\t\tminTickInterval,\n\t\t\ttickPixelIntervalOption = options.tickPixelInterval,\n\t\t\tcategories = axis.categories;\n\n\t\tif (!isDatetimeAxis && !categories && !isLinked) {\n\t\t\tthis.getTickAmount();\n\t\t}\n\n\t\t// linked axis gets the extremes from the parent axis\n\t\tif (isLinked) {\n\t\t\taxis.linkedParent = chart[axis.coll][options.linkedTo];\n\t\t\tlinkedParentExtremes = axis.linkedParent.getExtremes();\n\t\t\taxis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n\t\t\taxis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n\t\t\tif (options.type !== axis.linkedParent.options.type) {\n\t\t\t\terror(11, 1); // Can't link axes of different type\n\t\t\t}\n\t\t} else { // initial min and max from the extreme data values\n\t\t\taxis.min = pick(axis.userMin, options.min, axis.dataMin);\n\t\t\taxis.max = pick(axis.userMax, options.max, axis.dataMax);\n\t\t}\n\n\t\tif (isLog) {\n\t\t\tif (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n\t\t\t\terror(10, 1); // Can't plot negative values on log axis\n\t\t\t}\n\t\t\taxis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934\n\t\t\taxis.max = correctFloat(log2lin(axis.max));\n\t\t}\n\n\t\t// handle zoomed range\n\t\tif (axis.range && defined(axis.max)) {\n\t\t\taxis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618\n\t\t\taxis.userMax = axis.max;\n\n\t\t\taxis.range = null;  // don't use it when running setExtremes\n\t\t}\n\n\t\t// Hook for adjusting this.min and this.max. Used by bubble series.\n\t\tif (axis.beforePadding) {\n\t\t\taxis.beforePadding();\n\t\t}\n\n\t\t// adjust min and max for the minimum range\n\t\taxis.adjustForMinRange();\n\n\t\t// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n\t\t// into account, we do this after computing tick interval (#1337).\n\t\tif (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n\t\t\tlength = axis.max - axis.min;\n\t\t\tif (length) {\n\t\t\t\tif (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {\n\t\t\t\t\taxis.min -= length * minPadding;\n\t\t\t\t}\n\t\t\t\tif (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {\n\t\t\t\t\taxis.max += length * maxPadding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Stay within floor and ceiling\n\t\tif (isNumber(options.floor)) {\n\t\t\taxis.min = mathMax(axis.min, options.floor);\n\t\t}\n\t\tif (isNumber(options.ceiling)) {\n\t\t\taxis.max = mathMin(axis.max, options.ceiling);\n\t\t}\n\n\t\t// get tickInterval\n\t\tif (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n\t\t\taxis.tickInterval = 1;\n\t\t} else if (isLinked && !tickIntervalOption &&\n\t\t\t\ttickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n\t\t\taxis.tickInterval = axis.linkedParent.tickInterval;\n\t\t} else {\n\t\t\taxis.tickInterval = pick(\n\t\t\t\ttickIntervalOption,\n\t\t\t\tthis.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,\n\t\t\t\tcategories ? // for categoried axis, 1 is default, for linear axis use tickPix\n\t\t\t\t\t1 :\n\t\t\t\t\t// don't let it be more than the data range\n\t\t\t\t\t(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)\n\t\t\t);\n\t\t}\n\n\t\t// Now we're finished detecting min and max, crop and group series data. This\n\t\t// is in turn needed in order to find tick positions in ordinal axes.\n\t\tif (isXAxis && !secondPass) {\n\t\t\teach(axis.series, function (series) {\n\t\t\t\tseries.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n\t\t\t});\n\t\t}\n\n\t\t// set the translation factor used in translate function\n\t\taxis.setAxisTranslation(true);\n\n\t\t// hook for ordinal axes and radial axes\n\t\tif (axis.beforeSetTickPositions) {\n\t\t\taxis.beforeSetTickPositions();\n\t\t}\n\n\t\t// hook for extensions, used in Highstock ordinal axes\n\t\tif (axis.postProcessTickInterval) {\n\t\t\taxis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n\t\t}\n\n\t\t// In column-like charts, don't cramp in more ticks than there are points (#1943)\n\t\tif (axis.pointRange) {\n\t\t\taxis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);\n\t\t}\n\n\t\t// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n\t\tminTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n\t\tif (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n\t\t\taxis.tickInterval = minTickInterval;\n\t\t}\n\n\t\t// for linear axes, get magnitude and normalize the interval\n\t\tif (!isDatetimeAxis && !isLog) { // linear\n\t\t\tif (!tickIntervalOption) {\n\t\t\t\taxis.tickInterval = normalizeTickInterval(\n\t\t\t\t\taxis.tickInterval, \n\t\t\t\t\tnull, \n\t\t\t\t\tgetMagnitude(axis.tickInterval), \n\t\t\t\t\t// If the tick interval is between 0.5 and 5 and the axis max is in the order of\n\t\t\t\t\t// thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n\t\t\t\t\tpick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n\t\t\t\t\t!!this.tickAmount\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Prevent ticks from getting so close that we can't draw the labels\n\t\tif (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n\t\t\taxis.tickInterval = axis.unsquish();\n\t\t}\n\n\t\tthis.setTickPositions();\n\t},\n\n\t/**\n\t * Now we have computed the normalized tickInterval, get the tick positions\n\t */\n\tsetTickPositions: function () {\n\n\t\tvar options = this.options,\n\t\t\ttickPositions,\n\t\t\ttickPositionsOption = options.tickPositions,\n\t\t\ttickPositioner = options.tickPositioner,\n\t\t\tstartOnTick = options.startOnTick,\n\t\t\tendOnTick = options.endOnTick,\n\t\t\tsingle;\n\n\t\t// Set the tickmarkOffset\n\t\tthis.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && \n\t\t\tthis.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n\t\t// get minorTickInterval\n\t\tthis.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n\t\t\tthis.tickInterval / 5 : options.minorTickInterval;\n\n\t\t// Find the tick positions\n\t\tthis.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)\n\t\tif (!tickPositions) {\n\n\t\t\tif (this.isDatetimeAxis) {\n\t\t\t\ttickPositions = this.getTimeTicks(\n\t\t\t\t\tthis.normalizeTimeTickInterval(this.tickInterval, options.units),\n\t\t\t\t\tthis.min,\n\t\t\t\t\tthis.max,\n\t\t\t\t\toptions.startOfWeek,\n\t\t\t\t\tthis.ordinalPositions,\n\t\t\t\t\tthis.closestPointRange,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else if (this.isLog) {\n\t\t\t\ttickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n\t\t\t} else {\n\t\t\t\ttickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n\t\t\t}\n\n\t\t\tthis.tickPositions = tickPositions;\n\n\t\t\t// Run the tick positioner callback, that allows modifying auto tick positions.\n\t\t\tif (tickPositioner) {\n\t\t\t\ttickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n\t\t\t\tif (tickPositioner) {\n\t\t\t\t\tthis.tickPositions = tickPositions = tickPositioner;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (!this.isLinked) {\n\n\t\t\t// reset min/max or remove extremes based on start/end on tick\n\t\t\tthis.trimTicks(tickPositions, startOnTick, endOnTick);\n\n\t\t\t// When there is only one point, or all points have the same value on this axis, then min\n\t\t\t// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n\t\t\t// in order to center the point, but leave it with one tick. #1337.\n\t\t\tif (this.min === this.max && defined(this.min) && !this.tickAmount) {\n\t\t\t\t// Substract half a unit (#2619, #2846, #2515, #3390)\n\t\t\t\tsingle = true;\n\t\t\t\tthis.min -= 0.5;\n\t\t\t\tthis.max += 0.5;\n\t\t\t}\n\t\t\tthis.single = single;\n\n\t\t\tif (!tickPositionsOption && !tickPositioner) {\n\t\t\t\tthis.adjustTickAmount();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n\t */\n\ttrimTicks: function (tickPositions, startOnTick, endOnTick) {\n\t\tvar roundedMin = tickPositions[0],\n\t\t\troundedMax = tickPositions[tickPositions.length - 1],\n\t\t\tminPointOffset = this.minPointOffset || 0;\n\t\t\t\n\t\tif (startOnTick) {\n\t\t\tthis.min = roundedMin;\n\t\t} else if (this.min - minPointOffset > roundedMin) {\n\t\t\ttickPositions.shift();\n\t\t}\n\n\t\tif (endOnTick) {\n\t\t\tthis.max = roundedMax;\n\t\t} else if (this.max + minPointOffset < roundedMax) {\n\t\t\ttickPositions.pop();\n\t\t}\n\n\t\t// If no tick are left, set one tick in the middle (#3195) \n\t\tif (tickPositions.length === 0 && defined(roundedMin)) {\n\t\t\ttickPositions.push((roundedMax + roundedMin) / 2);\n\t\t}\t\t\n\t},\n\n\t/**\n\t * Set the max ticks of either the x and y axis collection\n\t */\n\tgetTickAmount: function () {\n\t\tvar others = {}, // Whether there is another axis to pair with this one\n\t\t\thasOther,\n\t\t\toptions = this.options,\n\t\t\ttickAmount = options.tickAmount,\n\t\t\ttickPixelInterval = options.tickPixelInterval;\n\n\t\tif (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n\t\t\t\t!this.isLog && options.startOnTick && options.endOnTick) {\n\t\t\ttickAmount = 2;\n\t\t}\n\n\t\tif (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n\t\t\t// Check if there are multiple axes in the same pane\n\t\t\teach(this.chart[this.coll], function (axis) {\n\t\t\t\tvar options = axis.options,\n\t\t\t\t\thoriz = axis.horiz,\n\t\t\t\t\tkey = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');\n\t\t\t\t\n\t\t\t\tif (others[key]) {\n\t\t\t\t\thasOther = true;\n\t\t\t\t} else {\n\t\t\t\t\tothers[key] = 1;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (hasOther) {\n\t\t\t\t// Add 1 because 4 tick intervals require 5 ticks (including first and last)\n\t\t\t\ttickAmount = mathCeil(this.len / tickPixelInterval) + 1;\n\t\t\t}\n\t\t}\n\n\t\t// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n\t\t// prevents the axis from adding ticks that are too far away from the data extremes.\n\t\tif (tickAmount < 4) {\n\t\t\tthis.finalTickAmt = tickAmount;\n\t\t\ttickAmount = 5;\n\t\t}\n\t\t\n\t\tthis.tickAmount = tickAmount;\n\t},\n\n\t/**\n\t * When using multiple axes, adjust the number of ticks to match the highest\n\t * number of ticks in that group\n\t */\n\tadjustTickAmount: function () {\n\t\tvar tickInterval = this.tickInterval,\n\t\t\ttickPositions = this.tickPositions,\n\t\t\ttickAmount = this.tickAmount,\n\t\t\tfinalTickAmt = this.finalTickAmt,\n\t\t\tcurrentTickAmount = tickPositions && tickPositions.length,\n\t\t\ti,\n\t\t\tlen;\n\n\t\tif (currentTickAmount < tickAmount) { // TODO: Check #3411\n\t\t\twhile (tickPositions.length < tickAmount) {\n\t\t\t\ttickPositions.push(correctFloat(\n\t\t\t\t\ttickPositions[tickPositions.length - 1] + tickInterval\n\t\t\t\t));\n\t\t\t}\n\t\t\tthis.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n\t\t\tthis.max = tickPositions[tickPositions.length - 1];\n\n\t\t// We have too many ticks, run second pass to try to reduce ticks\n\t\t} else if (currentTickAmount > tickAmount) {\n\t\t\tthis.tickInterval *= 2;\n\t\t\tthis.setTickPositions();\n\t\t}\n\n\t\t// The finalTickAmt property is set in getTickAmount\n\t\tif (defined(finalTickAmt)) {\n\t\t\ti = len = tickPositions.length;\n\t\t\twhile (i--) {\n\t\t\t\tif (\n\t\t\t\t\t(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n\t\t\t\t\t(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n\t\t\t\t) {\n\t\t\t\t\ttickPositions.splice(i, 1);\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tthis.finalTickAmt = UNDEFINED;\n\t\t}\n\t},\n\n\t/**\n\t * Set the scale based on data min and max, user set min and max or options\n\t *\n\t */\n\tsetScale: function () {\n\t\tvar axis = this,\n\t\t\tstacks = axis.stacks,\n\t\t\ttype,\n\t\t\ti,\n\t\t\tisDirtyData,\n\t\t\tisDirtyAxisLength;\n\n\t\taxis.oldMin = axis.min;\n\t\taxis.oldMax = axis.max;\n\t\taxis.oldAxisLength = axis.len;\n\n\t\t// set the new axisLength\n\t\taxis.setAxisSize();\n\t\t//axisLength = horiz ? axisWidth : axisHeight;\n\t\tisDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n\t\t// is there new data?\n\t\teach(axis.series, function (series) {\n\t\t\tif (series.isDirtyData || series.isDirty ||\n\t\t\t\t\tseries.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n\t\t\t\tisDirtyData = true;\n\t\t\t}\n\t\t});\n\n\t\t// do we really need to go through all this?\n\t\tif (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n\t\t\taxis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {\n\n\t\t\t// reset stacks\n\t\t\tif (!axis.isXAxis) {\n\t\t\t\tfor (type in stacks) {\n\t\t\t\t\tfor (i in stacks[type]) {\n\t\t\t\t\t\tstacks[type][i].total = null;\n\t\t\t\t\t\tstacks[type][i].cum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taxis.forceRedraw = false;\n\n\t\t\t// get data extremes if needed\n\t\t\taxis.getSeriesExtremes();\n\n\t\t\t// get fixed positions based on tickInterval\n\t\t\taxis.setTickInterval();\n\n\t\t\t// record old values to decide whether a rescale is necessary later on (#540)\n\t\t\taxis.oldUserMin = axis.userMin;\n\t\t\taxis.oldUserMax = axis.userMax;\n\n\t\t\t// Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n\t\t\tif (!axis.isDirty) {\n\t\t\t\taxis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n\t\t\t}\n\t\t} else if (!axis.isXAxis) {\n\t\t\tif (axis.oldStacks) {\n\t\t\t\tstacks = axis.stacks = axis.oldStacks;\n\t\t\t}\n\n\t\t\t// reset stacks\n\t\t\tfor (type in stacks) {\n\t\t\t\tfor (i in stacks[type]) {\n\t\t\t\t\tstacks[type][i].cum = stacks[type][i].total;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Set the extremes and optionally redraw\n\t * @param {Number} newMin\n\t * @param {Number} newMax\n\t * @param {Boolean} redraw\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t * @param {Object} eventArguments\n\t *\n\t */\n\tsetExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart;\n\n\t\tredraw = pick(redraw, true); // defaults to true\n\n\t\teach(axis.series, function (serie) {\n\t\t\tdelete serie.kdTree;\n\t\t});\n\n\t\t// Extend the arguments with min and max\n\t\teventArguments = extend(eventArguments, {\n\t\t\tmin: newMin,\n\t\t\tmax: newMax\n\t\t});\n\n\t\t// Fire the event\n\t\tfireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n\t\t\taxis.userMin = newMin;\n\t\t\taxis.userMax = newMax;\n\t\t\taxis.eventArgs = eventArguments;\n\n\t\t\t// Mark for running afterSetExtremes\n\t\t\taxis.isDirtyExtremes = true;\n\n\t\t\t// redraw\n\t\t\tif (redraw) {\n\t\t\t\tchart.redraw(animation);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n\t * in stock charts.\n\t */\n\tzoom: function (newMin, newMax) {\n\t\tvar dataMin = this.dataMin,\n\t\t\tdataMax = this.dataMax,\n\t\t\toptions = this.options;\n\n\t\t// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n\t\tif (!this.allowZoomOutside) {\n\t\t\tif (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {\n\t\t\t\tnewMin = UNDEFINED;\n\t\t\t}\n\t\t\tif (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {\n\t\t\t\tnewMax = UNDEFINED;\n\t\t\t}\n\t\t}\n\n\t\t// In full view, displaying the reset zoom button is not required\n\t\tthis.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;\n\n\t\t// Do it\n\t\tthis.setExtremes(\n\t\t\tnewMin,\n\t\t\tnewMax,\n\t\t\tfalse,\n\t\t\tUNDEFINED,\n\t\t\t{ trigger: 'zoom' }\n\t\t);\n\t\treturn true;\n\t},\n\n\t/**\n\t * Update the axis metrics\n\t */\n\tsetAxisSize: function () {\n\t\tvar chart = this.chart,\n\t\t\toptions = this.options,\n\t\t\toffsetLeft = options.offsetLeft || 0,\n\t\t\toffsetRight = options.offsetRight || 0,\n\t\t\thoriz = this.horiz,\n\t\t\twidth = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n\t\t\theight = pick(options.height, chart.plotHeight),\n\t\t\ttop = pick(options.top, chart.plotTop),\n\t\t\tleft = pick(options.left, chart.plotLeft + offsetLeft),\n\t\t\tpercentRegex = /%$/;\n\n\t\t// Check for percentage based input values\n\t\tif (percentRegex.test(height)) {\n\t\t\theight = parseFloat(height) / 100 * chart.plotHeight;\n\t\t}\n\t\tif (percentRegex.test(top)) {\n\t\t\ttop = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;\n\t\t}\n\n\t\t// Expose basic values to use in Series object and navigator\n\t\tthis.left = left;\n\t\tthis.top = top;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.bottom = chart.chartHeight - height - top;\n\t\tthis.right = chart.chartWidth - width - left;\n\n\t\t// Direction agnostic properties\n\t\tthis.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905\n\t\tthis.pos = horiz ? left : top; // distance from SVG origin\n\t},\n\n\t/**\n\t * Get the actual axis extremes\n\t */\n\tgetExtremes: function () {\n\t\tvar axis = this,\n\t\t\tisLog = axis.isLog;\n\n\t\treturn {\n\t\t\tmin: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n\t\t\tmax: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n\t\t\tdataMin: axis.dataMin,\n\t\t\tdataMax: axis.dataMax,\n\t\t\tuserMin: axis.userMin,\n\t\t\tuserMax: axis.userMax\n\t\t};\n\t},\n\n\t/**\n\t * Get the zero plane either based on zero or on the min or max value.\n\t * Used in bar and area plots\n\t */\n\tgetThreshold: function (threshold) {\n\t\tvar axis = this,\n\t\t\tisLog = axis.isLog;\n\n\t\tvar realMin = isLog ? lin2log(axis.min) : axis.min,\n\t\t\trealMax = isLog ? lin2log(axis.max) : axis.max;\n\n\t\tif (realMin > threshold || threshold === null) {\n\t\t\tthreshold = realMin;\n\t\t} else if (realMax < threshold) {\n\t\t\tthreshold = realMax;\n\t\t}\n\n\t\treturn axis.translate(threshold, 0, 1, 0, 1);\n\t},\n\n\t/**\n\t * Compute auto alignment for the axis label based on which side the axis is on\n\t * and the given rotation for the label\n\t */\n\tautoLabelAlign: function (rotation) {\n\t\tvar ret,\n\t\t\tangle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n\t\tif (angle > 15 && angle < 165) {\n\t\t\tret = 'right';\n\t\t} else if (angle > 195 && angle < 345) {\n\t\t\tret = 'left';\n\t\t} else {\n\t\t\tret = 'center';\n\t\t}\n\t\treturn ret;\n\t},\n\n\t/**\n\t * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n\t * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. \n\t * On a vertical axis remove ticks and add ellipsis.\n\t */\n\tunsquish: function () {\n\t\tvar chart = this.chart,\n\t\t\tticks = this.ticks,\n\t\t\tlabelOptions = this.options.labels,\n\t\t\thoriz = this.horiz,\n\t\t\ttickInterval = this.tickInterval,\n\t\t\tnewTickInterval = tickInterval,\n\t\t\tslotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n\t\t\trotation,\n\t\t\trotationOption = labelOptions.rotation,\n\t\t\tlabelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n\t\t\tstep,\n\t\t\tbestScore = Number.MAX_VALUE,\n\t\t\tautoRotation,\n\t\t\t// Return the multiple of tickInterval that is needed to avoid collision\n\t\t\tgetStep = function (spaceNeeded) {\n\t\t\t\tvar step = spaceNeeded / (slotSize || 1);\n\t\t\t\tstep = step > 1 ? mathCeil(step) : 1;\n\t\t\t\treturn step * tickInterval;\n\t\t\t};\n\t\t\n\t\tif (horiz) {\n\t\t\tautoRotation = defined(rotationOption) ? \n\t\t\t\t[rotationOption] :\n\t\t\t\tslotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;\n\n\t\t\tif (autoRotation) {\n\n\t\t\t\t// Loop over the given autoRotation options, and determine which gives the best score. The \n\t\t\t\t// best score is that with the lowest number of steps and a rotation closest to horizontal.\n\t\t\t\teach(autoRotation, function (rot) {\n\t\t\t\t\tvar score;\n\n\t\t\t\t\tif (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\t\t\t\t\t\n\t\t\t\t\t\tstep = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));\n\n\t\t\t\t\t\tscore = step + mathAbs(rot / 360);\n\n\t\t\t\t\t\tif (score < bestScore) {\n\t\t\t\t\t\t\tbestScore = score;\n\t\t\t\t\t\t\trotation = rot;\n\t\t\t\t\t\t\tnewTickInterval = step;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\tnewTickInterval = getStep(labelMetrics.h);\n\t\t}\n\n\t\tthis.autoRotation = autoRotation;\n\t\tthis.labelRotation = rotation;\n\n\t\treturn newTickInterval;\n\t},\n\n\trenderUnsquish: function () {\n\t\tvar chart = this.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\ttickPositions = this.tickPositions,\n\t\t\tticks = this.ticks,\n\t\t\tlabelOptions = this.options.labels,\n\t\t\thoriz = this.horiz,\n\t\t\tmargin = chart.margin,\n\t\t\tslotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&\n\t\t\t\t((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||\n\t\t\t\t(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,\n\t\t\tinnerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),\n\t\t\tattr = {},\n\t\t\tlabelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n\t\t\tcss,\n\t\t\tlabelLength = 0,\n\t\t\tlabel,\n\t\t\ti,\n\t\t\tpos;\n\n\t\t// Set rotation option unless it is \"auto\", like in gauges\n\t\tif (!isString(labelOptions.rotation)) {\n\t\t\tattr.rotation = labelOptions.rotation;\n\t\t}\n\t\t\n\t\t// Handle auto rotation on horizontal axis\n\t\tif (this.autoRotation) {\n\n\t\t\t// Get the longest label length\n\t\t\teach(tickPositions, function (tick) {\n\t\t\t\ttick = ticks[tick];\n\t\t\t\tif (tick && tick.labelLength > labelLength) {\n\t\t\t\t\tlabelLength = tick.labelLength;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// Apply rotation only if the label is too wide for the slot, and\n\t\t\t// the label is wider than its height.\n\t\t\tif (labelLength > innerWidth && labelLength > labelMetrics.h) {\n\t\t\t\tattr.rotation = this.labelRotation;\n\t\t\t} else {\n\t\t\t\tthis.labelRotation = 0;\n\t\t\t}\n\n\t\t// Handle word-wrap or ellipsis on vertical axis\n\t\t} else if (slotWidth) {\n\t\t\t// For word-wrap or ellipsis\n\t\t\tcss = { width: innerWidth + PX, textOverflow: 'clip' };\n\n\t\t\t// On vertical axis, only allow word wrap if there is room for more lines.\n\t\t\ti = tickPositions.length;\n\t\t\twhile (!horiz && i--) {\n\t\t\t\tpos = tickPositions[i];\n\t\t\t\tlabel = ticks[pos].label;\n\t\t\t\tif (label) {\n\t\t\t\t\tif (this.len / tickPositions.length - 4 < label.getBBox().height) {\n\t\t\t\t\t\tlabel.specCss = { textOverflow: 'ellipsis' };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// Add ellipsis if the label length is significantly longer than ideal\n\t\tif (attr.rotation) {\n\t\t\tcss = { \n\t\t\t\twidth: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,\n\t\t\t\ttextOverflow: 'ellipsis'\n\t\t\t};\n\t\t}\n\n\t\t// Set the explicit or automatic label alignment\n\t\tthis.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n\t\t// Apply general and specific CSS\n\t\teach(tickPositions, function (pos) {\n\t\t\tvar tick = ticks[pos],\n\t\t\t\tlabel = tick && tick.label;\n\t\t\tif (label) {\n\t\t\t\tif (css) {\n\t\t\t\t\tlabel.css(merge(css, label.specCss));\n\t\t\t\t}\n\t\t\t\tdelete label.specCss;\n\t\t\t\tlabel.attr(attr);\n\t\t\t\ttick.rotation = attr.rotation;\n\t\t\t}\n\t\t});\n\n\t\t// TODO: Why not part of getLabelPosition?\n\t\tthis.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);\n\t},\n\n\t/**\n\t * Render the tick labels to a preliminary position to get their sizes\n\t */\n\tgetOffset: function () {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\toptions = axis.options,\n\t\t\ttickPositions = axis.tickPositions,\n\t\t\tticks = axis.ticks,\n\t\t\thoriz = axis.horiz,\n\t\t\tside = axis.side,\n\t\t\tinvertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n\t\t\thasData,\n\t\t\tshowAxis,\n\t\t\ttitleOffset = 0,\n\t\t\ttitleOffsetOption,\n\t\t\ttitleMargin = 0,\n\t\t\taxisTitleOptions = options.title,\n\t\t\tlabelOptions = options.labels,\n\t\t\tlabelOffset = 0, // reset\n\t\t\tlabelOffsetPadded,\n\t\t\taxisOffset = chart.axisOffset,\n\t\t\tclipOffset = chart.clipOffset,\n\t\t\tdirectionFactor = [-1, 1, 1, -1][side],\n\t\t\tn,\n\t\t\tlineHeightCorrection;\n\n\t\t// For reuse in Axis.render\n\t\taxis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));\n\t\taxis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n\t\t// Set/reset staggerLines\n\t\taxis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n\t\t// Create the axisGroup and gridGroup elements on first iteration\n\t\tif (!axis.axisGroup) {\n\t\t\taxis.gridGroup = renderer.g('grid')\n\t\t\t\t.attr({ zIndex: options.gridZIndex || 1 })\n\t\t\t\t.add();\n\t\t\taxis.axisGroup = renderer.g('axis')\n\t\t\t\t.attr({ zIndex: options.zIndex || 2 })\n\t\t\t\t.add();\n\t\t\taxis.labelGroup = renderer.g('axis-labels')\n\t\t\t\t.attr({ zIndex: labelOptions.zIndex || 7 })\n\t\t\t\t.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')\n\t\t\t\t.add();\n\t\t}\n\n\t\tif (hasData || axis.isLinked) {\n\t\t\t\n\t\t\t// Generate ticks\n\t\t\teach(tickPositions, function (pos) {\n\t\t\t\tif (!ticks[pos]) {\n\t\t\t\t\tticks[pos] = new Tick(axis, pos);\n\t\t\t\t} else {\n\t\t\t\t\tticks[pos].addLabel(); // update labels depending on tick interval\n\t\t\t\t}\n\t\t\t});\n\n\t\t\taxis.renderUnsquish();\n\n\t\t\teach(tickPositions, function (pos) {\n\t\t\t\t// left side must be align: right and right side must have align: left for labels\n\t\t\t\tif (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {\n\n\t\t\t\t\t// get the highest offset\n\t\t\t\t\tlabelOffset = mathMax(\n\t\t\t\t\t\tticks[pos].getLabelSize(),\n\t\t\t\t\t\tlabelOffset\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (axis.staggerLines) {\n\t\t\t\tlabelOffset *= axis.staggerLines;\n\t\t\t\taxis.labelOffset = labelOffset;\n\t\t\t}\n\n\n\t\t} else { // doesn't have data\n\t\t\tfor (n in ticks) {\n\t\t\t\tticks[n].destroy();\n\t\t\t\tdelete ticks[n];\n\t\t\t}\n\t\t}\n\n\t\tif (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n\t\t\tif (!axis.axisTitle) {\n\t\t\t\taxis.axisTitle = renderer.text(\n\t\t\t\t\taxisTitleOptions.text,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\taxisTitleOptions.useHTML\n\t\t\t\t)\n\t\t\t\t.attr({\n\t\t\t\t\tzIndex: 7,\n\t\t\t\t\trotation: axisTitleOptions.rotation || 0,\n\t\t\t\t\talign:\n\t\t\t\t\t\taxisTitleOptions.textAlign ||\n\t\t\t\t\t\t{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]\n\t\t\t\t})\n\t\t\t\t.addClass(PREFIX + this.coll.toLowerCase() + '-title')\n\t\t\t\t.css(axisTitleOptions.style)\n\t\t\t\t.add(axis.axisGroup);\n\t\t\t\taxis.axisTitle.isNew = true;\n\t\t\t}\n\n\t\t\tif (showAxis) {\n\t\t\t\ttitleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n\t\t\t\ttitleOffsetOption = axisTitleOptions.offset;\n\t\t\t\ttitleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n\t\t\t}\n\n\t\t\t// hide or show the title depending on whether showEmpty is set\n\t\t\taxis.axisTitle[showAxis ? 'show' : 'hide']();\n\t\t}\n\n\t\t// handle automatic or user set offset\n\t\taxis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n\t\taxis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n\t\tlineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;\n\t\tlabelOffsetPadded = labelOffset + titleMargin +\n\t\t\t(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));\n\t\taxis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n\t\taxisOffset[side] = mathMax(\n\t\t\taxisOffset[side],\n\t\t\taxis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n\t\t\tlabelOffsetPadded // #3027\n\t\t);\n\t\tclipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);\n\t},\n\n\t/**\n\t * Get the path for the axis line\n\t */\n\tgetLinePath: function (lineWidth) {\n\t\tvar chart = this.chart,\n\t\t\topposite = this.opposite,\n\t\t\toffset = this.offset,\n\t\t\thoriz = this.horiz,\n\t\t\tlineLeft = this.left + (opposite ? this.width : 0) + offset,\n\t\t\tlineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n\t\tif (opposite) {\n\t\t\tlineWidth *= -1; // crispify the other way - #1480, #1687\n\t\t}\n\n\t\treturn chart.renderer.crispLine([\n\t\t\t\tM,\n\t\t\t\thoriz ?\n\t\t\t\t\tthis.left :\n\t\t\t\t\tlineLeft,\n\t\t\t\thoriz ?\n\t\t\t\t\tlineTop :\n\t\t\t\t\tthis.top,\n\t\t\t\tL,\n\t\t\t\thoriz ?\n\t\t\t\t\tchart.chartWidth - this.right :\n\t\t\t\t\tlineLeft,\n\t\t\t\thoriz ?\n\t\t\t\t\tlineTop :\n\t\t\t\t\tchart.chartHeight - this.bottom\n\t\t\t], lineWidth);\n\t},\n\n\t/**\n\t * Position the title\n\t */\n\tgetTitlePosition: function () {\n\t\t// compute anchor points for each of the title align options\n\t\tvar horiz = this.horiz,\n\t\t\taxisLeft = this.left,\n\t\t\taxisTop = this.top,\n\t\t\taxisLength = this.len,\n\t\t\taxisTitleOptions = this.options.title,\n\t\t\tmargin = horiz ? axisLeft : axisTop,\n\t\t\topposite = this.opposite,\n\t\t\toffset = this.offset,\n\t\t\tfontSize = pInt(axisTitleOptions.style.fontSize || 12),\n\n\t\t\t// the position in the length direction of the axis\n\t\t\talongAxis = {\n\t\t\t\tlow: margin + (horiz ? 0 : axisLength),\n\t\t\t\tmiddle: margin + axisLength / 2,\n\t\t\t\thigh: margin + (horiz ? axisLength : 0)\n\t\t\t}[axisTitleOptions.align],\n\n\t\t\t// the position in the perpendicular direction of the axis\n\t\t\toffAxis = (horiz ? axisTop + this.height : axisLeft) +\n\t\t\t\t(horiz ? 1 : -1) * // horizontal axis reverses the margin\n\t\t\t\t(opposite ? -1 : 1) * // so does opposite axes\n\t\t\t\tthis.axisTitleMargin +\n\t\t\t\t(this.side === 2 ? fontSize : 0);\n\n\t\treturn {\n\t\t\tx: horiz ?\n\t\t\t\talongAxis :\n\t\t\t\toffAxis + (opposite ? this.width : 0) + offset +\n\t\t\t\t\t(axisTitleOptions.x || 0), // x\n\t\t\ty: horiz ?\n\t\t\t\toffAxis - (opposite ? this.height : 0) + offset :\n\t\t\t\talongAxis + (axisTitleOptions.y || 0) // y\n\t\t};\n\t},\n\n\t/**\n\t * Render the axis\n\t */\n\trender: function () {\n\t\tvar axis = this,\n\t\t\tchart = axis.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\toptions = axis.options,\n\t\t\tisLog = axis.isLog,\n\t\t\tisLinked = axis.isLinked,\n\t\t\ttickPositions = axis.tickPositions,\n\t\t\taxisTitle = axis.axisTitle,\t\t\t\n\t\t\tticks = axis.ticks,\n\t\t\tminorTicks = axis.minorTicks,\n\t\t\talternateBands = axis.alternateBands,\n\t\t\tstackLabelOptions = options.stackLabels,\n\t\t\talternateGridColor = options.alternateGridColor,\n\t\t\ttickmarkOffset = axis.tickmarkOffset,\n\t\t\tlineWidth = options.lineWidth,\n\t\t\tlinePath,\n\t\t\thasRendered = chart.hasRendered,\n\t\t\tslideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n\t\t\thasData = axis.hasData,\n\t\t\tshowAxis = axis.showAxis,\n\t\t\tfrom,\n\t\t\tto;\n\n\t\t// Reset\n\t\taxis.labelEdge.length = 0;\n\t\t//axis.justifyToPlot = overflow === 'justify';\n\t\taxis.overlap = false;\n\n\t\t// Mark all elements inActive before we go over and mark the active ones\n\t\teach([ticks, minorTicks, alternateBands], function (coll) {\n\t\t\tvar pos;\n\t\t\tfor (pos in coll) {\n\t\t\t\tcoll[pos].isActive = false;\n\t\t\t}\n\t\t});\n\n\t\t// If the series has data draw the ticks. Else only the line and title\n\t\tif (hasData || isLinked) {\n\n\t\t\t// minor ticks\n\t\t\tif (axis.minorTickInterval && !axis.categories) {\n\t\t\t\teach(axis.getMinorTickPositions(), function (pos) {\n\t\t\t\t\tif (!minorTicks[pos]) {\n\t\t\t\t\t\tminorTicks[pos] = new Tick(axis, pos, 'minor');\n\t\t\t\t\t}\n\n\t\t\t\t\t// render new ticks in old position\n\t\t\t\t\tif (slideInTicks && minorTicks[pos].isNew) {\n\t\t\t\t\t\tminorTicks[pos].render(null, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tminorTicks[pos].render(null, false, 1);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Major ticks. Pull out the first item and render it last so that\n\t\t\t// we can get the position of the neighbour label. #808.\n\t\t\tif (tickPositions.length) { // #1300\n\t\t\t\teach(tickPositions, function (pos, i) {\n\n\t\t\t\t\t// linked axes need an extra check to find out if\n\t\t\t\t\tif (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n\t\t\t\t\t\tif (!ticks[pos]) {\n\t\t\t\t\t\t\tticks[pos] = new Tick(axis, pos);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// render new ticks in old position\n\t\t\t\t\t\tif (slideInTicks && ticks[pos].isNew) {\n\t\t\t\t\t\t\tticks[pos].render(i, true, 0.1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tticks[pos].render(i);\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t\t// In a categorized axis, the tick marks are displayed between labels. So\n\t\t\t\t// we need to add a tick mark and grid line at the left edge of the X axis.\n\t\t\t\tif (tickmarkOffset && (axis.min === 0 || axis.single)) {\n\t\t\t\t\tif (!ticks[-1]) {\n\t\t\t\t\t\tticks[-1] = new Tick(axis, -1, null, true);\n\t\t\t\t\t}\n\t\t\t\t\tticks[-1].render(-1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// alternate grid color\n\t\t\tif (alternateGridColor) {\n\t\t\t\teach(tickPositions, function (pos, i) {\n\t\t\t\t\tif (i % 2 === 0 && pos < axis.max) {\n\t\t\t\t\t\tif (!alternateBands[pos]) {\n\t\t\t\t\t\t\talternateBands[pos] = new Highcharts.PlotLineOrBand(axis);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfrom = pos + tickmarkOffset; // #949\n\t\t\t\t\t\tto = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;\n\t\t\t\t\t\talternateBands[pos].options = {\n\t\t\t\t\t\t\tfrom: isLog ? lin2log(from) : from,\n\t\t\t\t\t\t\tto: isLog ? lin2log(to) : to,\n\t\t\t\t\t\t\tcolor: alternateGridColor\n\t\t\t\t\t\t};\n\t\t\t\t\t\talternateBands[pos].render();\n\t\t\t\t\t\talternateBands[pos].isActive = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// custom plot lines and bands\n\t\t\tif (!axis._addedPlotLB) { // only first time\n\t\t\t\teach((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n\t\t\t\t\taxis.addPlotBandOrLine(plotLineOptions);\n\t\t\t\t});\n\t\t\t\taxis._addedPlotLB = true;\n\t\t\t}\n\n\t\t} // end if hasData\n\n\t\t// Remove inactive ticks\n\t\teach([ticks, minorTicks, alternateBands], function (coll) {\n\t\t\tvar pos,\n\t\t\t\ti,\n\t\t\t\tforDestruction = [],\n\t\t\t\tdelay = globalAnimation ? globalAnimation.duration || 500 : 0,\n\t\t\t\tdestroyInactiveItems = function () {\n\t\t\t\t\ti = forDestruction.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t// When resizing rapidly, the same items may be destroyed in different timeouts,\n\t\t\t\t\t\t// or the may be reactivated\n\t\t\t\t\t\tif (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n\t\t\t\t\t\t\tcoll[forDestruction[i]].destroy();\n\t\t\t\t\t\t\tdelete coll[forDestruction[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\tfor (pos in coll) {\n\n\t\t\t\tif (!coll[pos].isActive) {\n\t\t\t\t\t// Render to zero opacity\n\t\t\t\t\tcoll[pos].render(pos, false, 0);\n\t\t\t\t\tcoll[pos].isActive = false;\n\t\t\t\t\tforDestruction.push(pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// When the objects are finished fading out, destroy them\n\t\t\tif (coll === alternateBands || !chart.hasRendered || !delay) {\n\t\t\t\tdestroyInactiveItems();\n\t\t\t} else if (delay) {\n\t\t\t\tsetTimeout(destroyInactiveItems, delay);\n\t\t\t}\n\t\t});\n\n\t\t// Static items. As the axis group is cleared on subsequent calls\n\t\t// to render, these items are added outside the group.\n\t\t// axis line\n\t\tif (lineWidth) {\n\t\t\tlinePath = axis.getLinePath(lineWidth);\n\t\t\tif (!axis.axisLine) {\n\t\t\t\taxis.axisLine = renderer.path(linePath)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: options.lineColor,\n\t\t\t\t\t\t'stroke-width': lineWidth,\n\t\t\t\t\t\tzIndex: 7\n\t\t\t\t\t})\n\t\t\t\t\t.add(axis.axisGroup);\n\t\t\t} else {\n\t\t\t\taxis.axisLine.animate({ d: linePath });\n\t\t\t}\n\n\t\t\t// show or hide the line depending on options.showEmpty\n\t\t\taxis.axisLine[showAxis ? 'show' : 'hide']();\n\t\t}\n\n\t\tif (axisTitle && showAxis) {\n\n\t\t\taxisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n\t\t\t\taxis.getTitlePosition()\n\t\t\t);\n\t\t\taxisTitle.isNew = false;\n\t\t}\n\n\t\t// Stacked totals:\n\t\tif (stackLabelOptions && stackLabelOptions.enabled) {\n\t\t\taxis.renderStackTotals();\n\t\t}\n\t\t// End stacked totals\n\n\t\taxis.isDirty = false;\n\t},\n\n\t/**\n\t * Redraw the axis to reflect changes in the data or axis extremes\n\t */\n\tredraw: function () {\n\t\t\n\t\t// render the axis\n\t\tthis.render();\n\n\t\t// move plot lines and bands\n\t\teach(this.plotLinesAndBands, function (plotLine) {\n\t\t\tplotLine.render();\n\t\t});\n\n\t\t// mark associated series as dirty and ready for redraw\n\t\teach(this.series, function (series) {\n\t\t\tseries.isDirty = true;\n\t\t});\n\n\t},\n\n\t/**\n\t * Destroys an Axis instance.\n\t */\n\tdestroy: function (keepEvents) {\n\t\tvar axis = this,\n\t\t\tstacks = axis.stacks,\n\t\t\tstackKey,\n\t\t\tplotLinesAndBands = axis.plotLinesAndBands,\n\t\t\ti;\n\n\t\t// Remove the events\n\t\tif (!keepEvents) {\n\t\t\tremoveEvent(axis);\n\t\t}\n\n\t\t// Destroy each stack total\n\t\tfor (stackKey in stacks) {\n\t\t\tdestroyObjectProperties(stacks[stackKey]);\n\n\t\t\tstacks[stackKey] = null;\n\t\t}\n\n\t\t// Destroy collections\n\t\teach([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n\t\t\tdestroyObjectProperties(coll);\n\t\t});\n\t\ti = plotLinesAndBands.length;\n\t\twhile (i--) { // #1975\n\t\t\tplotLinesAndBands[i].destroy();\n\t\t}\n\n\t\t// Destroy local variables\n\t\teach(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n\t\t\tif (axis[prop]) {\n\t\t\t\taxis[prop] = axis[prop].destroy();\n\t\t\t}\n\t\t});\n\n\t\t// Destroy crosshair\n\t\tif (this.cross) {\n\t\t\tthis.cross.destroy();\n\t\t}\n\t},\n\n\t/**\n\t * Draw the crosshair\n\t */\n\tdrawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.\n\n\t\tvar path,\n\t\t\toptions = this.crosshair,\n\t\t\tanimation = options.animation,\n\t\t\tpos,\n\t\t\tattribs,\n\t\t\tcategorized;\n\t\t\n\t\tif (\n\t\t\t// Disabled in options\n\t\t\t!this.crosshair || \n\t\t\t// Snap\n\t\t\t((defined(point) || !pick(this.crosshair.snap, true)) === false)\n\t\t) {\n\t\t\tthis.hideCrosshair();\n\t\t\n\t\t} else {\t\t\t\n\n\t\t\t// Get the path\n\t\t\tif (!pick(options.snap, true)) {\n\t\t\t\tpos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n\t\t\t} else if (defined(point)) {\n\t\t\t\t/*jslint eqeq: true*/\n\t\t\t\tpos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n\t\t\t\t/*jslint eqeq: false*/\n\t\t\t}\n\n\t\t\tif (this.isRadial) {\n\t\t\t\tpath = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n\t\t\t} else {\n\t\t\t\tpath = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n\t\t\t}\n\n\t\t\tif (path === null) {\n\t\t\t\tthis.hideCrosshair();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Draw the cross\n\t\t\tif (this.cross) {\n\t\t\t\tthis.cross\n\t\t\t\t\t.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);\n\t\t\t} else {\n\t\t\t\tcategorized = this.categories && !this.isRadial;\n\t\t\t\tattribs = {\n\t\t\t\t\t'stroke-width': options.width || (categorized ? this.transA : 1),\n\t\t\t\t\tstroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n\t\t\t\t\tzIndex: options.zIndex || 2\n\t\t\t\t};\n\t\t\t\tif (options.dashStyle) {\n\t\t\t\t\tattribs.dashstyle = options.dashStyle;\n\t\t\t\t}\n\t\t\t\tthis.cross = this.chart.renderer.path(path).attr(attribs).add();\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t/**\n\t *\tHide the crosshair.\n\t */\n\thideCrosshair: function () {\n\t\tif (this.cross) {\n\t\t\tthis.cross.hide();\n\t\t}\n\t}\n}; // end Axis\n\nextend(Axis.prototype, AxisPlotLineOrBandExtension);\n\n/**\n * Set the tick positions to a time unit that makes sense, for example\n * on the first of each month or on every Monday. Return an array\n * with the time positions. Used in datetime axes as well as for grouping\n * data on a datetime axis.\n *\n * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n * @param {Number} min The minimum in axis values\n * @param {Number} max The maximum in axis values\n * @param {Number} startOfWeek\n */\nAxis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n\tvar tickPositions = [],\n\t\ti,\n\t\thigherRanks = {},\n\t\tuseUTC = defaultOptions.global.useUTC,\n\t\tminYear, // used in months and years as a basis for Date.UTC()\n\t\tminDate = new Date(min - getTZOffset(min)),\n\t\tinterval = normalizedInterval.unitRange,\n\t\tcount = normalizedInterval.count;\n\n\tif (defined(min)) { // #1300\n\t\tminDate.setMilliseconds(interval >= timeUnits.second ? 0 :\n\t\t\tcount * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n\t\tif (interval >= timeUnits.second) { // second\n\t\t\tminDate.setSeconds(interval >= timeUnits.minute ? 0 :\n\t\t\t\tcount * mathFloor(minDate.getSeconds() / count));\n\t\t}\n\t\n\t\tif (interval >= timeUnits.minute) { // minute\n\t\t\tminDate[setMinutes](interval >= timeUnits.hour ? 0 :\n\t\t\t\tcount * mathFloor(minDate[getMinutes]() / count));\n\t\t}\n\t\n\t\tif (interval >= timeUnits.hour) { // hour\n\t\t\tminDate[setHours](interval >= timeUnits.day ? 0 :\n\t\t\t\tcount * mathFloor(minDate[getHours]() / count));\n\t\t}\n\t\n\t\tif (interval >= timeUnits.day) { // day\n\t\t\tminDate[setDate](interval >= timeUnits.month ? 1 :\n\t\t\t\tcount * mathFloor(minDate[getDate]() / count));\n\t\t}\n\t\n\t\tif (interval >= timeUnits.month) { // month\n\t\t\tminDate[setMonth](interval >= timeUnits.year ? 0 :\n\t\t\t\tcount * mathFloor(minDate[getMonth]() / count));\n\t\t\tminYear = minDate[getFullYear]();\n\t\t}\n\t\n\t\tif (interval >= timeUnits.year) { // year\n\t\t\tminYear -= minYear % count;\n\t\t\tminDate[setFullYear](minYear);\n\t\t}\n\t\n\t\t// week is a special case that runs outside the hierarchy\n\t\tif (interval === timeUnits.week) {\n\t\t\t// get start of current week, independent of count\n\t\t\tminDate[setDate](minDate[getDate]() - minDate[getDay]() +\n\t\t\t\tpick(startOfWeek, 1));\n\t\t}\n\t\n\t\n\t\t// get tick positions\n\t\ti = 1;\n\t\tif (timezoneOffset || getTimezoneOffset) {\n\t\t\tminDate = minDate.getTime();\n\t\t\tminDate = new Date(minDate + getTZOffset(minDate));\n\t\t}\n\t\tminYear = minDate[getFullYear]();\n\t\tvar time = minDate.getTime(),\n\t\t\tminMonth = minDate[getMonth](),\n\t\t\tminDateDate = minDate[getDate](),\n\t\t\tlocalTimezoneOffset = (timeUnits.day + \n\t\t\t\t\t(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n\t\t\t\t) % timeUnits.day; // #950, #3359\n\t\n\t\t// iterate and add tick positions at appropriate values\n\t\twhile (time < max) {\n\t\t\ttickPositions.push(time);\n\t\n\t\t\t// if the interval is years, use Date.UTC to increase years\n\t\t\tif (interval === timeUnits.year) {\n\t\t\t\ttime = makeTime(minYear + i * count, 0);\n\t\n\t\t\t// if the interval is months, use Date.UTC to increase months\n\t\t\t} else if (interval === timeUnits.month) {\n\t\t\t\ttime = makeTime(minYear, minMonth + i * count);\n\t\n\t\t\t// if we're using global time, the interval is not fixed as it jumps\n\t\t\t// one hour at the DST crossover\n\t\t\t} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {\n\t\t\t\ttime = makeTime(minYear, minMonth, minDateDate +\n\t\t\t\t\ti * count * (interval === timeUnits.day ? 1 : 7));\n\t\n\t\t\t// else, the interval is fixed and we use simple addition\n\t\t\t} else {\n\t\t\t\ttime += interval * count;\n\t\t\t}\n\t\n\t\t\ti++;\n\t\t}\n\t\n\t\t// push the last time\n\t\ttickPositions.push(time);\n\n\n\t\t// mark new days if the time is dividible by day (#1649, #1760)\n\t\teach(grep(tickPositions, function (time) {\n\t\t\treturn interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n\t\t}), function (time) {\n\t\t\thigherRanks[time] = 'day';\n\t\t});\n\t}\n\n\n\t// record information on the chosen unit - for dynamic label formatter\n\ttickPositions.info = extend(normalizedInterval, {\n\t\thigherRanks: higherRanks,\n\t\ttotalRange: interval * count\n\t});\n\n\treturn tickPositions;\n};\n\n/**\n * Get a normalized tick interval for dates. Returns a configuration object with\n * unit range (interval), count and name. Used to prepare data for getTimeTicks. \n * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n * of segments in stock charts, the normalizing logic was extracted in order to \n * prevent it for running over again for each segment having the same interval. \n * #662, #697.\n */\nAxis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n\tvar units = unitsOption || [[\n\t\t\t\t'millisecond', // unit name\n\t\t\t\t[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n\t\t\t], [\n\t\t\t\t'second',\n\t\t\t\t[1, 2, 5, 10, 15, 30]\n\t\t\t], [\n\t\t\t\t'minute',\n\t\t\t\t[1, 2, 5, 10, 15, 30]\n\t\t\t], [\n\t\t\t\t'hour',\n\t\t\t\t[1, 2, 3, 4, 6, 8, 12]\n\t\t\t], [\n\t\t\t\t'day',\n\t\t\t\t[1, 2]\n\t\t\t], [\n\t\t\t\t'week',\n\t\t\t\t[1, 2]\n\t\t\t], [\n\t\t\t\t'month',\n\t\t\t\t[1, 2, 3, 4, 6]\n\t\t\t], [\n\t\t\t\t'year',\n\t\t\t\tnull\n\t\t\t]],\n\t\tunit = units[units.length - 1], // default unit is years\n\t\tinterval = timeUnits[unit[0]],\n\t\tmultiples = unit[1],\n\t\tcount,\n\t\ti;\n\t\t\n\t// loop through the units to find the one that best fits the tickInterval\n\tfor (i = 0; i < units.length; i++) {\n\t\tunit = units[i];\n\t\tinterval = timeUnits[unit[0]];\n\t\tmultiples = unit[1];\n\n\n\t\tif (units[i + 1]) {\n\t\t\t// lessThan is in the middle between the highest multiple and the next unit.\n\t\t\tvar lessThan = (interval * multiples[multiples.length - 1] +\n\t\t\t\t\t\ttimeUnits[units[i + 1][0]]) / 2;\n\n\t\t\t// break and keep the current unit\n\t\t\tif (tickInterval <= lessThan) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// prevent 2.5 years intervals, though 25, 250 etc. are allowed\n\tif (interval === timeUnits.year && tickInterval < 5 * interval) {\n\t\tmultiples = [1, 2, 5];\n\t}\n\n\t// get the count\n\tcount = normalizeTickInterval(\n\t\ttickInterval / interval, \n\t\tmultiples,\n\t\tunit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n\t);\n\t\n\treturn {\n\t\tunitRange: interval,\n\t\tcount: count,\n\t\tunitName: unit[0]\n\t};\n};/**\n * Methods defined on the Axis prototype\n */\n\n/**\n * Set the tick positions of a logarithmic axis\n */\nAxis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n\tvar axis = this,\n\t\toptions = axis.options,\n\t\taxisLength = axis.len,\n\t\t// Since we use this method for both major and minor ticks,\n\t\t// use a local variable and return the result\n\t\tpositions = []; \n\t\n\t// Reset\n\tif (!minor) {\n\t\taxis._minorAutoInterval = null;\n\t}\n\t\n\t// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n\tif (interval >= 0.5) {\n\t\tinterval = mathRound(interval);\n\t\tpositions = axis.getLinearTickPositions(interval, min, max);\n\t\t\n\t// Second case: We need intermediary ticks. For example \n\t// 1, 2, 4, 6, 8, 10, 20, 40 etc. \n\t} else if (interval >= 0.08) {\n\t\tvar roundedMin = mathFloor(min),\n\t\t\tintermediate,\n\t\t\ti,\n\t\t\tj,\n\t\t\tlen,\n\t\t\tpos,\n\t\t\tlastPos,\n\t\t\tbreak2;\n\t\t\t\n\t\tif (interval > 0.3) {\n\t\t\tintermediate = [1, 2, 4];\n\t\t} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n\t\t\tintermediate = [1, 2, 4, 6, 8];\n\t\t} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n\t\t\tintermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\t\t}\n\t\t\n\t\tfor (i = roundedMin; i < max + 1 && !break2; i++) {\n\t\t\tlen = intermediate.length;\n\t\t\tfor (j = 0; j < len && !break2; j++) {\n\t\t\t\tpos = log2lin(lin2log(i) * intermediate[j]);\n\t\t\t\tif (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113\n\t\t\t\t\tpositions.push(lastPos);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (lastPos > max) {\n\t\t\t\t\tbreak2 = true;\n\t\t\t\t}\n\t\t\t\tlastPos = pos;\n\t\t\t}\n\t\t}\n\t\t\n\t// Third case: We are so deep in between whole logarithmic values that\n\t// we might as well handle the tick positions like a linear axis. For\n\t// example 1.01, 1.02, 1.03, 1.04.\n\t} else {\n\t\tvar realMin = lin2log(min),\n\t\t\trealMax = lin2log(max),\n\t\t\ttickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n\t\t\tfilteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n\t\t\ttickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n\t\t\ttotalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\t\t\n\t\tinterval = pick(\n\t\t\tfilteredTickIntervalOption,\n\t\t\taxis._minorAutoInterval,\n\t\t\t(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n\t\t);\n\t\t\n\t\tinterval = normalizeTickInterval(\n\t\t\tinterval, \n\t\t\tnull, \n\t\t\tgetMagnitude(interval)\n\t\t);\n\t\t\n\t\tpositions = map(axis.getLinearTickPositions(\n\t\t\tinterval, \n\t\t\trealMin,\n\t\t\trealMax\t\n\t\t), log2lin);\n\t\t\n\t\tif (!minor) {\n\t\t\taxis._minorAutoInterval = interval / 5;\n\t\t}\n\t}\n\t\n\t// Set the axis-level tickInterval variable \n\tif (!minor) {\n\t\taxis.tickInterval = interval;\n\t}\n\treturn positions;\n};/**\n * The tooltip object\n * @param {Object} chart The chart instance\n * @param {Object} options Tooltip options\n */\nvar Tooltip = Highcharts.Tooltip = function () {\n\tthis.init.apply(this, arguments);\n};\n\nTooltip.prototype = {\n\n\tinit: function (chart, options) {\n\n\t\tvar borderWidth = options.borderWidth,\n\t\t\tstyle = options.style,\n\t\t\tpadding = pInt(style.padding);\n\n\t\t// Save the chart and options\n\t\tthis.chart = chart;\n\t\tthis.options = options;\n\n\t\t// Keep track of the current series\n\t\t//this.currentSeries = UNDEFINED;\n\n\t\t// List of crosshairs\n\t\tthis.crosshairs = [];\n\n\t\t// Current values of x and y when animating\n\t\tthis.now = { x: 0, y: 0 };\n\n\t\t// The tooltip is initially hidden\n\t\tthis.isHidden = true;\n\n\n\t\t// create the label\t\t\n\t\tthis.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n\t\t\t.attr({\n\t\t\t\tpadding: padding,\n\t\t\t\tfill: options.backgroundColor,\n\t\t\t\t'stroke-width': borderWidth,\n\t\t\t\tr: options.borderRadius,\n\t\t\t\tzIndex: 8\n\t\t\t})\n\t\t\t.css(style)\n\t\t\t.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n\t\t\t.add()\n\t\t\t.attr({ y: -9999 }); // #2301, #2657\n\n\t\t// When using canVG the shadow shows up as a gray circle\n\t\t// even if the tooltip is hidden.\n\t\tif (!useCanVG) {\n\t\t\tthis.label.shadow(options.shadow);\n\t\t}\n\n\t\t// Public property for getting the shared state.\n\t\tthis.shared = options.shared;\n\t},\n\n\t/**\n\t * Destroy the tooltip and its elements.\n\t */\n\tdestroy: function () {\n\t\t// Destroy and clear local variables\n\t\tif (this.label) {\n\t\t\tthis.label = this.label.destroy();\n\t\t}\n\t\tclearTimeout(this.hideTimer);\n\t\tclearTimeout(this.tooltipTimeout);\n\t},\n\n\t/**\n\t * Provide a soft movement for the tooltip\n\t *\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @private\n\t */\n\tmove: function (x, y, anchorX, anchorY) {\n\t\tvar tooltip = this,\n\t\t\tnow = tooltip.now,\n\t\t\tanimate = tooltip.options.animation !== false && !tooltip.isHidden && \n\t\t\t\t// When we get close to the target position, abort animation and land on the right place (#3056)\n\t\t\t\t(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),\n\t\t\tskipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n\t\t// Get intermediate values for animation\n\t\textend(now, {\n\t\t\tx: animate ? (2 * now.x + x) / 3 : x,\n\t\t\ty: animate ? (now.y + y) / 2 : y,\n\t\t\tanchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n\t\t\tanchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY\n\t\t});\n\n\t\t// Move to the intermediate value\n\t\ttooltip.label.attr(now);\n\n\t\t\n\t\t// Run on next tick of the mouse tracker\n\t\tif (animate) {\n\t\t\n\t\t\t// Never allow two timeouts\n\t\t\tclearTimeout(this.tooltipTimeout);\n\t\t\t\n\t\t\t// Set the fixed interval ticking for the smooth tooltip\n\t\t\tthis.tooltipTimeout = setTimeout(function () {\n\t\t\t\t// The interval function may still be running during destroy, so check that the chart is really there before calling.\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.move(x, y, anchorX, anchorY);\n\t\t\t\t}\n\t\t\t}, 32);\n\t\t\t\n\t\t}\n\t},\n\n\t/**\n\t * Hide the tooltip\n\t */\n\thide: function (delay) {\n\t\tvar tooltip = this,\n\t\t\thoverPoints;\n\t\t\n\t\tclearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n\t\tif (!this.isHidden) {\n\t\t\thoverPoints = this.chart.hoverPoints;\n\n\t\t\tthis.hideTimer = setTimeout(function () {\n\t\t\t\ttooltip.label.fadeOut();\n\t\t\t\ttooltip.isHidden = true;\n\t\t\t}, pick(delay, this.options.hideDelay, 500));\n\n\t\t\t// hide previous hoverPoints and set new\n\t\t\tif (hoverPoints) {\n\t\t\t\teach(hoverPoints, function (point) {\n\t\t\t\t\tpoint.setState();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.chart.hoverPoints = null;\n\t\t\tthis.chart.hoverSeries = null;\n\t\t}\n\t},\n\t\n\t/** \n\t * Extendable method to get the anchor position of the tooltip\n\t * from a point or set of points\n\t */\n\tgetAnchor: function (points, mouseEvent) {\n\t\tvar ret,\n\t\t\tchart = this.chart,\n\t\t\tinverted = chart.inverted,\n\t\t\tplotTop = chart.plotTop,\n\t\t\tplotLeft = chart.plotLeft,\n\t\t\tplotX = 0,\n\t\t\tplotY = 0,\n\t\t\tyAxis,\n\t\t\txAxis;\n\t\t\n\t\tpoints = splat(points);\n\t\t\n\t\t// Pie uses a special tooltipPos\n\t\tret = points[0].tooltipPos;\n\t\t\n\t\t// When tooltip follows mouse, relate the position to the mouse\n\t\tif (this.followPointer && mouseEvent) {\n\t\t\tif (mouseEvent.chartX === UNDEFINED) {\n\t\t\t\tmouseEvent = chart.pointer.normalize(mouseEvent);\n\t\t\t}\n\t\t\tret = [\n\t\t\t\tmouseEvent.chartX - chart.plotLeft,\n\t\t\t\tmouseEvent.chartY - plotTop\n\t\t\t];\n\t\t}\n\t\t// When shared, use the average position\n\t\tif (!ret) {\n\t\t\teach(points, function (point) {\n\t\t\t\tyAxis = point.series.yAxis;\n\t\t\t\txAxis = point.series.xAxis;\n\t\t\t\tplotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); \n\t\t\t\tplotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n\t\t\t\t\t(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n\t\t\t});\n\t\t\t\n\t\t\tplotX /= points.length;\n\t\t\tplotY /= points.length;\n\t\t\t\n\t\t\tret = [\n\t\t\t\tinverted ? chart.plotWidth - plotY : plotX,\n\t\t\t\tthis.shared && !inverted && points.length > 1 && mouseEvent ? \n\t\t\t\t\tmouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n\t\t\t\t\tinverted ? chart.plotHeight - plotX : plotY\n\t\t\t];\n\t\t}\n\n\t\treturn map(ret, mathRound);\n\t},\n\t\n\t/**\n\t * Place the tooltip in a chart without spilling over\n\t * and not covering the point it self.\n\t */\n\tgetPosition: function (boxWidth, boxHeight, point) {\n\t\t\n\t\tvar chart = this.chart,\n\t\t\tdistance = this.distance,\n\t\t\tret = {},\n\t\t\tswapped,\n\t\t\tfirst = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],\n\t\t\tsecond = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],\n\t\t\t// The far side is right or bottom\n\t\t\tpreferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),\n\t\t\t/**\n\t\t\t * Handle the preferred dimension. When the preferred dimension is tooltip\n\t\t\t * on top or bottom of the point, it will look for space there.\n\t\t\t */\n\t\t\tfirstDimension = function (dim, outerSize, innerSize, point) {\n\t\t\t\tvar roomLeft = innerSize < point - distance,\n\t\t\t\t\troomRight = point + distance + innerSize < outerSize,\n\t\t\t\t\talignedLeft = point - distance - innerSize,\n\t\t\t\t\talignedRight = point + distance;\n\n\t\t\t\tif (preferFarSide && roomRight) {\n\t\t\t\t\tret[dim] = alignedRight;\n\t\t\t\t} else if (!preferFarSide && roomLeft) {\n\t\t\t\t\tret[dim] = alignedLeft;\n\t\t\t\t} else if (roomLeft) {\n\t\t\t\t\tret[dim] = alignedLeft;\n\t\t\t\t} else if (roomRight) {\n\t\t\t\t\tret[dim] = alignedRight;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * Handle the secondary dimension. If the preferred dimension is tooltip\n\t\t\t * on top or bottom of the point, the second dimension is to align the tooltip\n\t\t\t * above the point, trying to align center but allowing left or right\n\t\t\t * align within the chart box.\n\t\t\t */\n\t\t\tsecondDimension = function (dim, outerSize, innerSize, point) {\n\t\t\t\t// Too close to the edge, return false and swap dimensions\n\t\t\t\tif (point < distance || point > outerSize - distance) {\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\t// Align left/top\n\t\t\t\t} else if (point < innerSize / 2) {\n\t\t\t\t\tret[dim] = 1;\n\t\t\t\t// Align right/bottom\n\t\t\t\t} else if (point > outerSize - innerSize / 2) {\n\t\t\t\t\tret[dim] = outerSize - innerSize - 2;\n\t\t\t\t// Align center\n\t\t\t\t} else {\n\t\t\t\t\tret[dim] = point - innerSize / 2;\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * Swap the dimensions \n\t\t\t */\n\t\t\tswap = function (count) {\n\t\t\t\tvar temp = first;\n\t\t\t\tfirst = second;\n\t\t\t\tsecond = temp;\n\t\t\t\tswapped = count;\n\t\t\t},\n\t\t\trun = function () {\n\t\t\t\tif (firstDimension.apply(0, first) !== false) {\n\t\t\t\t\tif (secondDimension.apply(0, second) === false && !swapped) {\n\t\t\t\t\t\tswap(true);\n\t\t\t\t\t\trun();\n\t\t\t\t\t}\n\t\t\t\t} else if (!swapped) {\n\t\t\t\t\tswap(true);\n\t\t\t\t\trun();\n\t\t\t\t} else {\n\t\t\t\t\tret.x = ret.y = 0;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Under these conditions, prefer the tooltip on the side of the point\n\t\tif (chart.inverted || this.len > 1) {\n\t\t\tswap();\n\t\t}\n\t\trun();\n\n\t\treturn ret;\n\t\n\t},\n\n\t/**\n\t * In case no user defined formatter is given, this will be used. Note that the context\n\t * here is an object holding point, series, x, y etc.\n\t */\n\tdefaultFormatter: function (tooltip) {\n\t\tvar items = this.points || splat(this),\n\t\t\ts;\n\n\t\t// build the header\n\t\ts = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n\t\t// build the values\n\t\ts = s.concat(tooltip.bodyFormatter(items));\n\n\t\t// footer\n\t\ts.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n\t\treturn s.join('');\n\t},\n\n\t/**\n\t * Refresh the tooltip's text and position.\n\t * @param {Object} point\n\t */\n\trefresh: function (point, mouseEvent) {\n\t\tvar tooltip = this,\n\t\t\tchart = tooltip.chart,\n\t\t\tlabel = tooltip.label,\n\t\t\toptions = tooltip.options,\n\t\t\tx,\n\t\t\ty,\n\t\t\tanchor,\n\t\t\ttextConfig = {},\n\t\t\ttext,\n\t\t\tpointConfig = [],\n\t\t\tformatter = options.formatter || tooltip.defaultFormatter,\n\t\t\thoverPoints = chart.hoverPoints,\n\t\t\tborderColor,\n\t\t\tshared = tooltip.shared,\n\t\t\tcurrentSeries;\n\t\t\t\n\t\tclearTimeout(this.hideTimer);\n\t\t\n\t\t// get the reference point coordinates (pie charts use tooltipPos)\n\t\ttooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n\t\tanchor = tooltip.getAnchor(point, mouseEvent);\n\t\tx = anchor[0];\n\t\ty = anchor[1];\n\n\t\t// shared tooltip, array is sent over\n\t\tif (shared && !(point.series && point.series.noSharedTooltip)) {\n\t\t\t\n\t\t\t// hide previous hoverPoints and set new\n\t\t\t\n\t\t\tchart.hoverPoints = point;\n\t\t\tif (hoverPoints) {\n\t\t\t\teach(hoverPoints, function (point) {\n\t\t\t\t\tpoint.setState();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\teach(point, function (item) {\n\t\t\t\titem.setState(HOVER_STATE);\n\n\t\t\t\tpointConfig.push(item.getLabelConfig());\n\t\t\t});\n\n\t\t\ttextConfig = {\n\t\t\t\tx: point[0].category,\n\t\t\t\ty: point[0].y\n\t\t\t};\n\t\t\ttextConfig.points = pointConfig;\n\t\t\tthis.len = pointConfig.length;\n\t\t\tpoint = point[0];\n\n\t\t// single point tooltip\n\t\t} else {\n\t\t\ttextConfig = point.getLabelConfig();\n\t\t}\n\t\ttext = formatter.call(textConfig, tooltip);\n\n\t\t// register the current series\n\t\tcurrentSeries = point.series;\n\t\tthis.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n\t\t// update the inner HTML\n\t\tif (text === false) {\n\t\t\tthis.hide();\n\t\t} else {\n\n\t\t\t// show it\n\t\t\tif (tooltip.isHidden) {\n\t\t\t\tstop(label);\n\t\t\t\tlabel.attr('opacity', 1).show();\n\t\t\t}\n\n\t\t\t// update text\n\t\t\tlabel.attr({\n\t\t\t\ttext: text\n\t\t\t});\n\n\t\t\t// set the stroke color of the box\n\t\t\tborderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n\t\t\tlabel.attr({\n\t\t\t\tstroke: borderColor\n\t\t\t});\n\t\t\t\n\t\t\ttooltip.updatePosition({ plotX: x, plotY: y, negative: point.negative, ttBelow: point.ttBelow });\n\t\t\n\t\t\tthis.isHidden = false;\n\t\t}\n\t\tfireEvent(chart, 'tooltipRefresh', {\n\t\t\t\ttext: text,\n\t\t\t\tx: x + chart.plotLeft,\n\t\t\t\ty: y + chart.plotTop,\n\t\t\t\tborderColor: borderColor\n\t\t\t});\n\t},\n\t\n\t/**\n\t * Find the new position and perform the move\n\t */\n\tupdatePosition: function (point) {\n\t\tvar chart = this.chart,\n\t\t\tlabel = this.label, \n\t\t\tpos = (this.options.positioner || this.getPosition).call(\n\t\t\t\tthis,\n\t\t\t\tlabel.width,\n\t\t\t\tlabel.height,\n\t\t\t\tpoint\n\t\t\t);\n\n\t\t// do the move\n\t\tthis.move(\n\t\t\tmathRound(pos.x), \n\t\t\tmathRound(pos.y), \n\t\t\tpoint.plotX + chart.plotLeft, \n\t\t\tpoint.plotY + chart.plotTop\n\t\t);\n\t},\n\n\t/** \n\t * Get the best X date format based on the closest point range on the axis.\n\t */\n\tgetXDateFormat: function (point, options, xAxis) {\n\t\tvar xDateFormat,\n\t\t\tdateTimeLabelFormats = options.dateTimeLabelFormats,\n\t\t\tclosestPointRange = xAxis && xAxis.closestPointRange,\n\t\t\tn,\n\t\t\tblank = '01-01 00:00:00.000',\n\t\t\tstrpos = {\n\t\t\t\tmillisecond: 15,\n\t\t\t\tsecond: 12,\n\t\t\t\tminute: 9,\n\t\t\t\thour: 6,\n\t\t\t\tday: 3\n\t\t\t},\n\t\t\tdate,\n\t\t\tlastN;\n\n\t\tif (closestPointRange) {\n\t\t\tdate = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n\t\t\tfor (n in timeUnits) {\n\n\t\t\t\t// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n\t\t\t\tif (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && \n\t\t\t\t\t\tdate.substr(6) === blank.substr(6)) {\n\t\t\t\t\tn = 'week';\n\t\t\t\t\tbreak;\n\n\t\t\t\t// The first format that is too great for the range\n\t\t\t\t} else if (timeUnits[n] > closestPointRange) {\n\t\t\t\t\tn = lastN;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t// If the point is placed every day at 23:59, we need to show\n\t\t\t\t// the minutes as well. #2637.\n\t\t\t\t} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n\t\t\t\tif (n !== 'week') {\n\t\t\t\t\tlastN = n;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (n) {\n\t\t\t\txDateFormat = dateTimeLabelFormats[n];\n\t\t\t}\n\t\t} else {\n\t\t\txDateFormat = dateTimeLabelFormats.day;\n\t\t}\n\n\t\treturn xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n\t},\n\n\t/**\n\t * Format the footer/header of the tooltip\n\t * #3397: abstraction to enable formatting of footer and header\n\t */\n\ttooltipFooterHeaderFormatter: function (point, isFooter) {\n\t\tvar footOrHead = isFooter ? 'footer' : 'header',\n\t\t\tseries = point.series,\n\t\t\ttooltipOptions = series.tooltipOptions,\n\t\t\txDateFormat = tooltipOptions.xDateFormat,\n\t\t\txAxis = series.xAxis,\n\t\t\tisDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n\t\t\tformatString = tooltipOptions[footOrHead+'Format'];\n\n\t\t// Guess the best date format based on the closest point distance (#568, #3418)\n\t\tif (isDateTime && !xDateFormat) {\n\t\t\txDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n\t\t}\n\n\t\t// Insert the footer date format if any\n\t\tif (isDateTime && xDateFormat) {\n\t\t\tformatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n\t\t}\n\n\t\treturn format(formatString, {\n\t\t\tpoint: point,\n\t\t\tseries: series\n\t\t});\n\t},\n\n\t/**\n     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n     * abstracting this functionality allows to easily overwrite and extend it. \n\t */\n\tbodyFormatter: function (items) {\n        return map(items, function (item) {\n            var tooltipOptions = item.series.tooltipOptions;\n            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n        });\n    }\n    \n};\n\nvar hoverChartIndex;\n\n// Global flag for touch support\nhasTouch = doc.documentElement.ontouchstart !== UNDEFINED;\n\n/**\n * The mouse tracker object. All methods starting with \"on\" are primary DOM event handlers. \n * Subsequent methods should be named differently from what they are doing.\n * @param {Object} chart The Chart instance\n * @param {Object} options The root options object\n */\nvar Pointer = Highcharts.Pointer = function (chart, options) {\n\tthis.init(chart, options);\n};\n\nPointer.prototype = {\n\t/**\n\t * Initialize Pointer\n\t */\n\tinit: function (chart, options) {\n\t\t\n\t\tvar chartOptions = options.chart,\n\t\t\tchartEvents = chartOptions.events,\n\t\t\tzoomType = useCanVG ? '' : chartOptions.zoomType,\n\t\t\tinverted = chart.inverted,\n\t\t\tzoomX,\n\t\t\tzoomY;\n\n\t\t// Store references\n\t\tthis.options = options;\n\t\tthis.chart = chart;\n\t\t\n\t\t// Zoom status\n\t\tthis.zoomX = zoomX = /x/.test(zoomType);\n\t\tthis.zoomY = zoomY = /y/.test(zoomType);\n\t\tthis.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n\t\tthis.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n\t\tthis.hasZoom = zoomX || zoomY;\n\n\t\t// Do we need to handle click on a touch device?\n\t\tthis.runChartClick = chartEvents && !!chartEvents.click;\n\n\t\tthis.pinchDown = [];\n\t\tthis.lastValidTouch = {};\n\n\t\tif (Highcharts.Tooltip && options.tooltip.enabled) {\n\t\t\tchart.tooltip = new Tooltip(chart, options.tooltip);\n\t\t\tthis.followTouchMove = pick(options.tooltip.followTouchMove, true);\n\t\t}\n\n\t\tthis.setDOMEvents();\n\t}, \n\n\t/**\n\t * Add crossbrowser support for chartX and chartY\n\t * @param {Object} e The event object in standard browsers\n\t */\n\tnormalize: function (e, chartPosition) {\n\t\tvar chartX,\n\t\t\tchartY,\n\t\t\tePos;\n\n\t\t// common IE normalizing\n\t\te = e || window.event;\n\n\t\t// Framework specific normalizing (#1165)\n\t\te = washMouseEvent(e);\n\n\t\t// More IE normalizing, needs to go after washMouseEvent\n\t\tif (!e.target) {\n\t\t\te.target = e.srcElement;\n\t\t}\n\t\t\n\t\t// iOS (#2757)\n\t\tePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n\t\t// Get mouse position\n\t\tif (!chartPosition) {\n\t\t\tthis.chartPosition = chartPosition = offset(this.chart.container);\n\t\t}\n\n\t\t// chartX and chartY\n\t\tif (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n\t\t\tchartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n\t\t\t\t// for IE10 quirks mode within framesets\n\t\t\tchartY = e.y;\n\t\t} else {\n\t\t\tchartX = ePos.pageX - chartPosition.left;\n\t\t\tchartY = ePos.pageY - chartPosition.top;\n\t\t}\n\n\t\treturn extend(e, {\n\t\t\tchartX: mathRound(chartX),\n\t\t\tchartY: mathRound(chartY)\n\t\t});\n\t},\n\n\t/**\n\t * Get the click position in terms of axis values.\n\t *\n\t * @param {Object} e A pointer event\n\t */\n\tgetCoordinates: function (e) {\n\t\tvar coordinates = {\n\t\t\t\txAxis: [],\n\t\t\t\tyAxis: []\n\t\t\t};\n\n\t\teach(this.chart.axes, function (axis) {\n\t\t\tcoordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n\t\t\t\taxis: axis,\n\t\t\t\tvalue: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n\t\t\t});\n\t\t});\n\t\treturn coordinates;\n\t},\n\t\n\t/**\n\t * With line type charts with a single tracker, get the point closest to the mouse.\n\t * Run Point.onMouseOver and display tooltip for the point or points.\n\t */\n\trunPointActions: function (e) {\n\n\t\tvar pointer = this,\n\t\t\tchart = pointer.chart,\n\t\t\tseries = chart.series,\n\t\t\ttooltip = chart.tooltip,\n\t\t\tshared = tooltip ? tooltip.shared : false,\n\t\t\tfollowPointer,\n\t\t\t//point,\n\t\t\t//points,\n\t\t\thoverPoint = chart.hoverPoint,\n\t\t\thoverSeries = chart.hoverSeries,\n\t\t\ti,\n\t\t\ttrueXkd,\n\t\t\ttrueX,\n\t\t\t//j,\n\t\t\tdistance = chart.chartWidth,\n\t\t\trdistance = chart.chartWidth,\n\t\t\tanchor,\n\t\t\tnoSharedTooltip,\n\t\t\tkdpoints = [],\n\t\t\tkdpoint,\n\t\t\tkdpointT;\n\n\t\t// For hovering over the empty parts of the plot area (hoverSeries is undefined). \n\t\t// If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n\t\tif (!shared && !hoverSeries) {\n\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\tif (series[i].directTouch || !series[i].options.stickyTracking) {\n\t\t\t\t\tseries = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle shared tooltip or cases where a series is not yet hovered\n\t\tif (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 \n\t\t\t// Find nearest points on all series\n\t\t\teach(series, function (s) {\n\t\t\t\t// Skip hidden series\n\t\t\t\tnoSharedTooltip = s.noSharedTooltip && shared;\n\t\t\t\tif (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821\n\t\t\t\t\tkdpointT = s.searchPoint(e); // #3828\n\t\t\t\t\tif (kdpointT) {\n\t\t\t\t\t\tkdpoints.push(kdpointT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Find absolute nearest point\n\t\t\teach(kdpoints, function (p) {\n\t\t\t\tif (p && defined(p.plotX) && defined(p.plotY)) {\n\t\t\t\t\tif ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {\n\t\t\t\t\t\tdistance = p.dist.distX;\n\t\t\t\t\t\trdistance = p.dist.distR;\n\t\t\t\t\t\tkdpoint = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\t\n\n\t\t// Handle non-shared tooltips\n\t\t} else {\n\t\t\t// If it has a hoverPoint and that series requires direct touch (like columns), use the hoverPoint (#3899).\n\t\t\t// Otherwise, search the k-d tree (like scatter).\n\t\t\tkdpoint = (hoverSeries.directTouch && hoverPoint) || (hoverSeries && hoverSeries.searchPoint(e));\n\t\t}\n\n\t\t// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926\n\t\tif (kdpoint && (kdpoint !== hoverPoint || (tooltip && tooltip.isHidden))) {\n\t\t\t// Draw tooltip if necessary\n\t\t\tif (shared && !kdpoint.series.noSharedTooltip) {\n\t\t\t\ti = kdpoints.length;\n\t\t\t\ttrueXkd = kdpoint.clientX;\n\t\t\t\twhile (i--) {\n\t\t\t\t\ttrueX = kdpoints[i].clientX;\n\t\t\t\t\tif (kdpoints[i].x !== kdpoint.x || trueX !== trueXkd || (kdpoints[i].series.noSharedTooltip || false)) {\n\t\t\t\t\t\tkdpoints.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (kdpoints.length && tooltip) {\n\t\t\t\t\ttooltip.refresh(kdpoints, e);\n\t\t\t\t}\n\n\t\t\t\t// do mouseover on all points except the closest\n\t\t\t\teach(kdpoints, function (point) {\n\t\t\t\t\tif (point !== kdpoint) { \n\t\t\t\t\t\tpoint.onMouseOver(e);\n\t\t\t\t\t}\n\t\t\t\t});\t\t\t\t\n\t\t\t\tkdpoint.onMouseOver(e); // #3919 do mouseover on the closest point last to ensure it is the hoverpoint\n\t\t\t} else {\n\t\t\t\tif (tooltip) { \n\t\t\t\t\ttooltip.refresh(kdpoint, e);\n\t\t\t\t}\n\t\t\t\tkdpoint.onMouseOver(e); \n\t\t\t}\n\t\t\n\t\t// Update positions (regardless of kdpoint or hoverPoint)\n\t\t} else {\n\t\t\tfollowPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n\t\t\tif (tooltip && followPointer && !tooltip.isHidden) {\n\t\t\t\tanchor = tooltip.getAnchor([{}], e);\n\t\t\t\ttooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t// Start the event listener to pick up the tooltip \n\t\tif (tooltip && !pointer._onDocumentMouseMove) {\n\t\t\tpointer._onDocumentMouseMove = function (e) {\n\t\t\t\tif (charts[hoverChartIndex]) {\n\t\t\t\t\tcharts[hoverChartIndex].pointer.onDocumentMouseMove(e);\n\t\t\t\t}\n\t\t\t};\n\t\t\taddEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n\t\t}\n\t\t\n\t\t// Crosshair\n\t\teach(chart.axes, function (axis) {\n\t\t\taxis.drawCrosshair(e, pick(kdpoint, hoverPoint));\n\t\t});\t\n\t\t\t\t\n\t},\n\n\n\n\t/**\n\t * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n\t * \n\t * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n\t */\n\treset: function (allowMove, delay) {\n\t\tvar pointer = this,\n\t\t\tchart = pointer.chart,\n\t\t\thoverSeries = chart.hoverSeries,\n\t\t\thoverPoint = chart.hoverPoint,\n\t\t\ttooltip = chart.tooltip,\n\t\t\ttooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;\n\t\t\t\n\t\t// Narrow in allowMove\n\t\tallowMove = allowMove && tooltip && tooltipPoints;\n\t\t\t\n\t\t// Check if the points have moved outside the plot area, #1003\t\t\n\t\tif (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {\n\t\t\tallowMove = false;\n\t\t}\t\n\t\t// Just move the tooltip, #349\n\t\tif (allowMove) {\n\t\t\ttooltip.refresh(tooltipPoints);\n\t\t\tif (hoverPoint) { // #2500\n\t\t\t\thoverPoint.setState(hoverPoint.state, true);\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\tif (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {\n\t\t\t\t\t\taxis.drawCrosshair(null, allowMove);\n\t\t\t\t\t}  else {\n\t\t\t\t\t\taxis.hideCrosshair();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\n\t\t// Full reset\n\t\t} else {\n\n\t\t\tif (hoverPoint) {\n\t\t\t\thoverPoint.onMouseOut();\n\t\t\t}\n\n\t\t\tif (hoverSeries) {\n\t\t\t\thoverSeries.onMouseOut();\n\t\t\t}\n\n\t\t\tif (tooltip) {\n\t\t\t\ttooltip.hide(delay);\n\t\t\t}\n\n\t\t\tif (pointer._onDocumentMouseMove) {\n\t\t\t\tremoveEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n\t\t\t\tpointer._onDocumentMouseMove = null;\n\t\t\t}\n\n\t\t\t// Remove crosshairs\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\taxis.hideCrosshair();\n\t\t\t});\n\t\t\t\n\t\t\tpointer.hoverX = null;\n\n\t\t}\n\t},\n\n\t/**\n\t * Scale series groups to a certain scale and translation\n\t */\n\tscaleGroups: function (attribs, clip) {\n\n\t\tvar chart = this.chart,\n\t\t\tseriesAttribs;\n\n\t\t// Scale each series\n\t\teach(chart.series, function (series) {\n\t\t\tseriesAttribs = attribs || series.getPlotBox(); // #1701\n\t\t\tif (series.xAxis && series.xAxis.zoomEnabled) {\n\t\t\t\tseries.group.attr(seriesAttribs);\n\t\t\t\tif (series.markerGroup) {\n\t\t\t\t\tseries.markerGroup.attr(seriesAttribs);\n\t\t\t\t\tseries.markerGroup.clip(clip ? chart.clipRect : null);\n\t\t\t\t}\n\t\t\t\tif (series.dataLabelsGroup) {\n\t\t\t\t\tseries.dataLabelsGroup.attr(seriesAttribs);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Clip\n\t\tchart.clipRect.attr(clip || chart.clipBox);\n\t},\n\n\t/**\n\t * Start a drag operation\n\t */\n\tdragStart: function (e) {\n\t\tvar chart = this.chart;\n\n\t\t// Record the start position\n\t\tchart.mouseIsDown = e.type;\n\t\tchart.cancelClick = false;\n\t\tchart.mouseDownX = this.mouseDownX = e.chartX;\n\t\tchart.mouseDownY = this.mouseDownY = e.chartY;\n\t},\n\n\t/**\n\t * Perform a drag operation in response to a mousemove event while the mouse is down\n\t */\n\tdrag: function (e) {\n\n\t\tvar chart = this.chart,\n\t\t\tchartOptions = chart.options.chart,\n\t\t\tchartX = e.chartX,\n\t\t\tchartY = e.chartY,\n\t\t\tzoomHor = this.zoomHor,\n\t\t\tzoomVert = this.zoomVert,\n\t\t\tplotLeft = chart.plotLeft,\n\t\t\tplotTop = chart.plotTop,\n\t\t\tplotWidth = chart.plotWidth,\n\t\t\tplotHeight = chart.plotHeight,\n\t\t\tclickedInside,\n\t\t\tsize,\n\t\t\tmouseDownX = this.mouseDownX,\n\t\t\tmouseDownY = this.mouseDownY,\n\t\t\tpanKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n\t\t// If the mouse is outside the plot area, adjust to cooordinates\n\t\t// inside to prevent the selection marker from going outside\n\t\tif (chartX < plotLeft) {\n\t\t\tchartX = plotLeft;\n\t\t} else if (chartX > plotLeft + plotWidth) {\n\t\t\tchartX = plotLeft + plotWidth;\n\t\t}\n\n\t\tif (chartY < plotTop) {\n\t\t\tchartY = plotTop;\n\t\t} else if (chartY > plotTop + plotHeight) {\n\t\t\tchartY = plotTop + plotHeight;\n\t\t}\n\t\t\n\t\t// determine if the mouse has moved more than 10px\n\t\tthis.hasDragged = Math.sqrt(\n\t\t\tMath.pow(mouseDownX - chartX, 2) +\n\t\t\tMath.pow(mouseDownY - chartY, 2)\n\t\t);\n\t\t\n\t\tif (this.hasDragged > 10) {\n\t\t\tclickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n\t\t\t// make a selection\n\t\t\tif (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n\t\t\t\tif (!this.selectionMarker) {\n\t\t\t\t\tthis.selectionMarker = chart.renderer.rect(\n\t\t\t\t\t\tplotLeft,\n\t\t\t\t\t\tplotTop,\n\t\t\t\t\t\tzoomHor ? 1 : plotWidth,\n\t\t\t\t\t\tzoomVert ? 1 : plotHeight,\n\t\t\t\t\t\t0\n\t\t\t\t\t)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tfill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n\t\t\t\t\t\tzIndex: 7\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// adjust the width of the selection marker\n\t\t\tif (this.selectionMarker && zoomHor) {\n\t\t\t\tsize = chartX - mouseDownX;\n\t\t\t\tthis.selectionMarker.attr({\n\t\t\t\t\twidth: mathAbs(size),\n\t\t\t\t\tx: (size > 0 ? 0 : size) + mouseDownX\n\t\t\t\t});\n\t\t\t}\n\t\t\t// adjust the height of the selection marker\n\t\t\tif (this.selectionMarker && zoomVert) {\n\t\t\t\tsize = chartY - mouseDownY;\n\t\t\t\tthis.selectionMarker.attr({\n\t\t\t\t\theight: mathAbs(size),\n\t\t\t\t\ty: (size > 0 ? 0 : size) + mouseDownY\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// panning\n\t\t\tif (clickedInside && !this.selectionMarker && chartOptions.panning) {\n\t\t\t\tchart.pan(e, chartOptions.panning);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * On mouse up or touch end across the entire document, drop the selection.\n\t */\n\tdrop: function (e) {\n\t\tvar pointer = this,\n\t\t\tchart = this.chart,\n\t\t\thasPinched = this.hasPinched;\n\n\t\tif (this.selectionMarker) {\n\t\t\tvar selectionData = {\n\t\t\t\t\txAxis: [],\n\t\t\t\t\tyAxis: [],\n\t\t\t\t\toriginalEvent: e.originalEvent || e\n\t\t\t\t},\n\t\t\t\tselectionBox = this.selectionMarker,\n\t\t\t\tselectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n\t\t\t\tselectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n\t\t\t\tselectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n\t\t\t\tselectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n\t\t\t\trunZoom;\n\n\t\t\t// a selection has been made\n\t\t\tif (this.hasDragged || hasPinched) {\n\n\t\t\t\t// record each axis' min and max\n\t\t\t\teach(chart.axes, function (axis) {\n\t\t\t\t\tif (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n\t\t\t\t\t\tvar horiz = axis.horiz,\n\t\t\t\t\t\t\tminPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075\n\t\t\t\t\t\t\tselectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n\t\t\t\t\t\t\tselectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n\t\t\t\t\t\tselectionData[axis.coll].push({\n\t\t\t\t\t\t\taxis: axis,\n\t\t\t\t\t\t\tmin: mathMin(selectionMin, selectionMax), // for reversed axes\n\t\t\t\t\t\t\tmax: mathMax(selectionMin, selectionMax)\n\t\t\t\t\t\t});\n\t\t\t\t\t\trunZoom = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (runZoom) {\n\t\t\t\t\tfireEvent(chart, 'selection', selectionData, function (args) { \n\t\t\t\t\t\tchart.zoom(extend(args, hasPinched ? { animation: false } : null)); \n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.selectionMarker = this.selectionMarker.destroy();\n\n\t\t\t// Reset scaling preview\n\t\t\tif (hasPinched) {\n\t\t\t\tthis.scaleGroups();\n\t\t\t}\n\t\t}\n\n\t\t// Reset all\n\t\tif (chart) { // it may be destroyed on mouse up - #877\n\t\t\tcss(chart.container, { cursor: chart._cursor });\n\t\t\tchart.cancelClick = this.hasDragged > 10; // #370\n\t\t\tchart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n\t\t\tthis.pinchDown = [];\n\t\t}\n\t},\n\n\tonContainerMouseDown: function (e) {\n\n\t\te = this.normalize(e);\n\n\t\t// issue #295, dragging not always working in Firefox\n\t\tif (e.preventDefault) {\n\t\t\te.preventDefault();\n\t\t}\n\t\t\n\t\tthis.dragStart(e);\n\t},\n\n\t\n\n\tonDocumentMouseUp: function (e) {\n\t\tif (charts[hoverChartIndex]) {\n\t\t\tcharts[hoverChartIndex].pointer.drop(e);\n\t\t}\n\t},\n\n\t/**\n\t * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n\t * Issue #149 workaround. The mouseleave event does not always fire. \n\t */\n\tonDocumentMouseMove: function (e) {\n\t\tvar chart = this.chart,\n\t\t\tchartPosition = this.chartPosition;\n\n\t\te = this.normalize(e, chartPosition);\n\n\t\t// If we're outside, hide the tooltip\n\t\tif (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n\t\t\t\t!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n\t\t\tthis.reset();\n\t\t}\n\t},\n\n\t/**\n\t * When mouse leaves the container, hide the tooltip.\n\t */\n\tonContainerMouseLeave: function () {\n\t\tvar chart = charts[hoverChartIndex];\n\t\tif (chart) {\n\t\t\tchart.pointer.reset();\n\t\t\tchart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n\t\t}\n\t},\n\n\t// The mousemove, touchmove and touchstart event handler\n\tonContainerMouseMove: function (e) {\n\n\t\tvar chart = this.chart;\n\n\t\thoverChartIndex = chart.index;\n\n\t\te = this.normalize(e);\t\t\n\t\te.returnValue = false; // #2251, #3224\n\t\t\n\t\tif (chart.mouseIsDown === 'mousedown') {\n\t\t\tthis.drag(e);\n\t\t} \n\t\t\n\t\t// Show the tooltip and run mouse over events (#977)\n\t\tif ((this.inClass(e.target, 'highcharts-tracker') || \n\t\t\t\tchart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n\t\t\tthis.runPointActions(e);\n\t\t}\n\t},\n\n\t/**\n\t * Utility to detect whether an element has, or has a parent with, a specific\n\t * class name. Used on detection of tracker objects and on deciding whether\n\t * hovering the tooltip should cause the active series to mouse out.\n\t */\n\tinClass: function (element, className) {\n\t\tvar elemClassName;\n\t\twhile (element) {\n\t\t\telemClassName = attr(element, 'class');\n\t\t\tif (elemClassName) {\n\t\t\t\tif (elemClassName.indexOf(className) !== -1) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telement = element.parentNode;\n\t\t}\t\t\n\t},\n\n\tonTrackerMouseOut: function (e) {\n\t\tvar series = this.chart.hoverSeries,\n\t\t\trelatedTarget = e.relatedTarget || e.toElement,\n\t\t\trelatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499\n\t\t\n\t\tif (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&\n\t\t\t\trelatedSeries !== series) {\n\t\t\tseries.onMouseOut();\n\t\t}\n\t},\n\n\tonContainerClick: function (e) {\n\t\tvar chart = this.chart,\n\t\t\thoverPoint = chart.hoverPoint, \n\t\t\tplotLeft = chart.plotLeft,\n\t\t\tplotTop = chart.plotTop;\n\t\t\n\t\te = this.normalize(e);\n\t\te.originalEvent = e; // #3913\n\t\te.cancelBubble = true; // IE specific\n\n\t\tif (!chart.cancelClick) {\n\t\t\t\n\t\t\t// On tracker click, fire the series and point events. #783, #1583\n\t\t\tif (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {\n\n\t\t\t\t// the series click event\n\t\t\t\tfireEvent(hoverPoint.series, 'click', extend(e, {\n\t\t\t\t\tpoint: hoverPoint\n\t\t\t\t}));\n\n\t\t\t\t// the point click event\n\t\t\t\tif (chart.hoverPoint) { // it may be destroyed (#1844)\n\t\t\t\t\thoverPoint.firePointEvent('click', e);\n\t\t\t\t}\n\n\t\t\t// When clicking outside a tracker, fire a chart event\n\t\t\t} else {\n\t\t\t\textend(e, this.getCoordinates(e));\n\n\t\t\t\t// fire a click event in the chart\n\t\t\t\tif (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n\t\t\t\t\tfireEvent(chart, 'click', e);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t},\n\n\t/**\n\t * Set the JS DOM events on the container and document. This method should contain\n\t * a one-to-one assignment between methods and their handlers. Any advanced logic should\n\t * be moved to the handler reflecting the event's name.\n\t */\n\tsetDOMEvents: function () {\n\n\t\tvar pointer = this,\n\t\t\tcontainer = pointer.chart.container;\n\n\t\tcontainer.onmousedown = function (e) {\n\t\t\tpointer.onContainerMouseDown(e);\n\t\t};\n\t\tcontainer.onmousemove = function (e) {\n\t\t\tpointer.onContainerMouseMove(e);\n\t\t};\n\t\tcontainer.onclick = function (e) {\n\t\t\tpointer.onContainerClick(e);\n\t\t};\n\t\taddEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n\t\tif (chartCount === 1) {\n\t\t\taddEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n\t\t}\n\t\tif (hasTouch) {\n\t\t\tcontainer.ontouchstart = function (e) {\n\t\t\t\tpointer.onContainerTouchStart(e);\n\t\t\t};\n\t\t\tcontainer.ontouchmove = function (e) {\n\t\t\t\tpointer.onContainerTouchMove(e);\n\t\t\t};\n\t\t\tif (chartCount === 1) {\n\t\t\t\taddEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n\t\t\t}\n\t\t}\n\t\t\n\t},\n\n\t/**\n\t * Destroys the Pointer object and disconnects DOM events.\n\t */\n\tdestroy: function () {\n\t\tvar prop;\n\n\t\tremoveEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n\t\tif (!chartCount) {\n\t\t\tremoveEvent(doc, 'mouseup', this.onDocumentMouseUp);\n\t\t\tremoveEvent(doc, 'touchend', this.onDocumentTouchEnd);\n\t\t}\n\n\t\t// memory and CPU leak\n\t\tclearInterval(this.tooltipTimeout);\n\n\t\tfor (prop in this) {\n\t\t\tthis[prop] = null;\n\t\t}\n\t}\n};\n\n\n/* Support for touch devices */\nextend(Highcharts.Pointer.prototype, {\n\n\t/**\n\t * Run translation operations\n\t */\n\tpinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n\t\tif (this.zoomHor || this.pinchHor) {\n\t\t\tthis.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\t\t}\n\t\tif (this.zoomVert || this.pinchVert) {\n\t\t\tthis.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\t\t}\n\t},\n\n\t/**\n\t * Run translation operations for each direction (horizontal and vertical) independently\n\t */\n\tpinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n\t\tvar chart = this.chart,\n\t\t\txy = horiz ? 'x' : 'y',\n\t\t\tXY = horiz ? 'X' : 'Y',\n\t\t\tsChartXY = 'chart' + XY,\n\t\t\twh = horiz ? 'width' : 'height',\n\t\t\tplotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n\t\t\tselectionWH,\n\t\t\tselectionXY,\n\t\t\tclipXY,\n\t\t\tscale = forcedScale || 1,\n\t\t\tinverted = chart.inverted,\n\t\t\tbounds = chart.bounds[horiz ? 'h' : 'v'],\n\t\t\tsingleTouch = pinchDown.length === 1,\n\t\t\ttouch0Start = pinchDown[0][sChartXY],\n\t\t\ttouch0Now = touches[0][sChartXY],\n\t\t\ttouch1Start = !singleTouch && pinchDown[1][sChartXY],\n\t\t\ttouch1Now = !singleTouch && touches[1][sChartXY],\n\t\t\toutOfBounds,\n\t\t\ttransformScale,\n\t\t\tscaleKey,\n\t\t\tsetScale = function () {\n\t\t\t\tif (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n\t\t\t\t\tscale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n\t\t\t\tselectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n\t\t\t};\n\n\t\t// Set the scale, first pass\n\t\tsetScale();\n\n\t\tselectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n\t\t// Out of bounds\n\t\tif (selectionXY < bounds.min) {\n\t\t\tselectionXY = bounds.min;\n\t\t\toutOfBounds = true;\n\t\t} else if (selectionXY + selectionWH > bounds.max) {\n\t\t\tselectionXY = bounds.max - selectionWH;\n\t\t\toutOfBounds = true;\n\t\t}\n\t\t\n\t\t// Is the chart dragged off its bounds, determined by dataMin and dataMax?\n\t\tif (outOfBounds) {\n\n\t\t\t// Modify the touchNow position in order to create an elastic drag movement. This indicates\n\t\t\t// to the user that the chart is responsive but can't be dragged further.\n\t\t\ttouch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n\t\t\tif (!singleTouch) {\n\t\t\t\ttouch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n\t\t\t}\n\n\t\t\t// Set the scale, second pass to adapt to the modified touchNow positions\n\t\t\tsetScale();\n\n\t\t} else {\n\t\t\tlastValidTouch[xy] = [touch0Now, touch1Now];\n\t\t}\n\n\t\t// Set geometry for clipping, selection and transformation\n\t\tif (!inverted) { // TODO: implement clipping for inverted charts\n\t\t\tclip[xy] = clipXY - plotLeftTop;\n\t\t\tclip[wh] = selectionWH;\n\t\t}\n\t\tscaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n\t\ttransformScale = inverted ? 1 / scale : scale;\n\n\t\tselectionMarker[wh] = selectionWH;\n\t\tselectionMarker[xy] = selectionXY;\n\t\ttransform[scaleKey] = scale;\n\t\ttransform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n\t},\n\t\n\t/**\n\t * Handle touch events with two touches\n\t */\n\tpinch: function (e) {\n\n\t\tvar self = this,\n\t\t\tchart = self.chart,\n\t\t\tpinchDown = self.pinchDown,\n\t\t\ttouches = e.touches,\n\t\t\ttouchesLength = touches.length,\n\t\t\tlastValidTouch = self.lastValidTouch,\n\t\t\thasZoom = self.hasZoom,\n\t\t\tselectionMarker = self.selectionMarker,\n\t\t\ttransform = {},\n\t\t\tfireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && \n\t\t\t\tchart.runTrackerClick) || self.runChartClick),\n\t\t\tclip = {};\n\n\t\t// On touch devices, only proceed to trigger click if a handler is defined\n\t\tif (hasZoom && !fireClickEvent) {\n\t\t\te.preventDefault();\n\t\t}\n\t\t\n\t\t// Normalize each touch\n\t\tmap(touches, function (e) {\n\t\t\treturn self.normalize(e);\n\t\t});\n\t\t\n\t\t// Register the touch start position\n\t\tif (e.type === 'touchstart') {\n\t\t\teach(touches, function (e, i) {\n\t\t\t\tpinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n\t\t\t});\n\t\t\tlastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n\t\t\tlastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n\t\t\t// Identify the data bounds in pixels\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\tif (axis.zoomEnabled) {\n\t\t\t\t\tvar bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n\t\t\t\t\t\tminPixelPadding = axis.minPixelPadding,\n\t\t\t\t\t\tmin = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n\t\t\t\t\t\tmax = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n\t\t\t\t\t\tabsMin = mathMin(min, max),\n\t\t\t\t\t\tabsMax = mathMax(min, max);\n\n\t\t\t\t\t// Store the bounds for use in the touchmove handler\n\t\t\t\t\tbounds.min = mathMin(axis.pos, absMin - minPixelPadding);\n\t\t\t\t\tbounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);\n\t\t\t\t}\n\t\t\t});\n\t\t\tself.res = true; // reset on next move\n\t\t\n\t\t// Event type is touchmove, handle panning and pinching\n\t\t} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\t\t\t\n\n\t\t\t// Set the marker\n\t\t\tif (!selectionMarker) {\n\t\t\t\tself.selectionMarker = selectionMarker = extend({\n\t\t\t\t\tdestroy: noop\n\t\t\t\t}, chart.plotBox);\n\t\t\t}\n\t\t\t\n\t\t\tself.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n\t\t\tself.hasPinched = hasZoom;\n\n\t\t\t// Scale and translate the groups to provide visual feedback during pinching\n\t\t\tself.scaleGroups(transform, clip);\n\t\t\t\n\t\t\t// Optionally move the tooltip on touchmove\n\t\t\tif (!hasZoom && self.followTouchMove && touchesLength === 1) {\n\t\t\t\tthis.runPointActions(self.normalize(e));\n\t\t\t} else if (self.res) {\n\t\t\t\tself.res = false;\n\t\t\t\tthis.reset(false, 0);\n\t\t\t}\n\t\t}\n\t},\n\n\tonContainerTouchStart: function (e) {\n\t\tvar chart = this.chart;\n\n\t\thoverChartIndex = chart.index;\n\n\t\tif (e.touches.length === 1) {\n\n\t\t\te = this.normalize(e);\n\n\t\t\tif (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n\t\t\t\t// Run mouse events and display tooltip etc\n\t\t\t\tthis.runPointActions(e);\n\n\t\t\t\tthis.pinch(e);\n\n\t\t\t} else {\n\t\t\t\t// Hide the tooltip on touching outside the plot area (#1203)\n\t\t\t\tthis.reset();\n\t\t\t}\n\n\t\t} else if (e.touches.length === 2) {\n\t\t\tthis.pinch(e);\n\t\t}   \n\t},\n\n\tonContainerTouchMove: function (e) {\n\t\tif (e.touches.length === 1 || e.touches.length === 2) {\n\t\t\tthis.pinch(e);\n\t\t}\n\t},\n\n\tonDocumentTouchEnd: function (e) {\n\t\tif (charts[hoverChartIndex]) {\n\t\t\tcharts[hoverChartIndex].pointer.drop(e);\n\t\t}\n\t}\n\n});\nif (win.PointerEvent || win.MSPointerEvent) {\n\t\n\t// The touches object keeps track of the points being touched at all times\n\tvar touches = {},\n\t\thasPointerEvent = !!win.PointerEvent,\n\t\tgetWebkitTouches = function () {\n\t\t\tvar key, fake = [];\n\t\t\tfake.item = function (i) { return this[i]; };\n\t\t\tfor (key in touches) {\n\t\t\t\tif (touches.hasOwnProperty(key)) {\n\t\t\t\t\tfake.push({\n\t\t\t\t\t\tpageX: touches[key].pageX,\n\t\t\t\t\t\tpageY: touches[key].pageY,\n\t\t\t\t\t\ttarget: touches[key].target\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fake;\n\t\t},\n\t\ttranslateMSPointer = function (e, method, wktype, callback) {\n\t\t\tvar p;\n\t\t\te = e.originalEvent || e;\n\t\t\tif ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {\n\t\t\t\tcallback(e);\n\t\t\t\tp = charts[hoverChartIndex].pointer;\n\t\t\t\tp[method]({\n\t\t\t\t\ttype: wktype,\n\t\t\t\t\ttarget: e.currentTarget,\n\t\t\t\t\tpreventDefault: noop,\n\t\t\t\t\ttouches: getWebkitTouches()\n\t\t\t\t});\t\t\t\t\n\t\t\t}\n\t\t};\n\n\t/**\n\t * Extend the Pointer prototype with methods for each event handler and more\n\t */\n\textend(Pointer.prototype, {\n\t\tonContainerPointerDown: function (e) {\n\t\t\ttranslateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n\t\t\t\ttouches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n\t\t\t});\n\t\t},\n\t\tonContainerPointerMove: function (e) {\n\t\t\ttranslateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n\t\t\t\ttouches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n\t\t\t\tif (!touches[e.pointerId].target) {\n\t\t\t\t\ttouches[e.pointerId].target = e.currentTarget;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tonDocumentPointerUp: function (e) {\n\t\t\ttranslateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {\n\t\t\t\tdelete touches[e.pointerId];\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Add or remove the MS Pointer specific events\n\t\t */\n\t\tbatchMSEvents: function (fn) {\n\t\t\tfn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n\t\t\tfn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n\t\t\tfn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n\t\t}\n\t});\n\n\t// Disable default IE actions for pinch and such on chart element\n\twrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n\t\tproceed.call(this, chart, options);\n\t\tif (this.hasZoom || this.followTouchMove) {\n\t\t\tcss(chart.container, {\n\t\t\t\t'-ms-touch-action': NONE,\n\t\t\t\t'touch-action': NONE\n\t\t\t});\n\t\t}\n\t});\n\n\t// Add IE specific touch events to chart\n\twrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n\t\tproceed.apply(this);\n\t\tif (this.hasZoom || this.followTouchMove) {\n\t\t\tthis.batchMSEvents(addEvent);\n\t\t}\n\t});\n\t// Destroy MS events also\n\twrap(Pointer.prototype, 'destroy', function (proceed) {\n\t\tthis.batchMSEvents(removeEvent);\n\t\tproceed.call(this);\n\t});\n}\n/**\n * The overview of the chart's series\n */\nvar Legend = Highcharts.Legend = function (chart, options) {\n\tthis.init(chart, options);\n};\n\nLegend.prototype = {\n\t\n\t/**\n\t * Initialize the legend\n\t */\n\tinit: function (chart, options) {\n\t\t\n\t\tvar legend = this,\n\t\t\titemStyle = options.itemStyle,\n\t\t\tpadding,\n\t\t\titemMarginTop = options.itemMarginTop || 0;\n\t\n\t\tthis.options = options;\n\n\t\tif (!options.enabled) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tlegend.itemStyle = itemStyle;\n\t\tlegend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n\t\tlegend.itemMarginTop = itemMarginTop;\n\t\tlegend.padding = padding = pick(options.padding, 8);\n\t\tlegend.initialItemX = padding;\n\t\tlegend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n\t\tlegend.maxItemWidth = 0;\n\t\tlegend.chart = chart;\n\t\tlegend.itemHeight = 0;\n\t\tlegend.symbolWidth = pick(options.symbolWidth, 16);\n\t\tlegend.pages = [];\n\n\n\t\t// Render it\n\t\tlegend.render();\n\n\t\t// move checkboxes\n\t\taddEvent(legend.chart, 'endResize', function () { \n\t\t\tlegend.positionCheckboxes();\n\t\t});\n\n\t},\n\n\t/**\n\t * Set the colors for the legend item\n\t * @param {Object} item A Series or Point instance\n\t * @param {Object} visible Dimmed or colored\n\t */\n\tcolorizeItem: function (item, visible) {\n\t\tvar legend = this,\n\t\t\toptions = legend.options,\n\t\t\tlegendItem = item.legendItem,\n\t\t\tlegendLine = item.legendLine,\n\t\t\tlegendSymbol = item.legendSymbol,\n\t\t\thiddenColor = legend.itemHiddenStyle.color,\n\t\t\ttextColor = visible ? options.itemStyle.color : hiddenColor,\n\t\t\tsymbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n\t\t\tmarkerOptions = item.options && item.options.marker,\n\t\t\tsymbolAttr = { fill: symbolColor },\n\t\t\tkey,\n\t\t\tval;\n\t\t\n\t\tif (legendItem) {\n\t\t\tlegendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n\t\t}\n\t\tif (legendLine) {\n\t\t\tlegendLine.attr({ stroke: symbolColor });\n\t\t}\n\t\t\n\t\tif (legendSymbol) {\n\t\t\t\n\t\t\t// Apply marker options\n\t\t\tif (markerOptions && legendSymbol.isMarker) { // #585\n\t\t\t\tsymbolAttr.stroke = symbolColor;\n\t\t\t\tmarkerOptions = item.convertAttribs(markerOptions);\n\t\t\t\tfor (key in markerOptions) {\n\t\t\t\t\tval = markerOptions[key];\n\t\t\t\t\tif (val !== UNDEFINED) {\n\t\t\t\t\t\tsymbolAttr[key] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlegendSymbol.attr(symbolAttr);\n\t\t}\n\t},\n\n\t/**\n\t * Position the legend item\n\t * @param {Object} item A Series or Point instance\n\t */\n\tpositionItem: function (item) {\n\t\tvar legend = this,\n\t\t\toptions = legend.options,\n\t\t\tsymbolPadding = options.symbolPadding,\n\t\t\tltr = !options.rtl,\n\t\t\tlegendItemPos = item._legendItemPos,\n\t\t\titemX = legendItemPos[0],\n\t\t\titemY = legendItemPos[1],\n\t\t\tcheckbox = item.checkbox;\n\n\t\tif (item.legendGroup) {\n\t\t\titem.legendGroup.translate(\n\t\t\t\tltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n\t\t\t\titemY\n\t\t\t);\n\t\t}\n\n\t\tif (checkbox) {\n\t\t\tcheckbox.x = itemX;\n\t\t\tcheckbox.y = itemY;\n\t\t}\n\t},\n\n\t/**\n\t * Destroy a single legend item\n\t * @param {Object} item The series or point\n\t */\n\tdestroyItem: function (item) {\n\t\tvar checkbox = item.checkbox;\n\n\t\t// destroy SVG elements\n\t\teach(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n\t\t\tif (item[key]) {\n\t\t\t\titem[key] = item[key].destroy();\n\t\t\t}\n\t\t});\n\n\t\tif (checkbox) {\n\t\t\tdiscardElement(item.checkbox);\n\t\t}\n\t},\n\n\t/**\n\t * Destroy all items.\n\t */\n\tclearItems: function () {\n\t\tvar legend = this;\n\t\teach(legend.getAllItems(), function (item) {\n\t\t\tlegend.destroyItem(item); \n\t\t});\t\t\n\t},\n\n\t/**\n\t * Destroys the legend.\n\t */\n\tdestroy: function () {\n\t\tvar legend = this,\n\t\t\tlegendGroup = legend.group,\n\t\t\tbox = legend.box;\n\n\t\tif (box) {\n\t\t\tlegend.box = box.destroy();\n\t\t}\n\n\t\tif (legendGroup) {\n\t\t\tlegend.group = legendGroup.destroy();\n\t\t}\n\t},\n\n\t/**\n\t * Position the checkboxes after the width is determined\n\t */\n\tpositionCheckboxes: function (scrollOffset) {\n\t\tvar alignAttr = this.group.alignAttr,\n\t\t\ttranslateY,\n\t\t\tclipHeight = this.clipHeight || this.legendHeight;\n\n\t\tif (alignAttr) {\n\t\t\ttranslateY = alignAttr.translateY;\n\t\t\teach(this.allItems, function (item) {\n\t\t\t\tvar checkbox = item.checkbox,\n\t\t\t\t\ttop;\n\t\t\t\t\n\t\t\t\tif (checkbox) {\n\t\t\t\t\ttop = (translateY + checkbox.y + (scrollOffset || 0) + 3);\n\t\t\t\t\tcss(checkbox, {\n\t\t\t\t\t\tleft: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,\n\t\t\t\t\t\ttop: top + PX,\n\t\t\t\t\t\tdisplay: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\t\n\t/**\n\t * Render the legend title on top of the legend\n\t */\n\trenderTitle: function () {\n\t\tvar options = this.options,\n\t\t\tpadding = this.padding,\n\t\t\ttitleOptions = options.title,\n\t\t\ttitleHeight = 0,\n\t\t\tbBox;\n\t\t\n\t\tif (titleOptions.text) {\n\t\t\tif (!this.title) {\n\t\t\t\tthis.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n\t\t\t\t\t.attr({ zIndex: 1 })\n\t\t\t\t\t.css(titleOptions.style)\n\t\t\t\t\t.add(this.group);\n\t\t\t}\n\t\t\tbBox = this.title.getBBox();\n\t\t\ttitleHeight = bBox.height;\n\t\t\tthis.offsetWidth = bBox.width; // #1717\n\t\t\tthis.contentGroup.attr({ translateY: titleHeight });\n\t\t}\n\t\tthis.titleHeight = titleHeight;\n\t},\n\n\t/**\n\t * Render a single specific legend item\n\t * @param {Object} item A series or point\n\t */\n\trenderItem: function (item) {\n\t\tvar legend = this,\n\t\t\tchart = legend.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\toptions = legend.options,\n\t\t\thorizontal = options.layout === 'horizontal',\n\t\t\tsymbolWidth = legend.symbolWidth,\n\t\t\tsymbolPadding = options.symbolPadding,\n\t\t\titemStyle = legend.itemStyle,\n\t\t\titemHiddenStyle = legend.itemHiddenStyle,\n\t\t\tpadding = legend.padding,\n\t\t\titemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n\t\t\tltr = !options.rtl,\n\t\t\titemHeight,\n\t\t\twidthOption = options.width,\n\t\t\titemMarginBottom = options.itemMarginBottom || 0,\n\t\t\titemMarginTop = legend.itemMarginTop,\n\t\t\tinitialItemX = legend.initialItemX,\n\t\t\tbBox,\n\t\t\titemWidth,\n\t\t\tli = item.legendItem,\n\t\t\tseries = item.series && item.series.drawLegendSymbol ? item.series : item,\n\t\t\tseriesOptions = series.options,\n\t\t\tshowCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n\t\t\tuseHTML = options.useHTML;\n\n\t\tif (!li) { // generate it once, later move it\n\n\t\t\t// Generate the group box\n\t\t\t// A group to hold the symbol and text. Text is to be appended in Legend class.\n\t\t\titem.legendGroup = renderer.g('legend-item')\n\t\t\t\t.attr({ zIndex: 1 })\n\t\t\t\t.add(legend.scrollGroup);\n\n\t\t\t// Generate the list item text and add it to the group\n\t\t\titem.legendItem = li = renderer.text(\n\t\t\t\t\toptions.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),\n\t\t\t\t\tltr ? symbolWidth + symbolPadding : -symbolPadding,\n\t\t\t\t\tlegend.baseline || 0,\n\t\t\t\t\tuseHTML\n\t\t\t\t)\n\t\t\t\t.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n\t\t\t\t.attr({\n\t\t\t\t\talign: ltr ? 'left' : 'right',\n\t\t\t\t\tzIndex: 2\n\t\t\t\t})\n\t\t\t\t.add(item.legendGroup);\n\n\t\t\t// Get the baseline for the first item - the font size is equal for all\n\t\t\tif (!legend.baseline) {\n\t\t\t\tlegend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;\n\t\t\t\tli.attr('y', legend.baseline);\n\t\t\t}\n\n\t\t\t// Draw the legend symbol inside the group box\n\t\t\tseries.drawLegendSymbol(legend, item);\n\n\t\t\tif (legend.setItemEvents) {\n\t\t\t\tlegend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);\n\t\t\t}\t\t\t\n\n\t\t\t// Colorize the items\n\t\t\tlegend.colorizeItem(item, item.visible);\n\n\t\t\t// add the HTML checkbox on top\n\t\t\tif (showCheckbox) {\n\t\t\t\tlegend.createCheckboxForItem(item);\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t// calculate the positions for the next line\n\t\tbBox = li.getBBox();\n\n\t\titemWidth = item.checkboxOffset = \n\t\t\toptions.itemWidth || \n\t\t\titem.legendItemWidth || \n\t\t\tsymbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n\t\tlegend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);\n\n\t\t// if the item exceeds the width, start a new line\n\t\tif (horizontal && legend.itemX - initialItemX + itemWidth >\n\t\t\t\t(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n\t\t\tlegend.itemX = initialItemX;\n\t\t\tlegend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n\t\t}\n\n\t\t// If the item exceeds the height, start a new column\n\t\t/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n\t\t\tlegend.itemY = legend.initialItemY;\n\t\t\tlegend.itemX += legend.maxItemWidth;\n\t\t\tlegend.maxItemWidth = 0;\n\t\t}*/\n\n\t\t// Set the edge positions\n\t\tlegend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n\t\tlegend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n\t\tlegend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n\t\t// cache the position of the newly generated or reordered items\n\t\titem._legendItemPos = [legend.itemX, legend.itemY];\n\n\t\t// advance\n\t\tif (horizontal) {\n\t\t\tlegend.itemX += itemWidth;\n\n\t\t} else {\n\t\t\tlegend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n\t\t\tlegend.lastLineHeight = itemHeight;\n\t\t}\n\n\t\t// the width of the widest item\n\t\tlegend.offsetWidth = widthOption || mathMax(\n\t\t\t(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n\t\t\tlegend.offsetWidth\n\t\t);\n\t},\n\n\t/**\n\t * Get all items, which is one item per series for normal series and one item per point\n\t * for pie series.\n\t */\n\tgetAllItems: function () {\n\t\tvar allItems = [];\n\t\teach(this.chart.series, function (series) {\n\t\t\tvar seriesOptions = series.options;\n\n\t\t\t// Handle showInLegend. If the series is linked to another series, defaults to false.\n\t\t\tif (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// use points or series for the legend item depending on legendType\n\t\t\tallItems = allItems.concat(\n\t\t\t\t\tseries.legendItems ||\n\t\t\t\t\t(seriesOptions.legendType === 'point' ?\n\t\t\t\t\t\t\tseries.data :\n\t\t\t\t\t\t\tseries)\n\t\t\t);\n\t\t});\n\t\treturn allItems;\n\t},\n\n\t/**\n\t * Adjust the chart margins by reserving space for the legend on only one side\n\t * of the chart. If the position is set to a corner, top or bottom is reserved\n\t * for horizontal legends and left or right for vertical ones.\n\t */\n\tadjustMargins: function (margin, spacing) {\n\t\tvar chart = this.chart, \n\t\t\toptions = this.options,\n\t\t\t// Use the first letter of each alignment option in order to detect the side \n\t\t\talignment = options.align[0] + options.verticalAlign[0] + options.layout[0];\n\t\t\t\n\t\tif (this.display && !options.floating) {\n\n\t\t\teach([\n\t\t\t\t/(lth|ct|rth)/,\n\t\t\t\t/(rtv|rm|rbv)/,\n\t\t\t\t/(rbh|cb|lbh)/,\n\t\t\t\t/(lbv|lm|ltv)/\n\t\t\t], function (alignments, side) {\n\t\t\t\tif (alignments.test(alignment) && !defined(margin[side])) {\n\t\t\t\t\t// Now we have detected on which side of the chart we should reserve space for the legend\n\t\t\t\t\tchart[marginNames[side]] = mathMax(\n\t\t\t\t\t\tchart[marginNames[side]],\n\t\t\t\t\t\tchart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + \n\t\t\t\t\t\t\t[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + \n\t\t\t\t\t\t\tpick(options.margin, 12) +\n\t\t\t\t\t\t\tspacing[side]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Render the legend. This method can be called both before and after\n\t * chart.render. If called after, it will only rearrange items instead\n\t * of creating new ones.\n\t */\n\trender: function () {\n\t\tvar legend = this,\n\t\t\tchart = legend.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tlegendGroup = legend.group,\n\t\t\tallItems,\n\t\t\tdisplay,\n\t\t\tlegendWidth,\n\t\t\tlegendHeight,\n\t\t\tbox = legend.box,\n\t\t\toptions = legend.options,\n\t\t\tpadding = legend.padding,\n\t\t\tlegendBorderWidth = options.borderWidth,\n\t\t\tlegendBackgroundColor = options.backgroundColor;\n\n\t\tlegend.itemX = legend.initialItemX;\n\t\tlegend.itemY = legend.initialItemY;\n\t\tlegend.offsetWidth = 0;\n\t\tlegend.lastItemY = 0;\n\n\t\tif (!legendGroup) {\n\t\t\tlegend.group = legendGroup = renderer.g('legend')\n\t\t\t\t.attr({ zIndex: 7 }) \n\t\t\t\t.add();\n\t\t\tlegend.contentGroup = renderer.g()\n\t\t\t\t.attr({ zIndex: 1 }) // above background\n\t\t\t\t.add(legendGroup);\n\t\t\tlegend.scrollGroup = renderer.g()\n\t\t\t\t.add(legend.contentGroup);\n\t\t}\n\t\t\n\t\tlegend.renderTitle();\n\n\t\t// add each series or point\n\t\tallItems = legend.getAllItems();\n\n\t\t// sort by legendIndex\n\t\tstableSort(allItems, function (a, b) {\n\t\t\treturn ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n\t\t});\n\n\t\t// reversed legend\n\t\tif (options.reversed) {\n\t\t\tallItems.reverse();\n\t\t}\n\n\t\tlegend.allItems = allItems;\n\t\tlegend.display = display = !!allItems.length;\n\n\t\t// render the items\n\t\tlegend.lastLineHeight = 0;\n\t\teach(allItems, function (item) {\n\t\t\tlegend.renderItem(item); \n\t\t});\n\n\t\t// Get the box\n\t\tlegendWidth = (options.width || legend.offsetWidth) + padding;\n\t\tlegendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n\t\tlegendHeight = legend.handleOverflow(legendHeight);\n\t\tlegendHeight += padding;\n\n\t\t// Draw the border and/or background\n\t\tif (legendBorderWidth || legendBackgroundColor) {\n\n\t\t\tif (!box) {\n\t\t\t\tlegend.box = box = renderer.rect(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlegendWidth,\n\t\t\t\t\tlegendHeight,\n\t\t\t\t\toptions.borderRadius,\n\t\t\t\t\tlegendBorderWidth || 0\n\t\t\t\t).attr({\n\t\t\t\t\tstroke: options.borderColor,\n\t\t\t\t\t'stroke-width': legendBorderWidth || 0,\n\t\t\t\t\tfill: legendBackgroundColor || NONE\n\t\t\t\t})\n\t\t\t\t.add(legendGroup)\n\t\t\t\t.shadow(options.shadow);\n\t\t\t\tbox.isNew = true;\n\n\t\t\t} else if (legendWidth > 0 && legendHeight > 0) {\n\t\t\t\tbox[box.isNew ? 'attr' : 'animate'](\n\t\t\t\t\tbox.crisp({ width: legendWidth, height: legendHeight })\n\t\t\t\t);\n\t\t\t\tbox.isNew = false;\n\t\t\t}\n\n\t\t\t// hide the border if no items\n\t\t\tbox[display ? 'show' : 'hide']();\n\t\t}\n\t\t\n\t\tlegend.legendWidth = legendWidth;\n\t\tlegend.legendHeight = legendHeight;\n\n\t\t// Now that the legend width and height are established, put the items in the \n\t\t// final position\n\t\teach(allItems, function (item) {\n\t\t\tlegend.positionItem(item);\n\t\t});\n\n\t\t// 1.x compatibility: positioning based on style\n\t\t/*var props = ['left', 'right', 'top', 'bottom'],\n\t\t\tprop,\n\t\t\ti = 4;\n\t\twhile (i--) {\n\t\t\tprop = props[i];\n\t\t\tif (options.style[prop] && options.style[prop] !== 'auto') {\n\t\t\t\toptions[i < 2 ? 'align' : 'verticalAlign'] = prop;\n\t\t\t\toptions[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n\t\t\t}\n\t\t}*/\n\n\t\tif (display) {\n\t\t\tlegendGroup.align(extend({\n\t\t\t\twidth: legendWidth,\n\t\t\t\theight: legendHeight\n\t\t\t}, options), true, 'spacingBox');\n\t\t}\n\n\t\tif (!chart.isResizing) {\n\t\t\tthis.positionCheckboxes();\n\t\t}\n\t},\n\t\n\t/**\n\t * Set up the overflow handling by adding navigation with up and down arrows below the\n\t * legend.\n\t */\n\thandleOverflow: function (legendHeight) {\n\t\tvar legend = this,\n\t\t\tchart = this.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\toptions = this.options,\n\t\t\toptionsY = options.y,\n\t\t\talignTop = options.verticalAlign === 'top',\n\t\t\tspaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n\t\t\tmaxHeight = options.maxHeight,\n\t\t\tclipHeight,\n\t\t\tclipRect = this.clipRect,\n\t\t\tnavOptions = options.navigation,\n\t\t\tanimation = pick(navOptions.animation, true),\n\t\t\tarrowSize = navOptions.arrowSize || 12,\n\t\t\tnav = this.nav,\n\t\t\tpages = this.pages,\n\t\t\tlastY,\n\t\t\tallItems = this.allItems;\n\t\t\t\n\t\t// Adjust the height\n\t\tif (options.layout === 'horizontal') {\n\t\t\tspaceHeight /= 2;\n\t\t}\n\t\tif (maxHeight) {\n\t\t\tspaceHeight = mathMin(spaceHeight, maxHeight);\n\t\t}\n\t\t\n\t\t// Reset the legend height and adjust the clipping rectangle\n\t\tpages.length = 0;\n\t\tif (legendHeight > spaceHeight && !options.useHTML) {\n\n\t\t\tthis.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);\n\t\t\tthis.currentPage = pick(this.currentPage, 1);\n\t\t\tthis.fullHeight = legendHeight;\n\t\t\t\n\t\t\t// Fill pages with Y positions so that the top of each a legend item defines\n\t\t\t// the scroll top for each page (#2098)\n\t\t\teach(allItems, function (item, i) {\n\t\t\t\tvar y = item._legendItemPos[1],\n\t\t\t\t\th = mathRound(item.legendItem.getBBox().height),\n\t\t\t\t\tlen = pages.length;\n\t\t\t\t\n\t\t\t\tif (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n\t\t\t\t\tpages.push(lastY || y);\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n\t\t\t\t\tpages.push(y);\n\t\t\t\t}\n\t\t\t\tif (y !== lastY) {\n\t\t\t\t\tlastY = y;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n\t\t\tif (!clipRect) {\n\t\t\t\tclipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);\n\t\t\t\tlegend.contentGroup.clip(clipRect);\n\t\t\t}\n\t\t\tclipRect.attr({\n\t\t\t\theight: clipHeight\n\t\t\t});\n\t\t\t\n\t\t\t// Add navigation elements\n\t\t\tif (!nav) {\n\t\t\t\tthis.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n\t\t\t\tthis.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n\t\t\t\t\t.on('click', function () {\n\t\t\t\t\t\tlegend.scroll(-1, animation);\n\t\t\t\t\t})\n\t\t\t\t\t.add(nav);\n\t\t\t\tthis.pager = renderer.text('', 15, 10)\n\t\t\t\t\t.css(navOptions.style)\n\t\t\t\t\t.add(nav);\n\t\t\t\tthis.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n\t\t\t\t\t.on('click', function () {\n\t\t\t\t\t\tlegend.scroll(1, animation);\n\t\t\t\t\t})\n\t\t\t\t\t.add(nav);\n\t\t\t}\n\t\t\t\n\t\t\t// Set initial position\n\t\t\tlegend.scroll(0);\n\t\t\t\n\t\t\tlegendHeight = spaceHeight;\n\t\t\t\n\t\t} else if (nav) {\n\t\t\tclipRect.attr({\n\t\t\t\theight: chart.chartHeight\n\t\t\t});\n\t\t\tnav.hide();\n\t\t\tthis.scrollGroup.attr({\n\t\t\t\ttranslateY: 1\n\t\t\t});\n\t\t\tthis.clipHeight = 0; // #1379\n\t\t}\n\t\t\n\t\treturn legendHeight;\n\t},\n\t\n\t/**\n\t * Scroll the legend by a number of pages\n\t * @param {Object} scrollBy\n\t * @param {Object} animation\n\t */\n\tscroll: function (scrollBy, animation) {\n\t\tvar pages = this.pages,\n\t\t\tpageCount = pages.length,\n\t\t\tcurrentPage = this.currentPage + scrollBy,\n\t\t\tclipHeight = this.clipHeight,\n\t\t\tnavOptions = this.options.navigation,\n\t\t\tactiveColor = navOptions.activeColor,\n\t\t\tinactiveColor = navOptions.inactiveColor,\n\t\t\tpager = this.pager,\n\t\t\tpadding = this.padding,\n\t\t\tscrollOffset;\n\t\t\n\t\t// When resizing while looking at the last page\n\t\tif (currentPage > pageCount) {\n\t\t\tcurrentPage = pageCount;\n\t\t}\n\t\t\n\t\tif (currentPage > 0) {\n\t\t\t\n\t\t\tif (animation !== UNDEFINED) {\n\t\t\t\tsetAnimation(animation, this.chart);\n\t\t\t}\n\t\t\t\n\t\t\tthis.nav.attr({\n\t\t\t\ttranslateX: padding,\n\t\t\t\ttranslateY: clipHeight + this.padding + 7 + this.titleHeight,\n\t\t\t\tvisibility: VISIBLE\n\t\t\t});\n\t\t\tthis.up.attr({\n\t\t\t\t\tfill: currentPage === 1 ? inactiveColor : activeColor\n\t\t\t\t})\n\t\t\t\t.css({\n\t\t\t\t\tcursor: currentPage === 1 ? 'default' : 'pointer'\n\t\t\t\t});\n\t\t\tpager.attr({\n\t\t\t\ttext: currentPage + '/' + pageCount\n\t\t\t});\n\t\t\tthis.down.attr({\n\t\t\t\t\tx: 18 + this.pager.getBBox().width, // adjust to text width\n\t\t\t\t\tfill: currentPage === pageCount ? inactiveColor : activeColor\n\t\t\t\t})\n\t\t\t\t.css({\n\t\t\t\t\tcursor: currentPage === pageCount ? 'default' : 'pointer'\n\t\t\t\t});\n\t\t\t\n\t\t\tscrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n\t\t\tthis.scrollGroup.animate({\n\t\t\t\ttranslateY: scrollOffset\n\t\t\t});\t\t\t\n\t\t\t\n\t\t\tthis.currentPage = currentPage;\n\t\t\tthis.positionCheckboxes(scrollOffset);\n\t\t}\n\t\t\t\n\t}\n\t\n};\n\n/*\n * LegendSymbolMixin\n */ \n\nvar LegendSymbolMixin = Highcharts.LegendSymbolMixin = {\n\n\t/**\n\t * Get the series' symbol in the legend\n\t * \n\t * @param {Object} legend The legend object\n\t * @param {Object} item The series (this) or point\n\t */\n\tdrawRectangle: function (legend, item) {\n\t\tvar symbolHeight = legend.options.symbolHeight || 12;\n\t\t\n\t\titem.legendSymbol = this.chart.renderer.rect(\n\t\t\t0,\n\t\t\tlegend.baseline - 5 - (symbolHeight / 2),\n\t\t\tlegend.symbolWidth,\n\t\t\tsymbolHeight,\n\t\t\tlegend.options.symbolRadius || 0\n\t\t).attr({\n\t\t\tzIndex: 3\n\t\t}).add(item.legendGroup);\t\t\n\t\t\n\t},\n\n\t/**\n\t * Get the series' symbol in the legend. This method should be overridable to create custom \n\t * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n\t * \n\t * @param {Object} legend The legend object\n\t */\n\tdrawLineMarker: function (legend) {\n\n\t\tvar options = this.options,\n\t\t\tmarkerOptions = options.marker,\n\t\t\tradius,\n\t\t\tlegendOptions = legend.options,\n\t\t\tlegendSymbol,\n\t\t\tsymbolWidth = legend.symbolWidth,\n\t\t\trenderer = this.chart.renderer,\n\t\t\tlegendItemGroup = this.legendGroup,\n\t\t\tverticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),\n\t\t\tattr;\n\n\t\t// Draw the line\n\t\tif (options.lineWidth) {\n\t\t\tattr = {\n\t\t\t\t'stroke-width': options.lineWidth\n\t\t\t};\n\t\t\tif (options.dashStyle) {\n\t\t\t\tattr.dashstyle = options.dashStyle;\n\t\t\t}\n\t\t\tthis.legendLine = renderer.path([\n\t\t\t\tM,\n\t\t\t\t0,\n\t\t\t\tverticalCenter,\n\t\t\t\tL,\n\t\t\t\tsymbolWidth,\n\t\t\t\tverticalCenter\n\t\t\t])\n\t\t\t.attr(attr)\n\t\t\t.add(legendItemGroup);\n\t\t}\n\t\t\n\t\t// Draw the marker\n\t\tif (markerOptions && markerOptions.enabled !== false) {\n\t\t\tradius = markerOptions.radius;\n\t\t\tthis.legendSymbol = legendSymbol = renderer.symbol(\n\t\t\t\tthis.symbol,\n\t\t\t\t(symbolWidth / 2) - radius,\n\t\t\t\tverticalCenter - radius,\n\t\t\t\t2 * radius,\n\t\t\t\t2 * radius\n\t\t\t)\n\t\t\t.add(legendItemGroup);\n\t\t\tlegendSymbol.isMarker = true;\n\t\t}\n\t}\n};\n\n// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n// and for #2580, a similar drawing flaw in Firefox 26.\n// TODO: Explore if there's a general cause for this. The problem may be related \n// to nested group elements, as the legend item texts are within 4 group elements.\nif (/Trident\\/7\\.0/.test(userAgent) || isFirefox) {\n\twrap(Legend.prototype, 'positionItem', function (proceed, item) {\n\t\tvar legend = this,\n\t\t\trunPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n\t\t\t\tif (item._legendItemPos) {\n\t\t\t\t\tproceed.call(legend, item);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Do it now, for export and to get checkbox placement\n\t\trunPositionItem();\n\t\t\n\t\t// Do it after to work around the core issue\n\t\tsetTimeout(runPositionItem);\n\t});\n}\n/**\n * The chart class\n * @param {Object} options\n * @param {Function} callback Function to run when the chart has loaded\n */\nvar Chart = Highcharts.Chart = function () {\n\tthis.init.apply(this, arguments);\n};\n\nChart.prototype = {\n\n\t/**\n\t * Hook for modules\n\t */\n\tcallbacks: [],\n\n\t/**\n\t * Initialize the chart\n\t */\n\tinit: function (userOptions, callback) {\n\n\t\t// Handle regular options\n\t\tvar options,\n\t\t\tseriesOptions = userOptions.series; // skip merging data points to increase performance\n\n\t\tuserOptions.series = null;\n\t\toptions = merge(defaultOptions, userOptions); // do the merge\n\t\toptions.series = userOptions.series = seriesOptions; // set back the series data\n\t\tthis.userOptions = userOptions;\n\n\t\tvar optionsChart = options.chart;\n\t\t\n\t\t// Create margin & spacing array\n\t\tthis.margin = this.splashArray('margin', optionsChart);\n\t\tthis.spacing = this.splashArray('spacing', optionsChart);\n\n\t\tvar chartEvents = optionsChart.events;\n\n\t\t//this.runChartClick = chartEvents && !!chartEvents.click;\n\t\tthis.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n\t\tthis.callback = callback;\n\t\tthis.isResizing = 0;\n\t\tthis.options = options;\n\t\t//chartTitleOptions = UNDEFINED;\n\t\t//chartSubtitleOptions = UNDEFINED;\n\n\t\tthis.axes = [];\n\t\tthis.series = [];\n\t\tthis.hasCartesianSeries = optionsChart.showAxes;\n\t\t//this.axisOffset = UNDEFINED;\n\t\t//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n\t\t//this.inverted = UNDEFINED;\n\t\t//this.loadingShown = UNDEFINED;\n\t\t//this.container = UNDEFINED;\n\t\t//this.chartWidth = UNDEFINED;\n\t\t//this.chartHeight = UNDEFINED;\n\t\t//this.marginRight = UNDEFINED;\n\t\t//this.marginBottom = UNDEFINED;\n\t\t//this.containerWidth = UNDEFINED;\n\t\t//this.containerHeight = UNDEFINED;\n\t\t//this.oldChartWidth = UNDEFINED;\n\t\t//this.oldChartHeight = UNDEFINED;\n\n\t\t//this.renderTo = UNDEFINED;\n\t\t//this.renderToClone = UNDEFINED;\n\n\t\t//this.spacingBox = UNDEFINED\n\n\t\t//this.legend = UNDEFINED;\n\n\t\t// Elements\n\t\t//this.chartBackground = UNDEFINED;\n\t\t//this.plotBackground = UNDEFINED;\n\t\t//this.plotBGImage = UNDEFINED;\n\t\t//this.plotBorder = UNDEFINED;\n\t\t//this.loadingDiv = UNDEFINED;\n\t\t//this.loadingSpan = UNDEFINED;\n\n\t\tvar chart = this,\n\t\t\teventType;\n\n\t\t// Add the chart to the global lookup\n\t\tchart.index = charts.length;\n\t\tcharts.push(chart);\n\t\tchartCount++;\n\n\t\t// Set up auto resize\n\t\tif (optionsChart.reflow !== false) {\n\t\t\taddEvent(chart, 'load', function () {\n\t\t\t\tchart.initReflow();\n\t\t\t});\n\t\t}\n\n\t\t// Chart event handlers\n\t\tif (chartEvents) {\n\t\t\tfor (eventType in chartEvents) {\n\t\t\t\taddEvent(chart, eventType, chartEvents[eventType]);\n\t\t\t}\n\t\t}\n\n\t\tchart.xAxis = [];\n\t\tchart.yAxis = [];\n\n\t\t// Expose methods and variables\n\t\tchart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n\t\tchart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n\t\tchart.firstRender();\n\t},\n\n\t/**\n\t * Initialize an individual series, called internally before render time\n\t */\n\tinitSeries: function (options) {\n\t\tvar chart = this,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\ttype = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n\t\t\tseries,\n\t\t\tconstr = seriesTypes[type];\n\n\t\t// No such series type\n\t\tif (!constr) {\n\t\t\terror(17, true);\n\t\t}\n\n\t\tseries = new constr();\n\t\tseries.init(this, options);\n\t\treturn series;\n\t},\n\n\t/**\n\t * Check whether a given point is within the plot area\n\t *\n\t * @param {Number} plotX Pixel x relative to the plot area\n\t * @param {Number} plotY Pixel y relative to the plot area\n\t * @param {Boolean} inverted Whether the chart is inverted\n\t */\n\tisInsidePlot: function (plotX, plotY, inverted) {\n\t\tvar x = inverted ? plotY : plotX,\n\t\t\ty = inverted ? plotX : plotY;\n\t\t\t\n\t\treturn x >= 0 &&\n\t\t\tx <= this.plotWidth &&\n\t\t\ty >= 0 &&\n\t\t\ty <= this.plotHeight;\n\t},\n\n\t/**\n\t * Redraw legend, axes or series based on updated data\n\t *\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t */\n\tredraw: function (animation) {\n\t\tvar chart = this,\n\t\t\taxes = chart.axes,\n\t\t\tseries = chart.series,\n\t\t\tpointer = chart.pointer,\n\t\t\tlegend = chart.legend,\n\t\t\tredrawLegend = chart.isDirtyLegend,\n\t\t\thasStackedSeries,\n\t\t\thasDirtyStacks,\n\t\t\thasCartesianSeries = chart.hasCartesianSeries,\n\t\t\tisDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?\n\t\t\tseriesLength = series.length,\n\t\t\ti = seriesLength,\n\t\t\tserie,\n\t\t\trenderer = chart.renderer,\n\t\t\tisHiddenChart = renderer.isHidden(),\n\t\t\tafterRedraw = [];\n\t\t\t\n\t\tsetAnimation(animation, chart);\n\t\t\n\t\tif (isHiddenChart) {\n\t\t\tchart.cloneRenderTo();\n\t\t}\n\n\t\t// Adjust title layout (reflow multiline text)\n\t\tchart.layOutTitles();\n\n\t\t// link stacked series\n\t\twhile (i--) {\n\t\t\tserie = series[i];\n\n\t\t\tif (serie.options.stacking) {\n\t\t\t\thasStackedSeries = true;\n\t\t\t\t\n\t\t\t\tif (serie.isDirty) {\n\t\t\t\t\thasDirtyStacks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasDirtyStacks) { // mark others as dirty\n\t\t\ti = seriesLength;\n\t\t\twhile (i--) {\n\t\t\t\tserie = series[i];\n\t\t\t\tif (serie.options.stacking) {\n\t\t\t\t\tserie.isDirty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// handle updated data in the series\n\t\teach(series, function (serie) {\n\t\t\tif (serie.isDirty) { // prepare the data so axis can read it\n\t\t\t\tif (serie.options.legendType === 'point') {\n\t\t\t\t\tredrawLegend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// handle added or removed series\n\t\tif (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n\t\t\t// draw legend graphics\n\t\t\tlegend.render();\n\n\t\t\tchart.isDirtyLegend = false;\n\t\t}\n\n\t\t// reset stacks\n\t\tif (hasStackedSeries) {\n\t\t\tchart.getStacks();\n\t\t}\n\n\n\t\tif (hasCartesianSeries) {\n\t\t\tif (!chart.isResizing) {\n\n\t\t\t\t// reset maxTicks\n\t\t\t\tchart.maxTicks = null;\n\n\t\t\t\t// set axes scales\n\t\t\t\teach(axes, function (axis) {\n\t\t\t\t\taxis.setScale();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tchart.getMargins(); // #3098\n\n\t\tif (hasCartesianSeries) {\n\t\t\t// If one axis is dirty, all axes must be redrawn (#792, #2169)\n\t\t\teach(axes, function (axis) {\n\t\t\t\tif (axis.isDirty) {\n\t\t\t\t\tisDirtyBox = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// redraw axes\n\t\t\teach(axes, function (axis) {\n\t\t\t\t\n\t\t\t\t// Fire 'afterSetExtremes' only if extremes are set\n\t\t\t\tif (axis.isDirtyExtremes) { // #821\n\t\t\t\t\taxis.isDirtyExtremes = false;\n\t\t\t\t\tafterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n\t\t\t\t\t\tfireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n\t\t\t\t\t\tdelete axis.eventArgs;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isDirtyBox || hasStackedSeries) {\n\t\t\t\t\taxis.redraw();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\t// the plot areas size has changed\n\t\tif (isDirtyBox) {\n\t\t\tchart.drawChartBox();\n\t\t}\n\n\n\t\t// redraw affected series\n\t\teach(series, function (serie) {\n\t\t\tif (serie.isDirty && serie.visible &&\n\t\t\t\t\t(!serie.isCartesian || serie.xAxis)) { // issue #153\n\t\t\t\tserie.redraw();\n\t\t\t}\n\t\t});\n\n\t\t// move tooltip or reset\n\t\tif (pointer) {\n\t\t\tpointer.reset(true);\n\t\t}\n\n\t\t// redraw if canvas\n\t\trenderer.draw();\n\n\t\t// fire the event\n\t\tfireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw\n\t\t\n\t\tif (isHiddenChart) {\n\t\t\tchart.cloneRenderTo(true);\n\t\t}\n\t\t\n\t\t// Fire callbacks that are put on hold until after the redraw\n\t\teach(afterRedraw, function (callback) {\n\t\t\tcallback.call();\n\t\t});\n\t},\n\n\t/**\n\t * Get an axis, series or point object by id.\n\t * @param id {String} The id as given in the configuration options\n\t */\n\tget: function (id) {\n\t\tvar chart = this,\n\t\t\taxes = chart.axes,\n\t\t\tseries = chart.series;\n\n\t\tvar i,\n\t\t\tj,\n\t\t\tpoints;\n\n\t\t// search axes\n\t\tfor (i = 0; i < axes.length; i++) {\n\t\t\tif (axes[i].options.id === id) {\n\t\t\t\treturn axes[i];\n\t\t\t}\n\t\t}\n\n\t\t// search series\n\t\tfor (i = 0; i < series.length; i++) {\n\t\t\tif (series[i].options.id === id) {\n\t\t\t\treturn series[i];\n\t\t\t}\n\t\t}\n\n\t\t// search points\n\t\tfor (i = 0; i < series.length; i++) {\n\t\t\tpoints = series[i].points || [];\n\t\t\tfor (j = 0; j < points.length; j++) {\n\t\t\t\tif (points[j].id === id) {\n\t\t\t\t\treturn points[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\t/**\n\t * Create the Axis instances based on the config options\n\t */\n\tgetAxes: function () {\n\t\tvar chart = this,\n\t\t\toptions = this.options,\n\t\t\txAxisOptions = options.xAxis = splat(options.xAxis || {}),\n\t\t\tyAxisOptions = options.yAxis = splat(options.yAxis || {}),\n\t\t\toptionsArray,\n\t\t\taxis;\n\n\t\t// make sure the options are arrays and add some members\n\t\teach(xAxisOptions, function (axis, i) {\n\t\t\taxis.index = i;\n\t\t\taxis.isX = true;\n\t\t});\n\n\t\teach(yAxisOptions, function (axis, i) {\n\t\t\taxis.index = i;\n\t\t});\n\n\t\t// concatenate all axis options into one array\n\t\toptionsArray = xAxisOptions.concat(yAxisOptions);\n\n\t\teach(optionsArray, function (axisOptions) {\n\t\t\taxis = new Axis(chart, axisOptions);\n\t\t});\n\t},\n\n\n\t/**\n\t * Get the currently selected points from all series\n\t */\n\tgetSelectedPoints: function () {\n\t\tvar points = [];\n\t\teach(this.series, function (serie) {\n\t\t\tpoints = points.concat(grep(serie.points || [], function (point) {\n\t\t\t\treturn point.selected;\n\t\t\t}));\n\t\t});\n\t\treturn points;\n\t},\n\n\t/**\n\t * Get the currently selected series\n\t */\n\tgetSelectedSeries: function () {\n\t\treturn grep(this.series, function (serie) {\n\t\t\treturn serie.selected;\n\t\t});\n\t},\n\n\t/**\n\t * Generate stacks for each series and calculate stacks total values\n\t */\n\tgetStacks: function () {\n\t\tvar chart = this;\n\n\t\t// reset stacks for each yAxis\n\t\teach(chart.yAxis, function (axis) {\n\t\t\tif (axis.stacks && axis.hasVisibleSeries) {\n\t\t\t\taxis.oldStacks = axis.stacks;\n\t\t\t}\n\t\t});\n\n\t\teach(chart.series, function (series) {\n\t\t\tif (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n\t\t\t\tseries.stackKey = series.type + pick(series.options.stack, '');\n\t\t\t}\n\t\t});\n\t},\t\n\n\t/**\n\t * Show the title and subtitle of the chart\n\t *\n\t * @param titleOptions {Object} New title options\n\t * @param subtitleOptions {Object} New subtitle options\n\t *\n\t */\n\tsetTitle: function (titleOptions, subtitleOptions, redraw) {\n\t\tvar chart = this,\n\t\t\toptions = chart.options,\n\t\t\tchartTitleOptions,\n\t\t\tchartSubtitleOptions;\n\n\t\tchartTitleOptions = options.title = merge(options.title, titleOptions);\n\t\tchartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n\t\t// add title and subtitle\n\t\teach([\n\t\t\t['title', titleOptions, chartTitleOptions],\n\t\t\t['subtitle', subtitleOptions, chartSubtitleOptions]\n\t\t], function (arr) {\n\t\t\tvar name = arr[0],\n\t\t\t\ttitle = chart[name],\n\t\t\t\ttitleOptions = arr[1],\n\t\t\t\tchartTitleOptions = arr[2];\n\n\t\t\tif (title && titleOptions) {\n\t\t\t\tchart[name] = title = title.destroy(); // remove old\n\t\t\t}\n\t\t\t\n\t\t\tif (chartTitleOptions && chartTitleOptions.text && !title) {\n\t\t\t\tchart[name] = chart.renderer.text(\n\t\t\t\t\tchartTitleOptions.text,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tchartTitleOptions.useHTML\n\t\t\t\t)\n\t\t\t\t.attr({\n\t\t\t\t\talign: chartTitleOptions.align,\n\t\t\t\t\t'class': PREFIX + name,\n\t\t\t\t\tzIndex: chartTitleOptions.zIndex || 4\n\t\t\t\t})\n\t\t\t\t.css(chartTitleOptions.style)\n\t\t\t\t.add();\n\t\t\t}\t\n\t\t});\n\t\tchart.layOutTitles(redraw);\n\t},\n\n\t/**\n\t * Lay out the chart titles and cache the full offset height for use in getMargins\n\t */\n\tlayOutTitles: function (redraw) {\n\t\tvar titleOffset = 0,\n\t\t\ttitle = this.title,\n\t\t\tsubtitle = this.subtitle,\n\t\t\toptions = this.options,\n\t\t\ttitleOptions = options.title,\n\t\t\tsubtitleOptions = options.subtitle,\n\t\t\trequiresDirtyBox,\n\t\t\trenderer = this.renderer,\n\t\t\tautoWidth = this.spacingBox.width - 44; // 44 makes room for default context button\n\n\t\tif (title) {\n\t\t\ttitle\n\t\t\t\t.css({ width: (titleOptions.width || autoWidth) + PX })\n\t\t\t\t.align(extend({ \n\t\t\t\t\ty: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3\n\t\t\t\t}, titleOptions), false, 'spacingBox');\n\t\t\t\n\t\t\tif (!titleOptions.floating && !titleOptions.verticalAlign) {\n\t\t\t\ttitleOffset = title.getBBox().height;\n\t\t\t}\n\t\t}\n\t\tif (subtitle) {\n\t\t\tsubtitle\n\t\t\t\t.css({ width: (subtitleOptions.width || autoWidth) + PX })\n\t\t\t\t.align(extend({ \n\t\t\t\t\ty: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b \n\t\t\t\t}, subtitleOptions), false, 'spacingBox');\n\t\t\t\n\t\t\tif (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n\t\t\t\ttitleOffset = mathCeil(titleOffset + subtitle.getBBox().height);\n\t\t\t}\n\t\t}\n\n\t\trequiresDirtyBox = this.titleOffset !== titleOffset;\t\t\t\t\n\t\tthis.titleOffset = titleOffset; // used in getMargins\n\n\t\tif (!this.isDirtyBox && requiresDirtyBox) {\n\t\t\tthis.isDirtyBox = requiresDirtyBox;\n\t\t\t// Redraw if necessary (#2719, #2744)\t\t\n\t\t\tif (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n\t\t\t\tthis.redraw();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get chart width and height according to options and container size\n\t */\n\tgetChartSize: function () {\n\t\tvar chart = this,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\twidthOption = optionsChart.width,\n\t\t\theightOption = optionsChart.height,\n\t\t\trenderTo = chart.renderToClone || chart.renderTo;\n\n\t\t// get inner width and height from jQuery (#824)\n\t\tif (!defined(widthOption)) {\n\t\t\tchart.containerWidth = adapterRun(renderTo, 'width');\n\t\t}\n\t\tif (!defined(heightOption)) {\n\t\t\tchart.containerHeight = adapterRun(renderTo, 'height');\n\t\t}\n\t\t\n\t\tchart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n\t\tchart.chartHeight = mathMax(0, pick(heightOption,\n\t\t\t// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n\t\t\tchart.containerHeight > 19 ? chart.containerHeight : 400));\n\t},\n\n\t/**\n\t * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n\t * size computation on chart.render and chart.redraw\n\t */\n\tcloneRenderTo: function (revert) {\n\t\tvar clone = this.renderToClone,\n\t\t\tcontainer = this.container;\n\t\t\n\t\t// Destroy the clone and bring the container back to the real renderTo div\n\t\tif (revert) {\n\t\t\tif (clone) {\n\t\t\t\tthis.renderTo.appendChild(container);\n\t\t\t\tdiscardElement(clone);\n\t\t\t\tdelete this.renderToClone;\n\t\t\t}\n\t\t\n\t\t// Set up the clone\n\t\t} else {\n\t\t\tif (container && container.parentNode === this.renderTo) {\n\t\t\t\tthis.renderTo.removeChild(container); // do not clone this\n\t\t\t}\n\t\t\tthis.renderToClone = clone = this.renderTo.cloneNode(0);\n\t\t\tcss(clone, {\n\t\t\t\tposition: ABSOLUTE,\n\t\t\t\ttop: '-9999px',\n\t\t\t\tdisplay: 'block' // #833\n\t\t\t});\n\t\t\tif (clone.style.setProperty) { // #2631\n\t\t\t\tclone.style.setProperty('display', 'block', 'important');\n\t\t\t}\n\t\t\tdoc.body.appendChild(clone);\n\t\t\tif (container) {\n\t\t\t\tclone.appendChild(container);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get the containing element, determine the size and create the inner container\n\t * div to hold the chart\n\t */\n\tgetContainer: function () {\n\t\tvar chart = this,\n\t\t\tcontainer,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\tchartWidth,\n\t\t\tchartHeight,\n\t\t\trenderTo,\n\t\t\tindexAttrName = 'data-highcharts-chart',\n\t\t\toldChartIndex,\n\t\t\tcontainerId;\n\n\t\tchart.renderTo = renderTo = optionsChart.renderTo;\n\t\tcontainerId = PREFIX + idCounter++;\n\n\t\tif (isString(renderTo)) {\n\t\t\tchart.renderTo = renderTo = doc.getElementById(renderTo);\n\t\t}\n\t\t\n\t\t// Display an error if the renderTo is wrong\n\t\tif (!renderTo) {\n\t\t\terror(13, true);\n\t\t}\n\t\t\n\t\t// If the container already holds a chart, destroy it. The check for hasRendered is there\n\t\t// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n\t\t// attribute and the SVG contents, but not an interactive chart. So in this case,\n\t\t// charts[oldChartIndex] will point to the wrong chart if any (#2609).\n\t\toldChartIndex = pInt(attr(renderTo, indexAttrName));\n\t\tif (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n\t\t\tcharts[oldChartIndex].destroy();\n\t\t}\t\t\n\t\t\n\t\t// Make a reference to the chart from the div\n\t\tattr(renderTo, indexAttrName, chart.index);\n\n\t\t// remove previous chart\n\t\trenderTo.innerHTML = '';\n\n\t\t// If the container doesn't have an offsetWidth, it has or is a child of a node\n\t\t// that has display:none. We need to temporarily move it out to a visible\n\t\t// state to determine the size, else the legend and tooltips won't render\n\t\t// properly. The allowClone option is used in sparklines as a micro optimization,\n\t\t// saving about 1-2 ms each chart.\n\t\tif (!optionsChart.skipClone && !renderTo.offsetWidth) {\n\t\t\tchart.cloneRenderTo();\n\t\t}\n\n\t\t// get the width and height\n\t\tchart.getChartSize();\n\t\tchartWidth = chart.chartWidth;\n\t\tchartHeight = chart.chartHeight;\n\n\t\t// create the inner container\n\t\tchart.container = container = createElement(DIV, {\n\t\t\t\tclassName: PREFIX + 'container' +\n\t\t\t\t\t(optionsChart.className ? ' ' + optionsChart.className : ''),\n\t\t\t\tid: containerId\n\t\t\t}, extend({\n\t\t\t\tposition: RELATIVE,\n\t\t\t\toverflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n\t\t\t\t\t// content overflow in IE\n\t\t\t\twidth: chartWidth + PX,\n\t\t\t\theight: chartHeight + PX,\n\t\t\t\ttextAlign: 'left',\n\t\t\t\tlineHeight: 'normal', // #427\n\t\t\t\tzIndex: 0, // #1072\n\t\t\t\t'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n\t\t\t}, optionsChart.style),\n\t\t\tchart.renderToClone || renderTo\n\t\t);\n\n\t\t// cache the cursor (#1650)\n\t\tchart._cursor = container.style.cursor;\n\n\t\t// Initialize the renderer\n\t\tchart.renderer =\n\t\t\toptionsChart.forExport ? // force SVG, used for SVG export\n\t\t\t\tnew SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :\n\t\t\t\tnew Renderer(container, chartWidth, chartHeight, optionsChart.style);\n\n\t\tif (useCanVG) {\n\t\t\t// If we need canvg library, extend and configure the renderer\n\t\t\t// to get the tracker for translating mouse events\n\t\t\tchart.renderer.create(chart, container, chartWidth, chartHeight);\n\t\t}\n\t\t// Add a reference to the charts index\n\t\tchart.renderer.chartIndex = chart.index;\n\t},\n\n\t/**\n\t * Calculate margins by rendering axis labels in a preliminary position. Title,\n\t * subtitle and legend have already been rendered at this stage, but will be\n\t * moved into their final positions\n\t */\n\tgetMargins: function (skipAxes) {\n\t\tvar chart = this,\n\t\t\tspacing = chart.spacing,\n\t\t\tmargin = chart.margin,\n\t\t\ttitleOffset = chart.titleOffset;\n\n\t\tchart.resetMargins();\n\n\t\t// Adjust for title and subtitle\n\t\tif (titleOffset && !defined(margin[0])) {\n\t\t\tchart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n\t\t}\n\t\t\n\t\t// Adjust for legend\n\t\tchart.legend.adjustMargins(margin, spacing);\n\n\t\t// adjust for scroller\n\t\tif (chart.extraBottomMargin) {\n\t\t\tchart.marginBottom += chart.extraBottomMargin;\n\t\t}\n\t\tif (chart.extraTopMargin) {\n\t\t\tchart.plotTop += chart.extraTopMargin;\n\t\t}\n\t\tif (!skipAxes) {\n\t\t\tthis.getAxisMargins();\n\t\t}\n\t},\n\n\tgetAxisMargins: function () {\n\n\t\tvar chart = this,\n\t\t\taxisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n\t\t\tmargin = chart.margin;\n\t\t\n\t\t// pre-render axes to get labels offset width\n\t\tif (chart.hasCartesianSeries) {\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\taxis.getOffset();\n\t\t\t});\n\t\t}\n\n\t\t// Add the axis offsets\n\t\teach(marginNames, function (m, side) {\n\t\t\tif (!defined(margin[side])) {\n\t\t\t\tchart[m] += axisOffset[side];\n\t\t\t}\t\t\n\t\t});\n\n\t\tchart.setChartSize();\n\n\t},\n\n\t/**\n\t * Resize the chart to its container if size is not explicitly set\n\t */\n\treflow: function (e) {\n\t\tvar chart = this,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\trenderTo = chart.renderTo,\n\t\t\twidth = optionsChart.width || adapterRun(renderTo, 'width'),\n\t\t\theight = optionsChart.height || adapterRun(renderTo, 'height'),\n\t\t\ttarget = e ? e.target : win, // #805 - MooTools doesn't supply e\n\t\t\tdoReflow = function () {\n\t\t\t\tif (chart.container) { // It may have been destroyed in the meantime (#1257)\n\t\t\t\t\tchart.setSize(width, height, false);\n\t\t\t\t\tchart.hasUserSize = null;\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t// Width and height checks for display:none. Target is doc in IE8 and Opera,\n\t\t// win in Firefox, Chrome and IE9.\n\t\tif (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n\t\t\tif (width !== chart.containerWidth || height !== chart.containerHeight) {\n\t\t\t\tclearTimeout(chart.reflowTimeout);\n\t\t\t\tif (e) { // Called from window.resize\n\t\t\t\t\tchart.reflowTimeout = setTimeout(doReflow, 100);\n\t\t\t\t} else { // Called directly (#2224)\n\t\t\t\t\tdoReflow();\n\t\t\t\t}\n\t\t\t}\n\t\t\tchart.containerWidth = width;\n\t\t\tchart.containerHeight = height;\n\t\t}\n\t},\n\n\t/**\n\t * Add the event handlers necessary for auto resizing\n\t */\n\tinitReflow: function () {\n\t\tvar chart = this,\n\t\t\treflow = function (e) {\n\t\t\t\tchart.reflow(e);\n\t\t\t};\n\t\t\t\n\t\t\n\t\taddEvent(win, 'resize', reflow);\n\t\taddEvent(chart, 'destroy', function () {\n\t\t\tremoveEvent(win, 'resize', reflow);\n\t\t});\n\t},\n\n\t/**\n\t * Resize the chart to a given width and height\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Object|Boolean} animation\n\t */\n\tsetSize: function (width, height, animation) {\n\t\tvar chart = this,\n\t\t\tchartWidth,\n\t\t\tchartHeight,\n\t\t\tfireEndResize;\n\n\t\t// Handle the isResizing counter\n\t\tchart.isResizing += 1;\n\t\tfireEndResize = function () {\n\t\t\tif (chart) {\n\t\t\t\tfireEvent(chart, 'endResize', null, function () {\n\t\t\t\t\tchart.isResizing -= 1;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// set the animation for the current process\n\t\tsetAnimation(animation, chart);\n\n\t\tchart.oldChartHeight = chart.chartHeight;\n\t\tchart.oldChartWidth = chart.chartWidth;\n\t\tif (defined(width)) {\n\t\t\tchart.chartWidth = chartWidth = mathMax(0, mathRound(width));\n\t\t\tchart.hasUserSize = !!chartWidth;\n\t\t}\n\t\tif (defined(height)) {\n\t\t\tchart.chartHeight = chartHeight = mathMax(0, mathRound(height));\n\t\t}\n\n\t\t// Resize the container with the global animation applied if enabled (#2503)\n\t\t(globalAnimation ? animate : css)(chart.container, {\n\t\t\twidth: chartWidth + PX,\n\t\t\theight: chartHeight + PX\n\t\t}, globalAnimation);\n\n\t\tchart.setChartSize(true);\n\t\tchart.renderer.setSize(chartWidth, chartHeight, animation);\n\n\t\t// handle axes\n\t\tchart.maxTicks = null;\n\t\teach(chart.axes, function (axis) {\n\t\t\taxis.isDirty = true;\n\t\t\taxis.setScale();\n\t\t});\n\n\t\t// make sure non-cartesian series are also handled\n\t\teach(chart.series, function (serie) {\n\t\t\tserie.isDirty = true;\n\t\t});\n\n\t\tchart.isDirtyLegend = true; // force legend redraw\n\t\tchart.isDirtyBox = true; // force redraw of plot and chart border\n\n\t\tchart.layOutTitles(); // #2857\n\t\tchart.getMargins();\n\n\t\tchart.redraw(animation);\n\n\n\t\tchart.oldChartHeight = null;\n\t\tfireEvent(chart, 'resize');\n\n\t\t// fire endResize and set isResizing back\n\t\t// If animation is disabled, fire without delay\n\t\tif (globalAnimation === false) {\n\t\t\tfireEndResize();\n\t\t} else { // else set a timeout with the animation duration\n\t\t\tsetTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);\n\t\t}\n\t},\n\n\t/**\n\t * Set the public chart properties. This is done before and after the pre-render\n\t * to determine margin sizes\n\t */\n\tsetChartSize: function (skipAxes) {\n\t\tvar chart = this,\n\t\t\tinverted = chart.inverted,\n\t\t\trenderer = chart.renderer,\n\t\t\tchartWidth = chart.chartWidth,\n\t\t\tchartHeight = chart.chartHeight,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\tspacing = chart.spacing,\n\t\t\tclipOffset = chart.clipOffset,\n\t\t\tclipX,\n\t\t\tclipY,\n\t\t\tplotLeft,\n\t\t\tplotTop,\n\t\t\tplotWidth,\n\t\t\tplotHeight,\n\t\t\tplotBorderWidth;\n\n\t\tchart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n\t\tchart.plotTop = plotTop = mathRound(chart.plotTop);\n\t\tchart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n\t\tchart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n\t\tchart.plotSizeX = inverted ? plotHeight : plotWidth;\n\t\tchart.plotSizeY = inverted ? plotWidth : plotHeight;\n\t\t\n\t\tchart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n\t\t// Set boxes used for alignment\n\t\tchart.spacingBox = renderer.spacingBox = {\n\t\t\tx: spacing[3],\n\t\t\ty: spacing[0],\n\t\t\twidth: chartWidth - spacing[3] - spacing[1],\n\t\t\theight: chartHeight - spacing[0] - spacing[2]\n\t\t};\n\t\tchart.plotBox = renderer.plotBox = {\n\t\t\tx: plotLeft,\n\t\t\ty: plotTop,\n\t\t\twidth: plotWidth,\n\t\t\theight: plotHeight\n\t\t};\n\n\t\tplotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);\n\t\tclipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);\n\t\tclipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);\n\t\tchart.clipBox = {\n\t\t\tx: clipX, \n\t\t\ty: clipY, \n\t\t\twidth: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), \n\t\t\theight: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n\t\t};\n\n\t\tif (!skipAxes) {\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\taxis.setAxisSize();\n\t\t\t\taxis.setAxisTranslation();\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Initial margins before auto size margins are applied\n\t */\n\tresetMargins: function () {\n\t\tvar chart = this;\n\n\t\teach(marginNames, function (m, side) {\n\t\t\tchart[m] = pick(chart.margin[side], chart.spacing[side]);\n\t\t});\n\t\tchart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n\t\tchart.clipOffset = [0, 0, 0, 0];\n\t},\n\n\t/**\n\t * Draw the borders and backgrounds for chart and plot area\n\t */\n\tdrawChartBox: function () {\n\t\tvar chart = this,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tchartWidth = chart.chartWidth,\n\t\t\tchartHeight = chart.chartHeight,\n\t\t\tchartBackground = chart.chartBackground,\n\t\t\tplotBackground = chart.plotBackground,\n\t\t\tplotBorder = chart.plotBorder,\n\t\t\tplotBGImage = chart.plotBGImage,\n\t\t\tchartBorderWidth = optionsChart.borderWidth || 0,\n\t\t\tchartBackgroundColor = optionsChart.backgroundColor,\n\t\t\tplotBackgroundColor = optionsChart.plotBackgroundColor,\n\t\t\tplotBackgroundImage = optionsChart.plotBackgroundImage,\n\t\t\tplotBorderWidth = optionsChart.plotBorderWidth || 0,\n\t\t\tmgn,\n\t\t\tbgAttr,\n\t\t\tplotLeft = chart.plotLeft,\n\t\t\tplotTop = chart.plotTop,\n\t\t\tplotWidth = chart.plotWidth,\n\t\t\tplotHeight = chart.plotHeight,\n\t\t\tplotBox = chart.plotBox,\n\t\t\tclipRect = chart.clipRect,\n\t\t\tclipBox = chart.clipBox;\n\n\t\t// Chart area\n\t\tmgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n\t\tif (chartBorderWidth || chartBackgroundColor) {\n\t\t\tif (!chartBackground) {\n\t\t\t\t\n\t\t\t\tbgAttr = {\n\t\t\t\t\tfill: chartBackgroundColor || NONE\n\t\t\t\t};\n\t\t\t\tif (chartBorderWidth) { // #980\n\t\t\t\t\tbgAttr.stroke = optionsChart.borderColor;\n\t\t\t\t\tbgAttr['stroke-width'] = chartBorderWidth;\n\t\t\t\t}\n\t\t\t\tchart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n\t\t\t\t\t\toptionsChart.borderRadius, chartBorderWidth)\n\t\t\t\t\t.attr(bgAttr)\n\t\t\t\t\t.addClass(PREFIX + 'background')\n\t\t\t\t\t.add()\n\t\t\t\t\t.shadow(optionsChart.shadow);\n\n\t\t\t} else { // resize\n\t\t\t\tchartBackground.animate(\n\t\t\t\t\tchartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\t\t// Plot background\n\t\tif (plotBackgroundColor) {\n\t\t\tif (!plotBackground) {\n\t\t\t\tchart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tfill: plotBackgroundColor\n\t\t\t\t\t})\n\t\t\t\t\t.add()\n\t\t\t\t\t.shadow(optionsChart.plotShadow);\n\t\t\t} else {\n\t\t\t\tplotBackground.animate(plotBox);\n\t\t\t}\n\t\t}\n\t\tif (plotBackgroundImage) {\n\t\t\tif (!plotBGImage) {\n\t\t\t\tchart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n\t\t\t\t\t.add();\n\t\t\t} else {\n\t\t\t\tplotBGImage.animate(plotBox);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Plot clip\n\t\tif (!clipRect) {\n\t\t\tchart.clipRect = renderer.clipRect(clipBox);\n\t\t} else {\n\t\t\tclipRect.animate({\n\t\t\t\twidth: clipBox.width,\n\t\t\t\theight: clipBox.height\n\t\t\t});\n\t\t}\n\n\t\t// Plot area border\n\t\tif (plotBorderWidth) {\n\t\t\tif (!plotBorder) {\n\t\t\t\tchart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tstroke: optionsChart.plotBorderColor,\n\t\t\t\t\t\t'stroke-width': plotBorderWidth,\n\t\t\t\t\t\tfill: NONE,\n\t\t\t\t\t\tzIndex: 1\n\t\t\t\t\t})\n\t\t\t\t\t.add();\n\t\t\t} else {\n\t\t\t\tplotBorder.animate(\n\t\t\t\t\tplotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// reset\n\t\tchart.isDirtyBox = false;\n\t},\n\n\t/**\n\t * Detect whether a certain chart property is needed based on inspecting its options\n\t * and series. This mainly applies to the chart.invert property, and in extensions to \n\t * the chart.angular and chart.polar properties.\n\t */\n\tpropFromSeries: function () {\n\t\tvar chart = this,\n\t\t\toptionsChart = chart.options.chart,\n\t\t\tklass,\n\t\t\tseriesOptions = chart.options.series,\n\t\t\ti,\n\t\t\tvalue;\n\t\t\t\n\t\t\t\n\t\teach(['inverted', 'angular', 'polar'], function (key) {\n\t\t\t\n\t\t\t// The default series type's class\n\t\t\tklass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n\t\t\t\n\t\t\t// Get the value from available chart-wide properties\n\t\t\tvalue = (\n\t\t\t\tchart[key] || // 1. it is set before\n\t\t\t\toptionsChart[key] || // 2. it is set in the options\n\t\t\t\t(klass && klass.prototype[key]) // 3. it's default series class requires it\n\t\t\t);\n\t\n\t\t\t// 4. Check if any the chart's series require it\n\t\t\ti = seriesOptions && seriesOptions.length;\n\t\t\twhile (!value && i--) {\n\t\t\t\tklass = seriesTypes[seriesOptions[i].type];\n\t\t\t\tif (klass && klass.prototype[key]) {\n\t\t\t\t\tvalue = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Set the chart property\n\t\t\tchart[key] = value;\t\n\t\t});\n\t\t\n\t},\n\n\t/**\n\t * Link two or more series together. This is done initially from Chart.render,\n\t * and after Chart.addSeries and Series.remove.\n\t */\n\tlinkSeries: function () {\n\t\tvar chart = this,\n\t\t\tchartSeries = chart.series;\n\n\t\t// Reset links\n\t\teach(chartSeries, function (series) {\n\t\t\tseries.linkedSeries.length = 0;\n\t\t});\n\n\t\t// Apply new links\n\t\teach(chartSeries, function (series) {\n\t\t\tvar linkedTo = series.options.linkedTo;\n\t\t\tif (isString(linkedTo)) {\n\t\t\t\tif (linkedTo === ':previous') {\n\t\t\t\t\tlinkedTo = chart.series[series.index - 1];\n\t\t\t\t} else {\n\t\t\t\t\tlinkedTo = chart.get(linkedTo);\n\t\t\t\t}\n\t\t\t\tif (linkedTo) {\n\t\t\t\t\tlinkedTo.linkedSeries.push(series);\n\t\t\t\t\tseries.linkedParent = linkedTo;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Render series for the chart\n\t */\n\trenderSeries: function () {\n\t\teach(this.series, function (serie) {\n\t\t\tserie.translate();\n\t\t\tserie.render();\n\t\t});\n\t},\n\t\t\n\t/**\n\t * Render labels for the chart\n\t */\n\trenderLabels: function () {\n\t\tvar chart = this,\n\t\t\tlabels = chart.options.labels;\n\t\tif (labels.items) {\n\t\t\teach(labels.items, function (label) {\n\t\t\t\tvar style = extend(labels.style, label.style),\n\t\t\t\t\tx = pInt(style.left) + chart.plotLeft,\n\t\t\t\t\ty = pInt(style.top) + chart.plotTop + 12;\n\n\t\t\t\t// delete to prevent rewriting in IE\n\t\t\t\tdelete style.left;\n\t\t\t\tdelete style.top;\n\n\t\t\t\tchart.renderer.text(\n\t\t\t\t\tlabel.html,\n\t\t\t\t\tx,\n\t\t\t\t\ty\n\t\t\t\t)\n\t\t\t\t.attr({ zIndex: 2 })\n\t\t\t\t.css(style)\n\t\t\t\t.add();\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Render all graphics for the chart\n\t */\n\trender: function () {\n\t\tvar chart = this,\n\t\t\taxes = chart.axes,\n\t\t\trenderer = chart.renderer,\n\t\t\toptions = chart.options,\n\t\t\ttempWidth,\n\t\t\ttempHeight,\n\t\t\tredoHorizontal,\n\t\t\tredoVertical;\n\n\t\t// Title\n\t\tchart.setTitle();\n\n\n\t\t// Legend\n\t\tchart.legend = new Legend(chart, options.legend);\n\n\t\tchart.getStacks(); // render stacks\n\n\t\t// Get chart margins\n\t\tchart.getMargins(true);\n\t\tchart.setChartSize();\n\n\t\t// Record preliminary dimensions for later comparison\n\t\ttempWidth = chart.plotWidth;\n\t\ttempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels\n\n\t\t// Get margins by pre-rendering axes\n\t\teach(axes, function (axis) {\n\t\t\taxis.setScale();\n\t\t});\n\t\tchart.getAxisMargins();\n\n\t\t// If the plot area size has changed significantly, calculate tick positions again\n\t\tredoHorizontal = tempWidth / chart.plotWidth > 1.2;\n\t\tredoVertical = tempHeight / chart.plotHeight > 1.1;\n\n\t\tif (redoHorizontal || redoVertical) {\n\n\t\t\tchart.maxTicks = null; // reset for second pass\n\t\t\teach(axes, function (axis) {\n\t\t\t\tif ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n\t\t\t\t\taxis.setTickInterval(true); // update to reflect the new margins\n\t\t\t\t}\n\t\t\t});\n\t\t\tchart.getMargins(); // second pass to check for new labels\n\t\t}\n\n\t\t// Draw the borders and backgrounds\n\t\tchart.drawChartBox();\t\t\n\n\n\t\t// Axes\n\t\tif (chart.hasCartesianSeries) {\n\t\t\teach(axes, function (axis) {\n\t\t\t\taxis.render();\n\t\t\t});\n\t\t}\n\n\t\t// The series\n\t\tif (!chart.seriesGroup) {\n\t\t\tchart.seriesGroup = renderer.g('series-group')\n\t\t\t\t.attr({ zIndex: 3 })\n\t\t\t\t.add();\n\t\t}\n\t\tchart.renderSeries();\n\n\t\t// Labels\n\t\tchart.renderLabels();\n\n\t\t// Credits\n\t\tchart.showCredits(options.credits);\n\n\t\t// Set flag\n\t\tchart.hasRendered = true;\n\n\t},\n\n\t/**\n\t * Show chart credits based on config options\n\t */\n\tshowCredits: function (credits) {\n\t\tif (credits.enabled && !this.credits) {\n\t\t\tthis.credits = this.renderer.text(\n\t\t\t\tcredits.text,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t)\n\t\t\t.on('click', function () {\n\t\t\t\tif (credits.href) {\n\t\t\t\t\tlocation.href = credits.href;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.attr({\n\t\t\t\talign: credits.position.align,\n\t\t\t\tzIndex: 8\n\t\t\t})\n\t\t\t.css(credits.style)\n\t\t\t.add()\n\t\t\t.align(credits.position);\n\t\t}\n\t},\n\n\t/**\n\t * Clean up memory usage\n\t */\n\tdestroy: function () {\n\t\tvar chart = this,\n\t\t\taxes = chart.axes,\n\t\t\tseries = chart.series,\n\t\t\tcontainer = chart.container,\n\t\t\ti,\n\t\t\tparentNode = container && container.parentNode;\n\t\t\t\n\t\t// fire the chart.destoy event\n\t\tfireEvent(chart, 'destroy');\n\t\t\n\t\t// Delete the chart from charts lookup array\n\t\tcharts[chart.index] = UNDEFINED;\n\t\tchartCount--;\n\t\tchart.renderTo.removeAttribute('data-highcharts-chart');\n\n\t\t// remove events\n\t\tremoveEvent(chart);\n\n\t\t// ==== Destroy collections:\n\t\t// Destroy axes\n\t\ti = axes.length;\n\t\twhile (i--) {\n\t\t\taxes[i] = axes[i].destroy();\n\t\t}\n\n\t\t// Destroy each series\n\t\ti = series.length;\n\t\twhile (i--) {\n\t\t\tseries[i] = series[i].destroy();\n\t\t}\n\n\t\t// ==== Destroy chart properties:\n\t\teach(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', \n\t\t\t\t'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', \n\t\t\t\t'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n\t\t\tvar prop = chart[name];\n\n\t\t\tif (prop && prop.destroy) {\n\t\t\t\tchart[name] = prop.destroy();\n\t\t\t}\n\t\t});\n\n\t\t// remove container and all SVG\n\t\tif (container) { // can break in IE when destroyed before finished loading\n\t\t\tcontainer.innerHTML = '';\n\t\t\tremoveEvent(container);\n\t\t\tif (parentNode) {\n\t\t\t\tdiscardElement(container);\n\t\t\t}\n\n\t\t}\n\n\t\t// clean it all up\n\t\tfor (i in chart) {\n\t\t\tdelete chart[i];\n\t\t}\n\n\t},\n\n\n\t/**\n\t * VML namespaces can't be added until after complete. Listening\n\t * for Perini's doScroll hack is not enough.\n\t */\n\tisReadyToRender: function () {\n\t\tvar chart = this;\n\n\t\t// Note: in spite of JSLint's complaints, win == win.top is required\n\t\t/*jslint eqeq: true*/\n\t\tif ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {\n\t\t/*jslint eqeq: false*/\n\t\t\tif (useCanVG) {\n\t\t\t\t// Delay rendering until canvg library is downloaded and ready\n\t\t\t\tCanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);\n\t\t\t} else {\n\t\t\t\tdoc.attachEvent('onreadystatechange', function () {\n\t\t\t\t\tdoc.detachEvent('onreadystatechange', chart.firstRender);\n\t\t\t\t\tif (doc.readyState === 'complete') {\n\t\t\t\t\t\tchart.firstRender();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t * Prepare for first rendering after all data are loaded\n\t */\n\tfirstRender: function () {\n\t\tvar chart = this,\n\t\t\toptions = chart.options,\n\t\t\tcallback = chart.callback;\n\n\t\t// Check whether the chart is ready to render\n\t\tif (!chart.isReadyToRender()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create the container\n\t\tchart.getContainer();\n\n\t\t// Run an early event after the container and renderer are established\n\t\tfireEvent(chart, 'init');\n\n\t\t\n\t\tchart.resetMargins();\n\t\tchart.setChartSize();\n\n\t\t// Set the common chart properties (mainly invert) from the given series\n\t\tchart.propFromSeries();\n\n\t\t// get axes\n\t\tchart.getAxes();\n\n\t\t// Initialize the series\n\t\teach(options.series || [], function (serieOptions) {\n\t\t\tchart.initSeries(serieOptions);\n\t\t});\n\n\t\tchart.linkSeries();\n\n\t\t// Run an event after axes and series are initialized, but before render. At this stage,\n\t\t// the series data is indexed and cached in the xData and yData arrays, so we can access\n\t\t// those before rendering. Used in Highstock. \n\t\tfireEvent(chart, 'beforeRender'); \n\n\t\t// depends on inverted and on margins being set\n\t\tif (Highcharts.Pointer) {\n\t\t\tchart.pointer = new Pointer(chart, options);\n\t\t}\n\n\t\tchart.render();\n\n\t\t// add canvas\n\t\tchart.renderer.draw();\n\t\t// run callbacks\n\t\tif (callback) {\n\t\t\tcallback.apply(chart, [chart]);\n\t\t}\n\t\teach(chart.callbacks, function (fn) {\n\t\t\tif (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)\n\t\t\t\tfn.apply(chart, [chart]);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Fire the load event\n\t\tfireEvent(chart, 'load');\t\t\n\t\t\n\t\t// If the chart was rendered outside the top container, put it back in (#3679)\n\t\tchart.cloneRenderTo(true);\n\n\t},\n\n\t/**\n\t* Creates arrays for spacing and margin from given options.\n\t*/\n\tsplashArray: function (target, options) {\n\t\tvar oVar = options[target],\n\t\t\ttArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n\t\treturn [pick(options[target + 'Top'], tArray[0]),\n\t\t\t\tpick(options[target + 'Right'], tArray[1]),\n\t\t\t\tpick(options[target + 'Bottom'], tArray[2]),\n\t\t\t\tpick(options[target + 'Left'], tArray[3])];\n\t}\n}; // end Chart\n\nvar CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {\n\t/**\n\t * Get the center of the pie based on the size and center options relative to the  \n\t * plot area. Borrowed by the polar and gauge series types.\n\t */\n\tgetCenter: function () {\n\t\t\n\t\tvar options = this.options,\n\t\t\tchart = this.chart,\n\t\t\tslicingRoom = 2 * (options.slicedOffset || 0),\n\t\t\thandleSlicingRoom,\n\t\t\tplotWidth = chart.plotWidth - 2 * slicingRoom,\n\t\t\tplotHeight = chart.plotHeight - 2 * slicingRoom,\n\t\t\tcenterOption = options.center,\n\t\t\tpositions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n\t\t\tsmallestSize = mathMin(plotWidth, plotHeight),\n\t\t\tisPercent,\n\t\t\ti,\n\t\t\tvalue;\n\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tvalue = positions[i];\n\t\t\tisPercent = /%$/.test(value);\n\t\t\thandleSlicingRoom = i < 2 || (i === 2 && isPercent);\n\t\t\tpositions[i] = (isPercent ?\n\t\t\t\t// i == 0: centerX, relative to width\n\t\t\t\t// i == 1: centerY, relative to height\n\t\t\t\t// i == 2: size, relative to smallestSize\n\t\t\t\t// i == 3: innerSize, relative to size\n\t\t\t\t[plotWidth, plotHeight, smallestSize, positions[2]][i] *\n\t\t\t\t\tpInt(value) / 100 :\n\t\t\t\tpInt(value)) + (handleSlicingRoom ? slicingRoom : 0);\n\t\t}\n\t\treturn positions;\n\t}\n};\n\n/**\n * The Point object and prototype. Inheritable and used as base for PiePoint\n */\nvar Point = function () {};\nPoint.prototype = {\n\n\t/**\n\t * Initialize the point\n\t * @param {Object} series The series object containing this point\n\t * @param {Object} options The data in either number, array or object format\n\t */\n\tinit: function (series, options, x) {\n\n\t\tvar point = this,\n\t\t\tcolors;\n\t\tpoint.series = series;\n\t\tpoint.color = series.color; // #3445\n\t\tpoint.applyOptions(options, x);\n\t\tpoint.pointAttr = {};\n\n\t\tif (series.options.colorByPoint) {\n\t\t\tcolors = series.options.colors || series.chart.options.colors;\n\t\t\tpoint.color = point.color || colors[series.colorCounter++];\n\t\t\t// loop back to zero\n\t\t\tif (series.colorCounter === colors.length) {\n\t\t\t\tseries.colorCounter = 0;\n\t\t\t}\n\t\t}\n\n\t\tseries.chart.pointCount++;\n\t\treturn point;\n\t},\n\t/**\n\t * Apply the options containing the x and y data and possible some extra properties.\n\t * This is called on point init or from point.update.\n\t *\n\t * @param {Object} options\n\t */\n\tapplyOptions: function (options, x) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tpointValKey = series.options.pointValKey || series.pointValKey;\n\n\t\toptions = Point.prototype.optionsToObject.call(this, options);\n\n\t\t// copy options directly to point\n\t\textend(point, options);\n\t\tpoint.options = point.options ? extend(point.options, options) : options;\n\n\t\t// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n\t\tif (pointValKey) {\n\t\t\tpoint.y = point[pointValKey];\n\t\t}\n\n\t\t// If no x is set by now, get auto incremented value. All points must have an\n\t\t// x value, however the y value can be null to create a gap in the series\n\t\tif (point.x === UNDEFINED && series) {\n\t\t\tpoint.x = x === UNDEFINED ? series.autoIncrement() : x;\n\t\t}\n\n\t\treturn point;\n\t},\n\n\t/**\n\t * Transform number or array configs into objects\n\t */\n\toptionsToObject: function (options) {\n\t\tvar ret = {},\n\t\t\tseries = this.series,\n\t\t\tpointArrayMap = series.pointArrayMap || ['y'],\n\t\t\tvalueCount = pointArrayMap.length,\n\t\t\tfirstItemType,\n\t\t\ti = 0,\n\t\t\tj = 0;\n\n\t\tif (typeof options === 'number' || options === null) {\n\t\t\tret[pointArrayMap[0]] = options;\n\n\t\t} else if (isArray(options)) {\n\t\t\t// with leading x value\n\t\t\tif (options.length > valueCount) {\n\t\t\t\tfirstItemType = typeof options[0];\n\t\t\t\tif (firstItemType === 'string') {\n\t\t\t\t\tret.name = options[0];\n\t\t\t\t} else if (firstItemType === 'number') {\n\t\t\t\t\tret.x = options[0];\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (j < valueCount) {\n\t\t\t\tret[pointArrayMap[j++]] = options[i++];\n\t\t\t}\n\t\t} else if (typeof options === 'object') {\n\t\t\tret = options;\n\n\t\t\t// This is the fastest way to detect if there are individual point dataLabels that need\n\t\t\t// to be considered in drawDataLabels. These can only occur in object configs.\n\t\t\tif (options.dataLabels) {\n\t\t\t\tseries._hasPointLabels = true;\n\t\t\t}\n\n\t\t\t// Same approach as above for markers\n\t\t\tif (options.marker) {\n\t\t\t\tseries._hasPointMarkers = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t},\n\n\t/**\n\t * Destroy a point to clear memory. Its reference still stays in series.data.\n\t */\n\tdestroy: function () {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tchart = series.chart,\n\t\t\thoverPoints = chart.hoverPoints,\n\t\t\tprop;\n\n\t\tchart.pointCount--;\n\n\t\tif (hoverPoints) {\n\t\t\tpoint.setState();\n\t\t\terase(hoverPoints, point);\n\t\t\tif (!hoverPoints.length) {\n\t\t\t\tchart.hoverPoints = null;\n\t\t\t}\n\n\t\t}\n\t\tif (point === chart.hoverPoint) {\n\t\t\tpoint.onMouseOut();\n\t\t}\n\n\t\t// remove all events\n\t\tif (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n\t\t\tremoveEvent(point);\n\t\t\tpoint.destroyElements();\n\t\t}\n\n\t\tif (point.legendItem) { // pies have legend items\n\t\t\tchart.legend.destroyItem(point);\n\t\t}\n\n\t\tfor (prop in point) {\n\t\t\tpoint[prop] = null;\n\t\t}\n\n\n\t},\n\n\t/**\n\t * Destroy SVG elements associated with the point\n\t */\n\tdestroyElements: function () {\n\t\tvar point = this,\n\t\t\tprops = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],\n\t\t\tprop,\n\t\t\ti = 6;\n\t\twhile (i--) {\n\t\t\tprop = props[i];\n\t\t\tif (point[prop]) {\n\t\t\t\tpoint[prop] = point[prop].destroy();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Return the configuration hash needed for the data label and tooltip formatters\n\t */\n\tgetLabelConfig: function () {\n\t\tvar point = this;\n\t\treturn {\n\t\t\tx: point.category,\n\t\t\ty: point.y,\n\t\t\tkey: point.name || point.category,\n\t\t\tseries: point.series,\n\t\t\tpoint: point,\n\t\t\tpercentage: point.percentage,\n\t\t\ttotal: point.total || point.stackTotal\n\t\t};\n\t},\t\n\n\t/**\n\t * Extendable method for formatting each point's tooltip line\n\t *\n\t * @return {String} A string to be concatenated in to the common tooltip text\n\t */\n\ttooltipFormatter: function (pointFormat) {\n\n\t\t// Insert options for valueDecimals, valuePrefix, and valueSuffix\n\t\tvar series = this.series,\n\t\t\tseriesTooltipOptions = series.tooltipOptions,\n\t\t\tvalueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n\t\t\tvaluePrefix = seriesTooltipOptions.valuePrefix || '',\n\t\t\tvalueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n\t\t// Loop over the point array map and replace unformatted values with sprintf formatting markup\n\t\teach(series.pointArrayMap || ['y'], function (key) {\n\t\t\tkey = '{point.' + key; // without the closing bracket\n\t\t\tif (valuePrefix || valueSuffix) {\n\t\t\t\tpointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n\t\t\t}\n\t\t\tpointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n\t\t});\n\n\t\treturn format(pointFormat, {\n\t\t\tpoint: this,\n\t\t\tseries: this.series\n\t\t});\n\t},\n\n\t/**\n\t * Fire an event on the Point object. Must not be renamed to fireEvent, as this\n\t * causes a name clash in MooTools\n\t * @param {String} eventType\n\t * @param {Object} eventArgs Additional event arguments\n\t * @param {Function} defaultFunction Default event handler\n\t */\n\tfirePointEvent: function (eventType, eventArgs, defaultFunction) {\n\t\tvar point = this,\n\t\t\tseries = this.series,\n\t\t\tseriesOptions = series.options;\n\n\t\t// load event handlers on demand to save time on mouseover/out\n\t\tif (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n\t\t\tthis.importEvents();\n\t\t}\n\n\t\t// add default handler if in selection mode\n\t\tif (eventType === 'click' && seriesOptions.allowPointSelect) {\n\t\t\tdefaultFunction = function (event) {\n\t\t\t\t// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n\t\t\t\tpoint.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n\t\t\t};\n\t\t}\n\n\t\tfireEvent(this, eventType, eventArgs, defaultFunction);\n\t}\n};/**\n * @classDescription The base function which all other series types inherit from. The data in the series is stored\n * in various arrays.\n *\n * - First, series.options.data contains all the original config options for\n * each point whether added by options or methods like series.addPoint.\n * - Next, series.data contains those values converted to points, but in case the series data length\n * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n * only contains the points that have been created on demand.\n * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n * compared to series.data and series.options.data. If however the series data is grouped, these can't\n * be correlated one to one.\n * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n *\n * @param {Object} chart\n * @param {Object} options\n */\nvar Series = Highcharts.Series = function () {};\n\nSeries.prototype = {\n\n\tisCartesian: true,\n\ttype: 'line',\n\tpointClass: Point,\n\tsorted: true, // requires the data to be sorted\n\trequireSorting: true,\n\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\tstroke: 'lineColor',\n\t\t'stroke-width': 'lineWidth',\n\t\tfill: 'fillColor',\n\t\tr: 'radius'\n\t},\n\taxisTypes: ['xAxis', 'yAxis'],\n\tcolorCounter: 0,\n\tparallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n\tinit: function (chart, options) {\n\t\tvar series = this,\n\t\t\teventType,\n\t\t\tevents,\n\t\t\tchartSeries = chart.series,\n\t\t\tsortByIndex = function (a, b) {\n\t\t\t\treturn pick(a.options.index, a._i) - pick(b.options.index, b._i);\n\t\t\t};\n\n\t\tseries.chart = chart;\n\t\tseries.options = options = series.setOptions(options); // merge with plotOptions\n\t\tseries.linkedSeries = [];\n\n\t\t// bind the axes\n\t\tseries.bindAxes();\n\n\t\t// set some variables\n\t\textend(series, {\n\t\t\tname: options.name,\n\t\t\tstate: NORMAL_STATE,\n\t\t\tpointAttr: {},\n\t\t\tvisible: options.visible !== false, // true by default\n\t\t\tselected: options.selected === true // false by default\n\t\t});\n\n\t\t// special\n\t\tif (useCanVG) {\n\t\t\toptions.animation = false;\n\t\t}\n\n\t\t// register event listeners\n\t\tevents = options.events;\n\t\tfor (eventType in events) {\n\t\t\taddEvent(series, eventType, events[eventType]);\n\t\t}\n\t\tif (\n\t\t\t(events && events.click) ||\n\t\t\t(options.point && options.point.events && options.point.events.click) ||\n\t\t\toptions.allowPointSelect\n\t\t) {\n\t\t\tchart.runTrackerClick = true;\n\t\t}\n\n\t\tseries.getColor();\n\t\tseries.getSymbol();\n\n\t\t// Set the data\n\t\teach(series.parallelArrays, function (key) {\n\t\t\tseries[key + 'Data'] = [];\n\t\t});\n\t\tseries.setData(options.data, false);\n\n\t\t// Mark cartesian\n\t\tif (series.isCartesian) {\n\t\t\tchart.hasCartesianSeries = true;\n\t\t}\n\n\t\t// Register it in the chart\n\t\tchartSeries.push(series);\n\t\tseries._i = chartSeries.length - 1;\n\n\t\t// Sort series according to index option (#248, #1123, #2456)\n\t\tstableSort(chartSeries, sortByIndex);\n\t\tif (this.yAxis) {\n\t\t\tstableSort(this.yAxis.series, sortByIndex);\n\t\t}\n\n\t\teach(chartSeries, function (series, i) {\n\t\t\tseries.index = i;\n\t\t\tseries.name = series.name || 'Series ' + (i + 1);\n\t\t});\n\n\t},\n\n\t/**\n\t * Set the xAxis and yAxis properties of cartesian series, and register the series\n\t * in the axis.series array\n\t */\n\tbindAxes: function () {\n\t\tvar series = this,\n\t\t\tseriesOptions = series.options,\n\t\t\tchart = series.chart,\n\t\t\taxisOptions;\n\n\t\teach(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n\t\t\teach(chart[AXIS], function (axis) { // loop through the chart's axis objects\n\t\t\t\taxisOptions = axis.options;\n\n\t\t\t\t// apply if the series xAxis or yAxis option mathches the number of the\n\t\t\t\t// axis, or if undefined, use the first axis\n\t\t\t\tif ((seriesOptions[AXIS] === axisOptions.index) ||\n\t\t\t\t\t\t(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n\t\t\t\t\t\t(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n\t\t\t\t\t// register this series in the axis.series lookup\n\t\t\t\t\taxis.series.push(series);\n\n\t\t\t\t\t// set this series.xAxis or series.yAxis reference\n\t\t\t\t\tseries[AXIS] = axis;\n\n\t\t\t\t\t// mark dirty for redraw\n\t\t\t\t\taxis.isDirty = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// The series needs an X and an Y axis\n\t\t\tif (!series[AXIS] && series.optionalAxis !== AXIS) {\n\t\t\t\terror(18, true);\n\t\t\t}\n\n\t\t});\n\t},\n\n\t/**\n\t * For simple series types like line and column, the data values are held in arrays like\n\t * xData and yData for quick lookup to find extremes and more. For multidimensional series\n\t * like bubble and map, this can be extended with arrays like zData and valueData by\n\t * adding to the series.parallelArrays array.\n\t */\n\tupdateParallelArrays: function (point, i) {\n\t\tvar series = point.series,\n\t\t\targs = arguments,\n\t\t\tfn = typeof i === 'number' ?\n\t\t\t\t // Insert the value in the given position\n\t\t\t\tfunction (key) {\n\t\t\t\t\tvar val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n\t\t\t\t\tseries[key + 'Data'][i] = val;\n\t\t\t\t} :\n\t\t\t\t// Apply the method specified in i with the following arguments as arguments\n\t\t\t\tfunction (key) {\n\t\t\t\t\tArray.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n\t\t\t\t};\n\n\t\teach(series.parallelArrays, fn);\n\t},\n\n\t/**\n\t * Return an auto incremented x value based on the pointStart and pointInterval options.\n\t * This is only used if an x value is not given for the point that calls autoIncrement.\n\t */\n\tautoIncrement: function () {\n\n\t\tvar options = this.options,\n\t\t\txIncrement = this.xIncrement,\n\t\t\tdate,\n\t\t\tpointInterval,\n\t\t\tpointIntervalUnit = options.pointIntervalUnit;\n\t\t\n\t\txIncrement = pick(xIncrement, options.pointStart, 0);\n\t\t\n\t\tthis.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n\t\t\n\t\t// Added code for pointInterval strings\n\t\tif (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {\n\t\t\tdate = new Date(xIncrement);\n\t\t\tdate = (pointIntervalUnit === 'month') ?\n\t\t\t\t+date[setMonth](date[getMonth]() + pointInterval) :\n\t\t\t\t+date[setFullYear](date[getFullYear]() + pointInterval);\n\t\t\tpointInterval = date - xIncrement;\n\t\t}\n\t\t\n\t\tthis.xIncrement = xIncrement + pointInterval;\n\t\treturn xIncrement;\n\t},\n\n\t/**\n\t * Divide the series data into segments divided by null values.\n\t */\n\tgetSegments: function () {\n\t\tvar series = this,\n\t\t\tlastNull = -1,\n\t\t\tsegments = [],\n\t\t\ti,\n\t\t\tpoints = series.points,\n\t\t\tpointsLength = points.length;\n\n\t\tif (pointsLength) { // no action required for []\n\n\t\t\t// if connect nulls, just remove null points\n\t\t\tif (series.options.connectNulls) {\n\t\t\t\ti = pointsLength;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (points[i].y === null) {\n\t\t\t\t\t\tpoints.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (points.length) {\n\t\t\t\t\tsegments = [points];\n\t\t\t\t}\n\n\t\t\t// else, split on null points\n\t\t\t} else {\n\t\t\t\teach(points, function (point, i) {\n\t\t\t\t\tif (point.y === null) {\n\t\t\t\t\t\tif (i > lastNull + 1) {\n\t\t\t\t\t\t\tsegments.push(points.slice(lastNull + 1, i));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastNull = i;\n\t\t\t\t\t} else if (i === pointsLength - 1) { // last value\n\t\t\t\t\t\tsegments.push(points.slice(lastNull + 1, i + 1));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// register it\n\t\tseries.segments = segments;\n\t},\n\n\t/**\n\t * Set the series options by merging from the options tree\n\t * @param {Object} itemOptions\n\t */\n\tsetOptions: function (itemOptions) {\n\t\tvar chart = this.chart,\n\t\t\tchartOptions = chart.options,\n\t\t\tplotOptions = chartOptions.plotOptions,\n\t\t\tuserOptions = chart.userOptions || {},\n\t\t\tuserPlotOptions = userOptions.plotOptions || {},\n\t\t\ttypeOptions = plotOptions[this.type],\n\t\t\toptions,\n\t\t\tzones;\n\n\t\tthis.userOptions = itemOptions;\n\n\t\t// General series options take precedence over type options because otherwise, default\n\t\t// type options like column.animation would be overwritten by the general option.\n\t\t// But issues have been raised here (#3881), and the solution may be to distinguish \n\t\t// between default option and userOptions like in the tooltip below.\n\t\toptions = merge(\n\t\t\ttypeOptions,\n\t\t\tplotOptions.series,\n\t\t\titemOptions\n\t\t);\n\n\t\t// The tooltip options are merged between global and series specific options\n\t\tthis.tooltipOptions = merge(\n\t\t\tdefaultOptions.tooltip,\n\t\t\tdefaultOptions.plotOptions[this.type].tooltip,\n\t\t\tuserOptions.tooltip,\n\t\t\tuserPlotOptions.series && userPlotOptions.series.tooltip,\n\t\t\tuserPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n\t\t\titemOptions.tooltip\n\t\t);\n\n\t\t// Delete marker object if not allowed (#1125)\n\t\tif (typeOptions.marker === null) {\n\t\t\tdelete options.marker;\n\t\t}\n\n\t\t// Handle color zones\n\t\tthis.zoneAxis = options.zoneAxis;\n\t\tzones = this.zones = (options.zones || []).slice();\n\t\tif ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n\t\t\tzones.push({\n\t\t\t\tvalue: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n\t\t\t\tcolor: options.negativeColor,\n\t\t\t\tfillColor: options.negativeFillColor\n\t\t\t});\n\t\t}\n\t\tif (zones.length) { // Push one extra zone for the rest\n\t\t\tif (defined(zones[zones.length - 1].value)) {\n\t\t\t\tzones.push({\n\t\t\t\t\tcolor: this.color,\n\t\t\t\t\tfillColor: this.fillColor\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t},\n\n\tgetCyclic: function (prop, value, defaults) {\n\t\tvar i,\n\t\t\tuserOptions = this.userOptions,\n\t\t\tindexName = '_' + prop + 'Index',\n\t\t\tcounterName = prop + 'Counter';\n\n\t\tif (!value) {\n\t\t\tif (defined(userOptions[indexName])) { // after Series.update()\n\t\t\t\ti = userOptions[indexName];\n\t\t\t} else {\n\t\t\t\tuserOptions[indexName] = i = this.chart[counterName] % defaults.length;\n\t\t\t\tthis.chart[counterName] += 1;\n\t\t\t}\n\t\t\tvalue = defaults[i];\n\t\t}\n\t\tthis[prop] = value;\n\t},\n\n\t/**\n\t * Get the series' color\n\t */\n\tgetColor: function () {\n\t\tif (!this.options.colorByPoint) {\n\t\t\tthis.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n\t\t}\n\t},\n\t/**\n\t * Get the series' symbol\n\t */\n\tgetSymbol: function () {\n\t\tvar seriesMarkerOption = this.options.marker;\n\n\t\tthis.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n\t\t// don't substract radius in image symbols (#604)\n\t\tif (/^url/.test(this.symbol)) {\n\t\t\tseriesMarkerOption.radius = 0;\n\t\t}\n\t},\n\n\tdrawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n\t/**\n\t * Replace the series data with a new set of data\n\t * @param {Object} data\n\t * @param {Object} redraw\n\t */\n\tsetData: function (data, redraw, animation, updatePoints) {\n\t\tvar series = this,\n\t\t\toldData = series.points,\n\t\t\toldDataLength = (oldData && oldData.length) || 0,\n\t\t\tdataLength,\n\t\t\toptions = series.options,\n\t\t\tchart = series.chart,\n\t\t\tfirstPoint = null,\n\t\t\txAxis = series.xAxis,\n\t\t\thasCategories = xAxis && !!xAxis.categories,\n\t\t\ti,\n\t\t\tturboThreshold = options.turboThreshold,\n\t\t\tpt,\n\t\t\txData = this.xData,\n\t\t\tyData = this.yData,\n\t\t\tpointArrayMap = series.pointArrayMap,\n\t\t\tvalueCount = pointArrayMap && pointArrayMap.length;\n\n\t\tdata = data || [];\n\t\tdataLength = data.length;\n\t\tredraw = pick(redraw, true);\n\n\t\t// If the point count is the same as is was, just run Point.update which is\n\t\t// cheaper, allows animation, and keeps references to points.\n\t\tif (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n\t\t\teach(data, function (point, i) {\n\t\t\t\toldData[i].update(point, false, null, false);\n\t\t\t});\n\n\t\t} else {\n\n\t\t\t// Reset properties\n\t\t\tseries.xIncrement = null;\n\t\t\tseries.pointRange = hasCategories ? 1 : options.pointRange;\n\n\t\t\tseries.colorCounter = 0; // for series with colorByPoint (#1547)\n\t\t\t\n\t\t\t// Update parallel arrays\n\t\t\teach(this.parallelArrays, function (key) {\n\t\t\t\tseries[key + 'Data'].length = 0;\n\t\t\t});\n\n\t\t\t// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n\t\t\t// first value is tested, and we assume that all the rest are defined the same\n\t\t\t// way. Although the 'for' loops are similar, they are repeated inside each\n\t\t\t// if-else conditional for max performance.\n\t\t\tif (turboThreshold && dataLength > turboThreshold) {\n\n\t\t\t\t// find the first non-null point\n\t\t\t\ti = 0;\n\t\t\t\twhile (firstPoint === null && i < dataLength) {\n\t\t\t\t\tfirstPoint = data[i];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\n\t\t\t\tif (isNumber(firstPoint)) { // assume all points are numbers\n\t\t\t\t\tvar x = pick(options.pointStart, 0),\n\t\t\t\t\t\tpointInterval = pick(options.pointInterval, 1);\n\n\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\txData[i] = x;\n\t\t\t\t\t\tyData[i] = data[i];\n\t\t\t\t\t\tx += pointInterval;\n\t\t\t\t\t}\n\t\t\t\t\tseries.xIncrement = x;\n\t\t\t\t} else if (isArray(firstPoint)) { // assume all points are arrays\n\t\t\t\t\tif (valueCount) { // [x, low, high] or [x, o, h, l, c]\n\t\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\t\tpt = data[i];\n\t\t\t\t\t\t\txData[i] = pt[0];\n\t\t\t\t\t\t\tyData[i] = pt.slice(1, valueCount + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // [x, y]\n\t\t\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\t\t\tpt = data[i];\n\t\t\t\t\t\t\txData[i] = pt[0];\n\t\t\t\t\t\t\tyData[i] = pt[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terror(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\t\tif (data[i] !== UNDEFINED) { // stray commas in oldIE\n\t\t\t\t\t\tpt = { series: series };\n\t\t\t\t\t\tseries.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n\t\t\t\t\t\tseries.updateParallelArrays(pt, i);\n\t\t\t\t\t\tif (hasCategories && pt.name) {\n\t\t\t\t\t\t\txAxis.names[pt.x] = pt.name; // #2046\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n\t\t\tif (isString(yData[0])) {\n\t\t\t\terror(14, true);\n\t\t\t}\n\n\t\t\tseries.data = [];\n\t\t\tseries.options.data = data;\n\t\t\t//series.zData = zData;\n\n\t\t\t// destroy old points\n\t\t\ti = oldDataLength;\n\t\t\twhile (i--) {\n\t\t\t\tif (oldData[i] && oldData[i].destroy) {\n\t\t\t\t\toldData[i].destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset minRange (#878)\n\t\t\tif (xAxis) {\n\t\t\t\txAxis.minRange = xAxis.userMinRange;\n\t\t\t}\n\n\t\t\t// redraw\n\t\t\tseries.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n\t\t\tanimation = false;\n\t\t}\n\n\t\tif (redraw) {\n\t\t\tchart.redraw(animation);\n\t\t}\n\t},\n\n\t/**\n\t * Process the data by cropping away unused data points if the series is longer\n\t * than the crop threshold. This saves computing time for lage series.\n\t */\n\tprocessData: function (force) {\n\t\tvar series = this,\n\t\t\tprocessedXData = series.xData, // copied during slice operation below\n\t\t\tprocessedYData = series.yData,\n\t\t\tdataLength = processedXData.length,\n\t\t\tcroppedData,\n\t\t\tcropStart = 0,\n\t\t\tcropped,\n\t\t\tdistance,\n\t\t\tclosestPointRange,\n\t\t\txAxis = series.xAxis,\n\t\t\ti, // loop variable\n\t\t\toptions = series.options,\n\t\t\tcropThreshold = options.cropThreshold,\n\t\t\tisCartesian = series.isCartesian,\n\t\t\txExtremes,\n\t\t\tmin,\n\t\t\tmax;\n\n\t\t// If the series data or axes haven't changed, don't go through this. Return false to pass\n\t\t// the message on to override methods like in data grouping.\n\t\tif (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (xAxis) {\n\t\t\txExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n\t\t\tmin = xExtremes.min;\n\t\t\tmax = xExtremes.max;\n\t\t}\n\n\t\t// optionally filter out points outside the plot area\n\t\tif (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n\t\t\t\n\t\t\t// it's outside current extremes\n\t\t\tif (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n\t\t\t\tprocessedXData = [];\n\t\t\t\tprocessedYData = [];\n\n\t\t\t// only crop if it's actually spilling out\n\t\t\t} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n\t\t\t\tcroppedData = this.cropData(series.xData, series.yData, min, max);\n\t\t\t\tprocessedXData = croppedData.xData;\n\t\t\t\tprocessedYData = croppedData.yData;\n\t\t\t\tcropStart = croppedData.start;\n\t\t\t\tcropped = true;\n\t\t\t}\n\t\t}\n\n\n\t\t// Find the closest distance between processed points\n\t\tfor (i = processedXData.length - 1; i >= 0; i--) {\n\t\t\tdistance = processedXData[i] - processedXData[i - 1];\n\t\t\t\n\t\t\tif (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n\t\t\t\tclosestPointRange = distance;\n\n\t\t\t// Unsorted data is not supported by the line tooltip, as well as data grouping and\n\t\t\t// navigation in Stock charts (#725) and width calculation of columns (#1900)\n\t\t\t} else if (distance < 0 && series.requireSorting) {\n\t\t\t\terror(15);\n\t\t\t}\n\t\t}\n\n\t\t// Record the properties\n\t\tseries.cropped = cropped; // undefined or true\n\t\tseries.cropStart = cropStart;\n\t\tseries.processedXData = processedXData;\n\t\tseries.processedYData = processedYData;\n\n\t\tif (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\n\t\t\tseries.pointRange = closestPointRange || 1;\n\t\t}\n\t\tseries.closestPointRange = closestPointRange;\n\n\t},\n\n\t/**\n\t * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n\t * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n\t */\n\tcropData: function (xData, yData, min, max) {\n\t\tvar dataLength = xData.length,\n\t\t\tcropStart = 0,\n\t\t\tcropEnd = dataLength,\n\t\t\tcropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n\t\t\ti;\n\n\t\t// iterate up to find slice start\n\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\tif (xData[i] >= min) {\n\t\t\t\tcropStart = mathMax(0, i - cropShoulder);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// proceed to find slice end\n\t\tfor (; i < dataLength; i++) {\n\t\t\tif (xData[i] > max) {\n\t\t\t\tcropEnd = i + cropShoulder;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\txData: xData.slice(cropStart, cropEnd),\n\t\t\tyData: yData.slice(cropStart, cropEnd),\n\t\t\tstart: cropStart,\n\t\t\tend: cropEnd\n\t\t};\n\t},\n\n\n\t/**\n\t * Generate the data point after the data has been processed by cropping away\n\t * unused points and optionally grouped in Highcharts Stock.\n\t */\n\tgeneratePoints: function () {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tdataOptions = options.data,\n\t\t\tdata = series.data,\n\t\t\tdataLength,\n\t\t\tprocessedXData = series.processedXData,\n\t\t\tprocessedYData = series.processedYData,\n\t\t\tpointClass = series.pointClass,\n\t\t\tprocessedDataLength = processedXData.length,\n\t\t\tcropStart = series.cropStart || 0,\n\t\t\tcursor,\n\t\t\thasGroupedData = series.hasGroupedData,\n\t\t\tpoint,\n\t\t\tpoints = [],\n\t\t\ti;\n\n\t\tif (!data && !hasGroupedData) {\n\t\t\tvar arr = [];\n\t\t\tarr.length = dataOptions.length;\n\t\t\tdata = series.data = arr;\n\t\t}\n\n\t\tfor (i = 0; i < processedDataLength; i++) {\n\t\t\tcursor = cropStart + i;\n\t\t\tif (!hasGroupedData) {\n\t\t\t\tif (data[cursor]) {\n\t\t\t\t\tpoint = data[cursor];\n\t\t\t\t} else if (dataOptions[cursor] !== UNDEFINED) { // #970\n\t\t\t\t\tdata[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n\t\t\t\t}\n\t\t\t\tpoints[i] = point;\n\t\t\t} else {\n\t\t\t\t// splat the y data in case of ohlc data array\n\t\t\t\tpoints[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n\t\t\t}\n\t\t\tpoints[i].index = cursor; // For faster access in Point.update\n\t\t}\n\n\t\t// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n\t\t// swithching view from non-grouped data to grouped data (#637)\n\t\tif (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n\t\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\t\tif (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n\t\t\t\t\ti += processedDataLength;\n\t\t\t\t}\n\t\t\t\tif (data[i]) {\n\t\t\t\t\tdata[i].destroyElements();\n\t\t\t\t\tdata[i].plotX = UNDEFINED; // #1003\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tseries.data = data;\n\t\tseries.points = points;\n\t},\n\n\t/**\n\t * Calculate Y extremes for visible data\n\t */\n\tgetExtremes: function (yData) {\n\t\tvar xAxis = this.xAxis,\n\t\t\tyAxis = this.yAxis,\n\t\t\txData = this.processedXData,\n\t\t\tyDataLength,\n\t\t\tactiveYData = [],\n\t\t\tactiveCounter = 0,\n\t\t\txExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n\t\t\txMin = xExtremes.min,\n\t\t\txMax = xExtremes.max,\n\t\t\tvalidValue,\n\t\t\twithinRange,\n\t\t\tdataMin,\n\t\t\tdataMax,\n\t\t\tx,\n\t\t\ty,\n\t\t\ti,\n\t\t\tj;\n\n\t\tyData = yData || this.stackedYData || this.processedYData;\n\t\tyDataLength = yData.length;\n\n\t\tfor (i = 0; i < yDataLength; i++) {\n\n\t\t\tx = xData[i];\n\t\t\ty = yData[i];\n\n\t\t\t// For points within the visible range, including the first point outside the\n\t\t\t// visible range, consider y extremes\n\t\t\tvalidValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));\n\t\t\twithinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&\n\t\t\t\t(xData[i - 1] || x) <= xMax);\n\n\t\t\tif (validValue && withinRange) {\n\n\t\t\t\tj = y.length;\n\t\t\t\tif (j) { // array, like ohlc or range data\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (y[j] !== null) {\n\t\t\t\t\t\t\tactiveYData[activeCounter++] = y[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tactiveYData[activeCounter++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.dataMin = pick(dataMin, arrayMin(activeYData));\n\t\tthis.dataMax = pick(dataMax, arrayMax(activeYData));\n\t},\n\n\t/**\n\t * Translate data points from raw data values to chart specific positioning data\n\t * needed later in drawPoints, drawGraph and drawTracker.\n\t */\n\ttranslate: function () {\n\t\tif (!this.processedXData) { // hidden series\n\t\t\tthis.processData();\n\t\t}\n\t\tthis.generatePoints();\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tstacking = options.stacking,\n\t\t\txAxis = series.xAxis,\n\t\t\tcategories = xAxis.categories,\n\t\t\tyAxis = series.yAxis,\n\t\t\tpoints = series.points,\n\t\t\tdataLength = points.length,\n\t\t\thasModifyValue = !!series.modifyValue,\n\t\t\ti,\n\t\t\tpointPlacement = options.pointPlacement,\n\t\t\tdynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n\t\t\tthreshold = options.threshold,\n\t\t\tplotX,\n\t\t\tplotY,\n\t\t\tlastPlotX,\n\t\t\tclosestPointRangePx = Number.MAX_VALUE;\n\n\t\t// Translate each point\n\t\tfor (i = 0; i < dataLength; i++) {\n\t\t\tvar point = points[i],\n\t\t\t\txValue = point.x,\n\t\t\t\tyValue = point.y,\n\t\t\t\tyBottom = point.low,\n\t\t\t\tstack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],\n\t\t\t\tpointStack,\n\t\t\t\tstackValues;\n\n\t\t\t// Discard disallowed y values for log axes (#3434)\n\t\t\tif (yAxis.isLog && yValue !== null && yValue <= 0) {\n\t\t\t\tpoint.y = yValue = null;\n\t\t\t\terror(10);\n\t\t\t}\n\n\t\t\t// Get the plotX translation\n\t\t\tpoint.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591\n\n\n\t\t\t// Calculate the bottom y value for stacked series\n\t\t\tif (stacking && series.visible && stack && stack[xValue]) {\n\n\t\t\t\tpointStack = stack[xValue];\n\t\t\t\tstackValues = pointStack.points[series.index + ',' + i];\n\t\t\t\tyBottom = stackValues[0];\n\t\t\t\tyValue = stackValues[1];\n\n\t\t\t\tif (yBottom === 0) {\n\t\t\t\t\tyBottom = pick(threshold, yAxis.min);\n\t\t\t\t}\n\t\t\t\tif (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n\t\t\t\t\tyBottom = null;\n\t\t\t\t}\n\n\t\t\t\tpoint.total = point.stackTotal = pointStack.total;\n\t\t\t\tpoint.percentage = pointStack.total && (point.y / pointStack.total * 100);\n\t\t\t\tpoint.stackY = yValue;\n\n\t\t\t\t// Place the stack label\n\t\t\t\tpointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n\t\t\t}\n\n\t\t\t// Set translated yBottom or remove it\n\t\t\tpoint.yBottom = defined(yBottom) ?\n\t\t\t\tyAxis.translate(yBottom, 0, 1, 0, 1) :\n\t\t\t\tnull;\n\n\t\t\t// general hook, used for Highstock compare mode\n\t\t\tif (hasModifyValue) {\n\t\t\t\tyValue = series.modifyValue(yValue, point);\n\t\t\t}\n\n\t\t\t// Set the the plotY value, reset it for redraws\n\t\t\tpoint.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n\t\t\t\tmathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n\t\t\t\tUNDEFINED;\n\t\t\tpoint.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519\n\t\t\t\tplotX >= 0 && plotX <= xAxis.len;\n\n\n\t\t\t// Set client related positions for mouse tracking\n\t\t\tpoint.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n\t\t\tpoint.negative = point.y < (threshold || 0);\n\n\t\t\t// some API data\n\t\t\tpoint.category = categories && categories[point.x] !== UNDEFINED ?\n\t\t\t\tcategories[point.x] : point.x;\n\n\t\t\t// Determine auto enabling of markers (#3635)\n\t\t\tif (i) {\n\t\t\t\tclosestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));\n\t\t\t}\n\t\t\tlastPlotX = plotX;\n\n\t\t}\n\n\t\tseries.closestPointRangePx = closestPointRangePx;\n\n\t\t// now that we have the cropped data, build the segments\n\t\tseries.getSegments();\n\t},\n\n\t/**\n\t * Set the clipping for the series. For animated series it is called twice, first to initiate\n\t * animating the clip then the second time without the animation to set the final clip.\n\t */\n\tsetClip: function (animation) {\n\t\tvar chart = this.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tinverted = chart.inverted,\n\t\t\tseriesClipBox = this.clipBox,\n\t\t\tclipBox = seriesClipBox || chart.clipBox,\n\t\t\tsharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),\n\t\t\tclipRect = chart[sharedClipKey],\n\t\t\tmarkerClipRect = chart[sharedClipKey + 'm'];\n\n\t\t// If a clipping rectangle with the same properties is currently present in the chart, use that.\n\t\tif (!clipRect) {\n\n\t\t\t// When animation is set, prepare the initial positions\n\t\t\tif (animation) { \n\t\t\t\tclipBox.width = 0;\n\n\t\t\t\tchart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n\t\t\t\t\t-99, // include the width of the first marker\n\t\t\t\t\tinverted ? -chart.plotLeft : -chart.plotTop,\n\t\t\t\t\t99,\n\t\t\t\t\tinverted ? chart.chartWidth : chart.chartHeight\n\t\t\t\t);\n\t\t\t}\n\t\t\tchart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n\t\t\t\n\t\t}\n\t\tif (animation) {\n\t\t\tclipRect.count += 1;\n\t\t}\n\n\t\tif (this.options.clip !== false) {\n\t\t\tthis.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n\t\t\tthis.markerGroup.clip(markerClipRect);\n\t\t\tthis.sharedClipKey = sharedClipKey;\n\t\t}\n\n\t\t// Remove the shared clipping rectancgle when all series are shown\n\t\tif (!animation) {\n\t\t\tclipRect.count -= 1;\n\t\t\tif (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n\t\t\t\tif (!seriesClipBox) {\n\t\t\t\t\tchart[sharedClipKey] = chart[sharedClipKey].destroy();\n\t\t\t\t}\n\t\t\t\tif (chart[sharedClipKey + 'm']) {\n\t\t\t\t\tchart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Animate in the series\n\t */\n\tanimate: function (init) {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\tclipRect,\n\t\t\tanimation = series.options.animation,\n\t\t\tsharedClipKey;\n\n\t\t// Animation option is set to true\n\t\tif (animation && !isObject(animation)) {\n\t\t\tanimation = defaultPlotOptions[series.type].animation;\n\t\t}\n\n\t\t// Initialize the animation. Set up the clipping rectangle.\n\t\tif (init) {\n\n\t\t\tseries.setClip(animation);\n\n\t\t// Run the animation\n\t\t} else {\n\t\t\tsharedClipKey = this.sharedClipKey;\n\t\t\tclipRect = chart[sharedClipKey];\n\t\t\tif (clipRect) {\n\t\t\t\tclipRect.animate({\n\t\t\t\t\twidth: chart.plotSizeX\n\t\t\t\t}, animation);\n\t\t\t}\n\t\t\tif (chart[sharedClipKey + 'm']) {\n\t\t\t\tchart[sharedClipKey + 'm'].animate({\n\t\t\t\t\twidth: chart.plotSizeX + 99\n\t\t\t\t}, animation);\n\t\t\t}\n\n\t\t\t// Delete this function to allow it only once\n\t\t\tseries.animate = null;\n \n\t\t}\n\t},\n\n\t/**\n\t * This runs after animation to land on the final plot clipping\n\t */\n\tafterAnimate: function () {\n\t\tthis.setClip();\n\t\tfireEvent(this, 'afterAnimate');\n\t},\n\n\t/**\n\t * Draw the markers\n\t */\n\tdrawPoints: function () {\n\t\tvar series = this,\n\t\t\tpointAttr,\n\t\t\tpoints = series.points,\n\t\t\tchart = series.chart,\n\t\t\tplotX,\n\t\t\tplotY,\n\t\t\ti,\n\t\t\tpoint,\n\t\t\tradius,\n\t\t\tsymbol,\n\t\t\tisImage,\n\t\t\tgraphic,\n\t\t\toptions = series.options,\n\t\t\tseriesMarkerOptions = options.marker,\n\t\t\tseriesPointAttr = series.pointAttr[''],\n\t\t\tpointMarkerOptions,\n\t\t\thasPointMarker,\n\t\t\tenabled,\n\t\t\tisInside,\n\t\t\tmarkerGroup = series.markerGroup,\n\t\t\txAxis = series.xAxis,\n\t\t\tgloballyEnabled = pick(\n\t\t\t\tseriesMarkerOptions.enabled, \n\t\t\t\txAxis.isRadial,\n\t\t\t\tseries.closestPointRangePx > 2 * seriesMarkerOptions.radius\n\t\t\t);\n\n\t\tif (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n\t\t\ti = points.length;\n\t\t\twhile (i--) {\n\t\t\t\tpoint = points[i];\n\t\t\t\tplotX = mathFloor(point.plotX); // #1843\n\t\t\t\tplotY = point.plotY;\n\t\t\t\tgraphic = point.graphic;\n\t\t\t\tpointMarkerOptions = point.marker || {};\n\t\t\t\thasPointMarker = !!point.marker;\n\t\t\t\tenabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n\t\t\t\tisInside = point.isInside;\n\n\t\t\t\t// only draw the point if y is defined\n\t\t\t\tif (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\n\t\t\t\t\t// shortcuts\n\t\t\t\t\tpointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;\n\t\t\t\t\tradius = pointAttr.r;\n\t\t\t\t\tsymbol = pick(pointMarkerOptions.symbol, series.symbol);\n\t\t\t\t\tisImage = symbol.indexOf('url') === 0;\n\n\t\t\t\t\tif (graphic) { // update\n\t\t\t\t\t\tgraphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n\t\t\t\t\t\t\t.animate(extend({\n\t\t\t\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\t\t\t\ty: plotY - radius\n\t\t\t\t\t\t\t}, graphic.symbolName ? { // don't apply to image symbols #507\n\t\t\t\t\t\t\t\twidth: 2 * radius,\n\t\t\t\t\t\t\t\theight: 2 * radius\n\t\t\t\t\t\t\t} : {}));\n\t\t\t\t\t} else if (isInside && (radius > 0 || isImage)) {\n\t\t\t\t\t\tpoint.graphic = graphic = chart.renderer.symbol(\n\t\t\t\t\t\t\tsymbol,\n\t\t\t\t\t\t\tplotX - radius,\n\t\t\t\t\t\t\tplotY - radius,\n\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\thasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t.add(markerGroup);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (graphic) {\n\t\t\t\t\tpoint.graphic = graphic.destroy(); // #1269\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t},\n\n\t/**\n\t * Convert state properties from API naming conventions to SVG attributes\n\t *\n\t * @param {Object} options API options object\n\t * @param {Object} base1 SVG attribute object to inherit from\n\t * @param {Object} base2 Second level SVG attribute object to inherit from\n\t */\n\tconvertAttribs: function (options, base1, base2, base3) {\n\t\tvar conversion = this.pointAttrToOptions,\n\t\t\tattr,\n\t\t\toption,\n\t\t\tobj = {};\n\n\t\toptions = options || {};\n\t\tbase1 = base1 || {};\n\t\tbase2 = base2 || {};\n\t\tbase3 = base3 || {};\n\n\t\tfor (attr in conversion) {\n\t\t\toption = conversion[attr];\n\t\t\tobj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n\t\t}\n\t\treturn obj;\n\t},\n\n\t/**\n\t * Get the state attributes. Each series type has its own set of attributes\n\t * that are allowed to change on a point's state change. Series wide attributes are stored for\n\t * all series, and additionally point specific attributes are stored for all\n\t * points with individual marker options. If such options are not defined for the point,\n\t * a reference to the series wide attributes is stored in point.pointAttr.\n\t */\n\tgetAttribs: function () {\n\t\tvar series = this,\n\t\t\tseriesOptions = series.options,\n\t\t\tnormalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,\n\t\t\tstateOptions = normalOptions.states,\n\t\t\tstateOptionsHover = stateOptions[HOVER_STATE],\n\t\t\tpointStateOptionsHover,\n\t\t\tseriesColor = series.color,\n\t\t\tseriesNegativeColor = series.options.negativeColor,\n\t\t\tnormalDefaults = {\n\t\t\t\tstroke: seriesColor,\n\t\t\t\tfill: seriesColor\n\t\t\t},\n\t\t\tpoints = series.points || [], // #927\n\t\t\ti,\n\t\t\tpoint,\n\t\t\tseriesPointAttr = [],\n\t\t\tpointAttr,\n\t\t\tpointAttrToOptions = series.pointAttrToOptions,\n\t\t\thasPointSpecificOptions = series.hasPointSpecificOptions,\n\t\t\tdefaultLineColor = normalOptions.lineColor,\n\t\t\tdefaultFillColor = normalOptions.fillColor,\n\t\t\tturboThreshold = seriesOptions.turboThreshold,\n\t\t\tzones = series.zones,\n\t\t\tzoneAxis = series.zoneAxis || 'y',\n\t\t\tattr,\n\t\t\tkey;\n\n\t\t// series type specific modifications\n\t\tif (seriesOptions.marker) { // line, spline, area, areaspline, scatter\n\n\t\t\t// if no hover radius is given, default to normal radius + 2\n\t\t\tstateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;\n\t\t\tstateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;\n\n\t\t} else { // column, bar, pie\n\n\t\t\t// if no hover color is given, brighten the normal color\n\t\t\tstateOptionsHover.color = stateOptionsHover.color ||\n\t\t\t\tColor(stateOptionsHover.color || seriesColor)\n\t\t\t\t\t.brighten(stateOptionsHover.brightness).get();\n\n\t\t\t// if no hover negativeColor is given, brighten the normal negativeColor\n\t\t\tstateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||\n\t\t\t\tColor(stateOptionsHover.negativeColor || seriesNegativeColor)\n\t\t\t\t\t.brighten(stateOptionsHover.brightness).get();\n\t\t}\n\n\t\t// general point attributes for the series normal state\n\t\tseriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n\t\t// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n\t\teach([HOVER_STATE, SELECT_STATE], function (state) {\n\t\t\tseriesPointAttr[state] =\n\t\t\t\t\tseries.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n\t\t});\n\n\t\t// set it\n\t\tseries.pointAttr = seriesPointAttr;\n\n\n\t\t// Generate the point-specific attribute collections if specific point\n\t\t// options are given. If not, create a referance to the series wide point\n\t\t// attributes\n\t\ti = points.length;\n\t\tif (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {\n\t\t\twhile (i--) {\n\t\t\t\tpoint = points[i];\n\t\t\t\tnormalOptions = (point.options && point.options.marker) || point.options;\n\t\t\t\tif (normalOptions && normalOptions.enabled === false) {\n\t\t\t\t\tnormalOptions.radius = 0;\n\t\t\t\t}\n\n\t\t\t\tif (zones.length) {\n\t\t\t\t\tvar j = 0,\n\t\t\t\t\t\tthreshold = zones[j];\n\t\t\t\t\twhile (point[zoneAxis] >= threshold.value) {\t\t\t\t\n\t\t\t\t\t\tthreshold = zones[++j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpoint.color = point.fillColor = threshold.color;\n\t\t\t\t}\n\n\t\t\t\thasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868\n\n\t\t\t\t// check if the point has specific visual options\n\t\t\t\tif (point.options) {\n\t\t\t\t\tfor (key in pointAttrToOptions) {\n\t\t\t\t\t\tif (defined(normalOptions[pointAttrToOptions[key]])) {\n\t\t\t\t\t\t\thasPointSpecificOptions = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a specific marker config object is defined for the individual point:\n\t\t\t\t// create it's own attribute collection\n\t\t\t\tif (hasPointSpecificOptions) {\n\t\t\t\t\tnormalOptions = normalOptions || {};\n\t\t\t\t\tpointAttr = [];\n\t\t\t\t\tstateOptions = normalOptions.states || {}; // reassign for individual point\n\t\t\t\t\tpointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n\t\t\t\t\t// Handle colors for column and pies\n\t\t\t\t\tif (!seriesOptions.marker) { // column, bar, point\n\t\t\t\t\t\t// If no hover color is given, brighten the normal color. #1619, #2579\n\t\t\t\t\t\tpointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||\n\t\t\t\t\t\t\tColor(point.color)\n\t\t\t\t\t\t\t\t.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)\n\t\t\t\t\t\t\t\t.get();\n\t\t\t\t\t}\n\n\t\t\t\t\t// normal point state inherits series wide normal state\n\t\t\t\t\tattr = { color: point.color }; // #868\n\t\t\t\t\tif (!defaultFillColor) { // Individual point color or negative color markers (#2219)\n\t\t\t\t\t\tattr.fillColor = point.color;\n\t\t\t\t\t}\n\t\t\t\t\tif (!defaultLineColor) {\n\t\t\t\t\t\tattr.lineColor = point.color; // Bubbles take point color, line markers use white\n\t\t\t\t\t}\n\t\t\t\t\tpointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n\t\t\t\t\t// inherit from point normal and series hover\n\t\t\t\t\tpointAttr[HOVER_STATE] = series.convertAttribs(\n\t\t\t\t\t\tstateOptions[HOVER_STATE],\n\t\t\t\t\t\tseriesPointAttr[HOVER_STATE],\n\t\t\t\t\t\tpointAttr[NORMAL_STATE]\n\t\t\t\t\t);\n\n\t\t\t\t\t// inherit from point normal and series hover\n\t\t\t\t\tpointAttr[SELECT_STATE] = series.convertAttribs(\n\t\t\t\t\t\tstateOptions[SELECT_STATE],\n\t\t\t\t\t\tseriesPointAttr[SELECT_STATE],\n\t\t\t\t\t\tpointAttr[NORMAL_STATE]\n\t\t\t\t\t);\n\n\n\t\t\t\t// no marker config object is created: copy a reference to the series-wide\n\t\t\t\t// attribute collection\n\t\t\t\t} else {\n\t\t\t\t\tpointAttr = seriesPointAttr;\n\t\t\t\t}\n\n\t\t\t\tpoint.pointAttr = pointAttr;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Clear DOM objects and free up memory\n\t */\n\tdestroy: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\tissue134 = /AppleWebKit\\/533/.test(userAgent),\n\t\t\tdestroy,\n\t\t\ti,\n\t\t\tdata = series.data || [],\n\t\t\tpoint,\n\t\t\tprop,\n\t\t\taxis;\n\n\t\t// add event hook\n\t\tfireEvent(series, 'destroy');\n\n\t\t// remove all events\n\t\tremoveEvent(series);\n\n\t\t// erase from axes\n\t\teach(series.axisTypes || [], function (AXIS) {\n\t\t\taxis = series[AXIS];\n\t\t\tif (axis) {\n\t\t\t\terase(axis.series, series);\n\t\t\t\taxis.isDirty = axis.forceRedraw = true;\n\t\t\t}\n\t\t});\n\n\t\t// remove legend items\n\t\tif (series.legendItem) {\n\t\t\tseries.chart.legend.destroyItem(series);\n\t\t}\n\n\t\t// destroy all points with their elements\n\t\ti = data.length;\n\t\twhile (i--) {\n\t\t\tpoint = data[i];\n\t\t\tif (point && point.destroy) {\n\t\t\t\tpoint.destroy();\n\t\t\t}\n\t\t}\n\t\tseries.points = null;\n\n\t\t// Clear the animation timeout if we are destroying the series during initial animation\n\t\tclearTimeout(series.animationTimeout);\n\n\t\t// destroy all SVGElements associated to the series\n\t\teach(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',\n\t\t\t\t'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {\n\t\t\tif (series[prop]) {\n\n\t\t\t\t// issue 134 workaround\n\t\t\t\tdestroy = issue134 && prop === 'group' ?\n\t\t\t\t\t'hide' :\n\t\t\t\t\t'destroy';\n\n\t\t\t\tseries[prop][destroy]();\n\t\t\t}\n\t\t});\n\n\t\t// remove from hoverSeries\n\t\tif (chart.hoverSeries === series) {\n\t\t\tchart.hoverSeries = null;\n\t\t}\n\t\terase(chart.series, series);\n\n\t\t// clear all members\n\t\tfor (prop in series) {\n\t\t\tdelete series[prop];\n\t\t}\n\t},\n\n\t/**\n\t * Return the graph path of a segment\n\t */\n\tgetSegmentPath: function (segment) {\n\t\tvar series = this,\n\t\t\tsegmentPath = [],\n\t\t\tstep = series.options.step;\n\n\t\t// build the segment line\n\t\teach(segment, function (point, i) {\n\n\t\t\tvar plotX = point.plotX,\n\t\t\t\tplotY = point.plotY,\n\t\t\t\tlastPoint;\n\n\t\t\tif (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n\t\t\t\tsegmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n\n\t\t\t} else {\n\n\t\t\t\t// moveTo or lineTo\n\t\t\t\tsegmentPath.push(i ? L : M);\n\n\t\t\t\t// step line?\n\t\t\t\tif (step && i) {\n\t\t\t\t\tlastPoint = segment[i - 1];\n\t\t\t\t\tif (step === 'right') {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\tlastPoint.plotX,\n\t\t\t\t\t\t\tplotY\n\t\t\t\t\t\t);\n\n\t\t\t\t\t} else if (step === 'center') {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\tlastPoint.plotY,\n\t\t\t\t\t\t\t(lastPoint.plotX + plotX) / 2,\n\t\t\t\t\t\t\tplotY\n\t\t\t\t\t\t);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsegmentPath.push(\n\t\t\t\t\t\t\tplotX,\n\t\t\t\t\t\t\tlastPoint.plotY\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// normal line to next point\n\t\t\t\tsegmentPath.push(\n\t\t\t\t\tpoint.plotX,\n\t\t\t\t\tpoint.plotY\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\treturn segmentPath;\n\t},\n\n\t/**\n\t * Get the graph path\n\t */\n\tgetGraphPath: function () {\n\t\tvar series = this,\n\t\t\tgraphPath = [],\n\t\t\tsegmentPath,\n\t\t\tsinglePoints = []; // used in drawTracker\n\n\t\t// Divide into segments and build graph and area paths\n\t\teach(series.segments, function (segment) {\n\n\t\t\tsegmentPath = series.getSegmentPath(segment);\n\n\t\t\t// add the segment to the graph, or a single point for tracking\n\t\t\tif (segment.length > 1) {\n\t\t\t\tgraphPath = graphPath.concat(segmentPath);\n\t\t\t} else {\n\t\t\t\tsinglePoints.push(segment[0]);\n\t\t\t}\n\t\t});\n\n\t\t// Record it for use in drawGraph and drawTracker, and return graphPath\n\t\tseries.singlePoints = singlePoints;\n\t\tseries.graphPath = graphPath;\n\n\t\treturn graphPath;\n\n\t},\n\n\t/**\n\t * Draw the actual graph\n\t */\n\tdrawGraph: function () {\n\t\tvar series = this,\n\t\t\toptions = this.options,\n\t\t\tprops = [['graph', options.lineColor || this.color, options.dashStyle]],\n\t\t\tlineWidth = options.lineWidth,\n\t\t\troundCap = options.linecap !== 'square',\n\t\t\tgraphPath = this.getGraphPath(),\n\t\t\tfillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph\n\t\t\tzones = this.zones;\n\n\t\teach(zones, function (threshold, i) {\n\t\t\tprops.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n\t\t});\n\t\t\n\t\t// Draw the graph\n\t\teach(props, function (prop, i) {\n\t\t\tvar graphKey = prop[0],\n\t\t\t\tgraph = series[graphKey],\n\t\t\t\tattribs;\n\n\t\t\tif (graph) {\n\t\t\t\tstop(graph); // cancel running animations, #459\n\t\t\t\tgraph.animate({ d: graphPath });\n\n\t\t\t} else if ((lineWidth || fillColor) && graphPath.length) { // #1487\n\t\t\t\tattribs = {\n\t\t\t\t\tstroke: prop[1],\n\t\t\t\t\t'stroke-width': lineWidth,\n\t\t\t\t\tfill: fillColor,\n\t\t\t\t\tzIndex: 1 // #1069\n\t\t\t\t};\n\t\t\t\tif (prop[2]) {\n\t\t\t\t\tattribs.dashstyle = prop[2];\n\t\t\t\t} else if (roundCap) {\n\t\t\t\t\tattribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n\t\t\t\t}\n\n\t\t\t\tseries[graphKey] = series.chart.renderer.path(graphPath)\n\t\t\t\t\t.attr(attribs)\n\t\t\t\t\t.add(series.group)\n\t\t\t\t\t.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Clip the graphs into the positive and negative coloured graphs\n\t */\n\tapplyZones: function () {\n\t\tvar series = this,\n\t\t\tchart = this.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tzones = this.zones,\n\t\t\ttranslatedFrom,\n\t\t\ttranslatedTo,\n\t\t\tclips = this.clips || [],\n\t\t\tclipAttr,\n\t\t\tgraph = this.graph,\n\t\t\tarea = this.area,\n\t\t\tchartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),\n\t\t\tzoneAxis = this.zoneAxis || 'y',\n\t\t\taxis = this[zoneAxis + 'Axis'],\n\t\t\treversed = axis.reversed,\n\t\t\thoriz = axis.horiz,\n\t\t\tignoreZones = false;\n\n\t\tif (zones.length && (graph || area)) {\n\t\t\t// The use of the Color Threshold assumes there are no gaps\n\t\t\t// so it is safe to hide the original graph and area\n\t\t\tgraph.hide();\n\t\t\tif (area) { area.hide(); }\n\n\t\t\t// Create the clips\n\t\t\teach(zones, function (threshold, i) {\n\t\t\t\ttranslatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));\n\t\t\t\ttranslatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));\n\n\t\t\t\tif (ignoreZones) {\n\t\t\t\t\ttranslatedFrom = translatedTo = axis.toPixels(axis.max);\n\t\t\t\t}\n\n\t\t\t\tif (axis.isXAxis) {\n\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\tx: reversed ? translatedTo : translatedFrom,\n\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\twidth: Math.abs(translatedFrom - translatedTo), \n\t\t\t\t\t\theight: chartSizeMax\n\t\t\t\t\t};\n\t\t\t\t\tif (!horiz) {\n\t\t\t\t\t\tclipAttr.x = chart.plotHeight - clipAttr.x;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\ty: reversed ? translatedFrom : translatedTo,\n\t\t\t\t\t\twidth: chartSizeMax, \n\t\t\t\t\t\theight: Math.abs(translatedFrom - translatedTo)\n\t\t\t\t\t};\n\t\t\t\t\tif (horiz) {\n\t\t\t\t\t\tclipAttr.y = chart.plotWidth - clipAttr.y;\n\t\t\t\t\t}\n\t\t\t\t} \n\n\t\t\t\t/// VML SUPPPORT\n\t\t\t\tif (chart.inverted && renderer.isVML) {\n\t\t\t\t\tif (axis.isXAxis) {\t\t\t\n\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\ty: reversed ? translatedFrom : translatedTo,\n\t\t\t\t\t\t\theight: clipAttr.width,\n\t\t\t\t\t\t\twidth: chart.chartWidth\n\t\t\t\t\t\t};\t\t\n\t\t\t\t\t} else {\t\t\t\t\n\t\t\t\t\t\tclipAttr = {\n\t\t\t\t\t\t\tx: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\twidth: clipAttr.height,\n\t\t\t\t\t\t\theight: chart.chartHeight\n\t\t\t\t\t\t};\t\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t\t/// END OF VML SUPPORT\n\n\t\t\t\tif (clips[i]) {\n\t\t\t\t\tclips[i].animate(clipAttr);\n\t\t\t\t} else {\n\t\t\t\t\tclips[i] = renderer.clipRect(clipAttr);\n\n\t\t\t\t\tseries['colorGraph' + i].clip(clips[i]);\n\n\t\t\t\t\tif (area) {\n\t\t\t\t\t\tseries['colorArea' + i].clip(clips[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if this zone extends out of the axis, ignore the others\n\t\t\t\tignoreZones = threshold.value > axis.max;\n\t\t\t});\n\t\t\tthis.clips = clips;\n\t\t}\n\t},\n\n\t/**\n\t * Initialize and perform group inversion on series.group and series.markerGroup\n\t */\n\tinvertGroups: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart;\n\n\t\t// Pie, go away (#1736)\n\t\tif (!series.xAxis) {\n\t\t\treturn;\n\t\t}\n\n\t\t// A fixed size is needed for inversion to work\n\t\tfunction setInvert() {\n\t\t\tvar size = {\n\t\t\t\twidth: series.yAxis.len,\n\t\t\t\theight: series.xAxis.len\n\t\t\t};\n\n\t\t\teach(['group', 'markerGroup'], function (groupName) {\n\t\t\t\tif (series[groupName]) {\n\t\t\t\t\tseries[groupName].attr(size).invert();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\taddEvent(chart, 'resize', setInvert); // do it on resize\n\t\taddEvent(series, 'destroy', function () {\n\t\t\tremoveEvent(chart, 'resize', setInvert);\n\t\t});\n\n\t\t// Do it now\n\t\tsetInvert(); // do it now\n\n\t\t// On subsequent render and redraw, just do setInvert without setting up events again\n\t\tseries.invertGroups = setInvert;\n\t},\n\n\t/**\n\t * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n\t * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n\t */\n\tplotGroup: function (prop, name, visibility, zIndex, parent) {\n\t\tvar group = this[prop],\n\t\t\tisNew = !group;\n\n\t\t// Generate it on first call\n\t\tif (isNew) {\n\t\t\tthis[prop] = group = this.chart.renderer.g(name)\n\t\t\t\t.attr({\n\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\tzIndex: zIndex || 0.1 // IE8 needs this\n\t\t\t\t})\n\t\t\t\t.add(parent);\n\t\t}\n\t\t// Place it on first and subsequent (redraw) calls\n\t\tgroup[isNew ? 'attr' : 'animate'](this.getPlotBox());\n\t\treturn group;\n\t},\n\n\t/**\n\t * Get the translation and scale for the plot area of this series\n\t */\n\tgetPlotBox: function () {\n\t\tvar chart = this.chart,\n\t\t\txAxis = this.xAxis,\n\t\t\tyAxis = this.yAxis;\n\n\t\t// Swap axes for inverted (#2339)\n\t\tif (chart.inverted) {\n\t\t\txAxis = yAxis;\n\t\t\tyAxis = this.xAxis;\n\t\t}\n\t\treturn {\n\t\t\ttranslateX: xAxis ? xAxis.left : chart.plotLeft,\n\t\t\ttranslateY: yAxis ? yAxis.top : chart.plotTop,\n\t\t\tscaleX: 1, // #1623\n\t\t\tscaleY: 1\n\t\t};\n\t},\n\n\t/**\n\t * Render the graph and markers\n\t */\n\trender: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\tgroup,\n\t\t\toptions = series.options,\n\t\t\tanimation = options.animation,\n\t\t\t// Animation doesn't work in IE8 quirks when the group div is hidden,\n\t\t\t// and looks bad in other oldIE\n\t\t\tanimDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,\n\t\t\tvisibility = series.visible ? VISIBLE : HIDDEN,\n\t\t\tzIndex = options.zIndex,\n\t\t\thasRendered = series.hasRendered,\n\t\t\tchartSeriesGroup = chart.seriesGroup;\n\n\t\t// the group\n\t\tgroup = series.plotGroup(\n\t\t\t'group',\n\t\t\t'series',\n\t\t\tvisibility,\n\t\t\tzIndex,\n\t\t\tchartSeriesGroup\n\t\t);\n\n\t\tseries.markerGroup = series.plotGroup(\n\t\t\t'markerGroup',\n\t\t\t'markers',\n\t\t\tvisibility,\n\t\t\tzIndex,\n\t\t\tchartSeriesGroup\n\t\t);\n\n\t\t// initiate the animation\n\t\tif (animDuration) {\n\t\t\tseries.animate(true);\n\t\t}\n\n\t\t// cache attributes for shapes\n\t\tseries.getAttribs();\n\n\t\t// SVGRenderer needs to know this before drawing elements (#1089, #1795)\n\t\tgroup.inverted = series.isCartesian ? chart.inverted : false;\n\n\t\t// draw the graph if any\n\t\tif (series.drawGraph) {\n\t\t\tseries.drawGraph();\n\t\t\tseries.applyZones();\n\t\t}\n\n\t\teach(series.points, function (point) {\n\t\t\tif (point.redraw) {\n\t\t\t\tpoint.redraw();\n\t\t\t}\n\t\t});\n\n\t\t// draw the data labels (inn pies they go before the points)\n\t\tif (series.drawDataLabels) {\n\t\t\tseries.drawDataLabels();\n\t\t}\n\n\t\t// draw the points\n\t\tif (series.visible) {\n\t\t\tseries.drawPoints();\n\t\t}\n\n\n\t\t// draw the mouse tracking area\n\t\tif (series.drawTracker && series.options.enableMouseTracking !== false) {\n\t\t\tseries.drawTracker();\n\t\t}\n\n\t\t// Handle inverted series and tracker groups\n\t\tif (chart.inverted) {\n\t\t\tseries.invertGroups();\n\t\t}\n\n\t\t// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n\t\tif (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n\t\t\tgroup.clip(chart.clipRect);\n\t\t}\n\n\t\t// Run the animation\n\t\tif (animDuration) {\n\t\t\tseries.animate();\n\t\t} \n\n\t\t// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n\t\t// which should be available to the user).\n\t\tif (!hasRendered) {\n\t\t\tif (animDuration) {\n\t\t\t\tseries.animationTimeout = setTimeout(function () {\n\t\t\t\t\tseries.afterAnimate();\n\t\t\t\t}, animDuration);\n\t\t\t} else {\n\t\t\t\tseries.afterAnimate();\n\t\t\t}\n\t\t}\n\n\t\tseries.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n\t\t// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n\t\tseries.hasRendered = true;\n\t},\n\n\t/**\n\t * Redraw the series after an update in the axes.\n\t */\n\tredraw: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\twasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n\t\t\twasDirty = series.isDirty,\n\t\t\tgroup = series.group,\n\t\t\txAxis = series.xAxis,\n\t\t\tyAxis = series.yAxis;\n\n\t\t// reposition on resize\n\t\tif (group) {\n\t\t\tif (chart.inverted) {\n\t\t\t\tgroup.attr({\n\t\t\t\t\twidth: chart.plotWidth,\n\t\t\t\t\theight: chart.plotHeight\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tgroup.animate({\n\t\t\t\ttranslateX: pick(xAxis && xAxis.left, chart.plotLeft),\n\t\t\t\ttranslateY: pick(yAxis && yAxis.top, chart.plotTop)\n\t\t\t});\n\t\t}\n\n\t\tseries.translate();\n\t\tseries.render();\n\t\tif (wasDirtyData) {\n\t\t\tfireEvent(series, 'updatedData');\n\t\t}\n\t\tif (wasDirty || wasDirtyData) {\t\t\t// #3945 recalculate the kdtree when dirty\n\t\t\tdelete this.kdTree; // #3868 recalculate the kdtree with dirty data\n\t\t}\n\t},\n\n\t/**\n\t * KD Tree && PointSearching Implementation\n\t */\n\n\tkdDimensions: 1,\n\tkdTree: null,\n\tkdAxisArray: ['plotX', 'plotY'],\n\tkdComparer: 'distX',\n\n\tsearchPoint: function (e) {\n\t\tvar series = this,\n\t\t\txAxis = series.xAxis,\n\t\t\tyAxis = series.yAxis,\n\t\t\tinverted = series.chart.inverted;\n\t\t\n\t\te.plotX = inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos;\n\t\te.plotY = inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos;\n\n\t\treturn this.searchKDTree(e);\n\t},\n\n\tbuildKDTree: function () {\n\t\tvar series = this,\n\t\t\tdimensions = series.kdDimensions;\n\n\t\t// Internal function\n\t\tfunction _kdtree(points, depth, dimensions) {\n\t\t\tvar axis, median, length = points && points.length;\n\n\t\t\tif (length) {\n\n\t\t\t\t// alternate between the axis\n\t\t\t\taxis = series.kdAxisArray[depth % dimensions];\n\n\t\t\t\t// sort point array\n\t\t\t\tpoints.sort(function(a, b) {\n\t\t\t\t\treturn a[axis] - b[axis];\n\t\t\t\t});\n\t\t\t\n\t\t\t\tmedian = Math.floor(length / 2);\n\t\t\t\t\n\t\t\t\t// build and return node\n\t\t\t\treturn {\n\t\t\t\t\tpoint: points[median],\n\t\t\t\t\tleft: _kdtree(points.slice(0, median), depth + 1, dimensions),\n\t\t\t\t\tright: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n\t\t\t\t};\n\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t// Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n\t\tfunction startRecursive() {\n\t\t\tvar points = grep(series.points, function (point) {\n\t\t\t\treturn point.y !== null;\n\t\t\t});\n\t\t\tseries.kdTree = _kdtree(points, dimensions, dimensions);\t\t\n\t\t}\n\n\t\tdelete series.kdTree;\n\t\t\n\t\tif (series.options.kdSync) {  // For testing tooltips, don't build async\n\t\t\tstartRecursive();\n\t\t} else {\n\t\t\tsetTimeout(startRecursive);\n\t\t}\n\t},\n\n\tsearchKDTree: function (point) {\n\t\tvar series = this,\n\t\t\tkdComparer = this.kdComparer,\n\t\t\tkdX = this.kdAxisArray[0],\n\t\t\tkdY = this.kdAxisArray[1];\n\n\t\t// Internal function\n\t\tfunction _distance(p1, p2) {\n\t\t\tvar x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n\t\t\t\ty = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n\t\t\t\tr = (x || 0) + (y || 0);\n\t\t\t\t\n\t\t\treturn {\n\t\t\t\tdistX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,\n\t\t\t\tdistY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,\n\t\t\t\tdistR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE\n\t\t\t};\n\t\t}\n\t\tfunction _search(search, tree, depth, dimensions) {\n\t\t\tvar point = tree.point,\n\t\t\t\taxis = series.kdAxisArray[depth % dimensions],\n\t\t\t\ttdist,\n\t\t\t\tsideA,\n\t\t\t\tsideB,\n\t\t\t\tret = point,\n\t\t\t\tnPoint1,\n\t\t\t\tnPoint2;\n\t\t\tpoint.dist = _distance(search, point);\n\n\t\t\t// Pick side based on distance to splitting point\n\t\t\ttdist = search[axis] - point[axis];\n\t\t\tsideA = tdist < 0 ? 'left' : 'right';\n\n\t\t\t// End of tree\n\t\t\tif (tree[sideA]) {\n\t\t\t\tnPoint1 =_search(search, tree[sideA], depth + 1, dimensions);\n\n\t\t\t\tret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);\n\n\t\t\t\tsideB = tdist < 0 ? 'right' : 'left';\n\t\t\t\tif (tree[sideB]) {\n\t\t\t\t\t// compare distance to current best to splitting point to decide wether to check side B or not\n\t\t\t\t\tif (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {\n\t\t\t\t\t\tnPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n\t\t\t\t\t\tret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!this.kdTree) {\n\t\t\tthis.buildKDTree();\n\t\t}\n\n\t\tif (this.kdTree) {\n\t\t\treturn _search(point, \n\t\t\t\tthis.kdTree, this.kdDimensions, this.kdDimensions);\n\t\t}\n\t}\n\n}; // end Series prototype\n\n/**\n * The class for stack items\n */\nfunction StackItem(axis, options, isNegative, x, stackOption) {\n\t\n\tvar inverted = axis.chart.inverted;\n\n\tthis.axis = axis;\n\n\t// Tells if the stack is negative\n\tthis.isNegative = isNegative;\n\n\t// Save the options to be able to style the label\n\tthis.options = options;\n\n\t// Save the x value to be able to position the label later\n\tthis.x = x;\n\n\t// Initialize total value\n\tthis.total = null;\n\n\t// This will keep each points' extremes stored by series.index and point index\n\tthis.points = {};\n\n\t// Save the stack option on the series configuration object, and whether to treat it as percent\n\tthis.stack = stackOption;\n\n\t// The align options and text align varies on whether the stack is negative and\n\t// if the chart is inverted or not.\n\t// First test the user supplied value, then use the dynamic.\n\tthis.alignOptions = {\n\t\talign: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n\t\tverticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n\t\ty: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n\t\tx: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n\t};\n\n\tthis.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n}\n\nStackItem.prototype = {\n\tdestroy: function () {\n\t\tdestroyObjectProperties(this, this.axis);\n\t},\n\n\t/**\n\t * Renders the stack total label and adds it to the stack label group.\n\t */\n\trender: function (group) {\n\t\tvar options = this.options,\n\t\t\tformatOption = options.format,\n\t\t\tstr = formatOption ?\n\t\t\t\tformat(formatOption, this) : \n\t\t\t\toptions.formatter.call(this);  // format the text in the label\n\n\t\t// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n\t\tif (this.label) {\n\t\t\tthis.label.attr({text: str, visibility: HIDDEN});\n\t\t// Create new label\n\t\t} else {\n\t\t\tthis.label =\n\t\t\t\tthis.axis.chart.renderer.text(str, null, null, options.useHTML)\t\t// dummy positions, actual position updated with setOffset method in columnseries\n\t\t\t\t\t.css(options.style)\t\t\t\t// apply style\n\t\t\t\t\t.attr({\n\t\t\t\t\t\talign: this.textAlign,\t\t\t\t// fix the text-anchor\n\t\t\t\t\t\trotation: options.rotation,\t// rotation\n\t\t\t\t\t\tvisibility: HIDDEN\t\t\t\t\t// hidden until setOffset is called\n\t\t\t\t\t})\t\t\t\t\n\t\t\t\t\t.add(group);\t\t\t\t\t\t\t// add to the labels-group\n\t\t}\n\t},\n\n\t/**\n\t * Sets the offset that the stack has from the x value and repositions the label.\n\t */\n\tsetOffset: function (xOffset, xWidth) {\n\t\tvar stackItem = this,\n\t\t\taxis = stackItem.axis,\n\t\t\tchart = axis.chart,\n\t\t\tinverted = chart.inverted,\n\t\t\tneg = this.isNegative,\t\t\t\t\t\t\t// special treatment is needed for negative stacks\n\t\t\ty = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n\t\t\tyZero = axis.translate(0),\t\t\t\t\t\t// stack origin\n\t\t\th = mathAbs(y - yZero),\t\t\t\t\t\t\t// stack height\n\t\t\tx = chart.xAxis[0].translate(this.x) + xOffset,\t// stack x position\n\t\t\tplotHeight = chart.plotHeight,\n\t\t\tstackBox = {\t// this is the box for the complete stack\n\t\t\t\tx: inverted ? (neg ? y : y - h) : x,\n\t\t\t\ty: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n\t\t\t\twidth: inverted ? h : xWidth,\n\t\t\t\theight: inverted ? xWidth : h\n\t\t\t},\n\t\t\tlabel = this.label,\n\t\t\talignAttr;\n\t\t\n\t\tif (label) {\n\t\t\tlabel.align(this.alignOptions, null, stackBox);\t// align the label to the box\n\t\t\t\t\n\t\t\t// Set visibility (#678)\n\t\t\talignAttr = label.alignAttr;\n\t\t\tlabel[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n\t\t}\n\t}\n};\n\n\n// Stacking methods defined on the Axis prototype\n\n/**\n * Build the stacks from top down\n */\nAxis.prototype.buildStacks = function () {\n\tvar series = this.series,\n\t\treversedStacks = pick(this.options.reversedStacks, true),\n\t\ti = series.length;\n\tif (!this.isXAxis) {\n\t\tthis.usePercentage = false;\n\t\twhile (i--) {\n\t\t\tseries[reversedStacks ? i : series.length - i - 1].setStackedPoints();\n\t\t}\n\t\t// Loop up again to compute percent stack\n\t\tif (this.usePercentage) {\n\t\t\tfor (i = 0; i < series.length; i++) {\n\t\t\t\tseries[i].setPercentStacks();\n\t\t\t}\n\t\t}\n\t}\n};\n\nAxis.prototype.renderStackTotals = function () {\n\tvar axis = this,\n\t\tchart = axis.chart,\n\t\trenderer = chart.renderer,\n\t\tstacks = axis.stacks,\n\t\tstackKey, \n\t\toneStack, \n\t\tstackCategory,\n\t\tstackTotalGroup = axis.stackTotalGroup;\n\n\t// Create a separate group for the stack total labels\n\tif (!stackTotalGroup) {\n\t\taxis.stackTotalGroup = stackTotalGroup =\n\t\t\trenderer.g('stack-labels')\n\t\t\t\t.attr({\n\t\t\t\t\tvisibility: VISIBLE,\n\t\t\t\t\tzIndex: 6\n\t\t\t\t})\n\t\t\t\t.add();\n\t}\n\n\t// plotLeft/Top will change when y axis gets wider so we need to translate the\n\t// stackTotalGroup at every render call. See bug #506 and #516\n\tstackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n\t// Render each stack total\n\tfor (stackKey in stacks) {\n\t\toneStack = stacks[stackKey];\n\t\tfor (stackCategory in oneStack) {\n\t\t\toneStack[stackCategory].render(stackTotalGroup);\n\t\t}\n\t}\n};\n\n\n// Stacking methods defnied for Series prototype\n\n/**\n * Adds series' points value to corresponding stack\n */\nSeries.prototype.setStackedPoints = function () {\n\tif (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n\t\treturn;\n\t}\n\n\tvar series = this,\n\t\txData = series.processedXData,\n\t\tyData = series.processedYData,\n\t\tstackedYData = [],\n\t\tyDataLength = yData.length,\n\t\tseriesOptions = series.options,\n\t\tthreshold = seriesOptions.threshold,\n\t\tstackOption = seriesOptions.stack,\n\t\tstacking = seriesOptions.stacking,\n\t\tstackKey = series.stackKey,\n\t\tnegKey = '-' + stackKey,\n\t\tnegStacks = series.negStacks,\n\t\tyAxis = series.yAxis,\n\t\tstacks = yAxis.stacks,\n\t\toldStacks = yAxis.oldStacks,\n\t\tisNegative,\n\t\tstack,\n\t\tother,\n\t\tkey,\n\t\tpointKey,\n\t\ti,\n\t\tx,\n\t\ty;\n\n\t// loop over the non-null y values and read them into a local array\n\tfor (i = 0; i < yDataLength; i++) {\n\t\tx = xData[i];\n\t\ty = yData[i];\n\t\tpointKey = series.index + ',' + i;\n\n\t\t// Read stacked values into a stack based on the x value,\n\t\t// the sign of y and the stack key. Stacking is also handled for null values (#739)\n\t\tisNegative = negStacks && y < threshold;\n\t\tkey = isNegative ? negKey : stackKey;\n\n\t\t// Create empty object for this stack if it doesn't exist yet\n\t\tif (!stacks[key]) {\n\t\t\tstacks[key] = {};\n\t\t}\n\n\t\t// Initialize StackItem for this x\n\t\tif (!stacks[key][x]) {\n\t\t\tif (oldStacks[key] && oldStacks[key][x]) {\n\t\t\t\tstacks[key][x] = oldStacks[key][x];\n\t\t\t\tstacks[key][x].total = null;\n\t\t\t} else {\n\t\t\t\tstacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n\t\t\t}\n\t\t}\n\n\t\t// If the StackItem doesn't exist, create it first\n\t\tstack = stacks[key][x];\n\t\tstack.points[pointKey] = [stack.cum || 0];\n\n\t\t// Add value to the stack total\n\t\tif (stacking === 'percent') {\n\n\t\t\t// Percent stacked column, totals are the same for the positive and negative stacks\n\t\t\tother = isNegative ? stackKey : negKey;\n\t\t\tif (negStacks && stacks[other] && stacks[other][x]) {\n\t\t\t\tother = stacks[other][x];\n\t\t\t\tstack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;\n\n\t\t\t// Percent stacked areas\n\t\t\t} else {\n\t\t\t\tstack.total = correctFloat(stack.total + (mathAbs(y) || 0));\n\t\t\t}\n\t\t} else {\n\t\t\tstack.total = correctFloat(stack.total + (y || 0));\n\t\t}\n\n\t\tstack.cum = (stack.cum || 0) + (y || 0);\n\n\t\tstack.points[pointKey].push(stack.cum);\n\t\tstackedYData[i] = stack.cum;\n\n\t}\n\n\tif (stacking === 'percent') {\n\t\tyAxis.usePercentage = true;\n\t}\n\n\tthis.stackedYData = stackedYData; // To be used in getExtremes\n\n\t// Reset old stacks\n\tyAxis.oldStacks = {};\n};\n\n/**\n * Iterate over all stacks and compute the absolute values to percent\n */\nSeries.prototype.setPercentStacks = function () {\n\tvar series = this,\n\t\tstackKey = series.stackKey,\n\t\tstacks = series.yAxis.stacks,\n\t\tprocessedXData = series.processedXData;\n\n\teach([stackKey, '-' + stackKey], function (key) {\n\t\tvar i = processedXData.length,\n\t\t\tx,\n\t\t\tstack,\n\t\t\tpointExtremes,\n\t\t\ttotalFactor;\n\n\t\twhile (i--) {\n\t\t\tx = processedXData[i];\n\t\t\tstack = stacks[key] && stacks[key][x];\n\t\t\tpointExtremes = stack && stack.points[series.index + ',' + i];\n\t\t\tif (pointExtremes) {\n\t\t\t\ttotalFactor = stack.total ? 100 / stack.total : 0;\n\t\t\t\tpointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n\t\t\t\tpointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n\t\t\t\tseries.stackedYData[i] = pointExtremes[1];\n\t\t\t}\n\t\t}\n\t});\n};\n\n// Extend the Chart prototype for dynamic methods\nextend(Chart.prototype, {\n\n\t/**\n\t * Add a series dynamically after  time\n\t *\n\t * @param {Object} options The config options\n\t * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t *\n\t * @return {Object} series The newly created series object\n\t */\n\taddSeries: function (options, redraw, animation) {\n\t\tvar series,\n\t\t\tchart = this;\n\n\t\tif (options) {\n\t\t\tredraw = pick(redraw, true); // defaults to true\n\n\t\t\tfireEvent(chart, 'addSeries', { options: options }, function () {\n\t\t\t\tseries = chart.initSeries(options);\n\n\t\t\t\tchart.isDirtyLegend = true; // the series array is out of sync with the display\n\t\t\t\tchart.linkSeries();\n\t\t\t\tif (redraw) {\n\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn series;\n\t},\n\n\t/**\n     * Add an axis to the chart\n     * @param {Object} options The axis option\n     * @param {Boolean} isX Whether it is an X axis or a value axis\n     */\n\taddAxis: function (options, isX, redraw, animation) {\n\t\tvar key = isX ? 'xAxis' : 'yAxis',\n\t\t\tchartOptions = this.options,\n\t\t\taxis;\n\n\t\t/*jslint unused: false*/\n\t\taxis = new Axis(this, merge(options, {\n\t\t\tindex: this[key].length,\n\t\t\tisX: isX\n\t\t}));\n\t\t/*jslint unused: true*/\n\n\t\t// Push the new axis options to the chart options\n\t\tchartOptions[key] = splat(chartOptions[key] || {});\n\t\tchartOptions[key].push(options);\n\n\t\tif (pick(redraw, true)) {\n\t\t\tthis.redraw(animation);\n\t\t}\n\t},\n\n\t/**\n\t * Dim the chart and show a loading text or symbol\n\t * @param {String} str An optional text to show in the loading label instead of the default one\n\t */\n\tshowLoading: function (str) {\n\t\tvar chart = this,\n\t\t\toptions = chart.options,\n\t\t\tloadingDiv = chart.loadingDiv,\n\t\t\tloadingOptions = options.loading,\n\t\t\tsetLoadingSize = function () {\n\t\t\t\tif (loadingDiv) {\n\t\t\t\t\tcss(loadingDiv, {\n\t\t\t\t\t\tleft: chart.plotLeft + PX,\n\t\t\t\t\t\ttop: chart.plotTop + PX,\n\t\t\t\t\t\twidth: chart.plotWidth + PX,\n\t\t\t\t\t\theight: chart.plotHeight + PX\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t// create the layer at the first call\n\t\tif (!loadingDiv) {\n\t\t\tchart.loadingDiv = loadingDiv = createElement(DIV, {\n\t\t\t\tclassName: PREFIX + 'loading'\n\t\t\t}, extend(loadingOptions.style, {\n\t\t\t\tzIndex: 10,\n\t\t\t\tdisplay: NONE\n\t\t\t}), chart.container);\n\n\t\t\tchart.loadingSpan = createElement(\n\t\t\t\t'span',\n\t\t\t\tnull,\n\t\t\t\tloadingOptions.labelStyle,\n\t\t\t\tloadingDiv\n\t\t\t);\n\t\t\taddEvent(chart, 'redraw', setLoadingSize); // #1080\n\t\t}\n\n\t\t// update text\n\t\tchart.loadingSpan.innerHTML = str || options.lang.loading;\n\n\t\t// show it\n\t\tif (!chart.loadingShown) {\n\t\t\tcss(loadingDiv, {\n\t\t\t\topacity: 0,\n\t\t\t\tdisplay: ''\t\t\t\t\n\t\t\t});\n\t\t\tanimate(loadingDiv, {\n\t\t\t\topacity: loadingOptions.style.opacity\n\t\t\t}, {\n\t\t\t\tduration: loadingOptions.showDuration || 0\n\t\t\t});\n\t\t\tchart.loadingShown = true;\n\t\t}\n\t\tsetLoadingSize();\n\t},\n\n\t/**\n\t * Hide the loading layer\n\t */\n\thideLoading: function () {\n\t\tvar options = this.options,\n\t\t\tloadingDiv = this.loadingDiv;\n\n\t\tif (loadingDiv) {\n\t\t\tanimate(loadingDiv, {\n\t\t\t\topacity: 0\n\t\t\t}, {\n\t\t\t\tduration: options.loading.hideDuration || 100,\n\t\t\t\tcomplete: function () {\n\t\t\t\t\tcss(loadingDiv, { display: NONE });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.loadingShown = false;\n\t}\n});\n\n// extend the Point prototype for dynamic methods\nextend(Point.prototype, {\n\t/**\n\t * Update the point with new options (typically x/y data) and optionally redraw the series.\n\t *\n\t * @param {Object} options Point options as defined in the series.data array\n\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t *\n\t */\n\tupdate: function (options, redraw, animation, runEvent) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tgraphic = point.graphic,\n\t\t\ti,\n\t\t\tchart = series.chart,\n\t\t\tseriesOptions = series.options,\n\t\t\tnames = series.xAxis && series.xAxis.names;\n\n\t\tredraw = pick(redraw, true);\n\n\t\tfunction update() {\n\n\t\t\tpoint.applyOptions(options);\n\n\t\t\t// Update visuals\n\t\t\tif (isObject(options) && !isArray(options)) {\n\t\t\t\t// Defer the actual redraw until getAttribs has been called (#3260)\n\t\t\t\tpoint.redraw = function () {\n\t\t\t\t\tif (graphic) {\n\t\t\t\t\t\tif (options && options.marker && options.marker.symbol) {\n\t\t\t\t\t\t\tpoint.graphic = graphic.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgraphic.attr(point.pointAttr[point.state || '']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (options && options.dataLabels && point.dataLabel) { // #2468\n\t\t\t\t\t\tpoint.dataLabel = point.dataLabel.destroy();\n\t\t\t\t\t}\n\t\t\t\t\tpoint.redraw = null;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// record changes in the parallel arrays\n\t\t\ti = point.index;\n\t\t\tseries.updateParallelArrays(point, i);\n\t\t\tif (names && point.name) {\n\t\t\t\tnames[point.x] = point.name;\n\t\t\t}\n\n\t\t\tseriesOptions.data[i] = point.options;\n\n\t\t\t// redraw\n\t\t\tseries.isDirty = series.isDirtyData = true;\n\t\t\tif (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n\t\t\t\tchart.isDirtyBox = true;\n\t\t\t}\n\n\t\t\tif (chart.legend.display && seriesOptions.legendType === 'point') { // #1831, #1885, #3934\n\t\t\t\tseries.updateTotals();\n\t\t\t\tchart.legend.clearItems();\n\t\t\t}\n\t\t\tif (redraw) {\n\t\t\t\tchart.redraw(animation);\n\t\t\t}\n\t\t}\n\n\t\t// Fire the event with a default handler of doing the update\n\t\tif (runEvent === false) { // When called from setData\n\t\t\tupdate();\n\t\t} else {\n\t\t\tpoint.firePointEvent('update', { options: options }, update);\n\t\t}\n\t},\n\n\t/**\n\t * Remove a point and optionally redraw the series and if necessary the axes\n\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t */\n\tremove: function (redraw, animation) {\n\t\tthis.series.removePoint(inArray(this, this.series.data), redraw, animation);\n\t}\n});\n\n// Extend the series prototype for dynamic methods\nextend(Series.prototype, {\n\t/**\n\t * Add a point dynamically after chart load time\n\t * @param {Object} options Point options as given in series.data\n\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t * @param {Boolean} shift If shift is true, a point is shifted off the start\n\t *    of the series as one is appended to the end.\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t */\n\taddPoint: function (options, redraw, shift, animation) {\n\t\tvar series = this,\n\t\t\tseriesOptions = series.options,\n\t\t\tdata = series.data,\n\t\t\tgraph = series.graph,\n\t\t\tarea = series.area,\n\t\t\tchart = series.chart,\n\t\t\tnames = series.xAxis && series.xAxis.names,\n\t\t\tcurrentShift = (graph && graph.shift) || 0,\n\t\t\tdataOptions = seriesOptions.data,\n\t\t\tpoint,\n\t\t\tisInTheMiddle,\n\t\t\txData = series.xData,\n\t\t\tx,\n\t\t\ti;\n\n\t\tsetAnimation(animation, chart);\n\n\t\t// Make graph animate sideways\n\t\tif (shift) {\n\t\t\teach([graph, area, series.graphNeg, series.areaNeg], function (shape) {\n\t\t\t\tif (shape) {\n\t\t\t\t\tshape.shift = currentShift + 1;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (area) {\n\t\t\tarea.isArea = true; // needed in animation, both with and without shift\n\t\t}\n\n\t\t// Optional redraw, defaults to true\n\t\tredraw = pick(redraw, true);\n\n\t\t// Get options and push the point to xData, yData and series.options. In series.generatePoints\n\t\t// the Point instance will be created on demand and pushed to the series.data array.\n\t\tpoint = { series: series };\n\t\tseries.pointClass.prototype.applyOptions.apply(point, [options]);\n\t\tx = point.x;\n\n\t\t// Get the insertion point\n\t\ti = xData.length;\n\t\tif (series.requireSorting && x < xData[i - 1]) {\n\t\t\tisInTheMiddle = true;\n\t\t\twhile (i && xData[i - 1] > x) {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tseries.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n\t\tseries.updateParallelArrays(point, i); // update it\n\n\t\tif (names && point.name) {\n\t\t\tnames[x] = point.name;\n\t\t}\n\t\tdataOptions.splice(i, 0, options);\n\n\t\tif (isInTheMiddle) {\n\t\t\tseries.data.splice(i, 0, null);\n\t\t\tseries.processData();\n\t\t}\n\n\t\t// Generate points to be added to the legend (#1329)\n\t\tif (seriesOptions.legendType === 'point') {\n\t\t\tseries.generatePoints();\n\t\t}\n\n\t\t// Shift the first point off the parallel arrays\n\t\t// todo: consider series.removePoint(i) method\n\t\tif (shift) {\n\t\t\tif (data[0] && data[0].remove) {\n\t\t\t\tdata[0].remove(false);\n\t\t\t} else {\n\t\t\t\tdata.shift();\n\t\t\t\tseries.updateParallelArrays(point, 'shift');\n\n\t\t\t\tdataOptions.shift();\n\t\t\t}\n\t\t}\n\n\t\t// redraw\n\t\tseries.isDirty = true;\n\t\tseries.isDirtyData = true;\n\t\tif (redraw) {\n\t\t\tseries.getAttribs(); // #1937\n\t\t\tchart.redraw();\n\t\t}\n\t},\n\n\t/**\n\t * Remove a point (rendered or not), by index\n\t */\n\tremovePoint: function (i, redraw, animation) {\n\n\t\tvar series = this,\n\t\t\tdata = series.data,\n\t\t\tpoint = data[i],\n\t\t\tpoints = series.points,\n\t\t\tchart = series.chart,\n\t\t\tremove = function () {\n\n\t\t\t\tif (data.length === points.length) {\n\t\t\t\t\tpoints.splice(i, 1);\n\t\t\t\t}\n\t\t\t\tdata.splice(i, 1);\n\t\t\t\tseries.options.data.splice(i, 1);\n\t\t\t\tseries.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n\t\t\t\tif (point) {\n\t\t\t\t\tpoint.destroy();\n\t\t\t\t}\n\n\t\t\t\t// redraw\n\t\t\t\tseries.isDirty = true;\n\t\t\t\tseries.isDirtyData = true;\n\t\t\t\tif (redraw) {\n\t\t\t\t\tchart.redraw();\n\t\t\t\t}\n\t\t\t};\n\n\t\tsetAnimation(animation, chart);\n\t\tredraw = pick(redraw, true);\n\n\t\t// Fire the event with a default handler of removing the point\n\t\tif (point) {\n\t\t\tpoint.firePointEvent('remove', null, remove);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t},\n\n\t/**\n\t * Remove a series and optionally redraw the chart\n\t *\n\t * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n\t * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n\t *    configuration\n\t */\n\n\tremove: function (redraw, animation) {\n\t\tvar series = this,\n\t\t\tchart = series.chart;\n\t\tredraw = pick(redraw, true);\n\n\t\tif (!series.isRemoving) {  /* prevent triggering native event in jQuery\n\t\t\t\t(calling the remove function from the remove event) */\n\t\t\tseries.isRemoving = true;\n\n\t\t\t// fire the event with a default handler of removing the point\n\t\t\tfireEvent(series, 'remove', null, function () {\n\n\n\t\t\t\t// destroy elements\n\t\t\t\tseries.destroy();\n\n\n\t\t\t\t// redraw\n\t\t\t\tchart.isDirtyLegend = chart.isDirtyBox = true;\n\t\t\t\tchart.linkSeries();\n\n\t\t\t\tif (redraw) {\n\t\t\t\t\tchart.redraw(animation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t\tseries.isRemoving = false;\n\t},\n\n\t/**\n\t * Update the series with a new set of options\n\t */\n\tupdate: function (newOptions, redraw) {\n\t\tvar series = this,\n\t\t\tchart = this.chart,\n\t\t\t// must use user options when changing type because this.options is merged\n\t\t\t// in with type specific plotOptions\n\t\t\toldOptions = this.userOptions,\n\t\t\toldType = this.type,\n\t\t\tproto = seriesTypes[oldType].prototype,\n\t\t\tpreserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n\t\t\tn;\n\n\t\t// If we're changing type or zIndex, create new groups (#3380, #3404)\n\t\tif ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n\t\t\tpreserve.length = 0;\n\t\t}\n\n\t\t// Make sure groups are not destroyed (#3094)\n\t\teach(preserve, function (prop) {\n\t\t\tpreserve[prop] = series[prop];\n\t\t\tdelete series[prop];\n\t\t});\n\n\t\t// Do the merge, with some forced options\n\t\tnewOptions = merge(oldOptions, {\n\t\t\tanimation: false,\n\t\t\tindex: this.index,\n\t\t\tpointStart: this.xData[0] // when updating after addPoint\n\t\t}, { data: this.options.data }, newOptions);\n\n\t\t// Destroy the series and delete all properties. Reinsert all methods \n\t\t// and properties from the new type prototype (#2270, #3719)\n\t\tthis.remove(false);\n\t\tfor (n in proto) {\n\t\t\tthis[n] = UNDEFINED;\n\t\t}\n\t\textend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n\t\t// Re-register groups (#3094)\n\t\teach(preserve, function (prop) {\n\t\t\tseries[prop] = preserve[prop];\n\t\t});\n\n\t\tthis.init(chart, newOptions);\n\t\tchart.linkSeries(); // Links are lost in this.remove (#3028)\n\t\tif (pick(redraw, true)) {\n\t\t\tchart.redraw(false);\n\t\t}\n\t}\n});\n\n// Extend the Axis.prototype for dynamic methods\nextend(Axis.prototype, {\n\n\t/**\n\t * Update the axis with a new options structure\n\t */\n\tupdate: function (newOptions, redraw) {\n\t\tvar chart = this.chart;\n\n\t\tnewOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n\t\tthis.destroy(true);\n\t\tthis._addedPlotLB = UNDEFINED; // #1611, #2887\n\n\t\tthis.init(chart, extend(newOptions, { events: UNDEFINED }));\n\n\t\tchart.isDirtyBox = true;\n\t\tif (pick(redraw, true)) {\n\t\t\tchart.redraw();\n\t\t}\n\t},\n\n\t/**\n     * Remove the axis from the chart\n     */\n\tremove: function (redraw) {\n\t\tvar chart = this.chart,\n\t\t\tkey = this.coll, // xAxis or yAxis\n\t\t\taxisSeries = this.series,\n\t\t\ti = axisSeries.length;\n\n\t\t// Remove associated series (#2687)\n\t\twhile (i--) {\n\t\t\tif (axisSeries[i]) {\n\t\t\t\taxisSeries[i].remove(false);\n\t\t\t}\n\t\t}\n\n\t\t// Remove the axis\n\t\terase(chart.axes, this);\n\t\terase(chart[key], this);\n\t\tchart.options[key].splice(this.options.index, 1);\n\t\teach(chart[key], function (axis, i) { // Re-index, #1706\n\t\t\taxis.options.index = i;\n\t\t});\n\t\tthis.destroy();\n\t\tchart.isDirtyBox = true;\n\n\t\tif (pick(redraw, true)) {\n\t\t\tchart.redraw();\n\t\t}\n\t},\n\n\t/**\n\t * Update the axis title by options\n\t */\n\tsetTitle: function (newTitleOptions, redraw) {\n\t\tthis.update({ title: newTitleOptions }, redraw);\n\t},\n\n\t/**\n\t * Set new axis categories and optionally redraw\n\t * @param {Array} categories\n\t * @param {Boolean} redraw\n\t */\n\tsetCategories: function (categories, redraw) {\n\t\tthis.update({ categories: categories }, redraw);\n\t}\n\n});\n\n\n/**\n * LineSeries object\n */\nvar LineSeries = extendClass(Series);\nseriesTypes.line = LineSeries;\n\n/**\n * Set the default options for area\n */\ndefaultPlotOptions.area = merge(defaultSeriesOptions, {\n\tthreshold: 0\n\t// trackByArea: false,\n\t// lineColor: null, // overrides color, but lets fillColor be unaltered\n\t// fillOpacity: 0.75,\n\t// fillColor: null\n});\n\n/**\n * AreaSeries object\n */\nvar AreaSeries = extendClass(Series, {\n\ttype: 'area',\n\t/**\n\t * For stacks, don't split segments on null values. Instead, draw null values with \n\t * no marker. Also insert dummy points for any X position that exists in other series\n\t * in the stack.\n\t */ \n\tgetSegments: function () {\n\t\tvar series = this,\n\t\t\tsegments = [],\n\t\t\tsegment = [],\n\t\t\tkeys = [],\n\t\t\txAxis = this.xAxis,\n\t\t\tyAxis = this.yAxis,\n\t\t\tstack = yAxis.stacks[this.stackKey],\n\t\t\tpointMap = {},\n\t\t\tplotX,\n\t\t\tplotY,\n\t\t\tpoints = this.points,\n\t\t\tconnectNulls = this.options.connectNulls,\n\t\t\ti,\n\t\t\tx;\n\n\t\tif (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue\n\t\t\t// Create a map where we can quickly look up the points by their X value.\n\t\t\tfor (i = 0; i < points.length; i++) {\n\t\t\t\tpointMap[points[i].x] = points[i];\n\t\t\t}\n\n\t\t\t// Sort the keys (#1651)\n\t\t\tfor (x in stack) {\n\t\t\t\tif (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n\t\t\t\t\tkeys.push(+x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tkeys.sort(function (a, b) {\n\t\t\t\treturn a - b;\n\t\t\t});\n\n\t\t\teach(keys, function (x) {\n\t\t\t\tvar y = 0,\n\t\t\t\t\tstackPoint;\n\n\t\t\t\tif (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836\n\t\t\t\t\treturn;\n\n\t\t\t\t// The point exists, push it to the segment\n\t\t\t\t} else if (pointMap[x]) {\n\t\t\t\t\tsegment.push(pointMap[x]);\n\n\t\t\t\t// There is no point for this X value in this series, so we \n\t\t\t\t// insert a dummy point in order for the areas to be drawn\n\t\t\t\t// correctly.\n\t\t\t\t} else {\n\n\t\t\t\t\t// Loop down the stack to find the series below this one that has\n\t\t\t\t\t// a value (#1991)\n\t\t\t\t\tfor (i = series.index; i <= yAxis.series.length; i++) {\n\t\t\t\t\t\tstackPoint = stack[x].points[i + ',' + x];\n\t\t\t\t\t\tif (stackPoint) {\n\t\t\t\t\t\t\ty = stackPoint[1];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tplotX = xAxis.translate(x);\n\t\t\t\t\tplotY = yAxis.toPixels(y, true);\n\t\t\t\t\tsegment.push({ \n\t\t\t\t\t\ty: null, \n\t\t\t\t\t\tplotX: plotX,\n\t\t\t\t\t\tclientX: plotX, \n\t\t\t\t\t\tplotY: plotY, \n\t\t\t\t\t\tyBottom: plotY,\n\t\t\t\t\t\tonMouseOver: noop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (segment.length) {\n\t\t\t\tsegments.push(segment);\n\t\t\t}\n\n\t\t} else {\n\t\t\tSeries.prototype.getSegments.call(this);\n\t\t\tsegments = this.segments;\n\t\t}\n\n\t\tthis.segments = segments;\n\t},\n\t\n\t/**\n\t * Extend the base Series getSegmentPath method by adding the path for the area.\n\t * This path is pushed to the series.areaPath property.\n\t */\n\tgetSegmentPath: function (segment) {\n\t\t\n\t\tvar segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method\n\t\t\tareaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\n\t\t\ti,\n\t\t\toptions = this.options,\n\t\t\tsegLength = segmentPath.length,\n\t\t\ttranslatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181\n\t\t\tyBottom;\n\t\t\n\t\tif (segLength === 3) { // for animation from 1 to two points\n\t\t\tareaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n\t\t}\n\t\tif (options.stacking && !this.closedStacks) {\n\t\t\t\n\t\t\t// Follow stack back. Todo: implement areaspline. A general solution could be to \n\t\t\t// reverse the entire graphPath of the previous series, though may be hard with\n\t\t\t// splines and with series with different extremes\n\t\t\tfor (i = segment.length - 1; i >= 0; i--) {\n\n\t\t\t\tyBottom = pick(segment[i].yBottom, translatedThreshold);\n\t\t\t\n\t\t\t\t// step line?\n\t\t\t\tif (i < segment.length - 1 && options.step) {\n\t\t\t\t\tareaSegmentPath.push(segment[i + 1].plotX, yBottom);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tareaSegmentPath.push(segment[i].plotX, yBottom);\n\t\t\t}\n\n\t\t} else { // follow zero line back\n\t\t\tthis.closeSegment(areaSegmentPath, segment, translatedThreshold);\n\t\t}\n\t\tthis.areaPath = this.areaPath.concat(areaSegmentPath);\n\t\treturn segmentPath;\n\t},\n\t\n\t/**\n\t * Extendable method to close the segment path of an area. This is overridden in polar \n\t * charts.\n\t */\n\tcloseSegment: function (path, segment, translatedThreshold) {\n\t\tpath.push(\n\t\t\tL,\n\t\t\tsegment[segment.length - 1].plotX,\n\t\t\ttranslatedThreshold,\n\t\t\tL,\n\t\t\tsegment[0].plotX,\n\t\t\ttranslatedThreshold\n\t\t);\n\t},\n\t\n\t/**\n\t * Draw the graph and the underlying area. This method calls the Series base\n\t * function and adds the area. The areaPath is calculated in the getSegmentPath\n\t * method called from Series.prototype.drawGraph.\n\t */\n\tdrawGraph: function () {\n\t\t\n\t\t// Define or reset areaPath\n\t\tthis.areaPath = [];\n\t\t\n\t\t// Call the base method\n\t\tSeries.prototype.drawGraph.apply(this);\n\t\t\n\t\t// Define local variables\n\t\tvar series = this,\n\t\t\tareaPath = this.areaPath,\n\t\t\toptions = this.options,\n\t\t\tzones = this.zones,\n\t\t\tprops = [['area', this.color, options.fillColor]]; // area name, main color, fill color\n\t\t\n\t\teach(zones, function (threshold, i) {\n\t\t\tprops.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);\n\t\t});\n\t\teach(props, function (prop) {\n\t\t\tvar areaKey = prop[0],\n\t\t\t\tarea = series[areaKey];\n\t\t\t\t\n\t\t\t// Create or update the area\n\t\t\tif (area) { // update\n\t\t\t\tarea.animate({ d: areaPath });\n\t\n\t\t\t} else { // create\n\t\t\t\tseries[areaKey] = series.chart.renderer.path(areaPath)\n\t\t\t\t\t.attr({\n\t\t\t\t\t\tfill: pick(\n\t\t\t\t\t\t\tprop[2],\n\t\t\t\t\t\t\tColor(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tzIndex: 0 // #1069\n\t\t\t\t\t}).add(series.group);\n\t\t\t}\n\t\t});\n\t},\n\n\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle\n});\n\nseriesTypes.area = AreaSeries;\n/**\n * Set the default options for spline\n */\ndefaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n/**\n * SplineSeries object\n */\nvar SplineSeries = extendClass(Series, {\n\ttype: 'spline',\n\n\t/**\n\t * Get the spline segment from a given point's previous neighbour to the given point\n\t */\n\tgetPointSpline: function (segment, point, i) {\n\t\tvar smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n\t\t\tdenom = smoothing + 1,\n\t\t\tplotX = point.plotX,\n\t\t\tplotY = point.plotY,\n\t\t\tlastPoint = segment[i - 1],\n\t\t\tnextPoint = segment[i + 1],\n\t\t\tleftContX,\n\t\t\tleftContY,\n\t\t\trightContX,\n\t\t\trightContY,\n\t\t\tret;\n\n\t\t// find control points\n\t\tif (lastPoint && nextPoint) {\n\t\t\n\t\t\tvar lastX = lastPoint.plotX,\n\t\t\t\tlastY = lastPoint.plotY,\n\t\t\t\tnextX = nextPoint.plotX,\n\t\t\t\tnextY = nextPoint.plotY,\n\t\t\t\tcorrection;\n\n\t\t\tleftContX = (smoothing * plotX + lastX) / denom;\n\t\t\tleftContY = (smoothing * plotY + lastY) / denom;\n\t\t\trightContX = (smoothing * plotX + nextX) / denom;\n\t\t\trightContY = (smoothing * plotY + nextY) / denom;\n\n\t\t\t// have the two control points make a straight line through main point\n\t\t\tcorrection = ((rightContY - leftContY) * (rightContX - plotX)) /\n\t\t\t\t(rightContX - leftContX) + plotY - rightContY;\n\n\t\t\tleftContY += correction;\n\t\t\trightContY += correction;\n\n\t\t\t// to prevent false extremes, check that control points are between\n\t\t\t// neighbouring points' y values\n\t\t\tif (leftContY > lastY && leftContY > plotY) {\n\t\t\t\tleftContY = mathMax(lastY, plotY);\n\t\t\t\trightContY = 2 * plotY - leftContY; // mirror of left control point\n\t\t\t} else if (leftContY < lastY && leftContY < plotY) {\n\t\t\t\tleftContY = mathMin(lastY, plotY);\n\t\t\t\trightContY = 2 * plotY - leftContY;\n\t\t\t}\n\t\t\tif (rightContY > nextY && rightContY > plotY) {\n\t\t\t\trightContY = mathMax(nextY, plotY);\n\t\t\t\tleftContY = 2 * plotY - rightContY;\n\t\t\t} else if (rightContY < nextY && rightContY < plotY) {\n\t\t\t\trightContY = mathMin(nextY, plotY);\n\t\t\t\tleftContY = 2 * plotY - rightContY;\n\t\t\t}\n\n\t\t\t// record for drawing in next point\n\t\t\tpoint.rightContX = rightContX;\n\t\t\tpoint.rightContY = rightContY;\n\n\t\t}\n\t\t\n\t\t// Visualize control points for debugging\n\t\t/*\n\t\tif (leftContX) {\n\t\t\tthis.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n\t\t\t\t.attr({\n\t\t\t\t\tstroke: 'red',\n\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\tfill: 'none'\n\t\t\t\t})\n\t\t\t\t.add();\n\t\t\tthis.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n\t\t\t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n\t\t\t\t.attr({\n\t\t\t\t\tstroke: 'red',\n\t\t\t\t\t'stroke-width': 1\n\t\t\t\t})\n\t\t\t\t.add();\n\t\t\tthis.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n\t\t\t\t.attr({\n\t\t\t\t\tstroke: 'green',\n\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\tfill: 'none'\n\t\t\t\t})\n\t\t\t\t.add();\n\t\t\tthis.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n\t\t\t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n\t\t\t\t.attr({\n\t\t\t\t\tstroke: 'green',\n\t\t\t\t\t'stroke-width': 1\n\t\t\t\t})\n\t\t\t\t.add();\n\t\t}\n\t\t*/\n\n\t\t// moveTo or lineTo\n\t\tif (!i) {\n\t\t\tret = [M, plotX, plotY];\n\t\t} else { // curve from last point to this\n\t\t\tret = [\n\t\t\t\t'C',\n\t\t\t\tlastPoint.rightContX || lastPoint.plotX,\n\t\t\t\tlastPoint.rightContY || lastPoint.plotY,\n\t\t\t\tleftContX || plotX,\n\t\t\t\tleftContY || plotY,\n\t\t\t\tplotX,\n\t\t\t\tplotY\n\t\t\t];\n\t\t\tlastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n\t\t}\n\t\treturn ret;\n\t}\n});\nseriesTypes.spline = SplineSeries;\n\n/**\n * Set the default options for areaspline\n */\ndefaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n/**\n * AreaSplineSeries object\n */\nvar areaProto = AreaSeries.prototype,\n\tAreaSplineSeries = extendClass(SplineSeries, {\n\t\ttype: 'areaspline',\n\t\tclosedStacks: true, // instead of following the previous graph back, follow the threshold back\n\t\t\n\t\t// Mix in methods from the area series\n\t\tgetSegmentPath: areaProto.getSegmentPath,\n\t\tcloseSegment: areaProto.closeSegment,\n\t\tdrawGraph: areaProto.drawGraph,\n\t\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle\n\t});\n\nseriesTypes.areaspline = AreaSplineSeries;\n\n/**\n * Set the default options for column\n */\ndefaultPlotOptions.column = merge(defaultSeriesOptions, {\n\tborderColor: '#FFFFFF',\n\t//borderWidth: 1,\n\tborderRadius: 0,\n\t//colorByPoint: undefined,\n\tgroupPadding: 0.2,\n\t//grouping: true,\n\tmarker: null, // point options are specified in the base options\n\tpointPadding: 0.1,\n\t//pointWidth: null,\n\tminPointLength: 0,\n\tcropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n\tpointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n\tstates: {\n\t\thover: {\n\t\t\tbrightness: 0.1,\n\t\t\tshadow: false,\n\t\t\thalo: false\n\t\t},\n\t\tselect: {\n\t\t\tcolor: '#C0C0C0',\n\t\t\tborderColor: '#000000',\n\t\t\tshadow: false\n\t\t}\n\t},\n\tdataLabels: {\n\t\talign: null, // auto\n\t\tverticalAlign: null, // auto\n\t\ty: null\n\t},\n\tstickyTracking: false,\n\ttooltip: {\n\t\tdistance: 6\n\t},\n\tthreshold: 0\n});\n\n/**\n * ColumnSeries object\n */\nvar ColumnSeries = extendClass(Series, {\n\ttype: 'column',\n\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\tstroke: 'borderColor',\n\t\tfill: 'color',\n\t\tr: 'borderRadius'\n\t},\n\tcropShoulder: 0,\n\tdirectTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n\ttrackerGroups: ['group', 'dataLabelsGroup'],\n\tnegStacks: true, // use separate negative stacks, unlike area stacks where a negative \n\t\t// point is substracted from previous (#1910)\n\t\n\t/**\n\t * Initialize the series\n\t */\n\tinit: function () {\n\t\tSeries.prototype.init.apply(this, arguments);\n\n\t\tvar series = this,\n\t\t\tchart = series.chart;\n\n\t\t// if the series is added dynamically, force redraw of other\n\t\t// series affected by a new column\n\t\tif (chart.hasRendered) {\n\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\tif (otherSeries.type === series.type) {\n\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n\t * pointWidth etc. \n\t */\n\tgetColumnMetrics: function () {\n\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\txAxis = series.xAxis,\n\t\t\tyAxis = series.yAxis,\n\t\t\treversedXAxis = xAxis.reversed,\n\t\t\tstackKey,\n\t\t\tstackGroups = {},\n\t\t\tcolumnIndex,\n\t\t\tcolumnCount = 0;\n\n\t\t// Get the total number of column type series.\n\t\t// This is called on every series. Consider moving this logic to a\n\t\t// chart.orderStacks() function and call it on init, addSeries and removeSeries\n\t\tif (options.grouping === false) {\n\t\t\tcolumnCount = 1;\n\t\t} else {\n\t\t\teach(series.chart.series, function (otherSeries) {\n\t\t\t\tvar otherOptions = otherSeries.options,\n\t\t\t\t\totherYAxis = otherSeries.yAxis;\n\t\t\t\tif (otherSeries.type === series.type && otherSeries.visible &&\n\t\t\t\t\t\tyAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n\t\t\t\t\tif (otherOptions.stacking) {\n\t\t\t\t\t\tstackKey = otherSeries.stackKey;\n\t\t\t\t\t\tif (stackGroups[stackKey] === UNDEFINED) {\n\t\t\t\t\t\t\tstackGroups[stackKey] = columnCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolumnIndex = stackGroups[stackKey];\n\t\t\t\t\t} else if (otherOptions.grouping !== false) { // #1162\n\t\t\t\t\t\tcolumnIndex = columnCount++;\n\t\t\t\t\t}\n\t\t\t\t\totherSeries.columnIndex = columnIndex;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar categoryWidth = mathMin(\n\t\t\t\tmathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n\t\t\t\txAxis.len // #1535\n\t\t\t),\n\t\t\tgroupPadding = categoryWidth * options.groupPadding,\n\t\t\tgroupWidth = categoryWidth - 2 * groupPadding,\n\t\t\tpointOffsetWidth = groupWidth / columnCount,\n\t\t\toptionPointWidth = options.pointWidth,\n\t\t\tpointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :\n\t\t\t\tpointOffsetWidth * options.pointPadding,\n\t\t\tpointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts\n\t\t\tcolIndex = (reversedXAxis ? \n\t\t\t\tcolumnCount - (series.columnIndex || 0) : // #1251\n\t\t\t\tseries.columnIndex) || 0,\n\t\t\tpointXOffset = pointPadding + (groupPadding + colIndex *\n\t\t\t\tpointOffsetWidth - (categoryWidth / 2)) *\n\t\t\t\t(reversedXAxis ? -1 : 1);\n\n\t\t// Save it for reading in linked series (Error bars particularly)\n\t\treturn (series.columnMetrics = { \n\t\t\twidth: pointWidth, \n\t\t\toffset: pointXOffset \n\t\t});\n\t\t\t\n\t},\n\n\t/**\n\t * Translate each point to the plot area coordinate system and find shape positions\n\t */\n\ttranslate: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\toptions = series.options,\n\t\t\tborderWidth = series.borderWidth = pick(\n\t\t\t\toptions.borderWidth, \n\t\t\t\tseries.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635\n\t\t\t),\n\t\t\tyAxis = series.yAxis,\n\t\t\tthreshold = options.threshold,\n\t\t\ttranslatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n\t\t\tminPointLength = pick(options.minPointLength, 5),\n\t\t\tmetrics = series.getColumnMetrics(),\n\t\t\tpointWidth = metrics.width,\n\t\t\tseriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n\t\t\tpointXOffset = series.pointXOffset = metrics.offset,\n\t\t\txCrisp = -(borderWidth % 2 ? 0.5 : 0),\n\t\t\tyCrisp = borderWidth % 2 ? 0.5 : 1;\n\n\t\tif (chart.renderer.isVML && chart.inverted) {\n\t\t\tyCrisp += 1;\n\t\t}\n\n\t\t// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n\t\t// columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n\t\t// columns (#2694).\n\t\tif (options.pointPadding) {\n\t\t\tseriesBarW = mathCeil(seriesBarW);\n\t\t}\n\n\t\tSeries.prototype.translate.apply(series);\n\n\t\t// Record the new values\n\t\teach(series.points, function (point) {\n\t\t\tvar yBottom = pick(point.yBottom, translatedThreshold),\n\t\t\t\tplotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)\n\t\t\t\tbarX = point.plotX + pointXOffset,\n\t\t\t\tbarW = seriesBarW,\n\t\t\t\tbarY = mathMin(plotY, yBottom),\n\t\t\t\tright,\n\t\t\t\tbottom,\n\t\t\t\tfromTop,\n\t\t\t\tbarH = mathMax(plotY, yBottom) - barY;\n\n\t\t\t// Handle options.minPointLength\n\t\t\tif (mathAbs(barH) < minPointLength) {\n\t\t\t\tif (minPointLength) {\n\t\t\t\t\tbarH = minPointLength;\n\t\t\t\t\tbarY =\n\t\t\t\t\t\tmathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n\t\t\t\t\t\t\tyBottom - minPointLength : // keep position\n\t\t\t\t\t\t\ttranslatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache for access in polar\n\t\t\tpoint.barX = barX;\n\t\t\tpoint.pointWidth = pointWidth;\n\n\t\t\t// Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n\t\t\tpoint.tooltipPos = chart.inverted ? \n\t\t\t\t[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : \n\t\t\t\t[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];\n\n\t\t\t// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)\n\t\t\tright = mathRound(barX + barW) + xCrisp;\n\t\t\tbarX = mathRound(barX) + xCrisp;\n\t\t\tbarW = right - barX;\n\n\t\t\tfromTop = mathAbs(barY) < 0.5;\n\t\t\tbottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575\n\t\t\tbarY = mathRound(barY) + yCrisp;\n\t\t\tbarH = bottom - barY;\n\n\t\t\t// Top edges are exceptions\n\t\t\tif (fromTop) {\n\t\t\t\tbarY -= 1;\n\t\t\t\tbarH += 1;\n\t\t\t}\n\n\t\t\t// Register shape type and arguments to be used in drawPoints\n\t\t\tpoint.shapeType = 'rect';\n\t\t\tpoint.shapeArgs = {\n\t\t\t\tx: barX,\n\t\t\t\ty: barY,\n\t\t\t\twidth: barW,\n\t\t\t\theight: barH\n\t\t\t};\n\n\t\t});\n\n\t},\n\n\tgetSymbol: noop,\n\t\n\t/**\n\t * Use a solid rectangle like the area series types\n\t */\n\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\t\n\t\n\t/**\n\t * Columns have no graph\n\t */\n\tdrawGraph: noop,\n\n\t/**\n\t * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n\t * apply for columns and bars. This method is inherited by scatter series.\n\t *\n\t */\n\tdrawPoints: function () {\n\t\tvar series = this,\n\t\t\tchart = this.chart,\n\t\t\toptions = series.options,\n\t\t\trenderer = chart.renderer,\n\t\t\tanimationLimit = options.animationLimit || 250,\n\t\t\tshapeArgs,\n\t\t\tpointAttr;\n\n\t\t// draw the columns\n\t\teach(series.points, function (point) {\n\t\t\tvar plotY = point.plotY,\n\t\t\t\tgraphic = point.graphic,\n\t\t\t\tborderAttr;\n\n\t\t\tif (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\t\t\t\tshapeArgs = point.shapeArgs;\n\n\t\t\t\tborderAttr = defined(series.borderWidth) ? {\n\t\t\t\t\t'stroke-width': series.borderWidth\n\t\t\t\t} : {};\n\n\t\t\t\tpointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];\n\t\t\t\t\n\t\t\t\tif (graphic) { // update\n\t\t\t\t\tstop(graphic);\n\t\t\t\t\tgraphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));\n\n\t\t\t\t} else {\n\t\t\t\t\tpoint.graphic = graphic = renderer[point.shapeType](shapeArgs)\n\t\t\t\t\t\t.attr(borderAttr)\n\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t.add(series.group)\n\t\t\t\t\t\t.shadow(options.shadow, null, options.stacking && !options.borderRadius);\n\t\t\t\t}\n\n\t\t\t} else if (graphic) {\n\t\t\t\tpoint.graphic = graphic.destroy(); // #1269\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Animate the column heights one by one from zero\n\t * @param {Boolean} init Whether to initialize the animation or run it\n\t */\n\tanimate: function (init) {\n\t\tvar series = this,\n\t\t\tyAxis = this.yAxis,\n\t\t\toptions = series.options,\n\t\t\tinverted = this.chart.inverted,\n\t\t\tattr = {},\n\t\t\ttranslatedThreshold;\n\n\t\tif (hasSVG) { // VML is too slow anyway\n\t\t\tif (init) {\n\t\t\t\tattr.scaleY = 0.001;\n\t\t\t\ttranslatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));\n\t\t\t\tif (inverted) {\n\t\t\t\t\tattr.translateX = translatedThreshold - yAxis.len;\n\t\t\t\t} else {\n\t\t\t\t\tattr.translateY = translatedThreshold;\n\t\t\t\t}\n\t\t\t\tseries.group.attr(attr);\n\n\t\t\t} else { // run the animation\n\t\t\t\t\n\t\t\t\tattr.scaleY = 1;\n\t\t\t\tattr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n\t\t\t\tseries.group.animate(attr, series.options.animation);\n\n\t\t\t\t// delete this function to allow it only once\n\t\t\t\tseries.animate = null;\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Remove this series from the chart\n\t */\n\tremove: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart;\n\n\t\t// column and bar series affects other series of the same type\n\t\t// as they are either stacked or grouped\n\t\tif (chart.hasRendered) {\n\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\tif (otherSeries.type === series.type) {\n\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tSeries.prototype.remove.apply(series, arguments);\n\t}\n});\nseriesTypes.column = ColumnSeries;\n/**\n * Set the default options for bar\n */\ndefaultPlotOptions.bar = merge(defaultPlotOptions.column);\n/**\n * The Bar series class\n */\nvar BarSeries = extendClass(ColumnSeries, {\n\ttype: 'bar',\n\tinverted: true\n});\nseriesTypes.bar = BarSeries;\n\n/**\n * Set the default options for scatter\n */\ndefaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n\tlineWidth: 0,\n\tmarker: {\n\t\tenabled: true // Overrides auto-enabling in line series (#3647)\n\t},\n\ttooltip: {\n\t\theaderFormat: '<span style=\"color:{series.color}\">\\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',\n\t\tpointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n\t}\n});\n\n/**\n * The scatter series class\n */\nvar ScatterSeries = extendClass(Series, {\n\ttype: 'scatter',\n\tsorted: false,\n\trequireSorting: false,\n\tnoSharedTooltip: true,\n\ttrackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n\ttakeOrdinalPosition: false, // #2342\n\tkdDimensions: 2,\n\tkdComparer: 'distR',\n\tdrawGraph: function () {\n\t\tif (this.options.lineWidth) {\n\t\t\tSeries.prototype.drawGraph.call(this);\n\t\t}\n\t}\n});\n\nseriesTypes.scatter = ScatterSeries;\n\n/**\n * Set the default options for pie\n */\ndefaultPlotOptions.pie = merge(defaultSeriesOptions, {\n\tborderColor: '#FFFFFF',\n\tborderWidth: 1,\n\tcenter: [null, null],\n\tclip: false,\n\tcolorByPoint: true, // always true for pies\n\tdataLabels: {\n\t\t// align: null,\n\t\t// connectorWidth: 1,\n\t\t// connectorColor: point.color,\n\t\t// connectorPadding: 5,\n\t\tdistance: 30,\n\t\tenabled: true,\n\t\tformatter: function () { // #2945\n\t\t\treturn this.point.name;\n\t\t},\n\t\t// softConnector: true,\n\t\tx: 0\n\t\t// y: 0\n\t},\n\tignoreHiddenPoint: true,\n\t//innerSize: 0,\n\tlegendType: 'point',\n\tmarker: null, // point options are specified in the base options\n\tsize: null,\n\tshowInLegend: false,\n\tslicedOffset: 10,\n\tstates: {\n\t\thover: {\n\t\t\tbrightness: 0.1,\n\t\t\tshadow: false\n\t\t}\n\t},\n\tstickyTracking: false,\n\ttooltip: {\n\t\tfollowPointer: true\n\t}\n});\n\n/**\n * Extended point object for pies\n */\nvar PiePoint = extendClass(Point, {\n\t/**\n\t * Initiate the pie slice\n\t */\n\tinit: function () {\n\n\t\tPoint.prototype.init.apply(this, arguments);\n\n\t\tvar point = this,\n\t\t\ttoggleSlice;\n\n\t\textend(point, {\n\t\t\tvisible: point.visible !== false,\n\t\t\tname: pick(point.name, 'Slice')\n\t\t});\n\n\t\t// add event listener for select\n\t\ttoggleSlice = function (e) {\n\t\t\tpoint.slice(e.type === 'select');\n\t\t};\n\t\taddEvent(point, 'select', toggleSlice);\n\t\taddEvent(point, 'unselect', toggleSlice);\n\n\t\treturn point;\n\t},\n\n\t/**\n\t * Toggle the visibility of the pie slice\n\t * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n\t *    visibility is toggled\n\t */\n\tsetVisible: function (vis) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tchart = series.chart,\n\t\t\tdoRedraw = !series.isDirty && series.options.ignoreHiddenPoint;\n\n\t\t// if called without an argument, toggle visibility\n\t\tpoint.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n\t\tseries.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n\t\t// Show and hide associated elements\n\t\teach(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n\t\t\tif (point[key]) {\n\t\t\t\tpoint[key][vis ? 'show' : 'hide'](true);\n\t\t\t}\n\t\t});\n\n\t\tif (point.legendItem) {\n\t\t\tif (chart.hasRendered) {\n\t\t\t\tseries.updateTotals();\n\t\t\t\tchart.legend.clearItems();\n\t\t\t\tif (!doRedraw) {\n\t\t\t\t\tchart.legend.render();\n\t\t\t\t}\n\t\t\t}\n\t\t\tchart.legend.colorizeItem(point, vis);\n\t\t}\n\n\t\t// Handle ignore hidden slices\n\t\tif (doRedraw) {\n\t\t\tseries.isDirty = true;\n\t\t\tchart.redraw();\n\t\t}\n\t},\n\n\t/**\n\t * Set or toggle whether the slice is cut out from the pie\n\t * @param {Boolean} sliced When undefined, the slice state is toggled\n\t * @param {Boolean} redraw Whether to redraw the chart. True by default.\n\t */\n\tslice: function (sliced, redraw, animation) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tchart = series.chart,\n\t\t\ttranslation;\n\n\t\tsetAnimation(animation, chart);\n\n\t\t// redraw is true by default\n\t\tredraw = pick(redraw, true);\n\n\t\t// if called without an argument, toggle\n\t\tpoint.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n\t\tseries.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n\t\ttranslation = sliced ? point.slicedTranslation : {\n\t\t\ttranslateX: 0,\n\t\t\ttranslateY: 0\n\t\t};\n\n\t\tpoint.graphic.animate(translation);\n\t\t\n\t\tif (point.shadowGroup) {\n\t\t\tpoint.shadowGroup.animate(translation);\n\t\t}\n\n\t},\n\n\thaloPath: function (size) {\n\t\tvar shapeArgs = this.shapeArgs,\n\t\t\tchart = this.series.chart;\n\n\t\treturn this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n\t\t\tinnerR: this.shapeArgs.r,\n\t\t\tstart: shapeArgs.start,\n\t\t\tend: shapeArgs.end\n\t\t});\n\t}\n});\n\n/**\n * The Pie series class\n */\nvar PieSeries = {\n\ttype: 'pie',\n\tisCartesian: false,\n\tpointClass: PiePoint,\n\trequireSorting: false,\n\tnoSharedTooltip: true,\n\ttrackerGroups: ['group', 'dataLabelsGroup'],\n\taxisTypes: [],\n\tpointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n\t\tstroke: 'borderColor',\n\t\t'stroke-width': 'borderWidth',\n\t\tfill: 'color'\n\t},\n\n\t/**\n\t * Pies have one color each point\n\t */\n\tgetColor: noop,\n\n\t/**\n\t * Animate the pies in\n\t */\n\tanimate: function (init) {\n\t\tvar series = this,\n\t\t\tpoints = series.points,\n\t\t\tstartAngleRad = series.startAngleRad;\n\n\t\tif (!init) {\n\t\t\teach(points, function (point) {\n\t\t\t\tvar graphic = point.graphic,\n\t\t\t\t\targs = point.shapeArgs;\n\n\t\t\t\tif (graphic) {\n\t\t\t\t\t// start values\n\t\t\t\t\tgraphic.attr({\n\t\t\t\t\t\tr: series.center[3] / 2, // animate from inner radius (#779)\n\t\t\t\t\t\tstart: startAngleRad,\n\t\t\t\t\t\tend: startAngleRad\n\t\t\t\t\t});\n\n\t\t\t\t\t// animate\n\t\t\t\t\tgraphic.animate({\n\t\t\t\t\t\tr: args.r,\n\t\t\t\t\t\tstart: args.start,\n\t\t\t\t\t\tend: args.end\n\t\t\t\t\t}, series.options.animation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// delete this function to allow it only once\n\t\t\tseries.animate = null;\n\t\t}\n\t},\n\n\t/**\n\t * Extend the basic setData method by running processData and generatePoints immediately,\n\t * in order to access the points from the legend.\n\t */\n\tsetData: function (data, redraw, animation, updatePoints) {\n\t\tSeries.prototype.setData.call(this, data, false, animation, updatePoints);\n\t\tthis.processData();\n\t\tthis.generatePoints();\n\t\tif (pick(redraw, true)) {\n\t\t\tthis.chart.redraw(animation);\n\t\t} \n\t},\n\n\t/**\n\t * Recompute total chart sum and update percentages of points.\n\t */\n\tupdateTotals: function () {\n\t\tvar i,\n\t\t\ttotal = 0,\n\t\t\tpoints,\n\t\t\tlen,\n\t\t\tpoint,\n\t\t\tignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n\t\t// Populate local vars\n\t\tpoints = this.points;\n\t\tlen = points.length;\n\t\t\n\t\t// Get the total sum\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tpoint = points[i];\n\n\t\t\t// Disallow negative values (#1530, #3623)\n\t\t\tif (point.y < 0) {\n\t\t\t\tpoint.y = null;\n\t\t\t}\n\t\t\t\n\t\t\ttotal += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n\t\t}\n\t\tthis.total = total;\n\n\t\t// Set each point's properties\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tpoint = points[i];\n\t\t\t//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;\n\t\t\tpoint.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n\t\t\tpoint.total = total;\n\t\t}\n\t},\n\n\t/**\n\t * Extend the generatePoints method by adding total and percentage properties to each point\n\t */\n\tgeneratePoints: function () {\n\t\tSeries.prototype.generatePoints.call(this);\n\t\tthis.updateTotals();\n\t},\n\t\n\t/**\n\t * Do translation for pie slices\n\t */\n\ttranslate: function (positions) {\n\t\tthis.generatePoints();\n\t\t\n\t\tvar series = this,\n\t\t\tcumulative = 0,\n\t\t\tprecision = 1000, // issue #172\n\t\t\toptions = series.options,\n\t\t\tslicedOffset = options.slicedOffset,\n\t\t\tconnectorOffset = slicedOffset + options.borderWidth,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tangle,\n\t\t\tstartAngle = options.startAngle || 0,\n\t\t\tstartAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),\n\t\t\tendAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n\t\t\tcirc = endAngleRad - startAngleRad, //2 * mathPI,\n\t\t\tpoints = series.points,\n\t\t\tradiusX, // the x component of the radius vector for a given point\n\t\t\tradiusY,\n\t\t\tlabelDistance = options.dataLabels.distance,\n\t\t\tignoreHiddenPoint = options.ignoreHiddenPoint,\n\t\t\ti,\n\t\t\tlen = points.length,\n\t\t\tpoint;\n\n\t\t// Get positions - either an integer or a percentage string must be given.\n\t\t// If positions are passed as a parameter, we're in a recursive loop for adjusting\n\t\t// space for data labels.\n\t\tif (!positions) {\n\t\t\tseries.center = positions = series.getCenter();\n\t\t}\n\n\t\t// utility for getting the x value from a given y, used for anticollision logic in data labels\n\t\tseries.getX = function (y, left) {\n\n\t\t\tangle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n\t\t\treturn positions[0] +\n\t\t\t\t(left ? -1 : 1) *\n\t\t\t\t(mathCos(angle) * (positions[2] / 2 + labelDistance));\n\t\t};\n\n\t\t// Calculate the geometry for each point\n\t\tfor (i = 0; i < len; i++) {\n\t\t\t\n\t\t\tpoint = points[i];\n\t\t\t\n\t\t\t// set start and end angle\n\t\t\tstart = startAngleRad + (cumulative * circ);\n\t\t\tif (!ignoreHiddenPoint || point.visible) {\n\t\t\t\tcumulative += point.percentage / 100;\n\t\t\t}\n\t\t\tend = startAngleRad + (cumulative * circ);\n\n\t\t\t// set the shape\n\t\t\tpoint.shapeType = 'arc';\n\t\t\tpoint.shapeArgs = {\n\t\t\t\tx: positions[0],\n\t\t\t\ty: positions[1],\n\t\t\t\tr: positions[2] / 2,\n\t\t\t\tinnerR: positions[3] / 2,\n\t\t\t\tstart: mathRound(start * precision) / precision,\n\t\t\t\tend: mathRound(end * precision) / precision\n\t\t\t};\n\n\t\t\t// The angle must stay within -90 and 270 (#2645)\n\t\t\tangle = (end + start) / 2;\n\t\t\tif (angle > 1.5 * mathPI) {\n\t\t\t\tangle -= 2 * mathPI;\n\t\t\t} else if (angle < -mathPI / 2) {\n\t\t\t\tangle += 2 * mathPI;\n\t\t\t}\n\n\t\t\t// Center for the sliced out slice\n\t\t\tpoint.slicedTranslation = {\n\t\t\t\ttranslateX: mathRound(mathCos(angle) * slicedOffset),\n\t\t\t\ttranslateY: mathRound(mathSin(angle) * slicedOffset)\n\t\t\t};\n\n\t\t\t// set the anchor point for tooltips\n\t\t\tradiusX = mathCos(angle) * positions[2] / 2;\n\t\t\tradiusY = mathSin(angle) * positions[2] / 2;\n\t\t\tpoint.tooltipPos = [\n\t\t\t\tpositions[0] + radiusX * 0.7,\n\t\t\t\tpositions[1] + radiusY * 0.7\n\t\t\t];\n\t\t\t\n\t\t\tpoint.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;\n\t\t\tpoint.angle = angle;\n\n\t\t\t// set the anchor point for data labels\n\t\t\tconnectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678\n\t\t\tpoint.labelPos = [\n\t\t\t\tpositions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n\t\t\t\tpositions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n\t\t\t\tpositions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n\t\t\t\tpositions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n\t\t\t\tpositions[0] + radiusX, // landing point for connector\n\t\t\t\tpositions[1] + radiusY, // a/a\n\t\t\t\tlabelDistance < 0 ? // alignment\n\t\t\t\t\t'center' :\n\t\t\t\t\tpoint.half ? 'right' : 'left', // alignment\n\t\t\t\tangle // center angle\n\t\t\t];\n\n\t\t}\n\t},\n\t\n\tdrawGraph: null,\n\n\t/**\n\t * Draw the data points\n\t */\n\tdrawPoints: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\trenderer = chart.renderer,\n\t\t\tgroupTranslation,\n\t\t\t//center,\n\t\t\tgraphic,\n\t\t\t//group,\n\t\t\tshadow = series.options.shadow,\n\t\t\tshadowGroup,\n\t\t\tshapeArgs;\n\n\t\tif (shadow && !series.shadowGroup) {\n\t\t\tseries.shadowGroup = renderer.g('shadow')\n\t\t\t\t.add(series.group);\n\t\t}\n\n\t\t// draw the slices\n\t\teach(series.points, function (point) {\n\t\t\tgraphic = point.graphic;\n\t\t\tshapeArgs = point.shapeArgs;\n\t\t\tshadowGroup = point.shadowGroup;\n\n\t\t\t// put the shadow behind all points\n\t\t\tif (shadow && !shadowGroup) {\n\t\t\t\tshadowGroup = point.shadowGroup = renderer.g('shadow')\n\t\t\t\t\t.add(series.shadowGroup);\n\t\t\t}\n\n\t\t\t// if the point is sliced, use special translation, else use plot area traslation\n\t\t\tgroupTranslation = point.sliced ? point.slicedTranslation : {\n\t\t\t\ttranslateX: 0,\n\t\t\t\ttranslateY: 0\n\t\t\t};\n\n\t\t\t//group.translate(groupTranslation[0], groupTranslation[1]);\n\t\t\tif (shadowGroup) {\n\t\t\t\tshadowGroup.attr(groupTranslation);\n\t\t\t}\n\n\t\t\t// draw the slice\n\t\t\tif (graphic) {\n\t\t\t\tgraphic.animate(extend(shapeArgs, groupTranslation));\n\t\t\t} else {\n\t\t\t\tpoint.graphic = graphic = renderer[point.shapeType](shapeArgs)\n\t\t\t\t\t.setRadialReference(series.center)\n\t\t\t\t\t.attr(\n\t\t\t\t\t\tpoint.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]\n\t\t\t\t\t)\n\t\t\t\t\t.attr({ \n\t\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t\t\t//zIndex: 1 // #2722 (reversed)\n\t\t\t\t\t})\n\t\t\t\t\t.attr(groupTranslation)\n\t\t\t\t\t.add(series.group)\n\t\t\t\t\t.shadow(shadow, shadowGroup);\t\n\t\t\t}\n\n\t\t\t// detect point specific visibility (#2430)\n\t\t\tif (point.visible !== undefined) {\n\t\t\t\tpoint.setVisible(point.visible);\n\t\t\t}\n\n\t\t});\n\n\t},\n\n\n\tsearchPoint: noop,\n\n\t/**\n\t * Utility for sorting data labels\n\t */\n\tsortByAngle: function (points, sign) {\n\t\tpoints.sort(function (a, b) {\n\t\t\treturn a.angle !== undefined && (b.angle - a.angle) * sign;\n\t\t});\n\t},\t\t\n\n\t/**\n\t * Use a simple symbol from LegendSymbolMixin\n\t */\n\tdrawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\t/**\n\t * Use the getCenter method from drawLegendSymbol\n\t */\n\tgetCenter: CenteredSeriesMixin.getCenter,\n\n\t/**\n\t * Pies don't have point marker symbols\n\t */\n\tgetSymbol: noop\n\n};\nPieSeries = extendClass(Series, PieSeries);\nseriesTypes.pie = PieSeries;\n\n/**\n * Draw the data labels\n */\nSeries.prototype.drawDataLabels = function () {\n\n\tvar series = this,\n\t\tseriesOptions = series.options,\n\t\tcursor = seriesOptions.cursor,\n\t\toptions = seriesOptions.dataLabels,\n\t\tpoints = series.points,\n\t\tpointOptions,\n\t\tgeneralOptions,\n\t\thasRendered = series.hasRendered || 0,\n\t\tstr,\n\t\tdataLabelsGroup,\n\t\trenderer = series.chart.renderer;\n\n\tif (options.enabled || series._hasPointLabels) {\n\n\t\t// Process default alignment of data labels for columns\n\t\tif (series.dlProcessOptions) {\n\t\t\tseries.dlProcessOptions(options);\n\t\t}\n\n\t\t// Create a separate group for the data labels to avoid rotation\n\t\tdataLabelsGroup = series.plotGroup(\n\t\t\t'dataLabelsGroup',\n\t\t\t'data-labels',\n\t\t\toptions.defer ? HIDDEN : VISIBLE,\n\t\t\toptions.zIndex || 6\n\t\t);\n\n\t\tif (pick(options.defer, true)) {\n\t\t\tdataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n\t\t\tif (!hasRendered) {\n\t\t\t\taddEvent(series, 'afterAnimate', function () {\n\t\t\t\t\tif (series.visible) { // #3023, #3024\n\t\t\t\t\t\tdataLabelsGroup.show();\n\t\t\t\t\t}\n\t\t\t\t\tdataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Make the labels for each point\n\t\tgeneralOptions = options;\n\t\teach(points, function (point) {\n\n\t\t\tvar enabled,\n\t\t\t\tdataLabel = point.dataLabel,\n\t\t\t\tlabelConfig,\n\t\t\t\tattr,\n\t\t\t\tname,\n\t\t\t\trotation,\n\t\t\t\tconnector = point.connector,\n\t\t\t\tisNew = true,\n\t\t\t\tstyle,\n\t\t\t\tmoreStyle = {};\n\n\t\t\t// Determine if each data label is enabled\n\t\t\tpointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n\t\t\tenabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282\n\n\n\t\t\t// If the point is outside the plot area, destroy it. #678, #820\n\t\t\tif (dataLabel && !enabled) {\n\t\t\t\tpoint.dataLabel = dataLabel.destroy();\n\n\t\t\t// Individual labels are disabled if the are explicitly disabled\n\t\t\t// in the point options, or if they fall outside the plot area.\n\t\t\t} else if (enabled) {\n\n\t\t\t\t// Create individual options structure that can be extended without\n\t\t\t\t// affecting others\n\t\t\t\toptions = merge(generalOptions, pointOptions);\n\t\t\t\tstyle = options.style;\n\n\t\t\t\trotation = options.rotation;\n\n\t\t\t\t// Get the string\n\t\t\t\tlabelConfig = point.getLabelConfig();\n\t\t\t\tstr = options.format ?\n\t\t\t\t\tformat(options.format, labelConfig) :\n\t\t\t\t\toptions.formatter.call(labelConfig, options);\n\n\t\t\t\t// Determine the color\n\t\t\t\tstyle.color = pick(options.color, style.color, series.color, 'black');\n\n\n\t\t\t\t// update existing label\n\t\t\t\tif (dataLabel) {\n\n\t\t\t\t\tif (defined(str)) {\n\t\t\t\t\t\tdataLabel\n\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\ttext: str\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tisNew = false;\n\n\t\t\t\t\t} else { // #1437 - the label is shown conditionally\n\t\t\t\t\t\tpoint.dataLabel = dataLabel = dataLabel.destroy();\n\t\t\t\t\t\tif (connector) {\n\t\t\t\t\t\t\tpoint.connector = connector.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// create new label\n\t\t\t\t} else if (defined(str)) {\n\t\t\t\t\tattr = {\n\t\t\t\t\t\t//align: align,\n\t\t\t\t\t\tfill: options.backgroundColor,\n\t\t\t\t\t\tstroke: options.borderColor,\n\t\t\t\t\t\t'stroke-width': options.borderWidth,\n\t\t\t\t\t\tr: options.borderRadius || 0,\n\t\t\t\t\t\trotation: rotation,\n\t\t\t\t\t\tpadding: options.padding,\n\t\t\t\t\t\tzIndex: 1\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// Get automated contrast color\n\t\t\t\t\tif (style.color === 'contrast') {\n\t\t\t\t\t\tmoreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? \n\t\t\t\t\t\t\trenderer.getContrast(point.color || series.color) : \n\t\t\t\t\t\t\t'#000000';\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tmoreStyle.cursor = cursor;\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\t// Remove unused attributes (#947)\n\t\t\t\t\tfor (name in attr) {\n\t\t\t\t\t\tif (attr[name] === UNDEFINED) {\n\t\t\t\t\t\t\tdelete attr[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n\t\t\t\t\t\tstr,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t-999,\n\t\t\t\t\t\toptions.shape,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\toptions.useHTML\n\t\t\t\t\t)\n\t\t\t\t\t.attr(attr)\n\t\t\t\t\t.css(extend(style, moreStyle))\n\t\t\t\t\t.add(dataLabelsGroup)\n\t\t\t\t\t.shadow(options.shadow);\n\n\t\t\t\t}\n\n\t\t\t\tif (dataLabel) {\n\t\t\t\t\t// Now the data label is created and placed at 0,0, so we need to align it\n\t\t\t\t\tseries.alignDataLabel(point, dataLabel, options, null, isNew);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Align each individual data label\n */\nSeries.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n\tvar chart = this.chart,\n\t\tinverted = chart.inverted,\n\t\tplotX = pick(point.plotX, -999),\n\t\tplotY = pick(point.plotY, -999),\n\t\tbBox = dataLabel.getBBox(),\n\t\tbaseline = chart.renderer.fontMetrics(options.style.fontSize).b,\n\t\trotCorr, // rotation correction\n\t\t// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n\t\tvisible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||\n\t\t\t(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n\t\talignAttr; // the final position;\n\n\tif (visible) {\n\n\t\t// The alignment box is a singular point\n\t\talignTo = extend({\n\t\t\tx: inverted ? chart.plotWidth - plotY : plotX,\n\t\t\ty: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t}, alignTo);\n\n\t\t// Add the text size for alignment calculation\n\t\textend(options, {\n\t\t\twidth: bBox.width,\n\t\t\theight: bBox.height\n\t\t});\n\n\t\t// Allow a hook for changing alignment in the last moment, then do the alignment\n\t\tif (options.rotation) { // Fancy box alignment isn't supported for rotated text\n\t\t\trotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723\n\t\t\tdataLabel[isNew ? 'attr' : 'animate']({\n\t\t\t\t\tx: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n\t\t\t\t\ty: alignTo.y + options.y + alignTo.height / 2\n\t\t\t\t})\n\t\t\t\t.attr({ // #3003\n\t\t\t\t\talign: options.align\n\t\t\t\t});\n\t\t} else {\n\t\t\tdataLabel.align(options, null, alignTo);\n\t\t\talignAttr = dataLabel.alignAttr;\n\n\t\t\t// Handle justify or crop\n\t\t\tif (pick(options.overflow, 'justify') === 'justify') {\n\t\t\t\tthis.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n\n\t\t\t} else if (pick(options.crop, true)) {\n\t\t\t\t// Now check that the data label is within the plot area\n\t\t\t\tvisible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n\n\t\t\t}\n\n\t\t\t// When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n\t\t\tif (options.shape) {\n\t\t\t\tdataLabel.attr({\n\t\t\t\t\tanchorX: point.plotX,\n\t\t\t\t\tanchorY: point.plotY\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// Show or hide based on the final aligned position\n\tif (!visible) {\n\t\tdataLabel.attr({ y: -999 });\n\t\tdataLabel.placed = false; // don't animate back in\n\t}\n\n};\n\n/**\n * If data labels fall partly outside the plot area, align them back in, in a way that\n * doesn't hide the point.\n */\nSeries.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n\tvar chart = this.chart,\n\t\talign = options.align,\n\t\tverticalAlign = options.verticalAlign,\n\t\toff,\n\t\tjustified,\n\t\tpadding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n\t// Off left\n\toff = alignAttr.x + padding;\n\tif (off < 0) {\n\t\tif (align === 'right') {\n\t\t\toptions.align = 'left';\n\t\t} else {\n\t\t\toptions.x = -off;\n\t\t}\n\t\tjustified = true;\n\t}\n\n\t// Off right\n\toff = alignAttr.x + bBox.width - padding;\n\tif (off > chart.plotWidth) {\n\t\tif (align === 'left') {\n\t\t\toptions.align = 'right';\n\t\t} else {\n\t\t\toptions.x = chart.plotWidth - off;\n\t\t}\n\t\tjustified = true;\n\t}\n\n\t// Off top\n\toff = alignAttr.y + padding;\n\tif (off < 0) {\n\t\tif (verticalAlign === 'bottom') {\n\t\t\toptions.verticalAlign = 'top';\n\t\t} else {\n\t\t\toptions.y = -off;\n\t\t}\n\t\tjustified = true;\n\t}\n\n\t// Off bottom\n\toff = alignAttr.y + bBox.height - padding;\n\tif (off > chart.plotHeight) {\n\t\tif (verticalAlign === 'top') {\n\t\t\toptions.verticalAlign = 'bottom';\n\t\t} else {\n\t\t\toptions.y = chart.plotHeight - off;\n\t\t}\n\t\tjustified = true;\n\t}\n\n\tif (justified) {\n\t\tdataLabel.placed = !isNew;\n\t\tdataLabel.align(options, null, alignTo);\n\t}\n};\n\n/**\n * Override the base drawDataLabels method by pie specific functionality\n */\nif (seriesTypes.pie) {\n\tseriesTypes.pie.prototype.drawDataLabels = function () {\n\t\tvar series = this,\n\t\t\tdata = series.data,\n\t\t\tpoint,\n\t\t\tchart = series.chart,\n\t\t\toptions = series.options.dataLabels,\n\t\t\tconnectorPadding = pick(options.connectorPadding, 10),\n\t\t\tconnectorWidth = pick(options.connectorWidth, 1),\n\t\t\tplotWidth = chart.plotWidth,\n\t\t\tplotHeight = chart.plotHeight,\n\t\t\tconnector,\n\t\t\tconnectorPath,\n\t\t\tsoftConnector = pick(options.softConnector, true),\n\t\t\tdistanceOption = options.distance,\n\t\t\tseriesCenter = series.center,\n\t\t\tradius = seriesCenter[2] / 2,\n\t\t\tcenterY = seriesCenter[1],\n\t\t\toutside = distanceOption > 0,\n\t\t\tdataLabel,\n\t\t\tdataLabelWidth,\n\t\t\tlabelPos,\n\t\t\tlabelHeight,\n\t\t\thalves = [// divide the points into right and left halves for anti collision\n\t\t\t\t[], // right\n\t\t\t\t[]  // left\n\t\t\t],\n\t\t\tx,\n\t\t\ty,\n\t\t\tvisibility,\n\t\t\trankArr,\n\t\t\ti,\n\t\t\tj,\n\t\t\toverflow = [0, 0, 0, 0], // top, right, bottom, left\n\t\t\tsort = function (a, b) {\n\t\t\t\treturn b.y - a.y;\n\t\t\t};\n\n\t\t// get out if not enabled\n\t\tif (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// run parent method\n\t\tSeries.prototype.drawDataLabels.apply(series);\n\n\t\t// arrange points for detection collision\n\t\teach(data, function (point) {\n\t\t\tif (point.dataLabel && point.visible) { // #407, #2510\n\t\t\t\thalves[point.half].push(point);\n\t\t\t}\n\t\t});\n\n\t\t/* Loop over the points in each half, starting from the top and bottom\n\t\t * of the pie to detect overlapping labels.\n\t\t */\n\t\ti = 2;\n\t\twhile (i--) {\n\n\t\t\tvar slots = [],\n\t\t\t\tslotsLength,\n\t\t\t\tusedSlots = [],\n\t\t\t\tpoints = halves[i],\n\t\t\t\tpos,\n\t\t\t\tbottom,\n\t\t\t\tlength = points.length,\n\t\t\t\tslotIndex;\n\n\t\t\tif (!length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Sort by angle\n\t\t\tseries.sortByAngle(points, i - 0.5);\n\n\t\t\t// Assume equal label heights on either hemisphere (#2630)\n\t\t\tj = labelHeight = 0;\n\t\t\twhile (!labelHeight && points[j]) { // #1569\n\t\t\t\tlabelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t// Only do anti-collision when we are outside the pie and have connectors (#856)\n\t\t\tif (distanceOption > 0) {\n\n\t\t\t\t// Build the slots\n\t\t\t\tbottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);\n\t\t\t\tfor (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n\t\t\t\t\tslots.push(pos);\n\t\t\t\t}\n\t\t\t\tslotsLength = slots.length;\n\n\n\t\t\t\t/* Visualize the slots\n\t\t\t\tif (!series.slotElements) {\n\t\t\t\t\tseries.slotElements = [];\n\t\t\t\t}\n\t\t\t\tif (i === 1) {\n\t\t\t\t\tseries.slotElements.forEach(function (elem) {\n\t\t\t\t\t\telem.destroy();\n\t\t\t\t\t});\n\t\t\t\t\tseries.slotElements.length = 0;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tslots.forEach(function (pos, no) {\n\t\t\t\t\tvar slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n\t\t\t\t\t\tslotY = pos + chart.plotTop;\n\t\t\t\t\t\n\t\t\t\t\tif (!isNaN(slotX)) {\n\t\t\t\t\t\tseries.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\t'stroke-width': 1,\n\t\t\t\t\t\t\t\tstroke: 'silver',\n\t\t\t\t\t\t\t\tfill: 'rgba(0,0,255,0.1)'\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.add());\n\t\t\t\t\t\tseries.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n\t\t\t\t\t\t\t.attr({\n\t\t\t\t\t\t\t\tfill: 'silver'\n\t\t\t\t\t\t\t}).add());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// */\n\n\t\t\t\t// if there are more values than available slots, remove lowest values\n\t\t\t\tif (length > slotsLength) {\n\t\t\t\t\t// create an array for sorting and ranking the points within each quarter\n\t\t\t\t\trankArr = [].concat(points);\n\t\t\t\t\trankArr.sort(sort);\n\t\t\t\t\tj = length;\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\trankArr[j].rank = j;\n\t\t\t\t\t}\n\t\t\t\t\tj = length;\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (points[j].rank >= slotsLength) {\n\t\t\t\t\t\t\tpoints.splice(j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = points.length;\n\t\t\t\t}\n\n\t\t\t\t// The label goes to the nearest open slot, but not closer to the edge than\n\t\t\t\t// the label's index.\n\t\t\t\tfor (j = 0; j < length; j++) {\n\n\t\t\t\t\tpoint = points[j];\n\t\t\t\t\tlabelPos = point.labelPos;\n\n\t\t\t\t\tvar closest = 9999,\n\t\t\t\t\t\tdistance,\n\t\t\t\t\t\tslotI;\n\n\t\t\t\t\t// find the closest slot index\n\t\t\t\t\tfor (slotI = 0; slotI < slotsLength; slotI++) {\n\t\t\t\t\t\tdistance = mathAbs(slots[slotI] - labelPos[1]);\n\t\t\t\t\t\tif (distance < closest) {\n\t\t\t\t\t\t\tclosest = distance;\n\t\t\t\t\t\t\tslotIndex = slotI;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if that slot index is closer to the edges of the slots, move it\n\t\t\t\t\t// to the closest appropriate slot\n\t\t\t\t\tif (slotIndex < j && slots[j] !== null) { // cluster at the top\n\t\t\t\t\t\tslotIndex = j;\n\t\t\t\t\t} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n\t\t\t\t\t\tslotIndex = slotsLength - length + j;\n\t\t\t\t\t\twhile (slots[slotIndex] === null) { // make sure it is not taken\n\t\t\t\t\t\t\tslotIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Slot is taken, find next free slot below. In the next run, the next slice will find the\n\t\t\t\t\t\t// slot above these, because it is the closest one\n\t\t\t\t\t\twhile (slots[slotIndex] === null) { // make sure it is not taken\n\t\t\t\t\t\t\tslotIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tusedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n\t\t\t\t\tslots[slotIndex] = null; // mark as taken\n\t\t\t\t}\n\t\t\t\t// sort them in order to fill in from the top\n\t\t\t\tusedSlots.sort(sort);\n\t\t\t}\n\n\t\t\t// now the used slots are sorted, fill them up sequentially\n\t\t\tfor (j = 0; j < length; j++) {\n\n\t\t\t\tvar slot, naturalY;\n\n\t\t\t\tpoint = points[j];\n\t\t\t\tlabelPos = point.labelPos;\n\t\t\t\tdataLabel = point.dataLabel;\n\t\t\t\tvisibility = point.visible === false ? HIDDEN : VISIBLE;\n\t\t\t\tnaturalY = labelPos[1];\n\n\t\t\t\tif (distanceOption > 0) {\n\t\t\t\t\tslot = usedSlots.pop();\n\t\t\t\t\tslotIndex = slot.i;\n\n\t\t\t\t\t// if the slot next to currrent slot is free, the y value is allowed\n\t\t\t\t\t// to fall back to the natural position\n\t\t\t\t\ty = slot.y;\n\t\t\t\t\tif ((naturalY > y && slots[slotIndex + 1] !== null) ||\n\t\t\t\t\t\t\t(naturalY < y &&  slots[slotIndex - 1] !== null)) {\n\t\t\t\t\t\ty = mathMin(mathMax(0, naturalY), chart.plotHeight);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\ty = naturalY;\n\t\t\t\t}\n\n\t\t\t\t// get the x - use the natural x position for first and last slot, to prevent the top\n\t\t\t\t// and botton slice connectors from touching each other on either side\n\t\t\t\tx = options.justify ?\n\t\t\t\t\tseriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n\t\t\t\t\tseries.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n\t\t\t\t// Record the placement and visibility\n\t\t\t\tdataLabel._attr = {\n\t\t\t\t\tvisibility: visibility,\n\t\t\t\t\talign: labelPos[6]\n\t\t\t\t};\n\t\t\t\tdataLabel._pos = {\n\t\t\t\t\tx: x + options.x +\n\t\t\t\t\t\t({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n\t\t\t\t\ty: y + options.y - 10 // 10 is for the baseline (label vs text)\n\t\t\t\t};\n\t\t\t\tdataLabel.connX = x;\n\t\t\t\tdataLabel.connY = y;\n\n\n\t\t\t\t// Detect overflowing data labels\n\t\t\t\tif (this.options.size === null) {\n\t\t\t\t\tdataLabelWidth = dataLabel.width;\n\t\t\t\t\t// Overflow left\n\t\t\t\t\tif (x - dataLabelWidth < connectorPadding) {\n\t\t\t\t\t\toverflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n\t\t\t\t\t// Overflow right\n\t\t\t\t\t} else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n\t\t\t\t\t\toverflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Overflow top\n\t\t\t\t\tif (y - labelHeight / 2 < 0) {\n\t\t\t\t\t\toverflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);\n\n\t\t\t\t\t// Overflow left\n\t\t\t\t\t} else if (y + labelHeight / 2 > plotHeight) {\n\t\t\t\t\t\toverflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for each point\n\t\t} // for each half\n\n\t\t// Do not apply the final placement and draw the connectors until we have verified\n\t\t// that labels are not spilling over.\n\t\tif (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n\t\t\t// Place the labels in the final position\n\t\t\tthis.placeDataLabels();\n\n\t\t\t// Draw the connectors\n\t\t\tif (outside && connectorWidth) {\n\t\t\t\teach(this.points, function (point) {\n\t\t\t\t\tconnector = point.connector;\n\t\t\t\t\tlabelPos = point.labelPos;\n\t\t\t\t\tdataLabel = point.dataLabel;\n\n\t\t\t\t\tif (dataLabel && dataLabel._pos) {\n\t\t\t\t\t\tvisibility = dataLabel._attr.visibility;\n\t\t\t\t\t\tx = dataLabel.connX;\n\t\t\t\t\t\ty = dataLabel.connY;\n\t\t\t\t\t\tconnectorPath = softConnector ? [\n\t\t\t\t\t\t\tM,\n\t\t\t\t\t\t\tx + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\tx, y, // first break, next to the label\n\t\t\t\t\t\t\t2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n\t\t\t\t\t\t\tlabelPos[2], labelPos[3], // second break\n\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\tlabelPos[4], labelPos[5] // base\n\t\t\t\t\t\t] : [\n\t\t\t\t\t\t\tM,\n\t\t\t\t\t\t\tx + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\tlabelPos[2], labelPos[3], // second break\n\t\t\t\t\t\t\tL,\n\t\t\t\t\t\t\tlabelPos[4], labelPos[5] // base\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (connector) {\n\t\t\t\t\t\t\tconnector.animate({ d: connectorPath });\n\t\t\t\t\t\t\tconnector.attr('visibility', visibility);\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpoint.connector = connector = series.chart.renderer.path(connectorPath).attr({\n\t\t\t\t\t\t\t\t'stroke-width': connectorWidth,\n\t\t\t\t\t\t\t\tstroke: options.connectorColor || point.color || '#606060',\n\t\t\t\t\t\t\t\tvisibility: visibility\n\t\t\t\t\t\t\t\t//zIndex: 0 // #2722 (reversed)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.add(series.dataLabelsGroup);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (connector) {\n\t\t\t\t\t\tpoint.connector = connector.destroy();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\t/**\n\t * Perform the final placement of the data labels after we have verified that they\n\t * fall within the plot area.\n\t */\n\tseriesTypes.pie.prototype.placeDataLabels = function () {\n\t\teach(this.points, function (point) {\n\t\t\tvar dataLabel = point.dataLabel,\n\t\t\t\t_pos;\n\n\t\t\tif (dataLabel) {\n\t\t\t\t_pos = dataLabel._pos;\n\t\t\t\tif (_pos) {\n\t\t\t\t\tdataLabel.attr(dataLabel._attr);\n\t\t\t\t\tdataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n\t\t\t\t\tdataLabel.moved = true;\n\t\t\t\t} else if (dataLabel) {\n\t\t\t\t\tdataLabel.attr({ y: -999 });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\tseriesTypes.pie.prototype.alignDataLabel =  noop;\n\n\t/**\n\t * Verify whether the data labels are allowed to draw, or we should run more translation and data\n\t * label positioning to keep them inside the plot area. Returns true when data labels are ready\n\t * to draw.\n\t */\n\tseriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n\t\tvar center = this.center,\n\t\t\toptions = this.options,\n\t\t\tcenterOption = options.center,\n\t\t\tminSize = options.minSize || 80,\n\t\t\tnewSize = minSize,\n\t\t\tret;\n\n\t\t// Handle horizontal size and center\n\t\tif (centerOption[0] !== null) { // Fixed center\n\t\t\tnewSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);\n\n\t\t} else { // Auto center\n\t\t\tnewSize = mathMax(\n\t\t\t\tcenter[2] - overflow[1] - overflow[3], // horizontal overflow\n\t\t\t\tminSize\n\t\t\t);\n\t\t\tcenter[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n\t\t}\n\n\t\t// Handle vertical size and center\n\t\tif (centerOption[1] !== null) { // Fixed center\n\t\t\tnewSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);\n\n\t\t} else { // Auto center\n\t\t\tnewSize = mathMax(\n\t\t\t\tmathMin(\n\t\t\t\t\tnewSize,\n\t\t\t\t\tcenter[2] - overflow[0] - overflow[2] // vertical overflow\n\t\t\t\t),\n\t\t\t\tminSize\n\t\t\t);\n\t\t\tcenter[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n\t\t}\n\n\t\t// If the size must be decreased, we need to run translate and drawDataLabels again\n\t\tif (newSize < center[2]) {\n\t\t\tcenter[2] = newSize;\n\t\t\tthis.translate(center);\n\t\t\teach(this.points, function (point) {\n\t\t\t\tif (point.dataLabel) {\n\t\t\t\t\tpoint.dataLabel._pos = null; // reset\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (this.drawDataLabels) {\n\t\t\t\tthis.drawDataLabels();\n\t\t\t}\n\t\t// Else, return true to indicate that the pie and its labels is within the plot area\n\t\t} else {\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t};\n}\n\nif (seriesTypes.column) {\n\n\t/**\n\t * Override the basic data label alignment by adjusting for the position of the column\n\t */\n\tseriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n\t\tvar inverted = this.chart.inverted,\n\t\t\tseries = point.series,\n\t\t\tdlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n\t\t\tbelow = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),\n\t\t\tinside = pick(options.inside, !!this.options.stacking); // draw it inside the box?\n\n\t\t// Align to the column itself, or the top of it\n\t\tif (dlBox) { // Area range uses this method but not alignTo\n\t\t\talignTo = merge(dlBox);\n\n\t\t\tif (inverted) {\n\t\t\t\talignTo = {\n\t\t\t\t\tx: series.yAxis.len - alignTo.y - alignTo.height,\n\t\t\t\t\ty: series.xAxis.len - alignTo.x - alignTo.width,\n\t\t\t\t\twidth: alignTo.height,\n\t\t\t\t\theight: alignTo.width\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Compute the alignment box\n\t\t\tif (!inside) {\n\t\t\t\tif (inverted) {\n\t\t\t\t\talignTo.x += below ? 0 : alignTo.width;\n\t\t\t\t\talignTo.width = 0;\n\t\t\t\t} else {\n\t\t\t\t\talignTo.y += below ? alignTo.height : 0;\n\t\t\t\t\talignTo.height = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// When alignment is undefined (typically columns and bars), display the individual\n\t\t// point below or above the point depending on the threshold\n\t\toptions.align = pick(\n\t\t\toptions.align,\n\t\t\t!inverted || inside ? 'center' : below ? 'right' : 'left'\n\t\t);\n\t\toptions.verticalAlign = pick(\n\t\t\toptions.verticalAlign,\n\t\t\tinverted || inside ? 'middle' : below ? 'top' : 'bottom'\n\t\t);\n\n\t\t// Call the parent method\n\t\tSeries.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n\t};\n}\n\n\n\n/**\n * Highcharts JS v4.1.4 (2015-03-10)\n * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.\n *\n * (c) 2010-2014 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n/*global Highcharts, HighchartsAdapter */\n(function (H) {\n\tvar Chart = H.Chart,\n\t\teach = H.each,\n\t\taddEvent = HighchartsAdapter.addEvent;\n\n\t// Collect potensial overlapping data labels. Stack labels probably don't need to be \n\t// considered because they are usually accompanied by data labels that lie inside the columns.\n\tChart.prototype.callbacks.push(function (chart) {\n\t\tfunction collectAndHide() {\n\t\t\tvar labels = [];\n\n\t\t\teach(chart.series, function (series) {\n\t\t\t\tvar dlOptions = series.options.dataLabels;\n\t\t\t\tif ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n\t\t\t\t\teach(series.points, function (point) { \n\t\t\t\t\t\tif (point.dataLabel) {\n\t\t\t\t\t\t\tpoint.dataLabel.labelrank = point.labelrank;\n\t\t\t\t\t\t\tlabels.push(point.dataLabel);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tchart.hideOverlappingLabels(labels);\n\t\t}\n\n\t\t// Do it now ...\n\t\tcollectAndHide();\n\n\t\t// ... and after each chart redraw\n\t\taddEvent(chart, 'redraw', collectAndHide);\n\n\t});\n\n\t/**\n\t * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n\t * visual imression.\n\t */\t\t\n\tChart.prototype.hideOverlappingLabels = function (labels) {\n\n\t\tvar len = labels.length,\n\t\t\tlabel,\n\t\t\ti,\n\t\t\tj,\n\t\t\tlabel1,\n\t\t\tlabel2,\n\t\t\tintersectRect = function (pos1, pos2, size1, size2) {\n\t\t\t\treturn !(\n\t\t\t\t\tpos2.x > pos1.x + size1.width ||\n\t\t\t\t\tpos2.x + size2.width < pos1.x ||\n\t\t\t\t\tpos2.y > pos1.y + size1.height ||\n\t\t\t\t\tpos2.y + size2.height < pos1.y\n\t\t\t\t);\n\t\t\t};\n\t\n\t\t// Mark with initial opacity\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tlabel = labels[i];\n\t\t\tif (label) {\n\t\t\t\tlabel.oldOpacity = label.opacity;\n\t\t\t\tlabel.newOpacity = 1;\n\t\t\t}\n\t\t}\n\n\t\t// Detect overlapping labels\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tlabel1 = labels[i];\n\n\t\t\tfor (j = i + 1; j < len; ++j) {\n\t\t\t\tlabel2 = labels[j];\n\t\t\t\tif (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && \n\t\t\t\t\t\tintersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {\n\t\t\t\t\t(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Hide or show\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tlabel = labels[i];\n\t\t\tif (label) {\n\t\t\t\tif (label.oldOpacity !== label.newOpacity && label.placed) {\n\t\t\t\t\tlabel.alignAttr.opacity = label.newOpacity;\n\t\t\t\t\tlabel[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);\n\t\t\t\t}\n\t\t\t\tlabel.isOld = true;\n\t\t\t}\n\t\t}\n\t};\n\n}(Highcharts));/**\n * TrackerMixin for points and graphs\n */\n\nvar TrackerMixin = Highcharts.TrackerMixin = {\n\n\tdrawTrackerPoint: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\tpointer = chart.pointer,\n\t\t\tcursor = series.options.cursor,\n\t\t\tcss = cursor && { cursor: cursor },\n\t\t\tonMouseOver = function (e) {\n\t\t\t\tvar target = e.target,\n\t\t\t\tpoint;\n\n\t\t\t\twhile (target && !point) {\n\t\t\t\t\tpoint = target.point;\n\t\t\t\t\ttarget = target.parentNode;\n\t\t\t\t}\n\n\t\t\t\tif (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n\t\t\t\t\tpoint.onMouseOver(e);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Add reference to the point\n\t\teach(series.points, function (point) {\n\t\t\tif (point.graphic) {\n\t\t\t\tpoint.graphic.element.point = point;\n\t\t\t}\n\t\t\tif (point.dataLabel) {\n\t\t\t\tpoint.dataLabel.element.point = point;\n\t\t\t}\n\t\t});\n\n\t\t// Add the event listeners, we need to do this only once\n\t\tif (!series._hasTracking) {\n\t\t\teach(series.trackerGroups, function (key) {\n\t\t\t\tif (series[key]) { // we don't always have dataLabelsGroup\n\t\t\t\t\tseries[key]\n\t\t\t\t\t\t.addClass(PREFIX + 'tracker')\n\t\t\t\t\t\t.on('mouseover', onMouseOver)\n\t\t\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n\t\t\t\t\t\t.css(css);\n\t\t\t\t\tif (hasTouch) {\n\t\t\t\t\t\tseries[key].on('touchstart', onMouseOver);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tseries._hasTracking = true;\n\t\t}\n\t},\n\n\t/**\n\t * Draw the tracker object that sits above all data labels and markers to\n\t * track mouse events on the graph or points. For the line type charts\n\t * the tracker uses the same graphPath, but with a greater stroke width\n\t * for better control.\n\t */\n\tdrawTrackerGraph: function () {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\ttrackByArea = options.trackByArea,\n\t\t\ttrackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n\t\t\ttrackerPathLength = trackerPath.length,\n\t\t\tchart = series.chart,\n\t\t\tpointer = chart.pointer,\n\t\t\trenderer = chart.renderer,\n\t\t\tsnap = chart.options.tooltip.snap,\n\t\t\ttracker = series.tracker,\n\t\t\tcursor = options.cursor,\n\t\t\tcss = cursor && { cursor: cursor },\n\t\t\tsinglePoints = series.singlePoints,\n\t\t\tsinglePoint,\n\t\t\ti,\n\t\t\tonMouseOver = function () {\n\t\t\t\tif (chart.hoverSeries !== series) {\n\t\t\t\t\tseries.onMouseOver();\n\t\t\t\t}\n\t\t\t},\n\t\t\t/*\n\t\t\t * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n\t\t\t * IE6: 0.002\n\t\t\t * IE7: 0.002\n\t\t\t * IE8: 0.002\n\t\t\t * IE9: 0.00000000001 (unlimited)\n\t\t\t * IE10: 0.0001 (exporting only)\n\t\t\t * FF: 0.00000000001 (unlimited)\n\t\t\t * Chrome: 0.000001\n\t\t\t * Safari: 0.000001\n\t\t\t * Opera: 0.00000000001 (unlimited)\n\t\t\t */\n\t\t\tTRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';\n\n\t\t// Extend end points. A better way would be to use round linecaps,\n\t\t// but those are not clickable in VML.\n\t\tif (trackerPathLength && !trackByArea) {\n\t\t\ti = trackerPathLength + 1;\n\t\t\twhile (i--) {\n\t\t\t\tif (trackerPath[i] === M) { // extend left side\n\t\t\t\t\ttrackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n\t\t\t\t}\n\t\t\t\tif ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n\t\t\t\t\ttrackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// handle single points\n\t\tfor (i = 0; i < singlePoints.length; i++) {\n\t\t\tsinglePoint = singlePoints[i];\n\t\t\ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n\t\t\tL, singlePoint.plotX + snap, singlePoint.plotY);\n\t\t}\n\n\t\t// draw the tracker\n\t\tif (tracker) {\n\t\t\ttracker.attr({ d: trackerPath });\n\t\t} else { // create\n\n\t\t\tseries.tracker = renderer.path(trackerPath)\n\t\t\t.attr({\n\t\t\t\t'stroke-linejoin': 'round', // #1225\n\t\t\t\tvisibility: series.visible ? VISIBLE : HIDDEN,\n\t\t\t\tstroke: TRACKER_FILL,\n\t\t\t\tfill: trackByArea ? TRACKER_FILL : NONE,\n\t\t\t\t'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),\n\t\t\t\tzIndex: 2\n\t\t\t})\n\t\t\t.add(series.group);\n\n\t\t\t// The tracker is added to the series group, which is clipped, but is covered\n\t\t\t// by the marker group. So the marker group also needs to capture events.\n\t\t\teach([series.tracker, series.markerGroup], function (tracker) {\n\t\t\t\ttracker.addClass(PREFIX + 'tracker')\n\t\t\t\t\t.on('mouseover', onMouseOver)\n\t\t\t\t\t.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n\t\t\t\t\t.css(css);\n\n\t\t\t\tif (hasTouch) {\n\t\t\t\t\ttracker.on('touchstart', onMouseOver);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n};\n/* End TrackerMixin */\n\n\n/**\n * Add tracking event listener to the series group, so the point graphics\n * themselves act as trackers\n */ \n\nif (seriesTypes.column) {\n\tColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\t\n}\n\nif (seriesTypes.pie) {\n\tseriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\nif (seriesTypes.scatter) {\n\tScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n}\n\n/* \n * Extend Legend for item events \n */ \nextend(Legend.prototype, {\n\n\tsetItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {\n\tvar legend = this;\n\t// Set the events on the item group, or in case of useHTML, the item itself (#1249)\n\t(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n\t\t\titem.setState(HOVER_STATE);\n\t\t\tlegendItem.css(legend.options.itemHoverStyle);\n\t\t})\n\t\t.on('mouseout', function () {\n\t\t\tlegendItem.css(item.visible ? itemStyle : itemHiddenStyle);\n\t\t\titem.setState();\n\t\t})\n\t\t.on('click', function (event) {\n\t\t\tvar strLegendItemClick = 'legendItemClick',\n\t\t\t\tfnLegendItemClick = function () {\n\t\t\t\t\titem.setVisible();\n\t\t\t\t};\n\t\t\t\t\n\t\t\t// Pass over the click/touch event. #4.\n\t\t\tevent = {\n\t\t\t\tbrowserEvent: event\n\t\t\t};\n\n\t\t\t// click the name or symbol\n\t\t\tif (item.firePointEvent) { // point\n\t\t\t\titem.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n\t\t\t} else {\n\t\t\t\tfireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n\t\t\t}\n\t\t});\n\t},\n\n\tcreateCheckboxForItem: function (item) {\n\t\tvar legend = this;\n\n\t\titem.checkbox = createElement('input', {\n\t\t\ttype: 'checkbox',\n\t\t\tchecked: item.selected,\n\t\t\tdefaultChecked: item.selected // required by IE7\n\t\t}, legend.options.itemCheckboxStyle, legend.chart.container);\n\n\t\taddEvent(item.checkbox, 'click', function (event) {\n\t\t\tvar target = event.target;\n\t\t\tfireEvent(item.series || item, 'checkboxClick', { // #3712\n\t\t\t\t\tchecked: target.checked,\n\t\t\t\t\titem: item\n\t\t\t\t},\n\t\t\t\tfunction () {\n\t\t\t\t\titem.select();\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\t\n});\n\n/* \n * Add pointer cursor to legend itemstyle in defaultOptions\n */\ndefaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n/* \n * Extend the Chart object with interaction\n */\n\nextend(Chart.prototype, {\n\t/**\n\t * Display the zoom button\n\t */\n\tshowResetZoom: function () {\n\t\tvar chart = this,\n\t\t\tlang = defaultOptions.lang,\n\t\t\tbtnOptions = chart.options.chart.resetZoomButton,\n\t\t\ttheme = btnOptions.theme,\n\t\t\tstates = theme.states,\n\t\t\talignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\t\t\t\n\t\tthis.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)\n\t\t\t.attr({\n\t\t\t\talign: btnOptions.position.align,\n\t\t\t\ttitle: lang.resetZoomTitle\n\t\t\t})\n\t\t\t.add()\n\t\t\t.align(btnOptions.position, false, alignTo);\n\t\t\t\n\t},\n\n\t/**\n\t * Zoom out to 1:1\n\t */\n\tzoomOut: function () {\n\t\tvar chart = this;\n\t\tfireEvent(chart, 'selection', { resetSelection: true }, function () { \n\t\t\tchart.zoom();\n\t\t});\n\t},\n\n\t/**\n\t * Zoom into a given portion of the chart given by axis coordinates\n\t * @param {Object} event\n\t */\n\tzoom: function (event) {\n\t\tvar chart = this,\n\t\t\thasZoomed,\n\t\t\tpointer = chart.pointer,\n\t\t\tdisplayButton = false,\n\t\t\tresetZoomButton;\n\n\t\t// If zoom is called with no arguments, reset the axes\n\t\tif (!event || event.resetSelection) {\n\t\t\teach(chart.axes, function (axis) {\n\t\t\t\thasZoomed = axis.zoom();\n\t\t\t});\n\t\t} else { // else, zoom in on all axes\n\t\t\teach(event.xAxis.concat(event.yAxis), function (axisData) {\n\t\t\t\tvar axis = axisData.axis,\n\t\t\t\t\tisXAxis = axis.isXAxis;\n\n\t\t\t\t// don't zoom more than minRange\n\t\t\t\tif (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n\t\t\t\t\thasZoomed = axis.zoom(axisData.min, axisData.max);\n\t\t\t\t\tif (axis.displayBtn) {\n\t\t\t\t\t\tdisplayButton = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\t// Show or hide the Reset zoom button\n\t\tresetZoomButton = chart.resetZoomButton;\n\t\tif (displayButton && !resetZoomButton) {\n\t\t\tchart.showResetZoom();\n\t\t} else if (!displayButton && isObject(resetZoomButton)) {\n\t\t\tchart.resetZoomButton = resetZoomButton.destroy();\n\t\t}\n\t\t\n\n\t\t// Redraw\n\t\tif (hasZoomed) {\n\t\t\tchart.redraw(\n\t\t\t\tpick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t * Pan the chart by dragging the mouse across the pane. This function is called\n\t * on mouse move, and the distance to pan is computed from chartX compared to\n\t * the first chartX position in the dragging operation.\n\t */\n\tpan: function (e, panning) {\n\n\t\tvar chart = this,\n\t\t\thoverPoints = chart.hoverPoints,\n\t\t\tdoRedraw;\n\n\t\t// remove active points for shared tooltip\n\t\tif (hoverPoints) {\n\t\t\teach(hoverPoints, function (point) {\n\t\t\t\tpoint.setState();\n\t\t\t});\n\t\t}\n\n\t\teach(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n\t\t\tvar mousePos = e[isX ? 'chartX' : 'chartY'],\n\t\t\t\taxis = chart[isX ? 'xAxis' : 'yAxis'][0],\n\t\t\t\tstartPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],\n\t\t\t\thalfPointRange = (axis.pointRange || 0) / 2,\n\t\t\t\textremes = axis.getExtremes(),\n\t\t\t\tnewMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n\t\t\t\tnewMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,\n\t\t\t\tgoingLeft = startPos > mousePos; // #3613\n\n\t\t\tif (axis.series.length && \n\t\t\t\t\t(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && \n\t\t\t\t\t(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {\n\t\t\t\taxis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n\t\t\t\tdoRedraw = true;\n\t\t\t}\n\n\t\t\tchart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run\n\t\t});\n\n\t\tif (doRedraw) {\n\t\t\tchart.redraw(false);\n\t\t}\n\t\tcss(chart.container, { cursor: 'move' });\n\t}\n});\n\n/*\n * Extend the Point object with interaction\n */\nextend(Point.prototype, {\n\t/**\n\t * Toggle the selection status of a point\n\t * @param {Boolean} selected Whether to select or unselect the point.\n\t * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n\t *\t\t this happens if the control key (Cmd on Mac) was pressed during clicking.\n\t */\n\tselect: function (selected, accumulate) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tchart = series.chart;\n\n\t\tselected = pick(selected, !point.selected);\n\n\t\t// fire the event with the defalut handler\n\t\tpoint.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n\t\t\tpoint.selected = point.options.selected = selected;\n\t\t\tseries.options.data[inArray(point, series.data)] = point.options;\n\n\t\t\tpoint.setState(selected && SELECT_STATE);\n\n\t\t\t// unselect all other points unless Ctrl or Cmd + click\n\t\t\tif (!accumulate) {\n\t\t\t\teach(chart.getSelectedPoints(), function (loopPoint) {\n\t\t\t\t\tif (loopPoint.selected && loopPoint !== point) {\n\t\t\t\t\t\tloopPoint.selected = loopPoint.options.selected = false;\n\t\t\t\t\t\tseries.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n\t\t\t\t\t\tloopPoint.setState(NORMAL_STATE);\n\t\t\t\t\t\t\tloopPoint.firePointEvent('unselect');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Runs on mouse over the point\n\t */\n\tonMouseOver: function (e) {\n\t\tvar point = this,\n\t\t\tseries = point.series,\n\t\t\tchart = series.chart,\n\t\t\ttooltip = chart.tooltip,\n\t\t\thoverPoint = chart.hoverPoint;\n\n\t\tif (chart.hoverSeries !== series) {\n\t\t\tseries.onMouseOver();\n\t\t}\t\t\n\n\t\t// set normal state to previous series\n\t\tif (hoverPoint && hoverPoint !== point) {\n\t\t\thoverPoint.onMouseOut();\n\t\t}\n\n\t\t// trigger the event\n\t\tpoint.firePointEvent('mouseOver');\n\n\t\t// update the tooltip\n\t\tif (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n\t\t\ttooltip.refresh(point, e);\n\t\t}\n\n\t\t// hover this\n\t\tpoint.setState(HOVER_STATE);\n\t\tchart.hoverPoint = point;\n\t},\n\n\t/**\n\t * Runs on mouse out from the point\n\t */\n\tonMouseOut: function () {\n\t\tvar chart = this.series.chart,\n\t\t\thoverPoints = chart.hoverPoints;\n\n\t\tthis.firePointEvent('mouseOut');\n\n\t\tif (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n\t\t\tthis.setState();\n\t\t\tchart.hoverPoint = null;\n\t\t}\n\t},\n\n\t/**\n\t * Import events from the series' and point's options. Only do it on\n\t * demand, to save processing time on hovering.\n\t */\n\timportEvents: function () {\n\t\tif (!this.hasImportedEvents) {\n\t\t\tvar point = this,\n\t\t\t\toptions = merge(point.series.options.point, point.options),\n\t\t\t\tevents = options.events,\n\t\t\t\teventType;\n\n\t\t\tpoint.events = events;\n\n\t\t\tfor (eventType in events) {\n\t\t\t\taddEvent(point, eventType, events[eventType]);\n\t\t\t}\n\t\t\tthis.hasImportedEvents = true;\n\n\t\t}\n\t},\n\n\t/**\n\t * Set the point's state\n\t * @param {String} state\n\t */\n\tsetState: function (state, move) {\n\t\tvar point = this,\n\t\t\tplotX = point.plotX,\n\t\t\tplotY = point.plotY,\n\t\t\tseries = point.series,\n\t\t\tstateOptions = series.options.states,\n\t\t\tmarkerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n\t\t\tnormalDisabled = markerOptions && !markerOptions.enabled,\n\t\t\tmarkerStateOptions = markerOptions && markerOptions.states[state],\n\t\t\tstateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n\t\t\tstateMarkerGraphic = series.stateMarkerGraphic,\n\t\t\tpointMarker = point.marker || {},\n\t\t\tchart = series.chart,\n\t\t\tradius,\n\t\t\thalo = series.halo,\n\t\t\thaloOptions,\n\t\t\tnewSymbol,\n\t\t\tpointAttr;\n\n\t\tstate = state || NORMAL_STATE; // empty string\n\t\tpointAttr = point.pointAttr[state] || series.pointAttr[state];\n\n\t\tif (\n\t\t\t\t// already has this state\n\t\t\t\t(state === point.state && !move) ||\n\t\t\t\t// selected points don't respond to hover\n\t\t\t\t(point.selected && state !== SELECT_STATE) ||\n\t\t\t\t// series' state options is disabled\n\t\t\t\t(stateOptions[state] && stateOptions[state].enabled === false) ||\n\t\t\t\t// general point marker's state options is disabled\n\t\t\t\t(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n\t\t\t\t// individual point marker's state options is disabled\n\t\t\t\t(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n\t\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// apply hover styles to the existing point\n\t\tif (point.graphic) {\n\t\t\tradius = markerOptions && point.graphic.symbolName && pointAttr.r;\n\t\t\tpoint.graphic.attr(merge(\n\t\t\t\tpointAttr,\n\t\t\t\tradius ? { // new symbol attributes (#507, #612)\n\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\ty: plotY - radius,\n\t\t\t\t\twidth: 2 * radius,\n\t\t\t\t\theight: 2 * radius\n\t\t\t\t} : {}\n\t\t\t));\n\n\t\t\t// Zooming in from a range with no markers to a range with markers\n\t\t\tif (stateMarkerGraphic) {\n\t\t\t\tstateMarkerGraphic.hide();\n\t\t\t}\n\t\t} else {\n\t\t\t// if a graphic is not applied to each point in the normal state, create a shared\n\t\t\t// graphic for the hover state\n\t\t\tif (state && markerStateOptions) {\n\t\t\t\tradius = markerStateOptions.radius;\n\t\t\t\tnewSymbol = pointMarker.symbol || series.symbol;\n\n\t\t\t\t// If the point has another symbol than the previous one, throw away the\n\t\t\t\t// state marker graphic and force a new one (#1459)\n\t\t\t\tif (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n\t\t\t\t\tstateMarkerGraphic = stateMarkerGraphic.destroy();\n\t\t\t\t}\n\n\t\t\t\t// Add a new state marker graphic\n\t\t\t\tif (!stateMarkerGraphic) {\n\t\t\t\t\tif (newSymbol) {\n\t\t\t\t\t\tseries.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n\t\t\t\t\t\t\tnewSymbol,\n\t\t\t\t\t\t\tplotX - radius,\n\t\t\t\t\t\t\tplotY - radius,\n\t\t\t\t\t\t\t2 * radius,\n\t\t\t\t\t\t\t2 * radius\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.attr(pointAttr)\n\t\t\t\t\t\t.add(series.markerGroup);\n\t\t\t\t\t\tstateMarkerGraphic.currentSymbol = newSymbol;\n\t\t\t\t\t}\n\n\t\t\t\t// Move the existing graphic\n\t\t\t\t} else {\n\t\t\t\t\tstateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n\t\t\t\t\t\tx: plotX - radius,\n\t\t\t\t\t\ty: plotY - radius\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (stateMarkerGraphic) {\n\t\t\t\tstateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n\t\t\t}\n\t\t}\n\n\t\t// Show me your halo\n\t\thaloOptions = stateOptions[state] && stateOptions[state].halo;\n\t\tif (haloOptions && haloOptions.size) {\n\t\t\tif (!halo) {\n\t\t\t\tseries.halo = halo = chart.renderer.path()\n\t\t\t\t\t.add(chart.seriesGroup);\n\t\t\t}\n\t\t\thalo.attr(extend({\n\t\t\t\tfill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()\n\t\t\t}, haloOptions.attributes))[move ? 'animate' : 'attr']({\n\t\t\t\td: point.haloPath(haloOptions.size)\n\t\t\t});\n\t\t} else if (halo) {\n\t\t\thalo.attr({ d: [] });\n\t\t}\n\n\t\tpoint.state = state;\n\t},\n\n\thaloPath: function (size) {\n\t\tvar series = this.series,\n\t\t\tchart = series.chart,\n\t\t\tplotBox = series.getPlotBox(),\n\t\t\tinverted = chart.inverted;\n\n\t\treturn chart.renderer.symbols.circle(\n\t\t\tplotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, \n\t\t\tplotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, \n\t\t\tsize * 2, \n\t\t\tsize * 2\n\t\t);\n\t}\n});\n\n/*\n * Extend the Series object with interaction\n */\n\nextend(Series.prototype, {\n\t/**\n\t * Series mouse over handler\n\t */\n\tonMouseOver: function () {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\thoverSeries = chart.hoverSeries;\n\n\t\t// set normal state to previous series\n\t\tif (hoverSeries && hoverSeries !== series) {\n\t\t\thoverSeries.onMouseOut();\n\t\t}\n\n\t\t// trigger the event, but to save processing time,\n\t\t// only if defined\n\t\tif (series.options.events.mouseOver) {\n\t\t\tfireEvent(series, 'mouseOver');\n\t\t}\n\n\t\t// hover this\n\t\tseries.setState(HOVER_STATE);\n\t\tchart.hoverSeries = series;\n\t},\n\n\t/**\n\t * Series mouse out handler\n\t */\n\tonMouseOut: function () {\n\t\t// trigger the event only if listeners exist\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tchart = series.chart,\n\t\t\ttooltip = chart.tooltip,\n\t\t\thoverPoint = chart.hoverPoint;\n\n\t\t// trigger mouse out on the point, which must be in this series\n\t\tif (hoverPoint) {\n\t\t\thoverPoint.onMouseOut();\n\t\t}\n\n\t\t// fire the mouse out event\n\t\tif (series && options.events.mouseOut) {\n\t\t\tfireEvent(series, 'mouseOut');\n\t\t}\n\n\n\t\t// hide the tooltip\n\t\tif (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n\t\t\ttooltip.hide();\n\t\t}\n\n\t\t// set normal state\n\t\tseries.setState();\n\t\tchart.hoverSeries = null;\n\t},\n\n\t/**\n\t * Set the state of the graph\n\t */\n\tsetState: function (state) {\n\t\tvar series = this,\n\t\t\toptions = series.options,\n\t\t\tgraph = series.graph,\n\t\t\tgraphNeg = series.graphNeg,\n\t\t\tstateOptions = options.states,\n\t\t\tlineWidth = options.lineWidth,\n\t\t\tattribs;\n\n\t\tstate = state || NORMAL_STATE;\n\n\t\tif (series.state !== state) {\n\t\t\tseries.state = state;\n\n\t\t\tif (stateOptions[state] && stateOptions[state].enabled === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (state) {\n\t\t\t\tlineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);\n\t\t\t}\n\n\t\t\tif (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n\t\t\t\tattribs = {\n\t\t\t\t\t'stroke-width': lineWidth\n\t\t\t\t};\n\t\t\t\t// use attr because animate will cause any other animation on the graph to stop\n\t\t\t\tgraph.attr(attribs);\n\t\t\t\tif (graphNeg) {\n\t\t\t\t\tgraphNeg.attr(attribs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Set the visibility of the graph\n\t *\n\t * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n\t *\t\t\t\tthe visibility is toggled.\n\t */\n\tsetVisible: function (vis, redraw) {\n\t\tvar series = this,\n\t\t\tchart = series.chart,\n\t\t\tlegendItem = series.legendItem,\n\t\t\tshowOrHide,\n\t\t\tignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n\t\t\toldVisibility = series.visible;\n\n\t\t// if called without an argument, toggle visibility\n\t\tseries.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;\n\t\tshowOrHide = vis ? 'show' : 'hide';\n\n\t\t// show or hide elements\n\t\teach(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n\t\t\tif (series[key]) {\n\t\t\t\tseries[key][showOrHide]();\n\t\t\t}\n\t\t});\n\n\n\t\t// hide tooltip (#1361)\n\t\tif (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n\t\t\tseries.onMouseOut();\n\t\t}\n\n\n\t\tif (legendItem) {\n\t\t\tchart.legend.colorizeItem(series, vis);\n\t\t}\n\n\n\t\t// rescale or adapt to resized chart\n\t\tseries.isDirty = true;\n\t\t// in a stack, all other series are affected\n\t\tif (series.options.stacking) {\n\t\t\teach(chart.series, function (otherSeries) {\n\t\t\t\tif (otherSeries.options.stacking && otherSeries.visible) {\n\t\t\t\t\totherSeries.isDirty = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// show or hide linked series\n\t\teach(series.linkedSeries, function (otherSeries) {\n\t\t\totherSeries.setVisible(vis, false);\n\t\t});\n\n\t\tif (ignoreHiddenSeries) {\n\t\t\tchart.isDirtyBox = true;\n\t\t}\n\t\tif (redraw !== false) {\n\t\t\tchart.redraw();\n\t\t}\n\n\t\tfireEvent(series, showOrHide);\n\t},\n\n\t/**\n\t * Show the graph\n\t */\n\tshow: function () {\n\t\tthis.setVisible(true);\n\t},\n\n\t/**\n\t * Hide the graph\n\t */\n\thide: function () {\n\t\tthis.setVisible(false);\n\t},\n\n\n\t/**\n\t * Set the selected state of the graph\n\t *\n\t * @param selected {Boolean} True to select the series, false to unselect. If\n\t *\t\t\t\tUNDEFINED, the selection state is toggled.\n\t */\n\tselect: function (selected) {\n\t\tvar series = this;\n\t\t// if called without an argument, toggle\n\t\tseries.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n\t\tif (series.checkbox) {\n\t\t\tseries.checkbox.checked = selected;\n\t\t}\n\n\t\tfireEvent(series, selected ? 'select' : 'unselect');\n\t},\n\n\tdrawTracker: TrackerMixin.drawTrackerGraph\n});\n// global variables\nextend(Highcharts, {\n\t\n\t// Constructors\n\tColor: Color,\n\tPoint: Point,\n\tTick: Tick,\t\n\tRenderer: Renderer,\n\tSVGElement: SVGElement,\n\tSVGRenderer: SVGRenderer,\n\t\n\t// Various\n\tarrayMin: arrayMin,\n\tarrayMax: arrayMax,\n\tcharts: charts,\n\tdateFormat: dateFormat,\n\terror: error,\n\tformat: format,\n\tpathAnim: pathAnim,\n\tgetOptions: getOptions,\n\thasBidiBug: hasBidiBug,\n\tisTouchDevice: isTouchDevice,\n\tsetOptions: setOptions,\n\taddEvent: addEvent,\n\tremoveEvent: removeEvent,\n\tcreateElement: createElement,\n\tdiscardElement: discardElement,\n\tcss: css,\n\teach: each,\n\tmap: map,\n\tmerge: merge,\n\tsplat: splat,\n\textendClass: extendClass,\n\tpInt: pInt,\n\tsvg: hasSVG,\n\tcanvas: useCanVG,\n\tvml: !hasSVG && !useCanVG,\n\tproduct: PRODUCT,\n\tversion: VERSION\n});\n\nmodule.exports = Highcharts;\n/*eslint-enable*/\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/highcharts-commonjs/src/highcharts.src.js\n ** module id = 50\n ** module chunks = 6 7\n **/","/*!\n * jQuery JavaScript Library v2.1.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-18T15:11Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.3\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\"position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don't assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// Toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/highcharts-commonjs/~/jquery/dist/jquery.js\n ** module id = 156\n ** module chunks = 6 7\n **/"],"sourceRoot":""}